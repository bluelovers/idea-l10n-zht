action.DlvDumpAction.text=傾印 Goroutine
action.DlvRewindAction.description=向後執行程序，直到到達上一個中斷點
action.DlvRewindAction.text=後退
action.DlvShowPointerAddressesToggleAction.text=顯示指針地址
action.DlvShowTypesToggleAction.text=顯示類型
action.DlvToggleThreadsAction.description=顯示執行緒
action.DlvToggleThreadsAction.text=顯示執行緒
action.FilterStacktraces.description=僅顯示包含特定字串的堆疊
action.FilterStacktraces.task.name=篩選堆疊
action.Go.NewGoFile.description=建立新 Go 檔案
action.Go.NewGoFile.text=Go 檔案
action.GoAddContentRootFromGopath.description=將所選目錄新增到當前專案
action.GoAddContentRootFromGopath.text=將目錄新增到當前專案中
action.GoCallHierarchyPopupMenu.BaseOnThisDeclaration.text=基於此宣告
action.GoCoreDumpAction.text=開啟核心傾印…
action.GoFmtFileAction.description=使用 go fmt 工具格式化所選檔案
action.GoFmtFileAction.text=Go Fmt 檔案
action.GoFmtProjectAction.description=使用 go fmt 工具格式化專案
action.GoFmtProjectAction.text=Go Fmt 專案
action.GoGenerateConstructorAction.description=為結構生成建構函式
action.GoGenerateConstructorAction.text=建構函式
action.GoGenerateFileAction.description=在所選檔案上執行 go generate
action.GoGenerateFileAction.text=Go Generate 檔案
action.GoGenerateGetterAction.description=為欄位生成 getter 方法
action.GoGenerateGetterAction.text=Getter
action.GoGenerateGetterSetterAction.description=為欄位生成 getter 和 setter 方法
action.GoGenerateGetterSetterAction.text=Getter 和 Setter
action.GoGenerateMethodAction.text=方法
action.GoGenerateSetterAction.description=為欄位生成 setter 方法
action.GoGenerateSetterAction.text=Setter
action.GoGenerateStructFieldsFromJsonAction.description=從 JSON 生成結構欄位
action.GoGenerateStructFieldsFromJsonAction.text=JSON 中的結構欄位
action.GoGenerateTypeFromJsonAction.description=從 JSON 生成類型
action.GoGenerateTypeFromJsonAction.text=JSON 中的類型
action.GoIdeNewProjectAction.text=專案…
action.GoImportsFileAction.description=使用 goimports 工具最佳化所選檔案的匯入
action.GoImportsFileAction.text=Goimports 檔案
action.GoIntroduceTypeAction.text=引入類型…
action.GoOpenInPlaygroundAction.description=在 Go Playground 中開啟程式碼
action.GoOpenInPlaygroundAction.text=Playground
action.GoOpenProjectFromGopath.description=作為專案開啟所選目錄
action.GoOpenProjectFromGopath.text=作為專案開啟目錄
action.GoOpenSettings.description=開啟專案的 Go 設定
action.GoOpenSettings.text=開啟 Go 設定
action.GoRemoveContentRootAction.description=從當前專案中移除所選內容根目錄
action.GoRemoveContentRootAction.text=分離目錄…
action.GoReplayTraceAction.text=偵錯儲存的追蹤…
action.GoShareInPlaygroundAction.confirmation=是否要將 {0} 上傳到 Go Playground 並使之公開?
action.GoShareInPlaygroundAction.description=在 Go Playground 中共享當前檔案
action.GoShareInPlaygroundAction.empty.id=Playground 返回空 ID
action.GoShareInPlaygroundAction.error=無法在 Go Playground 中共享檔案: {0}
action.GoShareInPlaygroundAction.notification.copyUrl=將 URL 複製到剪貼簿
action.GoShareInPlaygroundAction.notification.text=Go Playground 中共享的檔案: <a href="{0}">{0}</a>
action.GoShareInPlaygroundAction.text=在 Playground 中共享
action.GoToggleCachingAction.cachingDisabled=Go 延伸模組快取已停用
action.GoToggleCachingAction.cachingEnabled=Go 延伸模組快取已啟用
action.GoToggleCachingAction.description=切換 Go 延伸模組中的快取
action.GoToggleCachingAction.disableCaching=停用 Go 延伸模組快取
action.GoToggleCachingAction.enableCaching=啟用 Go 延伸模組快取
action.GoToggleCachingAction.text=切換 Go 延伸模組快取
action.GoVetFileAction.description=使用 go vet 工具對所選檔案或目錄執行 Lint 動作
action.GoVetFileAction.text=Go Vet 檔案
action.HideGoroutine=隱藏 goroutine
action.HideSimilarGoroutines=隱藏具有相同堆疊的所有 goroutine
action.MergeIdenticalStacktraces.text=合併相同的堆疊追蹤
action.ResetHiddenAction.description=重設隱藏的 goroutine
action.ResetHiddenAction.text=重設隱藏的 Goroutine
action.Vgo.NewVgoFile.description=建立 Go 模組檔案
action.Vgo.NewVgoFile.text=Go 模組檔案
action.Vgo.NewVgoWorkspaceFile.description=建立 Go 工作區檔案
action.Vgo.NewVgoWorkspaceFile.text=Go 工作區檔案
action.WelcomeScreen.CreateDirectoryProject.text=新增專案
action.com.goide.vgo.actions.VgoSyncAction.description=同步 go 模組
action.com.goide.vgo.actions.VgoSyncAction.text=同步 Go 模組
action.com.goide.vgo.actions.VgoTidyAction.description=在模組中執行 `go mod tidy`
action.com.goide.vgo.actions.VgoTidyAction.text=Go Mod Tidy
action.com.goide.vgo.actions.VgoVendorAction.description=在模組中執行 'go mod vendor'
action.com.goide.vgo.actions.VgoVendorAction.text=Go Mod Vendor
action.go.exclude.package.from.import.and.completion=從匯入和補全中排除 ''{0}''
action.go.fill.paragraph=填充段落
exportable.GoSdkList.presentable.name=已知的 Go SDK 路徑列表
exportable.vgo.presentable.name=已知的 Go 相關環境變數列表
filetype.go.build.description=Go:build 約束
filetype.go.cgo.description=Cgo 檔案
filetype.go.description=Go 檔案
filetype.go.plus.build.description=Go +build 約束
filetype.go.settings.modules.dependency.description=Go 模組相依關係檔案
filetype.go.tag.description=Go 標記
filetype.go.time.description=Go 時間
go.action.playground.connection.failed=連線到伺服器失敗
go.add.import.command.name=新增匯入
go.add.import.with.alias.presentation={0} 作為 {1}
go.app.engine.not.gae.sdk.validation.message=App Engine 僅支援 Go 1.11 及更高版本
go.app.engine.wizard.description=建立 Go App Engine 專案以開發使用 Google App Engine 的 Go 應用程式。<br/>新模組包括 Go 中的預設組態設定和基本處理程序。
go.app.engine.wizard.name=App Engine
go.attach.directory.action.text=附加目錄“{0}”
go.auto.import.and.completion.add.exclude.label=輸入要從自動匯入和補全中排除的匯入路徑:
go.auto.import.and.completion.title=自動匯入和補全
go.background.task.compiling.title=正在編譯…
go.background.task.running.title=正在執行…
go.before.check.in.show.fmt.error.button=詳細資訊(&D)…
go.call.hierarchy.respect.interface.calls.action.name=遵循接口呼叫
go.call.hierarchy.respect.interface.calls.description=遵循接口呼叫
go.cannot.be.represented.by.type={0} 不能由類型 {1} 表示
go.checkin.factory.fmt.commit.anyway.question=仍要提交嗎?
go.checkin.factory.fmt.failed.message=GoFmt 在某些檔案上返回了非零程式碼。
go.checkin.factory.fmt.not.started.message=無法執行 gofmt。{0}
go.code.smells.commit.local.paths=提交本地路徑可能無法移植
go.code.vision.implementations={0, choice, 1#1 個實作|2#{0,number} 個實作}
go.code.vision.usages={0,choice, 0#無用法|1#1 個用法|2#{0,number} 個用法}
go.codeLens.inheritors.description=接口具有的後代數量。點擊提示可導覽到從此接口繼承的程式碼。
go.codeLens.references.description=專案中頂層宣告的使用次數。點擊提示可導覽到用法。
go.codeLens.vcs.code.vision.description=為類型、方法或任何其他程式碼元素編寫程式碼的人員名稱。該名稱取自 VCS。
go.colors.and.fonts.bad.character=錯誤字元
go.colors.and.fonts.braces.and.operators=大括號和運算符
go.colors.and.fonts.braces.and.operators.braces=大括號
go.colors.and.fonts.braces.and.operators.brackets=中括號
go.colors.and.fonts.braces.and.operators.colon=冒號
go.colors.and.fonts.braces.and.operators.comma=逗號
go.colors.and.fonts.braces.and.operators.dot=點
go.colors.and.fonts.braces.and.operators.operator=運算符
go.colors.and.fonts.braces.and.operators.parentheses=括號
go.colors.and.fonts.braces.and.operators.semicolon=分號
go.colors.and.fonts.comments=註釋
go.colors.and.fonts.comments.block.comment=塊註釋
go.colors.and.fonts.comments.build.constraints=建置約束
go.colors.and.fonts.comments.build.constraints.operators=運算符
go.colors.and.fonts.comments.build.constraints.parens=圓括號
go.colors.and.fonts.comments.build.constraints.tag=標記
go.colors.and.fonts.comments.comment.keyword=註釋關鍵字
go.colors.and.fonts.comments.comment.reference=註釋參照
go.colors.and.fonts.comments.line.comment=行註釋
go.colors.and.fonts.declarations=宣告
go.colors.and.fonts.declarations.constants=常數
go.colors.and.fonts.declarations.constants.builtin.constant=內建常數
go.colors.and.fonts.declarations.constants.local.constant=區域常數
go.colors.and.fonts.declarations.constants.package.exported.constant=軟體套件匯出的常數
go.colors.and.fonts.declarations.constants.package.local.constant=軟體套件區域常數
go.colors.and.fonts.declarations.function.parameter=函式參數
go.colors.and.fonts.declarations.functions=函式
go.colors.and.fonts.declarations.functions.builtin.function=內建函式
go.colors.and.fonts.declarations.functions.exported.function=匯出的函式
go.colors.and.fonts.declarations.functions.package.local.function=軟體套件區域函式
go.colors.and.fonts.declarations.label=標籤
go.colors.and.fonts.declarations.method.receiver=方法接收器
go.colors.and.fonts.declarations.package=軟體套件
go.colors.and.fonts.declarations.struct.tags=結構標記
go.colors.and.fonts.declarations.struct.tags.arbitraryText=任意文本
go.colors.and.fonts.declarations.struct.tags.colon=冒號
go.colors.and.fonts.declarations.struct.tags.key=鍵
go.colors.and.fonts.declarations.struct.tags.value=值
go.colors.and.fonts.declarations.types=類型
go.colors.and.fonts.declarations.types.package.exported.interface=軟體套件匯出的接口
go.colors.and.fonts.declarations.types.package.exported.struct=軟體套件匯出的結構
go.colors.and.fonts.declarations.types.package.local.interface=軟體套件本地接口
go.colors.and.fonts.declarations.types.package.local.struct=軟體套件本地結構
go.colors.and.fonts.declarations.types.type.specification=類型規範
go.colors.and.fonts.declarations.variables=變數
go.colors.and.fonts.declarations.variables.builtin.variable=內建變數
go.colors.and.fonts.declarations.variables.local.variable=區域變數
go.colors.and.fonts.declarations.variables.package.exported.variable=軟體套件匯出的變數
go.colors.and.fonts.declarations.variables.package.local.variable=軟體套件區域變數
go.colors.and.fonts.declarations.variables.reassignment.in.short.variable.declaration=短變數宣告中的重新賦值
go.colors.and.fonts.declarations.variables.scope.declared.variable=作用域宣告變數
go.colors.and.fonts.declarations.variables.shadowing.variable=陰影變數
go.colors.and.fonts.declarations.variables.struct.exported.member=結構匯出的成員
go.colors.and.fonts.declarations.variables.struct.local.member=結構本地成員
go.colors.and.fonts.identifier=關鍵字
go.colors.and.fonts.keyword=關鍵字
go.colors.and.fonts.number=數字
go.colors.and.fonts.references=參照
go.colors.and.fonts.references.function.calls=函式呼叫
go.colors.and.fonts.references.function.calls.builtin.function.call=內建函式呼叫
go.colors.and.fonts.references.function.calls.exported.function.call=匯出的函式呼叫
go.colors.and.fonts.references.function.calls.local.function.call=區域函式呼叫
go.colors.and.fonts.references.type.references=類型參照
go.colors.and.fonts.references.type.references.builtin.type.reference=內建類型參照
go.colors.and.fonts.references.type.references.package.exported.interface=軟體套件匯出的接口
go.colors.and.fonts.references.type.references.package.exported.struct=軟體套件匯出的結構
go.colors.and.fonts.references.type.references.package.local.interface=軟體套件本地接口
go.colors.and.fonts.references.type.references.package.local.struct=軟體套件本地結構
go.colors.and.fonts.references.type.references.type.specification=類型規範
go.colors.and.fonts.references.variable.calls=變數呼叫
go.colors.and.fonts.references.variable.calls.exported.variable.call=匯出的變數呼叫
go.colors.and.fonts.references.variable.calls.local.variable.call=區域變數呼叫
go.colors.and.fonts.references.variable.calls.package.local.variable.call=軟體套件區域變數呼叫
go.colors.and.fonts.references.variable.calls.struct.exported.member.call=結構匯出的成員呼叫
go.colors.and.fonts.references.variable.calls.struct.local.member.call=結構本地成員呼叫
go.colors.and.fonts.string=字串
go.colors.and.fonts.string.invalid.escape=無效的轉義
go.colors.and.fonts.string.text=文本
go.colors.and.fonts.string.valid.escape=有效的轉義
go.command.line.inspection.project.configurator.description=組態 Go 專案
go.command.line.inspection.project.configurator.download.dependencies=正在下載 Go 模組相依項…
go.completion.add.tag.key.to.all.fields=向所有欄位新增標記鍵…
go.completion.fill.all.fields.lookup.string=填充所有欄位…
go.completion.fill.selected.fields.lookup.string=填充所選欄位…
go.completion.generate.struct.fields.from.json=從 JSON 生成結構欄位…
go.completion.insert.if.not.nil.statement.command.name=插入 ''if value != nil {...}'' 語句
go.completion.insert.literal.command.name=插入 Go 文字
go.completion.insert.type.name.command.name=插入類型名稱
go.completion.method.like.completion.advertisement=按 {0} 檢視將表達式作為第一個實參的函式
go.completion.method.like.completion.command.name=函式的方法式補全
go.converter.build.run.configuration.description='Go Build' 執行組態已更改。需要轉換現有組態。
go.converter.build.tags.description=Go 專案設定存儲機制已更改，需要更新專案及其模組。
go.converter.project.model.description=Go 專案模型已更改，請更新專案及其模組
go.converter.sdk.description=Go 專案模型已更改，請更新專案及其模組
go.converter.single.file.run.configuration.description='Run single Go file' 執行組態已移除。需要轉換現有組態。
go.core.dump.dialog.dump.path.label=核心傾印(&C):
go.core.dump.dialog.executable.label=可執行檔案(&E):
go.core.dump.dialog.invalid.core.dump.validation.message=該檔案不是有效的核心傾印
go.core.dump.dialog.invalid.executable.validation.message=該檔案不是可執行檔案
go.core.dump.dialog.specify.core.dump.validation.message=指定核心傾印
go.core.dump.dialog.specify.executable.validation.message=指定可執行檔案
go.core.dump.failed.to.start.error.message=無法為核心傾印 {0} 啟動偵錯器: {1}
go.core.dump.session.name=核心傾印 {0}
go.create.intermediate.variable.declaration.fix.name=建立中間變數
go.create.new.file.action.command.name=建立 Go 檔案 {0}
go.create.new.file.action.name=Go 檔案
go.create.new.file.dialog.title=新增 Go 檔案
go.create.new.file.empty.file.kind.name=空檔案
go.create.new.file.simple.application.kind.name=簡單應用程式
go.debug.show.goroutines.action.name=顯示 Goroutine
go.debug.show.threads.action.name=顯示執行緒
go.debugger.and.n.more=和其他 {0} 個
go.debugger.another.command.is.in.progress=正在執行另一條指令
go.debugger.async.stacktrace.caption=異步堆疊追蹤
go.debugger.breakpoint.title=Go 中斷點
go.debugger.cannot.calculate.string.presentation=無法計算字串表示: {0}
go.debugger.cannot.calculate.value=無法計算值
go.debugger.cannot.connect.non.remote=Delve 程序無法連線，因為它未使用遠端連線
go.debugger.cannot.connect.twice=Delve 程序不能連線兩次
go.debugger.cannot.evaluate.call=無法對呼叫求值: {0}
go.debugger.cannot.evaluate.expression=無法對表達式 ''{0}'' 求值: {1}
go.debugger.cannot.find.debugger.path=找不到 {0} 的偵錯器路徑
go.debugger.cannot.find.file=找不到檔案 {0}
go.debugger.cannot.find.free.port=無法為偵錯器找到可用 TCP 連接埠
go.debugger.cannot.get.current.goroutine=無法獲取當前 goroutine
go.debugger.cannot.get.current.stack=無法獲取當前堆疊
go.debugger.cannot.load.remaining.call.result.children=無法載入呼叫結果的剩餘子級
go.debugger.cannot.pause=無法暫停
go.debugger.cannot.resolve.localhost=無法解析本地主機地址
go.debugger.cannot.retrieve.go.processes=無法檢索 Go 程序
go.debugger.cannot.retrieve.interface.value.type=無法檢索接口值的類型
go.debugger.connecting.to.address.message=正在連線到 {0}…
go.debugger.connecting.to.unknown.address.message=正在連線到遠端地址…
go.debugger.connection.failed.generic.message=連線到 {0} 失敗
go.debugger.create.dump.background.task.progress.text=正在傾印堆疊({0})…
go.debugger.create.dump.background.task.title=正在傾印堆疊…
go.debugger.custom.delve.extended.notification=正在使用自訂 Delve 進行偵錯: {0}。刪除 ''dlv.path'' <a href=''customProperties''>自訂屬性</a>並重啟 IDE 以使用捆綁的 Delve。
go.debugger.custom.delve.notification=正在使用自訂 Delve 進行偵錯: {0}
go.debugger.disconnected.unexpectedly=偵錯器意外斷開連線
go.debugger.error.breakpoint.display.text=致命錯誤
go.debugger.error.breakpoint.title=Go 錯誤中斷點
go.debugger.expression.is.nil=''{0}'' 為零
go.debugger.expression.is.not.a.function=''{0}'' 不是函式
go.debugger.failed.to.compute.node.presentation=無法計算節點表示
go.debugger.failed.to.create.breakpoint=無法建立中斷點
go.debugger.failed.to.run.to.position=無法執行到位置
go.debugger.failed.to.stop.mozilla.rr.recording=無法停止 mozilla rr 記錄
go.debugger.failed.to.stop.mozilla.rr.recording.details=無法停止 mozilla rr 記錄: {0}
go.debugger.fmt.sprintf.cannot.format.value=(無法格式化值)
go.debugger.fmt.sprintf.unsupported.format=(不支持的格式)
go.debugger.fmt.sprintf.unsupported.verb=(不支持的動詞)
go.debugger.go.version.is.not.officially.supported=Go {0} 不受該偵錯器的官方支援，某些功能可能無法正常使用。請升級到 Go {1} 或更高版本。
go.debugger.go.version.is.not.supported=Go {0} 不受該偵錯器的支援。請升級到 Go {1} 或更高版本。
go.debugger.goroutine=Goroutine
go.debugger.hidden.group.name=已隱藏({0})
go.debugger.install.gops.to.attach.to.go.processes=安裝 {0} 以附加到 Go 程序
go.debugger.internal.messaging.error=內部訊息傳遞錯誤
go.debugger.kill.existing.process.message=是否要終止偵錯器所連線的遠端程序?
go.debugger.kill.existing.process.title=終止遠端程序
go.debugger.local.attach.group.name=Go
go.debugger.missing.current.function=缺少當前函式
go.debugger.missing.function.name=<缺少>
go.debugger.no.debug.information.for.file=可執行檔案不包含 {0} 的偵錯資訊
go.debugger.non.top.frame.selected=已選擇非頂部框架
go.debugger.obsolete.value=<過時>
go.debugger.only.first.goroutines.are.shown=僅顯示第一個 {0} goroutines
go.debugger.process.terminated.stop.remote.delve.message=遠端程序已終止。是否也要停止遠端 Delve 實例?
go.debugger.record.and.debug.action.name=錄製並偵錯
go.debugger.record.and.debug.cannot.find.rr.message=<html>找不到 <a href="https://rr-project.org">mozilla rr</a> 可執行檔案。請安裝並將其新增到 PATH 中。</html>
go.debugger.record.and.debug.description=錄製並偵錯
go.debugger.record.and.debug.start.action.text=錄製並偵錯
go.debugger.recording.in.progress=正在記錄程序執行。要偵錯記錄，請等待程序終止或<a href=''{0}''>停止記錄</a>。
go.debugger.renderers.binary.name=二進制
go.debugger.renderers.decimal.name=十進制
go.debugger.renderers.hex.name=十六進制
go.debugger.smart.step.into.failed=智能步入失敗: {0}
go.debugger.smart.step.into.popup.title=步入函式
go.debugger.stop.remote.delve.message=是否要停止遠端 Delve 實例?
go.debugger.stop.remote.delve.title=停止遠端 Delve
go.debugger.thread=執行緒
go.debugger.thread.dump.display.name=傾印 {0}
go.debugger.thread.dump.error=無法獲取執行緒傾印: {0}
go.debugger.thread.dump.incomplete.display.name=傾印 {0} 不完整
go.debugger.thread.dump.is.in.progress=正在進行執行緒傾印
go.debugger.thread.dump.n.goroutines={0} {0,choice,0#goroutines|1#goroutine|2#goroutine}
go.debugger.thread.dump.n.goroutines.matched.by.filter={0} 個 {0, choice, 0#goroutine|1#goroutine|2#goroutine} 通過篩選器符合
go.debugger.thread.dump.n.hidden.goroutines={0} 隱藏的 {0,choice,0#goroutines|1#goroutine|2#goroutines}
go.debugger.thread.dump.n.unique.stacks={0} 個唯一{0,choice,0#堆疊|1#堆疊|2#堆疊}
go.debugger.unknown.function.name=<未知>
go.debugger.unreadable.error=\ 不可讀: {0}
go.debugger.unsupported.architecture.error=僅 64 位系統和 32 位 Linux 系統支援偵錯
go.debugger.unsupported.go.arch.on.darwin.arm64.error=不支持偵錯使用 {0} 編譯的程序。對 darwin/arm64 使用 go sdk。
go.debugger.unsupported.go.version.on.darwin.arm64.error=在 darwin/arm64 上偵錯要求 Go 1.16
go.debugger.unsupported.type=<不支持的類型: {0}>
go.debugger.unsupported.wsl1=不支持在 WSL1 上偵錯，請使用 WSL2
go.debugger.unused.functions.are.not.included.message=" (未使用的函式未包含在可執行檔案中)"
go.debugger.unused.methods.are.not.included.message=" (未使用的方法未包含在可執行檔案中)"
go.declarations.intentions.category=Go/宣告
go.detach.directory.action.text=分離目錄“{0}”
go.edit.actions.on.save.action.description=您可以在儲存時執行的編輯動作
go.edit.actions.on.save.action.text=儲存時的動作…
go.edit.auto.import.settings.action.name=編輯自動匯入設定
go.edit.settings.action.description=編輯 Go 特定的 {0}
go.element.is.not.go.expression.error.hint=選區不包含 Go 表達式
go.empty.element.text=<空>
go.enable.template.plugin.action.text=啟用延伸模組
go.enable.template.plugin.notification.text=啟用 Go 模板以增強 html/templates 軟體套件中的突出顯示、補全和導覽功能
go.error.annotator.argument.is.not.a.type={0} 不是類型
go.error.annotator.array.bound.must.be.a.constant.expression=無效的陣列綁定 ''{0}''，必須是一個常數表達式
go.error.annotator.array.bound.must.be.non.negative=無效的陣列綁定 ''{0}''，必須為非負
go.error.annotator.array.bound.must.be.representable.by.int.type=無效的陣列綁定 ''{0}''，該值必須可以通過 ''int'' 類型表示
go.error.annotator.assignment.count.mismatch=賦值計數不符合: {0} = {1}
go.error.annotator.bad.octal.escape=八進制轉義必須包含三個八進制數字，第一個數字必須小於或等於 3
go.error.annotator.binary.digits.are.not.supported=從 Go 1.13 開始支援二進制數字
go.error.annotator.break.statement.not.inside.a.for.loop.select.or.switch='break' 語句在 'for'、'select' 或 'switch' 語句外部
go.error.annotator.call.used.as.value.but.it.returns.nothing={0} 用作值，但它不返回任何內容
go.error.annotator.can.only.use.triple.dot.as.final.argument=只能將 '...' 用作列表中的最後一個實參
go.error.annotator.cannot.assign.to.expression=無法分配給 {0}
go.error.annotator.cannot.call.pointer.method=無法在 ''{0}'' 中呼叫指針方法
go.error.annotator.cannot.declare.in.post.statement.of.for.loop=無法在 for 迴圈的 post 語句中宣告變數
go.error.annotator.cannot.declare.init.must.be.a.function=無法宣告 init，必須為函式
go.error.annotator.cannot.embed.type.parameter=無法嵌入類型參數
go.error.annotator.cannot.fallthrough.final.case.in.switch=不能在 'switch' 語句的 final case 中使用 'fallthrough'
go.error.annotator.cannot.fallthrough.in.type.switch=無法在類型 switch 中使用 'fallthrough'
go.error.annotator.cannot.infer.types=無法推斷{0}
go.error.annotator.cannot.make.type=無法生成 {0}
go.error.annotator.cannot.make.type.no.single.underlying.type=無法設為 {0}；類型集沒有單個基礎類型
go.error.annotator.cannot.reassign.a.constant=不能重新分配常數
go.error.annotator.cannot.use.comparable.in.union=不能在聯合中使用 comparable
go.error.annotator.cannot.use.generic.function.without.instantiation=未經不實例化就不能使用泛型函式
go.error.annotator.cannot.use.interface.with.methods.in.union=在聯合中不能將接口與方法結合使用
go.error.annotator.cannot.use.triple.dot.for.output.arguments=無法在輸出實參列表中使用 '...'
go.error.annotator.cannot.use.type.assertion.on.type.parameter=無法對類型參數值 {0} 使用類型斷言
go.error.annotator.cannot.use.type.embedding.comparable.in.union=不能在聯合中使用 ''{0}'' (''{0}'' 會嵌入 comparable)
go.error.annotator.cannot.use.type.parameter.as.constraint=不能將類型參數用作約束
go.error.annotator.cannot.use.type.parameter.as.rhs.in.type.declaration=不能在類型宣告中將類型參數用作 RHS
go.error.annotator.cannot.use.type.switch.on.type.parameter=無法對類型參數值 {0} 使用類型切換
go.error.annotator.closing.single.quote.expected=應為右 '
go.error.annotator.comparable.outside.of.type.parameter=不能在類型約束之外使用類型 comparable : 接口(或嵌入)為 comparable
go.error.annotator.const.initializer.is.not.a.constant=常數初始設定式 ''{0}'' 不是常數
go.error.annotator.constraint.elements.outside.of.type.parameter=接口包含約束{0,choice,1#元素|2#元素} {1}，只能在類型參數中使用
go.error.annotator.constraint.outside.of.type.parameter=接口包括約束元素，只能在類型參數中使用
go.error.annotator.constraint.term.on.interface=~ 的使用無效(''{0}'' 為接口)
go.error.annotator.constraint.term.underlying.type.is.not.self=~ 的使用無效(''{0}'' 的基礎類型不是 ''{0}'')
go.error.annotator.continue.statement.not.inside.a.for.loop='continue' 語句在 'for' 迴圈外部
go.error.annotator.conversion.in.defer.or.go={0} 需要函式呼叫，而不是轉換
go.error.annotator.cyclic.definition.detected=檢測到迴圈定義
go.error.annotator.defer.or.go.requires.function.call={0} 中的表達式必須為函式呼叫
go.error.annotator.digit.separator.is.not.supported=從 Go 1.13 開始支援數字分隔符
go.error.annotator.embedded.type.cannot.be.a.pointer=嵌入類型不能是指針
go.error.annotator.embedded.type.cannot.be.a.pointer.to.a.type.parameter=嵌入的類型不能是指向類型參數的指針
go.error.annotator.embedded.type.cannot.be.a.pointer.to.interface=嵌入類型不能是指向接口的指針
go.error.annotator.embedded.type.cannot.be.a.type.parameter=嵌入的類型不能是類型參數
go.error.annotator.empty.rune.literal=空盧恩文字
go.error.annotator.end.of.file.in.comment=檔案結尾位於註釋中
go.error.annotator.evaluated.but.not.used={0} 已求值但未使用
go.error.annotator.extra.expression.in.const.declaration=常數宣告中有額外表達式
go.error.annotator.fallthrough.statement.out.of.place='fallthrough' 語句位置不當
go.error.annotator.func.literal.cannot.have.type.parameters=函式文字不能有類型參數
go.error.annotator.function.not.permitted.in.defer.or.go=無法在 {0} 語句中呼叫此函式
go.error.annotator.function.type.cannot.have.type.parameters=函式類型不能有類型參數
go.error.annotator.generic.type.cannot.be.alias=泛型不能是別名
go.error.annotator.got.n.arguments.but.m.type.parameters=已獲得 {0} 個實參，但有 {1} 個類型參數
go.error.annotator.hex.floats.are.not.supported=從 Go 1.13 開始支援十六進制浮點
go.error.annotator.interface.method.must.have.no.type.parameters=接口方法不能有類型參數
go.error.annotator.invalid.argument.for.cap=cap 函式的實參無效
go.error.annotator.invalid.argument.for.len=len 函式的實參無效
go.error.annotator.invalid.constant.type=無效的常數類型
go.error.annotator.invalid.embedded.type=無效的類型 {0}: 必須為 typeName 或 *typeName
go.error.annotator.invalid.escape.sequence=無效轉義序列
go.error.annotator.invalid.hex.escape.sequence.syntax=\\x 必須後跟兩個十六進制數字
go.error.annotator.invalid.index.or.slice.operation=無效的動作 {0} (字串的 3 索引切片)
go.error.annotator.invalid.long.unicode.escape.sequence.syntax=\\U 必須後跟八個十六進制數字
go.error.annotator.invalid.package.name=無效的軟體套件名稱
go.error.annotator.invalid.select.assignment=select 賦值的右側必須有接收運算
go.error.annotator.invalid.select.case=Select case 必須具有接收運算、發送運算、賦值或短變數宣告
go.error.annotator.invalid.type.assertion=無效的類型斷言: {0} (左側為非接口類型 {1})
go.error.annotator.invalid.type.switch.guard=無效的類型 switch 臨界: {0} (左側為非接口類型 {1})
go.error.annotator.invalid.unicode.code.point=無效的 Unicode 程式碼點
go.error.annotator.invalid.unicode.escape.sequence.syntax=\\u 必須後跟四個十六進制數字
go.error.annotator.is.not.a.generic.type={0} 不是泛型類型
go.error.annotator.list.of.type.arguments.must.not.be.empty=類型實參列表不得為空
go.error.annotator.list.of.type.parameters.must.not.be.empty=類型參數列表不得為空
go.error.annotator.main.or.init.has.invalid.signature={0} 函式不得有實參和返回值
go.error.annotator.map.key.type.is.not.comparable=無效的映射鍵類型: 必須為鍵類型完全定義比較運算符 == 和 !=
go.error.annotator.method.cannot.have.type.parameters=方法不能有類型參數
go.error.annotator.method.name.in.interface.cannot.be.blank=接口中的方法名稱不能為空
go.error.annotator.missing.argument.to.make=缺少要生成的實參
go.error.annotator.missing.condition.in.if.statement='if' 語句中缺少條件
go.error.annotator.missing.function.body=缺少{0}正文
go.error.annotator.missing.key.in.map.literal=映射文字中缺少鍵
go.error.annotator.missing.len.argument.to.make=make 函式中缺少 len 實參
go.error.annotator.missing.value.in.const.declaration=常數宣告中缺少值
go.error.annotator.multiple.defaults={0} 中存在多個預設值
go.error.annotator.multiple.value.in.single.value.context=單值上下文中存在多值 {0}
go.error.annotator.named.and.unnamed.parameters={0} 同時具有命名參數和未命名參數 ''{1}''
go.error.annotator.named.and.unnamed.return.parameters={0} 同時具有命名和未命名的返回參數 ''{1}''
go.error.annotator.new.line.in.string=字串中出現新行
go.error.annotator.no.new.variables=':=' 的左側沒有新變數
go.error.annotator.non.integer.capacity.argument.to.make=make 函式中存在非整數容量實參
go.error.annotator.non.integer.size.argument.to.make=make 函式中存在非整數大小實參
go.error.annotator.octal.prefix.is.not.supported=從 Go 1.13 開始支援八進制前綴
go.error.annotator.parenthesized.expression.in.defer.or.go={0} 中的表達式不得使用括號
go.error.annotator.problem.capacity.less.than.size.to.make=容量不得小於大小
go.error.annotator.problem.negative.capacity.to.make=make 函式中存在負容量實參
go.error.annotator.problem.negative.size.to.make=make 函式中存在負大小實參
go.error.annotator.problem.redundant.capacity.hint.to.make=冗餘容量提示
go.error.annotator.problem.redundant.size.hint.to.make=冗餘大小提示
go.error.annotator.reference.is.not.a.type={0} 不是類型
go.error.annotator.semicolon.is.missing=缺少 ;
go.error.annotator.shadowed.receiver.is.not.a.generic.type={0} 不是泛型類型(接收器由類型參數隱藏)
go.error.annotator.too.many.arguments.to.make=make 函式中的實參過多
go.error.annotator.too.many.arguments.to.new=實參過多，無法新增新實參
go.error.annotator.too.many.characters.in.rune.literal=rune 文字中的字元數過多
go.error.annotator.too.many.variables.in.range=範圍中的變數過多
go.error.annotator.type.aliases.are.available.since.go.1.9=類型宣告中存在意外的 '='；類型別名自 Go 1.9 以後可用
go.error.annotator.type.cannot.be.declared.in.generic.function=無法在泛型函式中宣告類型
go.error.annotator.type.cannot.be.declared.in.generic.method=無法在泛型方法中宣告類型
go.error.annotator.type.constraint.is.missing=缺少類型約束
go.error.annotator.type.is.not.an.expression=類型 ''{0}'' 不是表達式
go.error.annotator.type.parameters.are.not.supported=從 Go 1.18 開始支援泛型
go.error.annotator.unexpected.assign.operator=意外的 {0}，應為 '':=''、''='' 或 '',''
go.error.annotator.unexpected.end.of.statement=語法錯誤: 語句意外結束，應為 ':='、'=' 或 ','
go.error.annotator.unexpected.newline.after.if=意外換行，在 'if' 子句後應為 '{'
go.error.annotator.unexported.reference.usage=無法在當前軟體套件中使用未匯出的 {0} ''{1}''
go.error.annotator.use.of.generic.type.without.instantiation=在不實例化的情況下使用泛型
go.error.annotator.use.of.package.without.selector=使用無選擇器的軟體套件 ''{0}''
go.error.annotator.use.of.type.outside.type.switch=在類型 switch 外部使用 .(type)
go.error.go.build.after.package=go:build 指令必須位於 package 子句前面
go.error.go.build.and.plus.build.lines.dont.match=//+build 行不符合 //go:build 條件
go.error.go.build.expression.is.too.complex=表達式對於 //+build 行過於複雜
go.error.go.build.non.first.element=go:build 指令必須為程式碼行的第一個元素
go.error.go.build.only.one.allowed=一個檔案中只允許使用一條 //go:build 指令
go.error.go.build.without.plus.build=//go:build 註釋沒有 //+build 註釋
go.error.go.embed.all.prefix.not.supported=路徑模式無效，'all:' 前綴需要 Go 1.18
go.error.go.embed.empty.directory=無法嵌入空目錄
go.error.go.embed.file.must.import.embed=包含 go:embed 的 Go 檔案必須匯入 "embed" 軟體套件
go.error.go.embed.invalid.path.elements=路徑不得包含 '.' 或 '..' 路徑元素，也不得以前導斜杠開頭
go.error.go.embed.invalid.path.pattern=路徑模式無效
go.error.go.embed.invalid.syntax.of.paths=路徑模式語法無效
go.error.go.embed.must.be.above.var.declaration=go:embed 必須位於單個全域變數宣告的上方
go.error.go.embed.no.path.arguments=go:embed 後面應為路徑模式
go.error.go.embed.not.supported=自 Go 1.16 起支援 go:embed
go.error.go.embed.path.must.resolve.to.file='string' 和 '[]byte' 類型的變數只能嵌入一個檔案
go.error.go.embed.single.path.expected='string' 和 '[]byte' 類型的變數只能有一個路徑模式
go.error.go.embed.unresolved.path=未解析路徑
go.error.go.embed.var.has.wrong.type=go:embed's 變數必須為 'string'、'[]byte' 或 'embed.FS' 類型
go.error.go.plus.build.can.be.converted.to.go.build=//+build 註釋可以轉換為 //go:build 指令
go.error.go.plus.build.can.be.removed=可以移除 //+build 註釋
go.error.invalid.double.negation=雙重求反無效
go.error.invalid.non.alphanumeric.character=非字母數字字元無效
go.error.parser.expected=應為 ''{0}''
go.error.parser.expected.got=應為 ''{0}''，但得到的是 ''{1}''
go.error.parser.expected.or=應為 ''{0}'' 或 ''{1}''
go.error.parser.expected.or.got=應為 ''{0}'' 或 ''{1}''，但得到的是 ''{2}''
go.error.parser.unexpected=意外的''{0}''
go.error.windows.project.wsl.sdk=無法使用 WSL SDK 編譯 Windows 專案
go.error.wsl.project.requires.wsl.sdk=WSL 中的專案需要 WSL 中的 Go SDK
go.error.wsl.project.requires.wsl.sdk.from.same.instance=WSL 中的專案需要來自同一個 WSL 實例的 Go SDK
go.error.wsl.project.windows.sdk=無法使用 Windows SDK 編譯 WSL 專案
go.error.wsl.sdk.cannot.be.used.for.windows.project=WSL 中的 Go SDK 不能用於 Windows 專案
go.exclude.import.path.dialog.empty.path.validation.message=匯入路徑不能為空
go.exclude.import.path.dialog.title=排除匯入路徑
go.exclude.import.path.from.completion.action.name=排除 ''{0}''
go.execution.application.process.name=程序
go.execution.application.run.configuration.description=Go 建置執行組態
go.execution.application.run.configuration.display.name=Go 建置
go.execution.before.run.task.command.should.not.start.with.go.error=Go 指令不應以 'go' 開頭
go.execution.before.run.task.description=執行 ''{0}''
go.execution.before.run.task.edit.go.command.dialog.title=編輯 Go 指令任務
go.execution.before.run.task.empty.command.error=不允許空 Go 指令
go.execution.before.run.task.error.dialog.title=Go 指令任務
go.execution.before.run.task.executing.presentable.name=正在執行 ''{0}''
go.execution.before.run.task.name=執行 Go 指令
go.execution.before.run.task.supports.only.go.modules.error=Go 指令任務僅支援啟用了 Go 整合的模組
go.execution.before.run.task.supports.only.go.run.configurations.error=Go 指令任務僅支援 Go 執行組態
go.execution.can.not.run.go.local.process.error=無法執行 Go 本地程序
go.execution.cannot.create.output.file.error=無法建立輸出檔案 {0}
go.execution.cannot.create.output.file.in.error=無法在 {0} 中建立輸出檔案
go.execution.cannot.create.temp.output.file.error=無法建立臨時輸出檔案
go.execution.cannot.find.directory.error=找不到目錄 <code>{0}</code>
go.execution.cannot.find.input.file.error=找不到輸入檔案 <code>{0}</code>
go.execution.cannot.find.package.error=找不到軟體套件 <code>{0}</code>
go.execution.cannot.find.target.error=找不到目標 {0}
go.execution.cannot.find.target.to.compile.error=找不到要編譯的目標
go.execution.cannot.find.working.directory.error=找不到工作目錄 <code>{0}</code>
go.execution.cannot.make.temporary.file.executable.error=無法使臨時檔案成為可執行檔案 {0}
go.execution.change.goroot.action.name=更改 GOROOT
go.execution.compilation.failed.notification.title=編譯失敗
go.execution.compilation.finished.with.exit.code=編譯完成，並顯示退出程式碼 $EXIT_CODE$
go.execution.compiled.binary.cannot.be.executed=無法執行已編譯的二進制檔案
go.execution.could.not.bind.remote.debugging.port.error=無法綁定遠端偵錯連接埠
go.execution.coverage.cannot.run.coverage.on.directory.kind.run.configurations.error=無法在目錄種類執行組態上執行覆蓋率分析
go.execution.coverage.covered=已覆蓋
go.execution.coverage.downloading.coverage.report.progress.title=正在下載覆蓋率報告…
go.execution.coverage.engine.name=Go 覆蓋率
go.execution.coverage.loading.coverage.data=正在載入覆蓋率資料…
go.execution.coverage.percent.files=% 檔案
go.execution.coverage.percent.statements=% 語句
go.execution.coverage.runner.name=Go
go.execution.debugger.process.name=偵錯器
go.execution.directory.is.not.specified.error=未指定目錄
go.execution.dlv.not.found.for=找不到 {0}/{1} 的 Delve 可執行檔案。通過在 ''幫助 | 編輯自定義屬性'' 中新增 ''dlv.path=/path/to/delve'' 來指定 Delve 位置。
go.execution.dlv.not.found.for.target.platform=找不到目標平台的 Delve 可執行檔案。通過在 '幫助 | 編輯自定義屬性' 中新增 'dlv.path=/path/to/delve' 來指定 Delve 位置。
go.execution.duplicate.file.error=檔案已在列表中: {0}
go.execution.enter.sudo=輸入您的 sudo 密碼:
go.execution.failed.to.prepare.remote.environment.error=無法準備遠端環境: {0}
go.execution.file.is.not.specified.error=未指定檔案
go.execution.file.not.found.error=找不到檔案: <code>{0}</code>
go.execution.files.must.be.in.one.directory.error=命名檔案必須全部位於一個目錄中
go.execution.go.is.not.configured.error=沒有為此執行組態組態 Go: {0}
go.execution.go.sdk.is.not.downloaded.yet=Go SDK 尚未下載
go.execution.go.setup.folding.placeholder=<{0} go 設定{0,choice,1#呼叫|2#呼叫}>
go.execution.input.file.is.not.specified.error=未指定輸入檔案
go.execution.install.lldb.notification.text=使用 xcode-select --install 安裝 lldb
go.execution.module.does.not.exist.error=模組 <code>{0}</code> 在專案中不存在
go.execution.not.go.file.error=檔案不是 Go 檔案: {0}
go.execution.outdated.go.notification.text=要完全支援所有偵錯功能，請更新 Go 版本。
go.execution.outdated.go.notification.title=您的 Go 版本已過時
go.execution.package.contains.several.mains.error=軟體套件 <code>{0}</code> 包含多個 <code>main</code> 函式<br>請考慮改用檔案種類
go.execution.package.is.not.specified.error=未指定軟體套件
go.execution.process.cancelled=已取消
go.execution.process.failed.to.run=執行失敗
go.execution.process.finished.successfully=成功完成
go.execution.process.finished.with.exit.code={0} 已完成，退出程式碼為 {1}
go.execution.process.interrupted=已中斷
go.execution.remote.run.configuration.description=Go Remote
go.execution.remote.run.configuration.display.name=Go Remote
go.execution.remote.run.configuration.host.label=主機(&H):
go.execution.remote.run.configuration.port.label=連接埠(&P):
go.execution.remote.run.configuration.start.delve.text=在執行此組態之前，請按以下說明啟動您的應用程式和 Delve。<br> <br>允許 Delve 編譯您的應用程式: <br><pre>dlv debug --headless --listen=:{0} --api-version=2 --accept-multiclient</pre><br>或使用 Go {3} 或更高版本編譯應用程式: <br><pre>go build -gcflags "all=-N -l" github.com/app/demo</pre><br>，然後使用以下指令在 Delve 中執行: <br><pre>dlv --listen=:{1} --headless=true --api-version=2 --accept-multiclient exec ./{2}</pre>
go.execution.run.after.build.is.not.possible.incompatible.os.error=無法在建置後執行<br>結果二進制檔案將與作業系統不相容
go.execution.run.after.build.is.not.possible.main.not.found.many.files.error=無法在建置後執行<br>所選檔案都沒有 'main' 軟體套件和 'main' 函式
go.execution.run.after.build.is.not.possible.main.not.found.single.file.error=無法在建置後執行<br>'main' 檔案具有非 main 軟體套件或不包含 'main' 函式
go.execution.run.application.tooltip=執行應用程式
go.execution.scratch.runconfig.extension.different.contexts.notification=''{0}'' 執行組態針對為上下文使用不同模組的臨時檔案。請針對為上下文使用同一個模組的臨時檔案。
go.execution.scratch.runconfig.extension.edit.notification.action=編輯執行組態
go.execution.scratch.runconfig.extension.edit.notification.title=執行組態的目標無效
go.execution.scratch.runconfig.extension.wrong.kind.notification=''{0}'' 執行組態使用{1}執行種類。請在臨時檔案的執行組態中使用“檔案”執行種類。
go.execution.sdk.is.not.specified.error=沒有為模組 <code>{0}</code> 指定 Go SDK
go.execution.sdk.not.set.or.sdk.home.path.empty.for.module.error=未設定 SDK 或此模組的 SDK 主路徑為空
go.execution.test.collecting.build.tags.progress.title=正在收集建置標記…
go.execution.unknown.error=未知錯誤，詳情參見日誌
go.execution.unknown.target.delve.socket.error=無法執行 Delve。目標套接字未知。RunState: {0}
go.execution.working.directory.is.not.specified.error=未指定工作目錄
go.external.system.auto.import.is.disabled=由於設定了 'external.system.auto.import.disabled' 註冊表項，IDE 無法正常執行。請停用此設定並重啟 IDE。
go.file.watcher.go.fmt.description=對 Go 檔案執行 'go fmt'
go.file.watcher.go.imports.description=對 Go 檔案執行 'goimports'
go.file.watcher.golangci.description=在當前 Go 檔案目錄中執行 'golangci-lint'
go.find.usages.of.interface.methods.dialog.base.methods.checkbox=基方法(&B)
go.find.usages.of.interface.methods.dialog.message=類型 ''{0}'' 實作接口，方法 ''{1}'' 覆寫方法。是否要尋找接口方法的用法?
go.find.usages.of.interface.methods.dialog.title=尋找接口方法的用法?
go.find.usages.of.interface.methods.notification.show.options.text=顯示選項 {0}
go.find.usages.of.interface.methods.notification.title=正在尋找接口方法的用法
go.find.usages.show.usages.in.comments.description=在註釋中顯示元素用法
go.find.usages.show.usages.in.comments.text=在註釋中顯示用法
go.fix.add.comma.name=新增逗號
go.fix.add.comment.name=新增註釋
go.fix.add.explicit.dereference.name=新增顯式取消參照
go.fix.add.function.block.name=新增正文
go.fix.add.function.call.name=新增函式呼叫
go.fix.add.import.for.side.effects.name=副作用匯入
go.fix.add.keys.to.struct.literal.value.name=新增鍵並刪除零值
go.fix.add.local.var.for.expression.name=引入區域變數
go.fix.add.missing.new.line.name=新增缺少的新行
go.fix.add.missing.return.value.name=新增缺少的返回值
go.fix.add.plus.build.comments=新增 //+build 註釋
go.fix.add.pointer.name=新增指針
go.fix.add.prefix.to.comment.name=向註釋中新增 ''{0}'' 前綴
go.fix.add.return.statement.name=新增 return 語句
go.fix.add.square.brackets=新增中括號
go.fix.add.whitespace.name=新增空格
go.fix.always.false.for.name=移除 'for' 迴圈
go.fix.always.false.if.name=移除 'if' 分支
go.fix.always.true.for.name=移除冗餘條件
go.fix.always.true.if.name=移除其他分支並簡化當前的 'if'
go.fix.call.receiver.is.not.an.expression=意外的呼叫接收器，不是表達式
go.fix.change.array.size.to=將陣列大小更改為 {0}
go.fix.change.array.size.to.family.name=更改陣列大小
go.fix.change.import.sorting.settings.name=更改匯入排序設定
go.fix.change.parameters.name=更改參數
go.fix.change.parameters.parameter={0,choice,0#參數|1#參數|2#參數}
go.fix.change.result.parameters.in.assignment.name=更改賦值中的結果參數
go.fix.change.result.parameters.in.call.name=更改呼叫中的結果參數
go.fix.change.result.parameters.in.return.name=更改返回中的結果參數
go.fix.change.result.parameters.in.variable.specification.name=更改變數規範中的結果參數
go.fix.change.result.parameters.name=更改結果參數
go.fix.change.result.parameters.result.parameter={0,choice,0#結果參數|1#結果參數|2#結果參數}
go.fix.change.signature.from.function.type.name=從函式類型更改簽名
go.fix.change.signature.from.function.type.text=將{0} ''{1}'' 的簽名更改為 ({2}) ({3})
go.fix.change.signature.from.usage.add=將 ''{0}'' 作為第 {1,number,ordinal} 個{2}新增到{3} ''{4}'' 中
go.fix.change.signature.from.usage.change=將{2} ''{3}'' 的第 {0,number,ordinal} 個{1}從 ''{4}'' 更改為 ''{5}''
go.fix.change.signature.from.usage.mix=將{1} ''{2}'' 的{0}更改為 ({3})
go.fix.change.signature.from.usage.remove=從{2} ''{3}'' 中移除第 {0,number,ordinal} 個{1}
go.fix.change.signature.from.usage.text=從用法更改簽名
go.fix.change.signature.to.expected.name=對預期簽名的更改
go.fix.choose.package.name=選擇軟體套件名稱
go.fix.configure.go.sdk.text=組態 Go SDK
go.fix.convert.double.quoted.string.to.raw.string=將帶雙引號的字串轉換為原始字串
go.fix.convert.int.to.rune=將整數轉換為 rune
go.fix.convert.int.to.string.using.conversion.call=使用 {0} 呼叫將整數轉換為字串
go.fix.convert.plus.build.comments.to.go.build.directive=將 //+build 註釋轉換為 //go:build 指令
go.fix.convert.raw.string.to.double.quoted.string=將原始字串轉換為帶雙引號的字串
go.fix.convert.string.to.byte.name=將字串轉換為位元組
go.fix.convert.to.expected.type.name=轉換為
go.fix.convert.to.expected.type.text=轉換為 ''{0}''
go.fix.convert.to.format.function.name=更改為格式設定函式
go.fix.convert.to.format.function.text=更改 ''{0}'' 為格式設定函式
go.fix.convert.to.is.equal.name=轉換為 '=='
go.fix.create.directory.text=在 {1} 處建立目錄{0}
go.fix.create.wrapper.type.name=建立類型
go.fix.delete.all.unused.parameters.name=刪除所有未使用的參數
go.fix.delete.ampersand.and.type.in.composite.lit.name=刪除冗餘類型
go.fix.delete.blank.argument.name=刪除空白實參
go.fix.delete.conversion.name=刪除轉換
go.fix.delete.conversion.with.side.effects.name=刪除轉換(可能改變語意)
go.fix.delete.extra.expressions.name=刪除多餘的表達式
go.fix.delete.import.name=刪除匯入
go.fix.delete.name=刪除 {0}
go.fix.delete.parameter.names.name=刪除參數名稱
go.fix.delete.range.name=刪除元素
go.fix.delete.redundant.capacity.hint.to.make=刪除容量實參
go.fix.delete.redundant.index.name=刪除冗餘索引
go.fix.delete.redundant.size.hint.to.make=刪除大小實參
go.fix.delete.text=刪除{0} ''{1}''
go.fix.delete.third.index.name=刪除第三索引
go.fix.delete.type.arguments.in.index.or.slice.expr=刪除類型實參
go.fix.delete.type.arguments.name=刪除類型實參
go.fix.delete.type.parameters.name=刪除類型參數
go.fix.delete.unused.parameter.name=刪除未使用的參數
go.fix.drop.suffix.name=刪除特定於單元的後綴
go.fix.drop.suffix.text=刪除特定於單元的後綴 ''{0}''
go.fix.empty.signature.name=修復簽名
go.fix.enable.gopath.indexing.name=啟用 GOPATH 索引
go.fix.error.string.format=修正錯誤字串格式
go.fix.exclude.from.unhandled.inspection.name=不再報告此方法/函式
go.fix.export.field.name=匯出欄位
go.fix.export.name=匯出
go.fix.export.text=匯出 {0}
go.fix.extract.empty.slice.to.var.declaration.name=取代為零切片宣告(更改語意)
go.fix.extract.to.own.declaration.name=提取到自己的宣告
go.fix.failed.to.handle.error=無法處理錯誤
go.fix.failed.to.introduce.variables.from.call=無法從呼叫引入變數
go.fix.failed.to.resolve.called.function.signature=無法從呼叫解析簽名
go.fix.failed.to.simplify.if.statement=無法簡化 'if' 語句
go.fix.field.repeats.tag.with.value=欄位 ''{0}'' 重複 ''{3}'' 欄位中值為 ''{2}'' 的 ''{1}'' 標籤
go.fix.field.with.the.same.tag=包含相同 ''{1}'' 標籤的欄位 ''{0}''
go.fix.finish.call.name=完成呼叫表達式
go.fix.handle.error.name=處理錯誤
go.fix.ignore.explicitly.name=顯式忽略
go.fix.ignore.explicitly.using.closure.name=使用閉包顯式忽略
go.fix.ignore.unused.call.result.name=忽略未使用的呼叫結果
go.fix.implement.missing.methods.name=實作缺少的方法
go.fix.import.embed.package=匯入 "embed"
go.fix.insert.blank.identifiers.name=將空白關鍵字插入賦值語句的左側
go.fix.introduce.function.name=建立函式
go.fix.introduce.function.text=建立函式 ''{0}''
go.fix.introduce.local.variable.for.expression=引入 ''{0}'' 的區域變數
go.fix.introduce.method.name=建立方法
go.fix.introduce.method.text=建立方法 ''{0}''
go.fix.multiple.packages.command.name=將軟體套件重命名為 {0}
go.fix.multiple.packages.name=重新命名軟體套件
go.fix.multiple.packages.text=將軟體套件重命名為 {0}
go.fix.navigate.to.name=導覽到
go.fix.navigate.to.text=導覽到 {0}
go.fix.optimize.imports.name=最佳化 import
go.fix.place.build.tag.before.package.name=在軟體套件前面放置建置標記
go.fix.place.go.build.before.package=將 go:build 放在 package 前面
go.fix.remove.leading.whitespace.go.directive=移除 Go 指令前的前導空格
go.fix.remove.plus.build.comments=移除 //+build 註釋
go.fix.remove.redundant.bool.literal.name=簡化為
go.fix.rename.all.receivers.name=重新命名所有接收器
go.fix.rename.all.receivers.text=重新命名所有接收器為 ''{0}'' 
go.fix.rename.to.blank=重命名為 _
go.fix.rename.to.name=重命名為
go.fix.rename.to.text=重命名為 ''{0}''
go.fix.replace.and.return=取代為 ''{0}'' 和 ''return''
go.fix.replace.assign.with.equals.name=將 ':=' 取代為 '='
go.fix.replace.equals.with.assign.name=取代為 ':='
go.fix.replace.expression.name=預置 '\\&'
go.fix.replace.field.type.with.pointer=將{0,choice,0#欄位|1#欄位|2#欄位} ''{1}'' 類型取代為指針
go.fix.replace.switch.on.types.with.errors.as=Replace type switch on errors with 'errors.As'
go.fix.replace.switch.on.types.with.errors.as.error.hint.message=Cannot replace type switch on error with 'errors.As' when there is a type guard variable and more than one case clause
go.fix.replace.switch.on.types.with.errors.as.error.hint.title=Replace Type Switch on Error with 'errors.As' Failed
go.fix.replace.tilda.with.hat.name=將 '~' 取代為 '^'
go.fix.replace.type.assertion.with.errors.as=Replace type assertion with 'errors.As'
go.fix.replace.with.correct.defer.name=取代為正確的 defer 結構
go.fix.replace.with.name=取代為
go.fix.replace.with.nil.with.side.effects.name=取代為 nil (更改語意)
go.fix.replace.with.text=取代為 ''{0}''
go.fix.searching.for.usages.progress.title=正在搜尋用法…
go.fix.signature.name=修復簽名
go.fix.simplify.bool.expr.name=簡化表達式
go.fix.simplify.expression.to.boolean.literal.name=簡化條件
go.fix.simplify.something.to.text=將 ''{0}'' 簡化為 ''{1}''
go.fix.simplify.to.text=簡化為 ''{0}''
go.fix.sort.imports=import 排序
go.fix.suppress.all.inspections.for.text=禁止{0}的所有檢查
go.fix.suppress.inspection.for.text=對{0}禁止
go.fix.unpack.slice.name=解壓縮切片
go.fix.unwrap.parens.name=取消換行括號
go.fix.update.plus.build.comments=更新 //+build 註釋
go.fix.uppercase.type.parameter.name=為類型參數使用大寫
go.fix.uppercase.type.parameter.text=為類型參數 ''{0}'' 使用大寫
go.fix.view.all.duplicates.name=檢視重複的名稱
go.fix.view.all.duplicates.targets.code.usages.string=已找到重複項
go.fix.view.all.duplicates.targets.tab.text=''{0}'' 的重複項
go.fix.view.all.duplicates.targets.tool.window.title={1} 中的 {0}
go.fix.view.all.duplicates.text=檢視 ''{0}'' 的重複名稱
go.fix.wrap.error.handling.in.closure=在閉包內部封裝錯誤處理
go.fmt.add.leading.space.to.comments=向註釋新增前導空格
go.fmt.add.parentheses.for.single.import=為單個匯入新增括號
go.fmt.create.local.group.label=組
go.fmt.fill.paragraph.width.label=填充段落的列寬:
go.fmt.for.current.project.packages=當前專案軟體套件
go.fmt.for.imports.starting.with.prefix=匯入開頭:
go.fmt.for.imports.starting.with.prefix.comment=逗號分隔的前綴列表，與 'goimports -local' 相同
go.fmt.formatting.service.error.title=無法在 {0} 上執行 gofmt
go.fmt.group.stdlib.imports=對 Go SDK 中的軟體套件分組
go.fmt.import.sorting.type=排序類型
go.fmt.imports.prefix.error.empty.message=匯入前綴不能為空
go.fmt.imports.prefix.error.title=匯入前綴錯誤
go.fmt.imports.tab.title=匯入
go.fmt.move.all.imports.in.single.declaration=將所有匯入移至一個宣告中
go.fmt.move.all.stdlib.imports.in.single.group=將所有軟體套件移至一個組中
go.fmt.remove.redundant.import.aliases=移除冗餘匯入別名
go.fmt.run.gofmt.on.code.reformat.label=執行“重新格式化程式碼”動作時
go.fmt.run.gofmt.panel.border.title=執行 gofmt
go.fmt.use.back.quotes.for.imports=為匯入使用左引號
go.format.playground.could.not.format.message=無法格式化程式碼
go.generate.type.from.json.dialog.json.label=將 JSON 放置在此處:
go.generate.type.from.json.dialog.ok.label=生成
go.generate.type.from.json.dialog.title=從 JSON 生成 Go 類型
go.generate.type.from.json.error.invalid.json=無法從無效的 JSON 生成 go 類型
go.generate.type.from.json.error.no.top.value=JSON 應有一個頂層值
go.generate.type.from.json.on.paste.dialog.title=從 JSON 生成 Go 類型
go.generate.type.from.json.on.paste.struct.fields.message=插入的文本似乎是 JSON。是否要從它生成結構欄位?
go.generate.type.from.json.on.paste.type.message=插入的文本似乎是 JSON。是否要從它生成 Go 類型?
go.generate.type.from.json.properties.on.paste.struct.fields.message=插入的文本似乎是一系列 JSON 屬性。是否要從它生成結構欄位?
go.generate.type.from.json.properties.on.paste.type.message=插入的文本似乎是一系列 JSON 屬性。是否要從它生成 Go 類型?
go.get.package.fix.family.name=執行 'go get'
go.go.inspection.problem.replace.can.be.migrated=可以遷移到 Go 工作區
go.go.mod.error.annotator.missing.dependency=缺少相依關係
go.go.mod.error.annotator.multiple.module.statements=檔案中存在多個模組語句
go.go.mod.error.annotator.multiple.version.statements=檔案中存在多個 go 版本的語句
go.go.mod.error.annotator.no.module.statement=檔案中沒有模組語句
go.go.mod.error.annotator.unresolved.dependency=未解析的相依項
go.go.mod.error.module.version.expected=應為模組版本
go.go.mod.error.prohibited.directive=go.mod 檔案中不允許使用指令
go.go.mod.retract.not.supported=自 Go 1.16 起開始支援 'retract'
go.go.mod.retract.wrong.range.format=版本範圍必須採用 '[start, end]' 格式
go.go.mod.toolchain.not.supported='toolchain' is supported starting with Go 1.21
go.go.work.error.prohibited.directive=go.work 檔案中不允許使用指令
go.go.work.error.unresolved.path=未解析的路徑
go.go.work.multiple.use.directives=可以將多個 'use' 指令合併為一個
go.ignore.template.plugin.action.text=忽略此專案的延伸模組
go.import.optimizer.removed.aliases=移除的 {0} 個{0,choice,1#別名|2#別名}
go.import.optimizer.removed.imports=移除的 {0} 個{0,choice,1#匯入|2#匯入}
go.import.optimizer.removed.imports.and.aliases=已移除 {0} 條 {0,choice,1#import|2#import} 和 {1} 個{1,choice,1#別名|2#別名}
go.import.package.cannot.invoke.fix.with.ambiguous.imports.error=無法在編輯器 {0} 中對不明確的匯入呼叫修正。軟體套件: {1}
go.import.package.fix.family.name=匯入軟體套件
go.import.package.fix.text=匯入軟體套件
go.import.package.fix.text.many.variants=匯入{0}? (多個選擇…)
go.import.package.fix.text.no.variants=匯入軟體套件?
go.import.package.fix.text.single.variant=匯入{0}?
go.import.package.popup.title=要匯入的軟體套件
go.index.entire.gopath.checkbox=為整個 GOPATH 編制索引
go.index.entire.gopath.tooltip=禁用時，將僅對專案和 vendor 軟體套件編制索引。<br/>這樣可以提升整體性能，但無法使用 GOPATH 中的包。
go.init.with.zero.value=使用零值初始化
go.inlays.display.constant.definition=顯示常數定義的值
go.inlays.show.return.parameters.option=顯示返回參數
go.inlays.show.unnamed.fields.in.structure.values.option=在結構值中顯示未命名欄位
go.inspection.ambiguous.reference.message=不明確的參照 {0}
go.inspection.assignment.nil.without.explicit.type.message=如果沒有顯式類型，則無法分配 nil
go.inspection.assignment.to.receiver.display.name=賦值給接收器
go.inspection.bool.condition.display.name=布爾型條件
go.inspection.change.context.todo=考慮使用定義明確的上下文
go.inspection.comment.has.no.leading.space.display.name=註釋沒有前導空格
go.inspection.comment.of.exported.element.starts.with.incorrect.name.display.name=匯出的元素的註釋以不正確的名稱開頭
go.inspection.comment.should.be.meaningful.message=註釋應有意義，否則應當移除
go.inspection.comment.should.be.without.article.message=註釋格式應為 ''{0} ...'' (有可選的前導條目)
go.inspection.comment.should.have.package.prefix.message=軟體套件註釋應採用 ''Package {0} ...'' 的形式
go.inspection.convert.string.literals.display.name=轉換字串文字
go.inspection.defer.go.statement.calls.recover.or.panic.directly.display.name=Defer/go 語句直接呼叫 'recover' 或 'panic'
go.inspection.defer.in.loop.display.name=迴圈中的 'defer'
go.inspection.defer.or.go.should.not.call.function.message={0} 不應直接呼叫 {1}
go.inspection.deprecated.element.display.name=棄用的元素
go.inspection.discarded.context.cancel.function=應該呼叫取消函式，而不是將其捨棄，以避免上下文泄漏
go.inspection.division.by.zero.display.name=除以零
go.inspection.empty.declaration.display.name=空宣告
go.inspection.empty.declaration.message=宣告 {0} 為空
go.inspection.empty.slice.declared.via.literal.display.name=使用文字宣告的空切片
go.inspection.error.string.should.not.be.capitalized.or.end.with.punctuation.display.name=錯誤字串不應大寫或以標點結尾
go.inspection.exceeded.shift.expression.display.name=已超出 shift 表達式
go.inspection.execution.ends.without.context.cancel.function.after.instruction=執行可能在此指令後結束而不呼叫 ''{0}'' 函式，從而導致上下文泄漏
go.inspection.execution.ends.without.context.cancel.function.after.statement=執行可能在此 ''{0}'' 語句後結束而不呼叫 ''{1}'' 函式，從而導致上下文泄漏
go.inspection.expected.colon.after.key=鍵後面應為 ':'
go.inspection.expected.opening.double.quote.character.after.colon=':' 後面應為左雙引號字元
go.inspection.explicit.dereference.accessing.field.message=存取 {1}(類型為 {2})的欄位 {0} 需要顯式取消參照
go.inspection.explicit.dereference.calling.method.with.receiver.message=包含接收器 {1}(類型為 {2})的呼叫方法 {0} 需要顯式取消參照
go.inspection.exported.element.should.have.comment.display.name=匯出的元素應有註釋
go.inspection.exported.element.should.have.its.own.declaration.display.name=匯出的元素應有自己的宣告
go.inspection.extended.method.expression.syntax.before.go.1.10.message=意外的接收器類型，自 Go 1.10 起可以使用擴展的方法表達式語法
go.inspection.fail.now.called.from.non.test.goroutine=必須從執行測試或基準測試的 goroutine 呼叫此方法
go.inspection.fail.now.in.non.test.goroutine=非測試 goroutine 中的 'FailNow'
go.inspection.function.returns.without.calling.context.cancel.function=有一個執行路徑沒有呼叫此取消函式，從而導致上下文泄漏
go.inspection.imported.package.name.as.name.identifier.display.name=軟體套件名稱作為名稱關鍵字匯入
go.inspection.impossible.interface.type.assertion=不可能的接口類型斷言
go.inspection.incorrect.call.to.unmarshal.display.name=使用錯誤的實參呼叫了 'Unmarshal'
go.inspection.incorrect.strings.replace.count.argument.display.name=不正確的 'strings.Replace' 計數實參
go.inspection.incorrect.usage.of.printf.display.name=不正確的 'fmt.Printf' 和 'fmt.Println' 函式用法
go.inspection.incorrect.usage.of.the.errors.as.function.display.name=不正確的 'errors.As' 函式用法
go.inspection.incorrect.usage.of.the.sync.atomic.display.name=不正確的 'sync/atomic' 軟體套件用法
go.inspection.infinite.for.loop.display.name=無限的 'for' 迴圈
go.inspection.int.to.string.conversion=整數轉換為字串類型
go.inspection.invalid.conversions.of.uintptr.to.unsafe.Pointer=無效的 'uintptr' 到 'unsafe.Pointer' 轉換
go.inspection.key.is.empty.or.starts.from.incorrect.symbol=鍵為空或者以不正確的符號開頭
go.inspection.key.is.not.separated.by.space.from.previous.pair=鍵與上一對沒有用空格分隔
go.inspection.leading.whitespace.in.directive.comment=指令註釋中的前導空格
go.inspection.locks.mistakenly.passed.by.value=鎖通過值錯誤傳遞
go.inspection.loop.closure.display.name=函式文字捕獲的迴圈變數
go.inspection.loop.closure.message=由 <code>{0}</code> 語句中的 <code>func</code> 文字捕獲的迴圈變數可能有意外值
go.inspection.lost.cancel='context.CancelFunc' 未被呼叫
go.inspection.malformed.build.tag.display.name=建置標記的格式錯誤
go.inspection.malformed.struct.tag.display.name=結構標記的格式錯誤
go.inspection.missing.closing.double.quote.character.in.value=值中缺少右雙引號字元
go.inspection.missing.trailing.comma.before.newline.in.composite.literal.display.name=複合文字中的換行符前缺少尾隨逗號
go.inspection.mixed.receiver.types=結構 {0} 在值接收器和指針接收器上都有方法。Go 文檔不推薦使用此類別用法。
go.inspection.mixed.receiver.types.display.name=混合值和指針接收器
go.inspection.name.starts.with.package.name.display.name=名稱以軟體套件名稱開頭
go.inspection.nilness.analyzer.display.name=為零性分析器
go.inspection.non-standard.signature.for.well.known.function.names.display.name=已知函式名稱採用非標準簽名
go.inspection.options.panel.exclude=排除:
go.inspection.options.panel.function.name=函式名稱
go.inspection.options.panel.import.path=匯入路徑
go.inspection.options.panel.method.name=方法名稱
go.inspection.options.panel.receiver=接收器
go.inspection.options.panel.reported.functions=報告的函式/方法: 
go.inspection.options.panel.string.methods=字串方法:
go.inspection.possible.misuse.of.unsafe.pointer=可能濫用 {0}
go.inspection.problem.accessing.field.may.lead.to.nil.pointer.dereference=存取欄位 {0} 可能導致 nil 指針取消參照
go.inspection.problem.argument.causes.recursive.call.to.string.method=實參 {0} 導致對 {1} 方法的遞迴呼叫
go.inspection.problem.argument.is.not.a.function.call=實參 {0} 不是函式呼叫
go.inspection.problem.assignment.copies.lock.value=賦值將鎖定值複製到 {0}: {1}
go.inspection.problem.assignment.to.entry.may.panic.because.of.nil.map=由於 {0} 映射，賦值給某個條目可能會出現 panic
go.inspection.problem.assignment.to.method.receiver.doesnt.propagate=對方法接收器的賦值不傳播到其他呼叫
go.inspection.problem.assignment.to.method.receiver.propagates.only.to.callees=對方法接收器的賦值僅傳播到被呼叫方，不傳播到呼叫方
go.inspection.problem.assignment.used.as.value={0} 作為值使用
go.inspection.problem.at.is.not.allowed.in.import.paths=匯入路徑中不允許 @
go.inspection.problem.bad.count.argument.of.strings.replace={0} 的計數實參不應為 {1}
go.inspection.problem.bad.error.string=錯誤字串不應大寫或以標點結尾
go.inspection.problem.build.constraints.exclude.all.go.files=建置約束排除 {0} 中所有的 Go 檔案
go.inspection.problem.call.copies.lock.value=呼叫 {0} 將複製鎖定值: {1}
go.inspection.problem.cannot.assign.in.multiple.assignment=無法在多個賦值中將 {0} 賦給 {1}
go.inspection.problem.cannot.assign.value.to.blank.field=無法將值賦給空欄位
go.inspection.problem.cannot.assign.value.to.unexported.field=無法將值賦給未匯出的欄位 {0}
go.inspection.problem.cannot.call.non.function=無法呼叫類型為 {1} 的非函式 {0}
go.inspection.problem.cannot.convert.constant=無效運算: {0} (無法將常數 {1} 轉換為類型 {2})
go.inspection.problem.cannot.convert.expression=無法將類型 {0} 的表達式轉換為類型 {1}
go.inspection.problem.cannot.convert.known.value.to.type=無法將{0}轉換為{1}
go.inspection.problem.cannot.convert.nil=無法將 ''nil'' 轉換為類型 {0}
go.inspection.problem.cannot.convert.nil.to.type=無法將 {0} 轉換為類型 {1}
go.inspection.problem.cannot.convert.value.to.type=無法將值轉換為 {0}
go.inspection.problem.cannot.import=無法匯入 {0}
go.inspection.problem.cannot.import.absolute.path=無法匯入絕對路徑
go.inspection.problem.cannot.import.builtin.package=無法匯入 'builtin' 軟體套件
go.inspection.problem.cannot.range=範圍不能超過 {0}
go.inspection.problem.cannot.rename.import.c=無法重新命名 import 'C'
go.inspection.problem.cannot.slice=無法切片 {0} (類型 {1})
go.inspection.problem.cannot.take.address=無法提取 {0} 的地址
go.inspection.problem.cannot.take.address.of.non.addressable.operand=無法獲取不可尋址動作數的地址
go.inspection.problem.cannot.use.underscore.as.value=無法將 {0} 用作值
go.inspection.problem.comment.should.start.with.whitespace=註釋應以空白開頭
go.inspection.problem.condition.is.always.true.or.false=條件 {0} 始終為 {1}
go.inspection.problem.condition.is.always.true.or.false.because.of.nil=條件始終為 {0}，因為 {1} 始終是 {2}
go.inspection.problem.condition.is.always.true.or.false.because.of.not.nil=條件始終為 {0}，因為 {1} 始終不是 {2}
go.inspection.problem.contains=包含
go.inspection.problem.conversion.from.int.to.string=從 {0} 到 {1} 的轉換將整數值解釋為程式碼點
go.inspection.problem.convert.string.literals=轉換字串文字
go.inspection.problem.corresponding.error.may.be.not.nil={0} 可能有 {1} 或其他非預期值，因為它相應的錯誤變數可能不是 {2}
go.inspection.problem.declaration.shadows.declaration={0} 的宣告隱藏宣告
go.inspection.problem.declaration.shadows.declaration.at={0} 的宣告隱藏 {1} 處的宣告
go.inspection.problem.defer.is.called.in.a.for.loop=可能發生資源泄漏，在 {1} 迴圈中呼叫 {0}
go.inspection.problem.deprecated.is.still.used=被棄用的 {0} 仍在使用
go.inspection.problem.direct.assignment.to.atomic.value=直接賦值給原子值
go.inspection.problem.division.by.zero=除以零
go.inspection.problem.duplicate.argument=實參 {0} 重複
go.inspection.problem.duplicate.case=case {0} 重複
go.inspection.problem.duplicate.field=重複欄位 {0} 
go.inspection.problem.duplicate.index=重複的索引: {0}
go.inspection.problem.duplicate.key.in.map.literal=映射文字中的鍵 {0} 重複
go.inspection.problem.duplicate.method=方法 {0} 重複
go.inspection.problem.duplicate.type.param=重複的類型參數 {0}
go.inspection.problem.eliminate.snake.case=消除蛇形命名法
go.inspection.problem.empty.interface.usage='interface{}' 作為類型的用法
go.inspection.problem.empty.slice.declaration.via.literal=使用文字的空切片宣告
go.inspection.problem.example.for.unknown.field.or.method=範例參照未知欄位或方法:{0}。{1}
go.inspection.problem.example.for.unknown.identifier=範例參照未知關鍵字: {0}
go.inspection.problem.exported.const.should.have.its.own.declaration=匯出的常數 {0} 應有自己的宣告
go.inspection.problem.exported.element.should.have.comment=匯出的 {0} {1} 應有註釋，否則就是未匯出
go.inspection.problem.exported.function.with.unexported.return.type=匯出的 {0} 具有未匯出的返回值類型
go.inspection.problem.exported.var.should.have.its.own.declaration=匯出的變數 {0} 應有自己的宣告
go.inspection.problem.expression.can.be.simplified=可以簡化表達式
go.inspection.problem.expression.can.be.simplified.to.other={0} 可以簡化為 {1}
go.inspection.problem.expression.is.always.true.or.false=表達式 {0} 始終為 {1}
go.inspection.problem.expression.is.too.small.for.shift={0} ({1} 位)對於 {2} 的移位太小
go.inspection.problem.expression.with.type={0} (類型 {1})
go.inspection.problem.fields.are.assigned.without.explicit.names=欄位分配時沒有顯式名稱
go.inspection.problem.fmt.parameter.with.non.integer.expression=使用非整數型表達式 {1}{2} 指定了{0, choice, 0#寬度|1#精度|2#謂詞}
go.inspection.problem.found.several.packages=在 {1} 中找到多個軟體套件 [{0}]
go.inspection.problem.function.call.may.lead.to.nil.pointer.dereference=函式呼叫 {0} 可能導致 nil 指針取消參照
go.inspection.problem.function.does.not.take.writer=\n\
函式不使用 {0}，但第一個實參是 {1}
go.inspection.problem.function.passes.lock.by.value={0} 通過此值傳遞鎖定: {1}
go.inspection.problem.fuzzing.is.not.supported=從 Go 1.18 開始支援模糊處理
go.inspection.problem.go.plus.build.empty.tag='+build' 註釋包含一個等效於 'ignore' 的空標記
go.inspection.problem.imports.are.not.sorted=import 未排序
go.inspection.problem.impossible.interface.assertion=從 {0} 到 {1} 的接口宣告無效。模糊: {2}
go.inspection.problem.impossible.type.assertion=不可能的類型斷言: {0} 未實作 {1}
go.inspection.problem.impossible.type.switch.case=不可能的類型 swich case: {0} 未實作 {1}
go.inspection.problem.incompatible.empty.type.set=類型未實作約束 {0}，因為<b color={1}>約束類型集為空</b>
go.inspection.problem.incompatible.method.has.pointer.receiver=類型未實作 {0}，因為 <b color={1}>{2} 方法有指針接收器</b>
go.inspection.problem.incompatible.need.method.have.method=類型未實作 {0}<br/><b color={1}> 需要方法: {2}<br/>具有方法: {3}</b>
go.inspection.problem.incompatible.not.comparable=類型未實作約束 {0}，因為<b color={1}>類型不可比較</b>
go.inspection.problem.incompatible.not.in.type.set=類型未實作約束 {0}，因為<b color={1}>類型未包括在類型集({2})中</b>
go.inspection.problem.incompatible.types=無法將 {0} 用作類型 {1}
go.inspection.problem.incompatible.types.ambiguous.methods=類型未實作 {0}，因為 <b color={1}>{2} 不明確</b>
go.inspection.problem.incompatible.types.in.switch=switch {1} 中的 case {0} 無效
go.inspection.problem.incompatible.types.in.switch.on.expression={1} {2} 的 switch 中的 case {0} 無效
go.inspection.problem.incompatible.types.some.methods.are.missing=類型未實作 {0}，因為<b color={1}>缺少某些方法: <br/>{2}</b>
go.inspection.problem.incompatible.unexported.method=類型無法實作 {0}，因為<b color={1}>類型有未匯出的方法，並且是在不同的軟體套件中定義</b>
go.inspection.problem.index.must.be.a.non.negative.integer.constant=索引 {0} 必須是非負整數常數
go.inspection.problem.index.out.of.bounds=索引超出界限: {0}
go.inspection.problem.index.zero.is.illegal=索引值 [0] 為非法的 {0}
go.inspection.problem.indexing.may.panic.because.of.nil.slice=由於切片 {0}，索引可能會出現 panic
go.inspection.problem.infinite.for.loop=無限的 {0} 迴圈
go.inspection.problem.invalid.argument.must.be.complex.type=必須為複雜類型
go.inspection.problem.invalid.argument.must.be.send.channel.type=必須為雙向或僅發送通道
go.inspection.problem.invalid.composite.literal.type=無效的複合文字類型: {0}
go.inspection.problem.invalid.conversion=無效轉換
go.inspection.problem.invalid.conversion.type.comparable=不能在轉換中使用 comparable 接口
go.inspection.problem.invalid.conversion.type.with.constraints=不能在轉換中使用帶有類型約束的接口
go.inspection.problem.invalid.field.name=欄位名無效
go.inspection.problem.invalid.inc.dec.operation=無效運算: {0}(非數值類型 {1})
go.inspection.problem.invalid.indirect={0} (類型 {1})的間接參照無效
go.inspection.problem.invalid.iterable.index=無效的 {0} 索引 {1} ({2})
go.inspection.problem.invalid.low.high.indices=無效索引值，必須低值 <= 高值
go.inspection.problem.invalid.low.high.max.indices=無效索引值，必須為低值 <= 高值 <= 最大值
go.inspection.problem.invalid.operation.mismatched.types=無效運算: {0}(類型 {1} 和 {2} 不符合)
go.inspection.problem.invalid.receiver.interface.type=接口類型
go.inspection.problem.invalid.receiver.nonlocal.type=非本地類型
go.inspection.problem.invalid.receiver.pointer.type=指針類型
go.inspection.problem.invalid.receiver.type=無效接收器類型{0} ({1} 為 {2})
go.inspection.problem.invalid.receiver.unnamed.type=未命名類型
go.inspection.problem.invalid.recursive.type=無效遞迴 {0} {1}{2}
go.inspection.problem.invalid.second.argument.to.errors.as={0} 的第二個實參必須是一個指針，該指針指向接口或指向實作錯誤接口的類型
go.inspection.problem.invalid.slice.index=無效的切片索引 {0} ({1})
go.inspection.problem.invalid.unary.operation=無效運算: {0}
go.inspection.problem.invalid.use.of.triple.dot=無效使用 '...'，對應參數是非可變參數
go.inspection.problem.irregular.iota.usage='iota' 的非常規用法
go.inspection.problem.label.already.defined=已定義標籤 {0}
go.inspection.problem.last.argument.ends.with.redundant.newline={0} 的最後一個實參以冗餘的換行符結尾
go.inspection.problem.leading.whitespace.in.directive.comment=Go 指令必須緊跟在 // 之後，中間不能有任何空格(例如，//go:embed)
go.inspection.problem.literal.copies.lock.value=文字從 {0} 複製鎖定值: {1}
go.inspection.problem.malformed.benchmark.name=基準名稱格式錯誤: 'Benchmark' 後面的首個字母不得為小寫
go.inspection.problem.malformed.example.suffix=範例名稱格式錯誤: 後綴 {0} 必須以小寫字母開頭
go.inspection.problem.malformed.test.name=測試名稱格式錯誤: 'Test' 後面的首個字母不得為小寫
go.inspection.problem.method.call.may.lead.to.nil.pointer.dereference=方法呼叫 {0} 可能導致 nil 指針取消參照
go.inspection.problem.method.has.non.standard.signature=方法 {0} 應包含簽名 {1}
go.inspection.problem.method.has.non.standard.signature.unwrap=方法 {0} 應具有簽名 <code>Unwrap() error</code> 或 <code>Unwrap() []error</code>
go.inspection.problem.method.redeclared=方法重新宣告 {0}
go.inspection.problem.mismatched.types=(類型 {0} 和 {1} 不符合)
go.inspection.problem.mismatched.types.byte.and.string=不符合的類型: 位元組和字串
go.inspection.problem.missing.argument.to.conversion=缺少要轉換為 {0} 的實參: {1}
go.inspection.problem.missing.expression=缺少表達式
go.inspection.problem.missing.key.in.map.literal=映射文字中缺少鍵
go.inspection.problem.missing.return=函式末尾缺少 'return' 語句
go.inspection.problem.missing.type.in.composite.literal=複合文字中缺少類型
go.inspection.problem.mixture.of.field=混合欄位: 值和初始設定式
go.inspection.problem.multiple.packages.in.directory=目錄中有多個軟體套件: {0}
go.inspection.problem.must.be.imported.as=必須作為 {0} 匯入
go.inspection.problem.must.be.non.negative=必須為非整數型
go.inspection.problem.must.be.of.integer.type=必須為整數型
go.inspection.problem.must.be.representable.by.int=值必須可由 'int' 類型表示
go.inspection.problem.name.collides.with.builtin={0} {1} 與 ''builtin'' {2} 衝突
go.inspection.problem.name.collides.with.imported.package={0} {1} 與匯入的軟體套件名稱衝突
go.inspection.problem.name.collides.with.name.declared.in.this.package={0} 與此軟體套件中宣告的名稱衝突
go.inspection.problem.name.redeclared.as.imported.package={0} 被重新宣告為匯入的軟體套件名稱
go.inspection.problem.name.redeclared.in.this.block=此塊中重新聲明了 {0}
go.inspection.problem.name.redeclared.in.this.function=此函式中重新聲明了 {0}
go.inspection.problem.name.redeclared.in.this.package=此包中重新宣告的 {0}
go.inspection.problem.name.starts.with.package.name=名稱以軟體套件名稱開頭
go.inspection.problem.need.trailing.comma.in.argument.list=實參列表中的換行符前面需要有尾隨逗號
go.inspection.problem.need.trailing.comma.in.composite.literal=複合文字中的換行符前需要尾隨逗號
go.inspection.problem.need.trailing.comma.in.index.expression=索引表達式中的換行符前面需要有尾隨逗號
go.inspection.problem.need.trailing.comma.in.parameter.list=參數列表中的換行符前面需要有尾隨逗號
go.inspection.problem.need.trailing.comma.in.type.arguments.list=類型實參列表中的換行符前面需要有尾隨逗號
go.inspection.problem.need.trailing.comma.in.type.parameters.list=類型參數列表中的換行符前面需要有尾隨逗號
go.inspection.problem.negative.index=負索引: {0}
go.inspection.problem.negative.shift.count=無效運算: {0} (負移位計數)
go.inspection.problem.nil.is.not.allowed=不允許 {0}。必須為 {1}
go.inspection.problem.nil.loop.is.always.skipped=總是跳過迴圈，因為 {0} 總是 {1}
go.inspection.problem.no.argument.for.placeholder.part=沒有{0, choice, 0#寬度|1#精度|2#動詞}的實參: 實參索引 = {1}，實參計數 = {2}{3}
go.inspection.problem.no.non.test.go.files=軟體套件僅包含測試 Go 檔案: {0}
go.inspection.problem.no.placeholders.in.format.string=格式字串中沒有佔位符
go.inspection.problem.non.bool.used.as.condition=非布林值 {0} 用作條件
go.inspection.problem.non.canonical.import.path=非規範的匯入路徑: {0} 應為 {1}
go.inspection.problem.non.strict.comparability.not.supported=從 Go 1.20 開始，基本接口滿足 'comparable' 類型檢查規則
go.inspection.problem.not.enough.arguments.in.call={0} 呼叫中的實參不足
go.inspection.problem.not.enough.arguments.to.return=要返回的實參不足
go.inspection.problem.operator.not.defined=無效運算: {0} (在 {2} 中未定義運算符 {1})
go.inspection.problem.out.of.bounds.for.array={0} 元素的陣列超出界限
go.inspection.problem.out.of.bounds.for.string={0} 位元組的字串超出界限
go.inspection.problem.path.imports.package.that.expects.canonical.import={0} 匯入需要匯入“{1}”的軟體套件
go.inspection.problem.path.imports.package.with.invalid.import.comment={0} 匯入包含無效匯入註釋的軟體套件
go.inspection.problem.path.is.a.program.not.an.importable.package={0} 是程序，不是可匯入的軟體套件
go.inspection.problem.placeholder.argument.causes.recursive.call.to.string=佔位符實參導致對 {0} 方法 {1} 的遞迴呼叫
go.inspection.problem.placeholder.argument.has.wrong.type=佔位符實參 {0} 具有錯誤的類型 {1}{2}
go.inspection.problem.placeholder.argument.is.not.a.function.call=佔位符實參不是函式呼叫 {0}
go.inspection.problem.placeholder.syntax.error=佔位符語法錯誤 {0}
go.inspection.problem.possible.formatting.directive={0} 中可能的格式指令
go.inspection.problem.possible.malformed.build.comment='+build' 註釋的格式可能不正確
go.inspection.problem.possibly.redundant.type.conversion=類型轉換可能冗餘
go.inspection.problem.possibly.unused.dependency=可能未使用的相依項
go.inspection.problem.potential.nil.pointer.dereference=可能發生 nil 指針取消參照
go.inspection.problem.range.var.copies.lock=範圍變數 {0} 複製鎖定: {1}
go.inspection.problem.receive.from.non.chan.type=無效運算: {0} (從非 chan 類型 {1} 接收)
go.inspection.problem.receive.from.send.only.type=無效運算: {0} (從僅發送類型 {1} 接收)
go.inspection.problem.receive.may.block.because.of.nil.channel=由於 {0} 通道，接收運算可能會阻止 goroutine
go.inspection.problem.receive.no.core.type=無效運算: {0} (類型為 {2} 的表達式 {1} 沒有核心類型)
go.inspection.problem.receiver.has.generic.name=接收器具有泛型名稱
go.inspection.problem.receiver.may.be.nil.in.call=接收器 {0} 在呼叫中可能是 {1}
go.inspection.problem.receiver.names.are.different=接收器名稱不同
go.inspection.problem.redundant.alias=冗餘別名
go.inspection.problem.redundant.blank.expression=冗餘 {0} 表達式
go.inspection.problem.redundant.comma=冗餘逗號
go.inspection.problem.redundant.for.condition=條件冗餘
go.inspection.problem.redundant.index=冗餘索引 {0}
go.inspection.problem.redundant.parentheses=冗餘括號
go.inspection.problem.redundant.semicolon=冗餘分號
go.inspection.problem.redundant.type=冗餘類型
go.inspection.problem.redundant.type.conversion=冗餘類型轉換
go.inspection.problem.reference.is.deprecated=已棄用 {0}
go.inspection.problem.reference.jumps.over.declaration={0} 跳過 {1} 的宣告
go.inspection.problem.return.copies.lock.value=返回複製鎖定值: {0}
go.inspection.problem.return.value.has.a.function.type=返回值 {0} 具有函式類型
go.inspection.problem.return.value.of.placeholder.argument.has.a.function.type=佔位符實參的返回值具有函式類型 {0}
go.inspection.problem.self.import.is.not.allowed=不允許自我匯入
go.inspection.problem.send.may.block.because.of.nil.channel=由於 {0} 通道，發送運算可能會阻止 goroutine
go.inspection.problem.send.to.non.chan.type=無效運算: {0} (發送到非 chan 類型 {1})
go.inspection.problem.send.to.receive.only.type=無效運算: {0} (發送到僅接收類型 {1})
go.inspection.problem.shift.count.must.be.integer=無效運算: {0} (移位計數類型 {1}，必須為整數)
go.inspection.problem.shift.count.must.be.unsigned.integer=無效運算: {0} (移位計數類型 {1}，必須為無符號整數)
go.inspection.problem.this.verb.can.be.used.only.in.fmt.errorf=此動詞只能在 {0} 個呼叫 {1} 中使用
go.inspection.problem.this.verb.can.be.used.only.once.in.a.format.string=此動詞只能在格式字串 {0} 中使用一次
go.inspection.problem.too.few.values=值太少
go.inspection.problem.too.many.arguments.for.format.string=格式字串的實參過多: 應為 {0}，實際為 {1}
go.inspection.problem.too.many.arguments.in.call={0} 呼叫中的實參過多
go.inspection.problem.too.many.arguments.to.conversion=要轉換為 {0} 的實參過多: {1}
go.inspection.problem.too.many.arguments.to.return=要返回的實參太多
go.inspection.problem.too.many.values=值太多
go.inspection.problem.type.assertion.on.errors.fails.on.wrapped.errors=Type assertion on errors fails on wrapped errors
go.inspection.problem.type.does.not.support.indexing=無效運算: {0} (類型 {1} 不支持索引)
go.inspection.problem.type.has.both.field.and.method.with.name=\n\
類型 {0} 的欄位和方法均命名為 {1}
go.inspection.problem.type.has.same.named.field.and.method=\n\
類型 {0} 的欄位和方法均命名為 {1}
go.inspection.problem.type.is.sync.locker=類型 %s 為 <code>sync.Locker</code>
go.inspection.problem.type.or.type={0} 或 {1}
go.inspection.problem.type.parameters.are.not.supported=不支持類型參數
go.inspection.problem.type.switch.on.errors.fails.on.wrapped.errors=Type switch on errors fails on wrapped errors
go.inspection.problem.type.which.is.sync.locker=類型 %s，它是 <code>sync.Locker</code>
go.inspection.problem.unhandled.error=未處理錯誤
go.inspection.problem.unit.specific.suffix=特定於單元的後綴 {0}
go.inspection.problem.unknown.verb=未知動詞 {0}{1}
go.inspection.problem.unmarshal.argument.must.be.a.pointer=此實參必須為指針類型
go.inspection.problem.unnecessarily.exported.element=不必要地匯出了 {0} {1}
go.inspection.problem.unreachable.code=無法存取的程式碼
go.inspection.problem.unused.dependency=未使用的相依項
go.inspection.problem.unused.import=未使用的 import
go.inspection.problem.unused.result=未使用的結果: {0}
go.inspection.problem.usage.of.cgo.in.tests=不支持在測試中使用 cgo
go.inspection.problem.use.camelcase.instead.of.snake.case=使用駝峰式命名法，不使用蛇形命名法
go.inspection.problem.use.of.internal.package.is.not.allowed=不允許使用內部軟體套件
go.inspection.problem.use.of.vendored.package.is.not.allowed=不允許使用供應商提供的軟體套件
go.inspection.problem.value.is.assigned.to.itself={0} 的值被賦予本身
go.inspection.problem.variable.declaration.copies.lock.value=變數宣告將鎖定值複製到 {0}: {1}
go.inspection.problem.variable.repeated.on.left.side={0} 在 := 的左側重複
go.inspection.problem.verb.will.ignore.flag=動詞將忽略 {0} 標誌 {1}
go.inspection.problem.verb.will.ignore.flags=動詞將忽略 {0} 標誌 {1}
go.inspection.problem.wrong.example.signature=範例簽名錯誤
go.inspection.problem.wrong.location.of.build.comment='build' 註釋必須出現在軟體包子句前面，後面跟隨一個空白行
go.inspection.problem.wrong.test.signature=測試簽名錯誤
go.inspection.problematic.execution.path.end=有問題的執行路徑的結束
go.inspection.receiver.has.generic.name.display.name=接收器具有泛型名稱
go.inspection.redundant.blank.argument.in.range.display.name=範圍中存在冗餘空白實參
go.inspection.redundant.comma.display.name=冗餘逗號
go.inspection.redundant.import.alias.display.name=冗餘匯入別名
go.inspection.redundant.parentheses.display.name=冗餘括號
go.inspection.redundant.second.index.in.slices.display.name=切片中存在冗餘的第二個索引
go.inspection.redundant.semicolon.display.name=冗餘分號
go.inspection.redundant.true.in.for.loop.display.name=for 迴圈條件中存在冗餘的 'true'
go.inspection.redundant.type.conversion.display.name=冗餘類型轉換
go.inspection.redundant.types.in.composite.literals.display.name=複合文字中存在冗餘類型
go.inspection.reserved.word.used.as.name.display.name=保留詞用作名稱
go.inspection.self.assignment.display.name=自賦值
go.inspection.shadowing.variable.display.name=陰影變數
go.inspection.struct.field.has.tag.but.is.not.exported=結構欄位 ''{0}'' 具有 ''{1}'' 標記，但未被匯出
go.inspection.struct.initialization.settings.report.for.literals.without.type.checkbox=報告無類型的結構文字
go.inspection.struct.initialization.settings.report.for.local.type.checkbox=報告當前軟體套件中定義的類型
go.inspection.struct.initialization.without.field.names.display.name=結構初始化沒有欄位名稱
go.inspection.struct.tag.value.consists.only.of.spaces=結構標籤值僅包含空格
go.inspection.suspicious.extra.space.in.struct.tag.value=結構標記值中的可疑額外空格
go.inspection.suspicious.space.in.struct.tag.value=結構標記值中的可疑空格
go.inspection.suspicious.space.in.the.beginning.of.the.struct.tag.value=結構標籤值開頭有可疑的空格
go.inspection.suspicious.space.in.the.end.of.the.struct.tag.value=結構標記值末尾的可疑空格
go.inspection.test.name.display.name=格式錯誤的測試函式名稱
go.inspection.type.assertion.on.errors.display.name=Type assertion on errors
go.inspection.type.can.be.omitted.display.name=類型可以省略
go.inspection.type.can.be.omitted.message=類型可以省略
go.inspection.type.parameter.declared.in.lower.case.display.name=類型參數以小寫宣告
go.inspection.type.parameter.declared.in.lower.case.message=類型參數 ''{0}'' 以小寫宣告
go.inspection.unexported.return.type.of.exported.function.display.name=匯出函式的未匯出返回值類型
go.inspection.unhandled.error.display.name=未處理錯誤
go.inspection.unit.specific.suffix.for.time.duration.display.name=為 'time.Duration' 使用單位特定的後綴
go.inspection.unknown.field.message=結構文字中的欄位 {0} 未知
go.inspection.unnecessarily.exported.identifier.display.name=不必要地匯出了關鍵字
go.inspection.unreachable.code.display.name=無法存取的程式碼
go.inspection.unresolved.disabled.gopath.indexing.display.name=已停用 GOPATH 索引
go.inspection.unresolved.disabled.gopath.indexing.message=停用 GOPATH 索引可能會阻止正確進行參照解析
go.inspection.unresolved.label.message=未解析的標籤 {0}
go.inspection.unresolved.reference.message=未解析的參照 {0}
go.inspection.unresolved.type.message=未解析的類型 {0}
go.inspection.unsorted.imports.display.name=未排序的匯入
go.inspection.unused.constant.display.name=未使用的常數
go.inspection.unused.constant.message=未使用的常數 {0}
go.inspection.unused.exported.function.display.name=未使用的匯出函式
go.inspection.unused.exported.type.display.name=未使用的匯出類型
go.inspection.unused.function.display.name=未使用的函式
go.inspection.unused.function.message=未使用的函式 {0}
go.inspection.unused.function.or.method.call.result.display.name=未使用的函式或方法呼叫結果
go.inspection.unused.global.variable.display.name=未使用的全域變數
go.inspection.unused.label.message=未使用的標籤 {0}
go.inspection.unused.parameter.display.name=未使用的參數
go.inspection.unused.parameter.message=未使用的參數 {0}
go.inspection.unused.type.display.name=未使用的類型
go.inspection.unused.type.message=未使用的類型 {0}
go.inspection.unused.type.parameter.display.name=未使用的類型參數
go.inspection.unused.type.parameter.message=未使用的類型參數 {0}
go.inspection.unused.variable.message=未使用的變數 {0}
go.inspection.usage.of.context.todo=context.TODO() 的用法
go.inspection.usage.of.snake.case.display.name=使用了 Snake_Case(_C)
go.install.template.plugin.action.text=安裝延伸模組
go.install.template.plugin.notification.text=安裝 Go 模板以增強 html/templates 軟體套件中的突出顯示、補全和導覽功能
go.intention.add.declaration.parens.name=向宣告新增圓括號
go.intention.add.dot.import.alias.name=添加點匯入別名
go.intention.add.fmt.string.argument.name=新增格式字串實參
go.intention.add.import.alias.name=新增匯入別名
go.intention.add.tag.key=向標記新增鍵
go.intention.change.field.name.style.command=更改標記中的欄位名稱樣式
go.intention.change.field.name.style.in.tags=更改標記中的欄位名稱樣式
go.intention.change.field.name.style.select.style=選擇欄位名稱樣式:
go.intention.chop.arguments=將實參放在單獨的行中
go.intention.chop.composite.literal.elements=將元素放在單獨的行中
go.intention.chop.parameters=將參數放在單獨的行中
go.intention.convert.to.short.var.declaration.name=轉換為短變數宣告
go.intention.convert.to.var.declaration.name=轉換為變數宣告
go.intention.create.field.getter.and.setter.command.name=建立欄位存取器
go.intention.create.field.getter.and.setter.name=生成 getter 和 setter
go.intention.create.field.getter.name=建立 Getter
go.intention.create.field.setter.name=建立 Setter
go.intention.download.all.missing.modules.fix.text=將所有模組下載到模組快取
go.intention.download.single.missing.module.fix.family.name=將模組下載到模組快取
go.intention.download.single.missing.module.fix.from.replacement.text=將 {0} 從 {1} 下載到模組快取
go.intention.download.single.missing.module.fix.text=將{0}下載到模組快取
go.intention.expand.signature.types.name=展開簽名類型
go.intention.export.name=匯出
go.intention.fill.all.fields.command.name=填充結構
go.intention.fill.all.fields.enforce.multiline.checkbox=執行多行
go.intention.fill.all.fields.name=填充所有欄位
go.intention.fill.all.fields.recursively.checkbox=遞迴
go.intention.fill.all.fields.recursively.name=遞迴填充所有欄位
go.intention.fill.fields.name=填充欄位…
go.intention.flip.binary.operator.changes.operator.text=將 ''{0}'' 翻轉為 ''{1}''
go.intention.flip.binary.operator.changes.semantics.text=翻轉 ''{0}'' (更改語意)
go.intention.flip.binary.operator.name=翻轉二元運算符
go.intention.flip.binary.operator.text=翻轉 ''{0}''
go.intention.fmt.string.argument.bad.position.error.message=位置錯誤
go.intention.fmt.string.argument.explicit.indices.error.message=字串具有顯式索引
go.intention.fmt.string.argument.percent.with.args.error.message=字串具有帶實參的 %%
go.intention.fmt.string.argument.syntax.error.message=字串有語法錯誤
go.intention.fmt.string.argument.too.few.arguments.error.message=字串的實參太少
go.intention.fmt.string.argument.variadic.arg.error.message=字串具有 ... 實參
go.intention.fmt.string.title.error.message=無法新增 Fmt 字串實參
go.intention.generate.constructor.name=建立建構函式
go.intention.generate.method.name=生成方法
go.intention.generate.struct.fields.from.json=從 JSON 生成結構欄位
go.intention.generate.struct.fields.from.json.error=JSON 頂層值應當是物件或物件陣列
go.intention.generate.type.from.json=從 JSON 生成類型
go.intention.go.to.implementation.name=轉到實作
go.intention.go.to.implementation.text=轉到實作…
go.intention.go.to.super.name=轉到接口
go.intention.go.to.super.text=轉到接口…
go.intention.implement.interface.name=實作接口
go.intention.implement.interface.text=實作接口…
go.intention.invert.if.name=反轉 if
go.intention.join.arguments=將實參放在同一行中
go.intention.join.composite.literal.elements=將元素放在同一行中
go.intention.join.parameters=將參數放在同一行中
go.intention.merge.all.declarations.name=合併所有宣告
go.intention.merge.declaration.up.name=向上合併宣告
go.intention.merge.declarations.by.comma.name=通過逗號向上合併宣告
go.intention.migrate.function.parameter.to.method.receiver=將函式參數遷移到方法接收器
go.intention.migrate.function.parameter.to.method.receiver.error.hint.invalid.receiver.type=結果接收器類型 {0} 將無效 ({1} 為 {2})。
go.intention.migrate.function.parameter.to.method.receiver.error.hint.message=無法將函式參數遷移到方法接收器。\n\
{0}
go.intention.migrate.function.parameter.to.method.receiver.error.hint.method.with.type.parameter=結果方法將無效，因為方法必須沒有類型參數。
go.intention.migrate.function.parameter.to.method.receiver.error.hint.title=無法將函式參數遷移到方法接收器
go.intention.migrate.function.parameter.to.method.receiver.name=將函式參數遷移到方法接收器
go.intention.migrate.method.receiver.to.function.parameter=將方法接收者遷移到函式參數
go.intention.move.to.struct.initialization.name=將欄位賦值移至結構初始化
go.intention.negate.boolean.expression.name=求反表達式
go.intention.negate.boolean.expression.name.recursively.suffix=遞迴
go.intention.negate.boolean.expression.text=將 ''{0}'' 求反為 ''{1}''
go.intention.negate.boolean.topmost.expression.name=求反最頂端的表達式
go.intention.negate.boolean.topmost.expression.text=將最頂端的 ''{0}'' 求反為 ''{1}''
go.intention.remove.declaration.parens.name=從宣告中移除圓括號
go.intention.remove.dot.import.alias.name=移除點匯入別名
go.intention.remove.keys.from.struct.literal.value.name=從結構文本中移除鍵
go.intention.reuse.signature.types.name=重用簽名類型
go.intention.run.go.generate.name=在註釋上執行 go generate
go.intention.run.go.generate.on.file.name=在檔案上執行 go generate
go.intention.run.go.generate.on.package.name=在軟體包上執行 go generate
go.intention.run.go.generate.text=Go generate ''{0}''
go.intention.select.fields.dialog.title=選擇欄位
go.intention.specify.type.name=明確地指定類型
go.intention.split.all.declarations.name=拆分所有宣告
go.intention.split.declarations.by.comma.name=通過逗號拆分宣告
go.intention.split.declarations.name=將宣告拆分為兩個組
go.intention.update.value.in.tags=更新標記中的鍵值
go.intentions.category=Go
go.libraries.configurable.path.source.prefix.default=[預設]
go.libraries.configurable.path.source.prefix.gopath=[GOPATH]
go.live.template.context.type.block.presentable.name=塊
go.live.template.context.type.expression.presentable.name=表達式
go.live.template.context.type.file.presentable.name=檔案
go.live.template.context.type.statement.presentable.name=語句
go.live.template.context.type.tag.literal.presentable.name=標記文字
go.live.template.context.type.tag.presentable.name=標記
go.live.template.context.type.type.presentable.name=類型
go.load.file.dialog.invalid.file=檔案路徑無效
go.load.file.dialog.invalid.url=請使用以 https://go.dev/ 開頭的 URL
go.load.file.dialog.radio.file=檔案
go.load.file.dialog.radio.url=URL
go.load.file.dialog.title=選擇要從中將程式碼匯入臨時檔案的源:
go.load.file.dialog.url.comment=使用以 https://go.dev/ 開頭的 URL
go.load.to.playground.could.not.load.message=//無法載入共享程式碼
go.load.to.playground.dialog.title=匯入到臨時檔案
go.macro.bin.dirs.description=包含 Go 工具的 bin 目錄路徑
go.macro.executable.path.description=Go 可執行檔案路徑
go.macro.file.go.path.description=GOPATH 值
go.macro.file.go.root.description=專案 SDK 路徑
go.macro.file.import.path.description=匯入當前檔案的路徑
go.microservices.http.server.endpoint.title=Go HTTP 伺服器
go.module=模組
go.modules.automatic.dependencies.download.task.text=在 {0} 中執行 ''go mod download all'' ({1}/{2})
go.modules.background.task.updating.dependencies.text=正在 {0} 個 ''go.mod'' {0,choice,0#檔案|1#檔案|2#檔案} 上執行 ''go list''…
go.modules.background.task.updating.dependencies.title=正在更新 Go 模組相依項
go.modules.dependency.diagram=Go 模組相依關係圖
go.modules.scratch.file.notification.text=使用模組上下文
go.modules.tree.structure.replaced=(已取代)
go.modules.tree.structure.replacement=取代: {0}
go.modules.unknown.dependencies.notification.retry=重新執行 ''{0}''
go.modules.unknown.dependencies.notification.text=完整的模組相依項集合未知，某些特定於 Go 模組的功能可能不可用。
go.modules.unknown.dependencies.notification.tooltip=可能是由網絡連線問題或顯式 GOPROXY=off 導致。
go.modules.unsupported.workspace.mode=Go SDK {0} 不支持 ''go.work'' 檔案，請使用 Go 1.18 或更高版本
go.modules.wizard.description=建立 Go 模組專案，以開發使用 Go 模組進行相依項管理的 Go 應用程式和庫
go.modules.wizard.name=Go
go.mozilla.rr.dialog.specify.trace.directory.validation.message=指定追蹤目錄
go.mozilla.rr.dialog.trace.directory.label=追蹤目錄(&T):
go.mozilla.rr.failed.to.start.error.message=無法為 rr 追蹤 {0} 啟動偵錯器: {1}
go.mozilla.rr.session.name=追蹤 {0}
go.navigation.go.to.implementation=轉到實作
go.navigation.go.to.implementation.find.usages.title={0} 的實作
go.navigation.go.to.method.implementation.popup.title={1} {1, choice, 0#類型|1#類型|2#類型}中實作的方法 {0}
go.navigation.go.to.shadowed.method=轉到陰影方法
go.navigation.go.to.shadowed.method.popup.title=方法 {0} 隱藏了 {1} 個{1,choice,0#類型|1#類型|2#類型}的方法
go.navigation.go.to.shadowing.method=轉到隱藏方法
go.navigation.go.to.shadowing.method.find.usages.title={0} 的隱藏方法
go.navigation.go.to.shadowing.method.popup.title={1} {1, choice, 0#類型|1#類型|2#類型}中隱藏的方法 {0}
go.navigation.go.to.super=轉到接口
go.navigation.go.to.super.find.usages.title={0} 已實作的接口
go.navigation.go.to.super.method=轉到方法規範
go.navigation.go.to.super.method.find.usages.title.kind={0} 已實作的方法規範
go.navigation.go.to.super.method.popup.title=方法 {0} 實作了 {1} 個{1,choice,0#接口|1#接口|2#接口}中的方法
go.navigation.go.to.super.popup.title=類型 {0} 實作了 {1} 個{1,choice,0#接口|1#接口|2#接口}
go.navigation.go.to.type.implementation.popup.title={1} {1, choice, 0#類型|1#類型|2#類型}中實作的類型 {0}
go.navigation.progress.title=正在搜尋 {0}…
go.navigation.recursive.call=遞迴呼叫
go.navigation.shadowed.method.usages.title={0} 的隱藏方法
go.new.project.step.other.group.name=其他
go.new.project.step.web.group.name=Web
go.notification.add.to.gopath.action.text=新增到 GOPATH
go.notification.add.to.module.action.text=新增到模組
go.notification.add.vendored.package.to.project.action.text=向專案中新增 ''{0}''
go.notification.automatic.dependencies.download.text=如果連線受限或不需要所有相依項，請在設定中停用自動下載。
go.notification.automatic.dependencies.download.title=自動下載 Go 模組相依項
go.notification.automatic.download.open.settings=開啟設定…
go.notification.cgo.optimizations.are.not.disabled=CGO_CFLAGS 未設定為 '-O0 -g'，無法最佳化 cgo 程式碼。
go.notification.code.insight.disabled.for.vendored.files.text=庫中供應檔案的編輯程式碼洞察功能已停用
go.notification.code.insight.features.are.disabled.text=程式碼洞察功能不可用
go.notification.create.go.mod.file.action.text=建立 'go.mod' 檔案
go.notification.disable.cgo.support.action.text=停用 cgo 支援
go.notification.disable.go.modules.integration.action.text=停用 Go 模組整合
go.notification.do.not.show.action.text=不再顯示
go.notification.download.missing.module.successfully.done=已成功處理 {0} 個{0,choice,0#模組|1#模組|2#模組}
go.notification.enable.cgo.support.action.text=啟用 cgo 支援
go.notification.file.does.not.match.target.system.text=''{0}'' 與目標系統不符合。檔案將被建置工具忽略。
go.notification.file.exceeds.size.limit.text=檔案大小({0})超出了組態的限制({1})。{2}
go.notification.file.ignore.navigate.to.build.constraints.action.text=導覽到建置約束
go.notification.file.ignore.navigate.to.cgo.import.action.text=導覽到 cgo import
go.notification.file.is.ignored.because.arch.mismatch.text=由於架構不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.bad.syntax.text=由於語法錯誤，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.cgo.mismatch.text=由於 cgo 支援不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.compiler.mismatch.text=由於編譯器不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.custom.flag.text=由於自訂標誌，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.non.go.file.text=由於不是 Go 檔案，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.os.mismatch.text=由於 OS 不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.version.mismatch.text=由於 Go 版本不符合，''{0}'' 被建置工具忽略
go.notification.file.starts.with.dot.text=由於名稱以 ''.'' 開頭，''{0}'' 被建置工具忽略
go.notification.file.starts.with.underscore.text=由於名稱以 ''_'' 開頭，''{0}'' 被建置工具忽略
go.notification.go.edit.project.settings.action.text=編輯設定
go.notification.go.root.is.incorrect.text=GOROOT 不正確
go.notification.go.root.is.not.defined.text=未定義 GOROOT
go.notification.go.setup.action.text=設定 GOROOT
go.notification.go.support.enable.action.text=啟用 Go 支援
go.notification.go.support.is.disabled.in.module.text=''{0}'' 中停用 Go 支援
go.notification.go.tool.is.missing.run.go.get.invoke.go.get.action.text=呼叫 ''go get {0}''
go.notification.go.tool.is.missing.run.go.get.text=無法在 GOPATH 中找到 ''{0}''。
go.notification.go.tool.is.missing.text=GOPATH 中缺少可執行檔案 ''{0}''。是否要安裝?
go.notification.gopath.configure.action.text=組態 GOPATH
go.notification.gopath.detected.configure.gopath.action.text=組態 GOPATH
go.notification.gopath.detected.text=我們從您的 GOPATH 中檢測到一些庫。您可能需要在 GOPATH 組態中新增額外的庫。
go.notification.gopath.detected.title=檢測到 GOPATH
go.notification.gopath.is.empty.text=GOPATH 為空
go.notification.inspections.are.disabled.enabled.action.text=啟用檢查
go.notification.inspections.are.disabled.text=已停用對此檔案進行檢查
go.notification.install.as.tool.action.text=作為工具安裝
go.notification.install.go.tool.action.text=安裝 Go 工具
go.notification.install.package.action.text=安裝 {0}
go.notification.modules.file.is.absent.title='go.mod' 檔案不存在
go.notification.obsolete.imports.code.style.detected.title=檢測到過時的匯入程式碼樣式設定
go.notification.open.imports.settings=開啟匯入設定
go.notification.package.was.excluded=從匯入中排除 {0}
go.notification.rename.file.action.text=重新命名檔案
go.notification.review.code.style.settings.action.text=檢視程式碼樣式設定
go.playground.actions.format.description=使用 Go Playround API 格式化程式碼
go.playground.actions.format.text=格式化
go.playground.actions.go.context.description.prefix=所選上下文:
go.playground.actions.go.version.description.prefix=所選版本:
go.playground.actions.go.version.label=Go 版本
go.playground.actions.load.description=將程式碼從提供的 URL 或檔案載入到給定的 Playground 檔案中
go.playground.actions.load.text=載入
go.playground.actions.run.description=在 Go Playground 中執行檔案
go.playground.actions.run.locally.text=在本地執行
go.playground.actions.run.text=執行
go.playground.actions.share.description=通過提供可共享的鏈接在 Go Playground 中共享檔案程式碼
go.playground.actions.share.text=共享
go.profiler.allocated.objects.metric.name=已分配的物件
go.profiler.allocated.space.metric.name=已分配的空間
go.profiler.application.configurable.name=Go 分析器
go.profiler.blocking.profile.prefix=阻塞分析
go.profiler.blocking.profiler.name=阻塞分析器
go.profiler.cpu.profile.prefix=CPU 分析
go.profiler.cpu.profiler.name=CPU 分析器
go.profiler.cpu.time.metric.name=CPU 時間
go.profiler.downloading.profiler.dump.progress.title=正在下載分析器傾印…
go.profiler.in.use.objects.metric.name=使用中的物件
go.profiler.in.use.space.metric.name=使用中的空間
go.profiler.memory.profile.prefix=記憶體分析
go.profiler.memory.profiler.name=記憶體分析器
go.profiler.mutex.profile.prefix=Mutex 分析
go.profiler.mutex.profiler.name=Mutex 分析器
go.profiler.not.a.pprof.profile.error=不是 pprof 組態檔案
go.profiler.parse.error=解析組態檔案時出錯: {0}
go.profiler.parse.error.empty=組態檔案為空
go.profiler.parse.error.eof=意外的檔案結尾
go.profiler.profile.fraction.comment.text=控制組態檔案中報告的互斥爭用事件的分數。平均而言，報告 1/分數個事件。留空將使用預設分數 1。
go.profiler.profile.fraction.label.text=組態檔案分數:
go.profiler.profile.illegal.profile.fraction.validation.message=非法分析分數: {0}
go.profiler.profile.illegal.rate.validation.message=非法分析速率: {0}
go.profiler.profile.rate.cpu.comment.text=控制組態檔案中報告的 goroutine 阻塞事件的分數。平均而言，分析器的目標是在程序被阻塞的每個周期對一個阻塞事件采樣。周期以納秒為單位進行設定。要在組態檔案中包含每個阻塞事件，請將值設定為 1。留空將使用預設分析器速率 1。
go.profiler.profile.rate.label.text=組態檔案速率:
go.profiler.profile.rate.memory.comment.text=控制組態檔案中記錄和報告的記憶體分配分數。平均而言，分析器的目標是根據分配的每個位元組數對一次分配進行采樣。要在組態檔案中包含分配的每個塊，請將速率設定為 1。留空將使用 512 KB 的預設速率。
go.project.configurable.name=Go
go.quick.doc.assign.iota=為 'iota' 賦值不等於重設 'builtin.iota' 的計數器。相反，賦值會定義一個新的隱藏 'builtin.iota' 的常數 'iota'。
go.quick.doc.blank.identifier.hint=空白關鍵字 ('_') 可以賦給任何類型的任何值或用任何類型的值宣告。空白關鍵字會被捨棄，不會被編譯器使用。例如，當您想要捕獲返回值但不打算在以後使用此值時，可以考慮使用空白關鍵字。
go.quick.doc.channel.direction.label=通道方向:
go.quick.doc.channel.receive.label=從通道接收
go.quick.doc.channel.send.label=發送到通道
go.quick.doc.composite.literal.hint=此複合文字會使用給定值分配新的 {0} 實例。
go.quick.doc.empty.interface.hint=空接口 'interface{}' 代表所有類型的集合。空接口類型的變數可以存儲任何類型的值。
go.quick.doc.iota.example=例如，'const (C0 = iota; C1; C2)' 將列印 '0'、'1' 和 '2'。每次在程式碼中使用 'const' 時，計數都會重設為 '0'。要檢視 'iota' 分配的常數的值，請將滑鼠指針懸停在常量規范上。
go.quick.doc.keyword.resource.effective.go.label=Effective Go
go.quick.doc.keyword.resource.go.blog.label=Go 部落格
go.quick.doc.keyword.resource.language.spec.label=Go 語言規範
go.quick.doc.keyword.type.switch=類型 switch 符合接口值 'x' 的動態類型。動態類型與 'switch' case 中的類型符合。如果使用形式為 'v := x.(type)' 的短變數賦值作為 switch 臨界，並且 switch case 僅用於單一類型，則 'v' 將具有符合的 switch case 中指定的類型。
go.quick.doc.methods.on.label=方法物件:
go.quick.doc.package.label=軟體套件:
go.quick.doc.resolved.value.label=已解析的值: 
go.quick.doc.struct.literal.hint=您可以按順序指定欄位值，也可以使用其名稱。
go.quick.doc.too.large.to.render=太大，無法呈現
go.quick.doc.type.alias.and.definition.hint.link.text=Go 規範: 類型標識
go.quick.doc.type.alias.hint=類型{0}是類型{1}的別名。這些類型完全相同。有關詳細資訊，請參閱{2}
go.quick.doc.type.assertions.hint=類型斷言用於檢查變數是否為某種類型，並返回基礎接口值。類型斷言僅適用於接口。例如，在下面的程式碼中: 'var x interface{} = 42 t := x.(int)'，'x' 具有帶基礎 int 值  ('42') 的 'interface{}' 類型，'int' 是我們要檢查的具體類型。如果我們列印 't'，輸出將為 '42'。將具體類型更改為 'string' ('t := x.(string)') 將導致執行時宕機。類型斷言可以返回兩個值。例如，表達式 't, ok := x.(int)' 具有布林值 'ok'，如果斷言正確，則返回 'true'。如果 'ok' 為 'false'，則會將 't' 設定為零值，並且不會發生宕機。
go.quick.doc.type.definition.hint=類型{0}是基礎類型為{1}的新類型。這些類型是不同的。有關詳細資訊，請參閱{2}
go.quick.doc.type.parameter.hint={0} 宣告用於宣告類型參數。這些類型參數會將 {0} 變為泛型。泛型 {0} 可以處理多種類型。可能的類型集由類型參數的約束控制。有關泛型的詳細資訊，請參閱 {1}
go.quick.doc.type.parameter.hint.hyperlink.text=教程: go.dev 泛型入門
go.quick.doc.type.parameter.in.method.hint=該方法為泛型，因為接收器的基類型為泛型類型。方法規範必須宣告與接收器基本類型的類型參數相對應的類型參數。方法類型實參必須使用接收器基類型中使用的類型約束。有關泛型的詳細資訊，請參閱 {0}
go.refactoring.change.signature.current.method.option=僅{0}當前方法
go.refactoring.change.signature.function.will.not.perform.initialization.validation.message=函式 {0} 將不再執行初始化
go.refactoring.change.signature.function.will.not.start.application.validation.message=函式 {0} 將不再啟動應用程式
go.refactoring.change.signature.method.specification.and.implementations.option={0}方法規范和所有實作
go.refactoring.change.signature.named.and.unnamed.parameters.validation.message=無法同時使用命名參數和未命名參數。
go.refactoring.change.signature.new.parameter.validation.message.part=新參數
go.refactoring.change.signature.not.legal.identifier.validation.message=''{0}'' 不是合法關鍵字。
go.refactoring.change.signature.parameter.without.type.validation.message=第 {0,number,ordinal} 個參數應具有類型。
go.refactoring.change.signature.renamed.parameter.validation.message.part=重新命名的參數
go.refactoring.change.signature.result.parameters.tab.title=結果參數
go.refactoring.change.signature.reuse.types.checkbox=重用類型
go.refactoring.change.signature.target.not.found.error.message=文字游標必須位於要重構的函式或方法的名稱處
go.refactoring.change.signature.used.multiple.times.validation.message=''{0}'' 被多次使用。
go.refactoring.change.signature.variadic.is.not.last.validation.message=可變參數應始終是最後一個參數。
go.refactoring.change.signature.variadic.parameter.in.result.validation.message=結果中不允許使用可變形參。
go.refactoring.declarations.separator=宣告
go.refactoring.different.package.name.validation.message=現有檔案的軟體套件名稱不應不同。
go.refactoring.empty.target.directory.path.validation.message=目標目錄路徑不應為空。
go.refactoring.empty.target.file.name.validation.message=目標檔名不應為空。
go.refactoring.empty.target.package.validation.message=目標軟體套件名稱不應為空。
go.refactoring.exported.column.name=已匯出
go.refactoring.extract.interface.caret.should.be.inside.type.error.message=文字游標應置於要重構的類型內
go.refactoring.extract.interface.empty.type.name.validation.message=類型名稱不應為空。
go.refactoring.extract.interface.incorrect.type.name.validation.message=類型名稱不正確。
go.refactoring.extract.interface.rename.type.and.use.interface.radio.button=重新命名原始類型並在可能的情況下使用接口(&E)
go.refactoring.extract.interface.rename.type.spec.label=將類型規範重命名為:
go.refactoring.extract.interface.unexported.method.specification.validation.message={0} {1} 不會實作未匯出的方法規範
go.refactoring.extract.interface.unexported.not.be.accessible.validation.message=未匯出的{0}將無法從{1}存取
go.refactoring.failed.to.create.directory.error.message=找不到或建立目錄 ''{0}''
go.refactoring.failed.to.create.file.for.package.error.message=無法為軟體套件 ''{1}'' 找到或建立檔案 ''{0}''
go.refactoring.file.chooser.dialog.title=選擇目標目錄或檔案
go.refactoring.file.label=目標檔案:
go.refactoring.implement.methods.checkbox=非專案(&N)
go.refactoring.implement.methods.command=實作{0}
go.refactoring.implement.methods.create.type.name=建立類型…
go.refactoring.implement.methods.dummy.background.updater.task.title=正在搜尋類型…
go.refactoring.implement.methods.preparing.template.progress.title=正在準備模板…
go.refactoring.implement.methods.prompt=選擇要實作的接口:
go.refactoring.incorrect.file.name.validation.message=目標檔名不正確。
go.refactoring.incorrect.package.name.validation.message=目標軟體套件名稱不正確。
go.refactoring.inline.cannot.inline.call.from.defer=無法將內聯重構應用於來自 'defer' 語句的呼叫
go.refactoring.inline.cannot.inline.call.from.go=無法將內聯重構應用於來自 'go' 語句的呼叫
go.refactoring.inline.cannot.inline.in.loop.condition=無法將內聯重構應用於迴圈條件中的多行函式或軟體套件級別的 'var' 或 'const' 宣告
go.refactoring.inline.cannot.inline.many.returns=無法將內聯重構應用於具有多個返回的函式
go.refactoring.inline.cannot.inline.no.body=無法將內聯重構應用於沒有主體的函式
go.refactoring.inline.cannot.inline.recursive.functions=無法將內聯重構應用於遞迴函式
go.refactoring.inline.cannot.inline.variadic.parameter=不支持內聯可變形參
go.refactoring.inline.command.name=內聯函式/方法
go.refactoring.inline.defer.statements=該函式包含將在周圍函式呼叫後執行的 defer 語句
go.refactoring.inline.defined.in.goroot.error.message={0} {1} 在 GOROOT 中定義
go.refactoring.inline.defined.in.multi.value.context.error.message={0} {1} 在多值上下文中定義
go.refactoring.inline.found.usages.in.goroot.message=已在 GOROOT 中找到 ''{1}'' 的 {0, choice, 1#1 個用法|2#{0} 個用法}。
go.refactoring.inline.kept.definition.and.inlined.message=已保留定義{0, choice, 0#|1#和專案與 GOPATH 中的 1 個內聯用例|2#和專案與 GOPATH 中的 {0} 個內聯用例}。
go.refactoring.inline.no.initializer.error.message={0} {1} 沒有初始設定式
go.refactoring.inline.no.parameter.value.error.message=找不到參數 {0} 的值
go.refactoring.inline.options.dialog.all.keep=內聯所有呼叫並保留宣告(&K)
go.refactoring.inline.options.dialog.all.remove=內聯所有呼叫並移除宣告(&A)
go.refactoring.inline.options.dialog.name.label=如何執行內聯重構?
go.refactoring.inline.options.dialog.this.keep=僅內聯此呼叫並保留宣告(&T)
go.refactoring.inline.reassigned.error.message=已重新分配 {0}
go.refactoring.introduce.analyzing.before.extraction=正在對程式碼進行提取前的分析…
go.refactoring.introduce.collecting.free.vars=正在收集自由變數…
go.refactoring.introduce.continue.statement.interrupts.execution.flow.error.message=當 continue 語句中斷執行流時，不支持重構
go.refactoring.introduce.does.not.return.value.error.message=表達 {0} 不返回值。
go.refactoring.introduce.extract.function.command=提取函式
go.refactoring.introduce.extract.function.title=提取函式
go.refactoring.introduce.extract.method.command=提取方法
go.refactoring.introduce.extract.method.or.function.title=提取方法或函式
go.refactoring.introduce.extract.title=提取
go.refactoring.introduce.extract.variable.command=提取變數
go.refactoring.introduce.generating.code.template=正在生成程式碼模板…
go.refactoring.introduce.label.definition.selected.with.all.references.error.message=只有選擇標籤定義及其所有參照時，才支援重構
go.refactoring.introduce.label.reference.interrupts.execution.flow.error.message=當標籤參照中斷執行流時，不支持重構
go.refactoring.introduce.method.with.receiver.renderer=包含 {0} 接收器的方法
go.refactoring.introduce.not.constant.value.error.message=表達式 {0} 不是常量值。
go.refactoring.introduce.range.contains.defer.message=所選範圍包含 'defer' 語句，該語句可能會在提取期間重新排序
go.refactoring.introduce.receiver.without.name.error.message=接收器應有名稱
go.refactoring.introduce.type.chooser.title=選擇類型
go.refactoring.introduce.type.command=引入類型
go.refactoring.introduce.type.dialog.title=引入類型
go.refactoring.less.than.one.declaration.validation.message=應至少選擇一個宣告。
go.refactoring.merge.declarations.action.text=合併宣告
go.refactoring.merge.declarations.with.iota.warning=由於 'iota'，宣告初始設定式合併後會有不同的值
go.refactoring.move.affect.initialization.order.validation.message=移動函式 {0} 可能會影響該應用程式的初始化順序
go.refactoring.move.break.initialization.validation.message=移動變數 {0} 將中斷變數 {1} 的初始化
go.refactoring.move.exported.function.will.not.perform.initialization.validation.message=匯出的函式 {0} 將不再執行初始化
go.refactoring.move.exported.function.will.not.start.application.validation.message=匯出的函式 {0} 將不再啟動應用程式
go.refactoring.move.file.should.differ.validation.message=目標檔案應與原始檔不同
go.refactoring.move.function.will.not.start.application.validation.message=軟體套件 {1} 外部的函式 {0} 將不再啟動此應用程式
go.refactoring.move.required.by.validation.message={0}需要
go.refactoring.move.type.will.become.non.local.for.method.validation.message=類型 {0} 將成為方法 {1} 的非區域類型
go.refactoring.move.type.will.not.implement.interface.validation.message=類型 {0} 將不再實作接口 {1}
go.refactoring.move.value.will.change.validation.message=常數 {0} 的值將更改，因為它使用 {1} 進行宣告
go.refactoring.non.go.file.validation.message=目標檔案應為 Go 檔案。
go.refactoring.non.writable.directory.validation.message=目標目錄不可寫。
go.refactoring.non.writeable.file.validation.message=目標檔案不可寫。
go.refactoring.redeclare.validation.message={0} 將重新宣告相同名稱的 {1}
go.refactoring.refactor.action=重構
go.refactoring.rename.action=重新命名
go.refactoring.rename.all.receivers.option=重新命名所有接收器
go.refactoring.rename.current.receiver.option=僅重新命名當前接收器
go.refactoring.rename.directory.message=同時重新命名軟體套件目錄 ''{0}''?
go.refactoring.rename.looking.for.anonymous.field.usages.progress.title=正在尋找匿名欄位用法
go.refactoring.rename.looking.for.method.usages.progress.title=正在尋找方法用法
go.refactoring.rename.package.title=同時將軟體套件 ''{0}'' 重命名為 ''{1}''?
go.refactoring.rename.production.file.title=同時重新命名生產檔案 ''{0}''?
go.refactoring.rename.test.file.title=同時重新命名測試檔案 ''{0}''?
go.refactoring.rename.type.parameter.option.all=在類型定義和所有接收器中重新命名
go.refactoring.rename.type.parameter.option.current.only=僅重新命名此類型參數
go.refactoring.split.declarations.action.text=拆分宣告
go.refactoring.split.declarations.with.iota.warning=由於 'iota'，宣告初始設定式拆分後會有不同的值
go.refactoring.unexported.validation.message=未匯出的{0}將不再可以從{1}存取
go.remote.debug.disconnect.delve.label=斷開連線時:
go.remote.debug.disconnect.delve.option.ask=詢問
go.remote.debug.disconnect.delve.option.leave=保持執行
go.remote.debug.disconnect.delve.option.stop=停止遠端 Delve 程序
go.remove.else=移除 else
go.replace.field.type.with.pointer.family.name=將欄位類型取代為指針
go.run.configuration.add.go.tool.argument.label=新增
go.run.configuration.build.on.remote.target.checkbox=在遠端目標上建置(&B)
go.run.configuration.environment.label=環境(&V):
go.run.configuration.go.tool.arguments.label=Go 工具實參(&G):
go.run.configuration.kind.directory=目錄
go.run.configuration.kind.file=檔案
go.run.configuration.kind.package=軟體套件
go.run.configuration.module.label=模組(&M):
go.run.configuration.output.directory.label=輸出目錄(&O):
go.run.configuration.program.arguments.label=程式引數(&P):
go.run.configuration.run.after.build.checkbox=建置後執行(&R)
go.run.configuration.run.kind.label=執行種類(&K):
go.run.configuration.run.with.sudo.label=通過 sudo 執行(&I)
go.run.configuration.run.with.sudo.mnemonic=使用提升的權限執行(&I)
go.run.configuration.run.with.sudo.tooltip=使用超級使用者權限執行組態
go.run.configuration.target.directory.label=目錄(&D)
go.run.configuration.target.files.label=檔案(&F):
go.run.configuration.target.package.label=軟體套件路徑(&E):
go.run.configuration.test.framework=測試框架(&R):
go.run.configuration.test.kind.label=測試種類(&K):
go.run.configuration.test.pattern.label=模式(&T):
go.run.configuration.use.all.custom.build.tags.label=使用所有自訂建置標記(&L)
go.run.configuration.use.all.custom.build.tags.tooltip=All the custom build tags from your settings are added during the building process (see Go | Build Tags)
go.run.playground.could.not.run.message=無法執行程式碼
go.run.target.compiled.executables.description=目標上經過編譯的可執行檔案的輸出路徑
go.run.target.compiled.executables.directory.browsing.title=經過編譯的可執行檔案
go.run.target.compiled.executables.directory.label=經過編譯的可執行檔案目錄:
go.run.target.configure.label=Go 組態
go.run.target.executable.path.label=Go 可執行檔案: 
go.run.target.executable.path.title=Go 可執行檔案
go.run.target.gopath.label=GOPATH: 
go.run.target.gopath.title=GOPATH
go.run.target.project.sources.description=目標上專案源的輸出路徑
go.run.target.project.sources.directory.browsing.title=專案源
go.run.target.project.sources.directory.label=專案源目錄:
go.run.target.run.label=執行 Go 應用程式
go.run.target.version.label=版本:
go.sdk.no.version.text=<無版本>
go.settings.build.tags.any.sdk.value=任意
go.settings.build.tags.arch.label=Arch
go.settings.build.tags.cgo.support.label=cgo 支援
go.settings.build.tags.compiler.label=編譯器
go.settings.build.tags.custom.tags.hint=<html><body><p>以空格分隔的附加標記列表。<a href="https://www.jetbrains.com/help/go/configuring-build-constraints-and-vendoring.html">可以用於 </a>'go build' 指令。</p></body></html>
go.settings.build.tags.custom.tags.label=自訂標記
go.settings.build.tags.description=<html><body><p>以下選項描述編輯器的目標系統。IDE 使用這些值定義在驗證、解析和程式碼補全中使用的檔案。有關這些選項的詳細資訊，請參閱 <a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints">Go 約束文檔</a>。</p></body></html>
go.settings.build.tags.display.name=建置標記
go.settings.build.tags.group.name=編輯器約束
go.settings.build.tags.os.label=OS
go.settings.build.tags.version.label=Go 版本
go.settings.common.ask.for.confirmation.in.playground.checkbox=在 Go Playground 中共享之前詢問
go.settings.common.confirmation.show.options.option=顯示選項
go.settings.common.convert.json.on.paste.convert.option=將 JSON 轉換為 Go 類型
go.settings.common.convert.json.on.paste.insert.as.is.option=照原樣插入 JSON
go.settings.common.convert.json.on.paste.option=貼上 JSON 時
go.settings.common.detect.go.packages.from.clipboard.checkbox=從剪貼簿檢測 go 軟體套件
go.settings.common.directory.rename.do.not.rename.package.option=不重新命名軟體套件
go.settings.common.directory.rename.option=重新命名目錄時
go.settings.common.directory.rename.rename.package.option=重新命名軟體套件
go.settings.common.indent.on.enter.in.raw.strings.checkbox=在輸入原始字串時縮排
go.settings.common.package.rename.do.not.rename.directory.option=不重新命名目錄
go.settings.common.package.rename.option=重新命名軟體套件時
go.settings.common.package.rename.rename.directory.option=重新命名目錄
go.settings.common.show.auto.import.in.completion.popup.checkbox=在鍵入時建議需要附加匯入的變體
go.settings.common.show.documentation.in.parameter.info.checkbox=在參數資訊中顯示文檔
go.settings.common.suggest.parameter.names.checkbox=在補全時建議參數名稱
go.settings.common.test.do.not.rename.corresponding.file.option=不重新命名相應的測試或生產檔案
go.settings.common.test.rename.corresponding.file.option=重新命名相應的測試或生產檔案
go.settings.common.test.rename.option=重新命名檔案時
go.settings.completion.ml.display.name=Go
go.settings.debugger.dataViews.section.name=Go
go.settings.debugger.default.integer.format.label=預設整數格式:
go.settings.debugger.general.section.name=Go
go.settings.debugger.goroutines.limit.name=Goroutines 限制
go.settings.debugger.max.array.values=從陣列、切片或映射讀取的最大元素數
go.settings.debugger.max.string.len=從字串讀取的最大位元組數
go.settings.debugger.max.string.len.in.call=從字串讀取用於函式呼叫結果的最大位元組數
go.settings.debugger.max.struct.fields=從結構讀取的最大字段數 (-1 表示讀取所有欄位)
go.settings.debugger.rebuild.transitive.packages.checkbox=重新建置過渡軟體套件(&R)
go.settings.debugger.rebuild.transitive.packages.description=為了獲得更好的偵錯體驗，Delve 需要在 $GOROOT/pkg 中重新編譯最佳化的模組。
go.settings.debugger.show.pointer.addresses=顯示指針地址
go.settings.debugger.show.types=顯示類型
go.settings.debugger.stack.depth.name=堆疊深度
go.settings.debugger.use.custom.delve.settings=組態 Delve 偵錯設定
go.settings.default.value=預設 ({0})
go.settings.diff.ignore.imports.and.formatting.description=忽略匯入和格式化
go.settings.disabled=停用
go.settings.enabled=啟用
go.settings.folding.format.strings.checkbox=格式字串
go.settings.folding.one.line.panics.checkbox=1 行 panic
go.settings.folding.one.line.return.checkbox=一行返回
go.settings.formatter.add.space.except.for.comments.label=以此開頭的註釋除外: 
go.settings.formatter.comment.prefix.cannot.be.empty.validation.message=註釋前綴不能為空
go.settings.formatter.comment.prefix.dialog.title=註釋前綴
go.settings.formatter.no.exceptions.empty.text=無異常
go.settings.formatter.wrap.call.arguments=函式呼叫實參
go.settings.formatter.wrap.comp.lit=複合文字
go.settings.formatter.wrap.func.params=函式參數
go.settings.formatter.wrap.func.result=函式結果參數
go.settings.global.gopath.group.name=全域 GOPATH
go.settings.imports.display.name=匯入
go.settings.invalid.build.tag.error=建置標記無效: ''{0}''
go.settings.module.gopath.group.name=模組 GOPATH
go.settings.modules.add.other.environment.variable=其他
go.settings.modules.automatic.dependencies.download.disable.for.all=為所有專案停用
go.settings.modules.automatic.dependencies.download.disable.for.current.project=為當前專案停用，為其他專案啟用
go.settings.modules.automatic.dependencies.download.enable.for.all=為所有專案啟用
go.settings.modules.automatic.dependencies.download.enable.for.current.project=為當前專案啟用，為其他專案停用
go.settings.modules.automatic.dependencies.download.global.checkbox.tooltip=每次執行 'go list -m' 後自動執行 'go mod download'。如果互聯網連線受限，請停用此選項。
go.settings.modules.automatic.dependencies.download.label=下載 Go 模組相依項:
go.settings.modules.choose.module.dialog.title=選擇 Go 模組
go.settings.modules.choose.module.validation.message=選擇至少一個模組
go.settings.modules.display.title=Go 模組
go.settings.modules.enable.integration.checkbox=啟用 Go 模組整合
go.settings.modules.environment.context.help=GOPROXY、GOPRIVATE 和其他環境變數
go.settings.modules.environment.label=環境:
go.settings.modules.explain.environment.variable=解釋變數
go.settings.modules.gomodcache.description=GOMODCACHE 設定模組快取位置。
go.settings.modules.gomodcache.documentation.link.title=Go 1.15 發行說明
go.settings.modules.gonoproxy.description=GONOPROXY 列出了被視為 private 的軟體套件。下載這些軟體套件時，go 指令不會使用代理。覆蓋 GOPRIVATE。
go.settings.modules.gonosumdb.description=GONOSUMDB 列出了被視為 private 的軟體套件。驗證這些軟體套件時，go 指令不會使用校驗和資料庫。覆蓋 GOPRIVATE。
go.settings.modules.goprivate.description=GOPRIVATE 列出了被視為 private 的軟體套件。在下載和驗證這些軟體套件時，go 指令不會使用代理或校驗和資料庫。
go.settings.modules.goprivate.documentation.link.title=非 public 模組的模組組態
go.settings.modules.goproxy.documentation.link.title=模組下載和驗證
go.settings.modules.goproxy.tooltip=GOPROXY 指示 go 指令在下載相依項時使用特定的代理伺服器。
go.settings.modules.gosumdb.description=GOSUMDB 可以識別校驗和資料庫的名稱。go 指令使用它來確保下載的相依項的校驗和沒有更改。
go.settings.modules.gosumdb.documentation.link.title=模組身份驗證失敗
go.settings.modules.gotoolchain.description=GOTOOLCHAIN 會設定要使用的 Go SDK 版本。
go.settings.modules.gotoolchain.documentation.link.title=Go 工具鏈
go.settings.modules.sync.dependencies.fix.family.name=同步相依關係
go.settings.modules.sync.dependencies.fix.text=同步 {0} 的相依關係
go.settings.modules.vendoring.checkbox=自動啟用供應支援
go.settings.modules.vendoring.checkbox.tooltip=當模組包含 'vendor' 目錄時，啟用 vendoring 支援。如果 'vendor' 目錄不是由 Go 語言建立的，並且不包含 Go 相依項，請清除此複選框。當此選項關閉時，使用 '-mod=mod' 或 '-mod=readonly' 呼叫 'go' 工具。
go.settings.modules.vendoring.documentation.link.title=如何為模組使用 vendoring
go.settings.postfix.choose.type.action.name=選擇類型…
go.settings.postfix.choose.type.prompt.text=選擇類型
go.settings.postfix.enter.type.action.name=輸入類型名稱…
go.settings.postfix.enter.type.empty.type.validation.message=指定類型名稱
go.settings.postfix.enter.type.import.path.label=匯入路徑(&I):
go.settings.postfix.enter.type.name.label=類型名稱(&T):
go.settings.project.gopath.group.name=專案 GOPATH
go.settings.project.sdk.value=專案 SDK ({0})
go.settings.sdk.add.action.name=本地…
go.settings.sdk.add.button=新增 SDK…
go.settings.sdk.add.button.tooltip=新增 SDK ({0})
go.settings.sdk.add.local.title=為 Go SDK 選擇主目錄
go.settings.sdk.combo.tooltip=新增 SDK…
go.settings.sdk.detected.notification.configure.go.sdk.action.text=組態 Go SDK
go.settings.sdk.detected.notification.text=<b>{0}</b> 被自動設定為專案 SDK。您可以在 GOROOT 組態中進行更改。
go.settings.sdk.detected.notification.title=檢測到 GOROOT
go.settings.sdk.discovering.go.sdks.progress.title=正在發現 Go SDK…
go.settings.sdk.download.action.name=下載…
go.settings.sdk.download.checksum.of.downloaded.file.mismatched.error=下載的檔案的校驗和不符合
go.settings.sdk.download.could.not.copy.unpacked.sdk.error=無法複製解壓縮的 SDK
go.settings.sdk.download.could.not.find.go.directory.in.downloaded.file.error=無法在下載的檔案中找到 go 目錄
go.settings.sdk.download.could.not.get.checksum.error=無法獲取校驗和: {0}
go.settings.sdk.download.could.not.unpack.downloaded.file.error=無法解壓縮下載的檔案
go.settings.sdk.download.dialog.cannot.create.directory.validation.message=無法在給定路徑中建立目錄。
go.settings.sdk.download.dialog.cannot.load.go.versions.validation.message=無法載入 SDK 版本。{0}
go.settings.sdk.download.dialog.location.is.not.specified.validation.message=指定目標目錄。
go.settings.sdk.download.dialog.location.label=位置:
go.settings.sdk.download.dialog.progress.versions.status=Go SDK 版本
go.settings.sdk.download.dialog.reload.versions.action.name=重新載入
go.settings.sdk.download.dialog.title=下載 Go SDK
go.settings.sdk.download.dialog.version.is.not.specified.validation.message=指定版本。
go.settings.sdk.download.dialog.version.label=版本:
go.settings.sdk.download.failed.to.download.notification.title=下載 SDK 失敗
go.settings.sdk.download.installed.notification.title=已安裝 {0} {1}
go.settings.sdk.download.progress.copying.detailed.status=正在複製 {0}…
go.settings.sdk.download.progress.copying.status=正在複製 SDK…
go.settings.sdk.download.progress.downloading.status=正在下載 {0} {1}
go.settings.sdk.download.progress.unpacking.status=正在解壓縮 SDK…
go.settings.sdk.download.progress.verifying.status=正在驗證下載的歸檔…
go.settings.sdk.download.unpacked.sdk.is.corrupted.error=解壓縮的 SDK 損壞
go.settings.sdk.enable.integration.label=在模組中啟用 Go 支援: 
go.structure.view.exportability.sorter.text=按匯出性排序
go.structure.view.method.location=在 {0} 中
go.structure.view.private.members.filter.text=顯示 private 成員
go.structure.view.show.package.structure.action.text=顯示軟體套件結構
go.sum.generated.sources.filter.notification.text=不應編輯該檔案，因為該檔案僅供 Go 工具使用。更改可能會導致建置程序中斷。
go.template.intention.add.type.hint.name=指定點類型
go.template.intention.associate.file.extension.with.go.template=將檔案副檔名與 Go 模板關聯
go.template.intention.extension.associated.with.template=''{0}'' 副檔名已與 Go 模板關聯
go.template.intention.open.file.type.settings=開啟 Go 模板檔案類型設定
go.template.intention.undo=撤消
go.terms.anonymous.field=匿名欄位
go.terms.array=陣列
go.terms.case=case
go.terms.chan=chan
go.terms.closure=結束
go.terms.comma=逗號
go.terms.comment=註釋
go.terms.constant=常數
go.terms.declaration=宣告
go.terms.duplicate=重複
go.terms.duplicated.case=重複的 case
go.terms.duplicated.default=重複的預設值
go.terms.empty.declaration=空宣告
go.terms.field=欄位
go.terms.function=函式
go.terms.global.constant=全域常數
go.terms.global.variable=全域變數
go.terms.go.statement=go 語句
go.terms.import=匯入
go.terms.import.alias=匯入別名
go.terms.interface=接口
go.terms.label=標籤
go.terms.map=映射
go.terms.method=方法
go.terms.method.specification=方法規範
go.terms.module.statement=模組語句
go.terms.package=軟體套件
go.terms.package.capitalized=軟體套件
go.terms.package.statement=\ package 語句
go.terms.parameter=參數
go.terms.pointer=指針
go.terms.receiver=接收器
go.terms.semicolon=分號
go.terms.shadowed.declaration=隱藏的宣告
go.terms.slice=切片
go.terms.statement=語句
go.terms.string=字串
go.terms.struct=struct
go.terms.type=類型
go.terms.type.alias=類型別名
go.terms.type.parameters=類型參數
go.terms.type.pluralized=類型
go.terms.variable=變數
go.terms.version.statement=版本語句
go.test.cannot.find.files.compatible.with.framework.error=無法在與 <code>{1}</code> 框架相容的 <code>{0}</code> 中找到 Go 測試檔案
go.test.cannot.run.compiling.on.directory.kind.run.configurations.error=無法在類似目錄的執行組態中偵錯測試。您可以使用<a href="edit">測試種類: 軟體套件</a>偵錯每個軟體套件的測試
go.test.creator.cannot.find.field.type=找不到 {0} 的欄位類型
go.test.creator.cannot.find.function.signature=找不到函式簽名
go.test.creator.cannot.find.method.receiver=找不到 {0} 的方法接收器
go.test.creator.cannot.find.method.receiver.type=找不到 {0} 的方法接收器類型
go.test.creator.cannot.find.test.import.path=找不到測試匯入路徑
go.test.creator.cannot.find.test.package.name=找不到測試軟體套件名稱
go.test.creator.empty.test.file.name=空測試檔案
go.test.creator.gotests.failed.to.create.test.file=無法建立測試檔案 {0}
go.test.creator.gotests.generation.failed.notification.title=測試生成失敗
go.test.creator.gotests.generation.name=測試生成
go.test.creator.gotests.no.tests.generated=未生成測試
go.test.creator.progress.title.searching.for.functions.for.test=正在搜尋測試的函式…
go.test.creator.progress.title.searching.for.tests.for.function=正在搜尋函式的測試…
go.test.creator.test.for.file.name=檔案測試
go.test.creator.test.for.function.name=函式測試
go.test.creator.test.for.package.name=軟體套件測試
go.test.creator.test.for.selection.name=選區測試
go.test.file.does.not.exist.error=檔案不存在: {0}
go.test.framework.is.not.available.on.files.error=框架 <code>{0}</code> 在任何檔案 <code>{1}</code> 上都不可用
go.test.framework.not.available.in.module.error=框架 <code>{0}</code> 在所選模組中不可用
go.test.fuzzing.duplicate.header=重複的頭
go.test.fuzzing.header.expected=應為 'go test fuzz v1' 頭
go.test.fuzzing.incorrect.header.position=頭必須在檔案開頭
go.test.fuzzing.label.corpus.label=Go fuzz 種子語料庫
go.test.fuzzing.value.expected=應為至少一個值
go.test.generate.benchmark.text=基準
go.test.generate.example.text=範例
go.test.generate.function.description=生成 {0} 函式
go.test.generate.fuzz.text=模糊處理
go.test.generate.table.benchmark.description=生成表基準函式
go.test.generate.table.benchmark.text=表基準
go.test.generate.table.test.description=生成表測試函式
go.test.generate.table.test.text=表測試
go.test.generate.test.main.text=Test_main
go.test.generate.test.text=測試
go.test.no.tests.were.run=未執行任何測試
go.test.non.a.package.error=<code>{0}</code> 不是軟體套件。<br>使用目錄類型執行組態，以在目錄上遞迴執行測試。
go.test.not.go.file.error=檔案 ''{0}'' 不是 Go 檔案
go.test.run.configuration.description=Go 測試執行組態
go.test.run.configuration.name=Go 測試
go.test.run.fuzzing.tooltip=執行模糊處理
go.test.run.test.tooltip=執行測試
go.test.suggested.run.configuration.name={1} 中的 {0}
go.test.template.run.configuration.name=Go 測試
go.test.testify.run.configuration.name={1} 中的 {0}
go.test.testify.unknown.target.name=未知
go.test.testing.directory.does.not.exist.error=測試目錄不存在
go.test.working.directory.should.be.ancestor.of.testing.directory.error=工作目錄應當是該測試目錄的上級
go.unknown.type.information.hint=<未知>
go.unwrap.argument=解包實參
go.unwrap.argument.description=解包 {0}
go.unwrap.else=解包 else
go.unwrap.for=解包 for
go.unwrap.if=解包 if
go.usage.type.call=呼叫
go.usage.type.const.declaration=常數宣告
go.usage.type.field.declaration=欄位宣告
go.usage.type.function.argument=函式實參
go.usage.type.import=匯入
go.usage.type.parameter.declaration=參數宣告
go.usage.type.receiver=接收器
go.usage.type.return.type=返回值類型
go.usage.type.struct.initialization=結構初始化
go.usage.type.type.alias=類型別名
go.usage.type.type.assertion=類型斷言
go.usage.type.type.constraint=類型約束
go.usage.type.type.conversion=類型轉換
go.usage.type.type.instantiation=類型實例化
go.usage.type.type.parameter.declaration=類型參數宣告
go.usage.type.variable.declaration=變數宣告
go.use.gopath.from.system.environment.checkbox=使用系統環境中定義的 GOPATH
go.value.cannot.be.represented.by.type={0} 的值不能由類型 {1} 表示
go.wizard.description=建立 Go 專案以在 GOPATH 下開發應用程式或庫
go.wizard.name=Go (GOPATH)
go.wsl.attach.host.group.name=WSL
go.wsl.resolving.user.home=正在 WSL 中解析使用者主目錄
go.wsl.sdk.unpack.error=解包指令失敗，退出程式碼為 {0}
group.DlvDebugger.ViewAsGroup.text=檢視方式
group.GoTools.description=Go 外部工具
group.GoTools.text=Go 工具
inlay.go.inlays.display.constant.definition.description=解析常數定義的值。
inlay.parameters.go.return.parameters=在 return 語句中顯示參數名稱。
inlay.parameters.go.struct.unnamed.struct.fields=顯示匿名欄位的名稱。
notification.group.build=Go 建置
notification.group.debug=Go 偵錯
notification.group.execution=Go 執行
notification.group.general=Go
notification.group.tools=Go 工具整合
notification.group.tools.sticky=Go 工具整合(重要)
postfix.template.condition.array.name=陣列
postfix.template.condition.assignable.slice.name=可分配的切片
postfix.template.condition.boolean.name=布爾
postfix.template.condition.builtin.append.applicable.name=適用內建 append
postfix.template.condition.builtin.cap.applicable.name=適用內建 cap
postfix.template.condition.builtin.len.applicable.name=適用內建 len
postfix.template.condition.channel.name=通道
postfix.template.condition.comparable.to.nil.name=與 nil 相當
postfix.template.condition.error.expr.result.name=表達式包含錯誤結果
postfix.template.condition.error.name=錯誤
postfix.template.condition.expr.in.if.with.missing.block.name=缺少塊的 if 條件中的表達式
postfix.template.condition.floats.slice.name=float64s 的切片
postfix.template.condition.interface.impls.slice.name=排序接口實作的切片
postfix.template.condition.ints.slice.name=int 的切片
postfix.template.condition.map.name=映射
postfix.template.condition.non.void.name=非 void
postfix.template.condition.number.name=數字
postfix.template.condition.slice.name=切片
postfix.template.condition.slice.with.no.sort.name=沒有專用排序函式的切片
postfix.template.condition.string.name=字串
postfix.template.condition.strings.slice.name=字串切片
postfix.template.provider.name=Go
project.files.and.vendor.scope.name=專案檔案和供應商
vgo.fix.delete.replacement=刪除取代
vgo.fix.dependency-deprecated.family-name=顯示棄用通知
vgo.fix.dependency-deprecated.message=顯示 {0} 棄用通知
vgo.fix.dependency-update.family-name=更新相依項版本
vgo.fix.dependency-update.single.message=更新到最新版本 {0}
vgo.fix.dependency-version-retracted.family-name=顯示撤回通知
vgo.fix.dependency-version-retracted.message=顯示 {0} 撤回通知
vgo.inspection.dependency-deprecated-retracted.option.deprecation-notice=棄用通知
vgo.inspection.dependency-deprecated-retracted.option.retraction-notice=撤回通知
vgo.inspection.dependency-deprecated-retracted.tooltip-template=<html><body>{0}.<p><span style="color:{3}">{1}:</span> {2}</body></html>
vgo.inspection.dependency-deprecated.display-name=已棄用的相依項
vgo.inspection.dependency-deprecated.message=已棄用的模組 {0}
vgo.inspection.dependency-update.display-name=有可用的相依項更新
vgo.inspection.dependency-update.message=有可用的 {0}@{1} 新版本: {2}
vgo.inspection.dependency-update.tooltip=有可用的新版本: {0}
vgo.inspection.dependency-version-retracted.display-name=已撤回的相依項版本
vgo.inspection.dependency-version-retracted.message=已撤回的模組版本 {0}@{1}
vgo.inspection.dependency-version-retracted.tooltip=撤回的模組版本 {0}
vgo.intention.add.all.replaced.modules.to.workspace.fix.text=將所有本地取代的模組新增到工作區
vgo.intention.add.module.to.workspace.fix.family.name=將模組新增到工作區
vgo.intention.add.module.to.workspace.fix.text=將 ''{0}'' 模組新增到工作區
vgo.intention.add.or.update.go.version.fix.family.name=在 'go.mod' 中新增或更新 Go 版本
vgo.intention.add.or.update.go.version.fix.text=在 ''go.mod'' 中將 Go 版本設定為 {0}
vgo.intention.dependency-update.aggregated.message=更新…
vgo.intention.dependency-update.aggregated.popup.title=更新…
vgo.intention.dependency-update.all.message=將所有相依項更新為 {0} 版本
vgo.intention.dependency-update.direct.message=將直接相依項更新為 {0} 版本
vgo.intention.dependency-update.option.latest=最新
vgo.intention.dependency-update.option.latest-patch=最新補丁
vgo.intention.merge.use.directives.family.name=將多個 'use' 指令合併為一個
vgo.intention.run.why.command.fix.family.name=執行 'go mod why -m'
vgo.intentions.category=Go 模組
vgo.update-service.command-presentation-name=正在提取 {0} 的相依項更新
# File Types
filetype.javascript.description=JavaScript
filetype.actionscript.description=ActionScript
filetype.typescript.description=TypeScript
filetype.typescript.jsx.description=TypeScript JSX
filetype.ecmascript6.description=ECMAScript 6
filetype.jsx.description=React JSX
filetype.jsx.display.name=React JSX
filetype.flow.description=Flow JS
filetype.flow.display.name=Flow JS
javascript.file=JavaScript 檔案
typescript.file=TypeScript 檔案
filetype.typescript.config.description=TypeScript 設定
filetype.typescript.config.display.name=TypeScript 設定

# Languages
javascript.language.simple.name=JavaScript
typescript.language.simple.name=TypeScript

# Language terms
javascript.language.term.function=函數
javascript.language.term.inner.function=內部函數
javascript.language.term.method=方法
javascript.language.term.constructor=構造函數
javascript.language.term.class=類
javascript.language.term.inner.class=內部類
javascript.language.term.interface=接口
javascript.language.term.inner.interface=內部接口
javascript.language.term.enum=枚舉
javascript.language.term.type.alias=類型別名
javascript.language.term.definition=定義
javascript.language.term.namespace=命名空間
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.variable=變數
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.local.variable=局部變數
javascript.language.term.local.const=局部常數
javascript.language.term.field=欄位
javascript.language.term.tag=標記
javascript.language.term.label=標籤
javascript.language.term.attribute=特性
javascript.language.term.decorator=裝飾器
javascript.language.term.attribute.value=特性值
javascript.language.term.package=軟體套件
javascript.language.term.module=模組
javascript.language.term.external.module.reference=外部模組引用
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.entity.name=實體名稱
javascript.language.term.jsdoc.tag=JSDoc 標籤
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.import.statement=import 語句
javascript.language.term.type.parameter=類型參數
javascript.language.term.destructuring.property=析構屬性
javascript.language.term.default.export=預設匯出
javascript.language.term.file=檔案
javascript.language.term.global=全域
javascript.language.term.xml.tag=xml 標籤

# Parser error messages
javascript.parser.message.expected.expression=應為表達式
javascript.parser.message.expected.xml.element=應為 XML 元素
javascript.parser.property.expected=應為屬性
javascript.parser.message.expected.lbrace=應為 {
javascript.parser.message.expected.at=應為 @
javascript.parser.message.expected.rbrace=應為 }
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=應為關鍵字、字串文字或數字文字
javascript.parser.message.expected.colon=應為 :
javascript.parser.message.expected.colon.or.comma=應為 : 或 ,
javascript.parser.message.expected.semicolon=應為 ;
javascript.parser.message.expected.lbrace.or.semicolon=應為 { 或 ;
javascript.parser.message.expected.rbracket=應為 ]
javascript.parser.message.expected.lparen=應為 (
javascript.parser.message.expected.rparen=應為 )
javascript.parser.message.expected.name=應為名稱
javascript.parser.message.expected.comma.or.rparen=應為 , 或 )
javascript.parser.message.expected.function.name=應為函數名稱
javascript.parser.message.expected.formal.parameter.name=應為參數名稱
javascript.parser.message.expected.statement=應為語句
javascript.parser.message.expected.parameter.name=應為參數名稱
javascript.parser.message.expected.property.name=應為屬性名稱
javascript.parser.message.expected.case.or.default=應為 'case' 或 'default'
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration='in' 前面應為左側表達式或變數宣告
javascript.parser.message.expected.forloop.in.or.semicolon=應為 'in' 或 ;
javascript.parser.message.expected.while.keyword=應為 'while'
javascript.parser.message.expected.comma=應為 ,
javascript.parser.message.expected.comma.or.rbrace=應為 , 或 }
javascript.parser.message.expected.variable.name=應為變數名稱
javascript.parser.message.expected.mult.or.lbrace=應為 * 或 {
javascript.parser.message.missing.rbrace=缺少 }
javascript.parser.message.missing.or_rbrace=缺少 |}
javascript.parser.message.missing.attribute.name=缺少特性名稱
javascript.parser.message.unexpected.end.of.file=意外的檔案結尾
javascript.parser.message.expected.type.name=應為類型名稱
javascript.parser.message.unclosed.string.literal=未閉合的字串文字
javascript.parser.message.unclosed.comment=未閉合註釋
javascript.parser.message.are.not.supported.by.dialect=當前 JavaScript 版本不支持 {0}
javascript.parser.message.expected.from=應為 'from'
javascript.parser.message.expected.typename=應為類型名稱
javascript.parser.message.expected.typename.or.*=* 應為 * 或類型名稱
javascript.parser.message.expected.name.or.lbrace=應為軟體套件名稱或 {
javascript.parser.message.expected.declaration=應為宣告
javascript.parser.message.expected.namespace=應為 'namespace'
javascript.parser.message.expected.string.literal=應為字串文字
javascript.parser.message.expected.xml=應為 XML 上下文關鍵字
javascript.parser.message.expected.equal=應為 =
javascript.parser.message.expected.identifier.lbrace.or.lbracket=應為關鍵字、{ 或 [
javascript.parser.message.expected.eqgt=應為 =>
javascript.parser.message.expected.identifier=應為關鍵字
javascript.parser.message.expected.instanceof=應為 'instanceof'
javascript.parser.message.expected.in=應為 'in'
javascript.parser.message.expected.value=應為值
javascript.parser.message.expected.identifier.or.value=應為關鍵字或值
javascript.parser.message.expected.as=應為 'as'
javascript.parser.message.expected.identifier.string.literal.or.lbrace=應為關鍵字、字串文字或 {
javascript.parser.message.expected.import.value=應為匯入綁定或說明符
javascript.parser.message.expected.import.specifier=應為匯入說明符
javascript.parser.message.expected.heredoc.closing.identifier=應為 heredoc 結束關鍵字
javascript.parser.message.expected.type.member=應為類型成員
javascript.parser.message.expected.tuple.comma.or.rbracket=應為 , 或 ]
javascript.parser.message.expected.target=僅接受 'target' 作為要新建的元屬性
javascript.parser.message.expected.meta=僅接受 'meta' 作為要匯入的元屬性
javascript.parser.message.expected.declare=應為 'declare'
javascript.parser.message.expected.exports=應為 'exports'
javascript.parser.message.expected.checks=應為 'checks'
javascript.parser.message.expected.type.keyword=應為 'type'
javascript.parser.message.expected.type=應為類型
javascript.parser.message.expected.question=應為 ?
javascript.parser.message.expected.class=應為 'class'

# Validation messages
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.redundant.type=顯式類型實參 {0} 可被取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.declaration.fix.text=導航到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導航到上一個宣告
javascript.validation.message.redeclaration.of.block.scope=無法重新宣告塊範圍變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊範圍變數不能與同一塊範圍中的"var"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 變數不能與其可見性範圍內的塊範圍變數使用相同的名稱
javascript.validation.message.assignment.to.const=嘗試分配給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始設定式。以後無法賦予有意義的值。
javascript.validation.message.constructor.field.not.allowed=類可能沒有名為 'constructor' 的非 static 欄位
es6.validation.message.const.variable.without.initializer=不允許使用無初始設定式的 'const' 變數
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.return.outside.function.definition='return' 在函數定義外部
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.extend.multiple.classes=類不能擴展多個類
javascript.validation.message.extend.final.class=無法擴展 final 類 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函數中使用
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符一起使用
typescript.validation.message.abstract.class.be.created=無法創建 abstract 類 ''{0}'' 的實例
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=構造函數不能為 'abstract'
typescript.validation.message.function.implementation.missing=缺少函數實作或此宣告之後未緊隨函數實作
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在 abstract 類中
typescript.validation.module.reference.with.extension=外部模組引用不能以擴展結束
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是構造函數類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類構造函數具有指定數量的類型實參
typescript.validation.class.extend.many.constructors=基類構造函數必須具有相同的返回類型
typescript.validation.class.extend.cycled.definition=迴圈類定義
typescript.validation.class.extend.constructor.return.not.class=基類構造函數返回類型 ''{0}'' 不是類或接口類型。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.async.incorrect.type.annotation=異步函數不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.overload=多載簽名無法被宣告為生成器
typescript.validation.generators.ambient=環境上下文中不允許使用生成器
typescript.validation.generators.no.yield=生成器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回類型。
typescript.validation.generators.async.no.yield=生成器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回類型。
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參


# Surround with names
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.if=if
javascript.surround.with.if.else=if / else
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.cast=Type(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.finally=try / finally
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.surround.with.function=函數
javascript.surround.with.function.expression=函數表達式
javascript.surround.with.object.literal=物件文字

# Introduce variable
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入局部變數
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\n選定內容不構成表達式。
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\n選定的表達式類型無效。
javascript.introduce.variable.name.prompt=名稱(&N):
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.element.already.exists=範圍中已存在同名的 {0}。
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\n選定內容包含對箭頭函數參數的引用
javascript.introduce.variable.arrow.await.referenced=無法引入。\n選定內容包含 await 表達式
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.introduce.incorrect.context=無法引入變數。\n選定內容包含對"this"的引用
javascript.introduce.field.title=引入欄位
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\n選定內容不構成表達式。
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\n選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\n沒有封閉類。
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.initialize.in.scope=初始化在(&I):
javascript.introduce.field.visibility=可見性(&V):
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.before.super.call=無法引入欄位。\n在"super"調用前無法存取"this"。
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.constructor=構造函數
javascript.introduce.constant.title=引入常數
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\n選定內容不構成表達式。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\n選定的表達式類型無效。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\n選定內容不是常數表達式。
javascript.introduce.parameter.title=提取參數
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\n選定內容不構成表達式。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\n找不到要使用的包含函數。
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\n選定的表達式類型無效。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\n並非所有用法都包含在異步函數中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\n目標函數不是異步函數
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.throw.expressions.unsupported=無法調用重構。\n"Extract"重構中當前不支持 Throw 表達式。
javascript.introduce.breaks.operator.precedence=無法調用重構。\n通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.in.es5=無法調用重構。\n無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.in.embedded.expression=無法調用重構。\n無法在嵌入式表達式中引入
javascript.introduce.variable.make.constant=設為常數
list.item.class.field=類欄位
list.item.global.or.module.constant=全域或模組常數
list.item.local.constant=局部常數

# Highlighting categories
javascript.keyword=關鍵字
javascript.string=字串
javascript.number=數字
javascript.linecomment=行註釋
javascript.doccomment=文檔註釋
javascript.blockcomment=塊註釋
javascript.regexp=正則表達式
javascript.operation=運算
javascript.parens=括號
javascript.brackets=中括號
javascript.braces=大括號
javascript.semicolon=分號
javascript.badcharacter=錯誤字符
jsdoc.text=JSDoc 文本
jsdoc.tag=JSDoc 標籤
jsdoc.tag.value=JSDoc 標記值
jsdoc.type=JSDoc 類型
javascript.doctag=文檔標籤
javascript.doctagvalue=文檔標記值
javascript.valid.string.escape=有效字串轉義
javascript.invalid.string.escape=無效字串轉義
javascript.comma=逗號
javascript.dot=點

# Errors with intentions
javascript.unresolved.function.name.message=未解析的函數或方法 {0}() #loc
javascript.unresolved.variable.name.message=未解析的變數 {0} #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null #loc
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined #loc
javascript.unresolved.type.name.message=未解析的類型 {0} #loc
javascript.unresolved.circle.definition=匯入的圓定義
javascript.missing.read.property=未解析的讀取屬性 #loc
javascript.missing.write.property=未解析的寫入屬性 #loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.file=找不到檔案 {0}
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unknown.metadata.attribute=未知元資料特性
javascript.undeclared.variable.name.message=隱式宣告變數 {0} #loc
javascript.create.function.intention.name=創建函數 ''{0}''
javascript.create.variable.intention.name=創建變數 ''{0}''
javascript.create.constant.intention.name=創建常數 ''{0}''
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.create.field.intention.name=創建欄位 ''{0}''
javascript.create.constant.field.intention.name=創建常數欄位 ''{0}''
javascript.create.method.intention.name=創建方法 ''{0}''
javascript.create.property.intention.name=創建屬性 ''{0}''
javascript.create.function.property.intention.name=創建函數屬性 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類中創建構造函數
javascript.create.get.property.intention.name=創建 ''get'' 屬性 ''{0}''
javascript.create.set.property.intention.name=創建 ''set'' 屬性 ''{0}''
javascript.create.function.intention.family=創建 JavaScript 函數或方法
javascript.create.variable.intention.family=創建 JavaScript 變數或屬性
javascript.intention.create.getter.setter=為 ''{0}'' 創建 getter 和 setter
javascript.intention.create.getter.setter.desc=創建 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 創建 setter
javascript.intention.create.setter.desc=創建 setter
javascript.intention.create.getter=為 ''{0}'' 創建 getter
javascript.intention.create.getter.desc=創建 getter
create.mobile.view=創建檢視 ''{0}''
javascript.rename.reference.intention.name=重命名引用
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.rename.dynamic.references=搜尋動態引用 (&D)
js.usage.type.call=函數調用中的用法
js.anonymous.to.named.function=匿名函數轉換為命名函數
js.convert.to.named.function=轉換為命名函數
js.convert.to.named.function.to.class.method=轉換為類方法
js.convert.to.arrow.function=轉換為箭頭函數
js.add.braces.to.arrow.function=向箭頭函數中添加大括號
js.inspection.function.expression.is.used.instead.of.arrow=使用了函數表達式而不是箭頭函數
js.arrow.function.braces.can.be.removed.key=箭頭函數體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函數體周圍的大括號
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函數體周圍的大括號
js.convert.to.anonymous.function.family.name=箭頭函數轉換為匿名函數
js.convert.to.anonymous.function=轉換為匿名函數
js.named.to.anonymous.family.name=轉換為函數表達式
js.named.to.function.expression.text=轉換為包含變數的函數表達式
js.named.to.function.hoisting.conflict.text=函數在宣告之前使用。轉換為變數後，將中斷使用
js.named.to.arrow.text=轉換為含有 {0} 的箭頭函數
js.split.into.multiple.declarations=拆分為多個宣告
js.remove.digit.separators=移除數字分隔符
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.separate.digits=分隔數字
js.separate.nibbles=分隔半字節
js.separate.bytes=分隔字節
js.separate.words=分隔 16 位單詞
js.separate.thousands=分隔千位數
js.separate.thousands.in.integer.part=將千位數分隔成整數
js.split.declarations=拆分宣告
js.replace.string.with.es6.template=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板文字
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.convert.var.to.let.text=轉換為 let
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”操作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函數器頂部。\n要在使用“全部修復”操作時禁用此行為，請選中“保守轉換 var”選項。
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”操作在內部範圍內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部範圍內轉換 require()（例如 'if' 語句或內部函數）
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.map.to.for.of.intention.family=將 'map' 陣列調用取代為 'for..of' 迴圈
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 調用
js.add.then.fix=添加 '.then()'
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.quote=引用
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.unquote=取消引用
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.property.to.indexer.intention=取代為索引器存取
js.indexer.to.property.intention=取代為屬性存取
js.join.vars.intention=加入後續變數宣告
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型：為唯讀檔案

# Move module members
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.table.title=要移動的成員
es6.move.module.members.refactoring.create.file=創建檔案
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\n要創建嗎?
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標文件名在此操作系統中無效
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.dialog.field.from=從:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 引用未解析匯入 {1}
es6.move.module.members.references.local.message=選擇的 {0} 引用非匯出 {1}
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
dialog.title.move.members=移動成員

js.pull.up.will.be.made.abstract=非 abstract {0} 將被設為 abstract
es6.extract.super.destination.label=目標檔案 (&D)：
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類中不允許沒有實作的多載宣告 {0}
es6.extract.super.different.name.expected=應為不同名稱

# Unit testing
js.testing.inspection.group.name=單元測試
js.testing.highlight.line=在測試程式碼中高亮顯示失敗的行
rc.environmentVariables.label=環境變數(&E)：
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.testFile=測試檔案(&F)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.nodeOptions.label=節點選項 (&O)：
rc.workingDirectory.label=工作目錄(&W):
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.suite.label=套件名稱:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testOrSuiteScope.test.label=測試名稱：
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testRunScope.testFile.label=測試檔案:
rc.testRunScope.testFile.browseTitle=選擇測試檔案

# Unit testing: Jest
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.rc.configurationFile.label=設定檔案(&C):
jest.rc.configurationFile.title=選擇 Jest 設定檔案
jest.rc.jestPackageField.label=Jest 軟體套件(&J)：
jest.rc.jestOptions.label=Jest 選項：
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env=jsdom
jest.coverage.notification.title=Jest 覆蓋率
jest.coverage.directory.not.found.notification.content=無法從 Jest 設定中讀取 coverageDirectory 選項
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率: 找不到 {0}。

# Unit testing: Protractor
protractor.rc.configurationFile.label=設定檔案(&C):
protractor.rc.configurationFile.title=選擇 Protractor 設定檔案
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P)：
protractor.rc.protractorOptions.label=Protractor 選項 (&O)：
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement

# Node.js
node.js.inspection.group.name=Node.js
node.js.missing.require=缺少 require() 語句
node.js.unresolved.api=未解析的 Node.js API
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.downloading=正在下載 Node.js {0}
node.js.interpreters=Node.js 解釋器
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.add.interpreter.action=添加{0}…
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.download.types.node=無法下載 @types/node
status.text.add.interpreter.with=使用 {0} 添加解釋器
status.text.no.interpreters.added=未添加解釋器
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
node.no.interpreter=無解釋器
node.interpreter.not.found=找不到 {0}
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可執行檔案
merged.process.output.text={0}{2, choice, 0#\n\n標準錯誤:\n{1}|1#}{4, choice, 0#\n\n標準輸出:\n{3}|1#}\n\n{5}
node.interpreter.download=下載 Node.js
node.interpreter.project_node.reference.name=專案
node.interpreter.node_from_path.reference.name=node

# Inspections
js.inspection.group.name=一般
typescript.inspection.group.name=TypeScript
js.inspection.bitwise.group.name=按位運算問題
js.code.style.issues.group.name=程式碼樣式問題
js.probable.bugs.group.name=可能的錯誤
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.switch.group.name=switch 語句問題
js.inspection.async.group.name=Async 程式碼和 promise
js.function.metrics.group.name=函數指標
js.validity.issues.group.name=有效性問題
js.imports.dependencies.group.name=Import 和依賴項
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.assignment.issues.group.name=賦值問題
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的引用可能無效
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類中 'this' 的引用可能無效
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函數的 'this.' 對類欄位的引用存取可能無效
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始設定式跳過引用迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中引用可變變數
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
js.unresolved.variable.inspection.name=未解析的 JavaScript 變數
ts.unresolved.variable.inspection.name=未解析的 TypeScript 變數
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.duplicate.declaration.inspection.name=重複宣告
# WI-11522 only the first word should start with uppercase letter
js.linters.inspection.group.name=程式碼品質工具
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和設定檔案
js.unused.local.symbol.inspection.name=未使用的局部符號
js.unused.es6.import.inspection.name=未使用的 import
js.unused.assignment.inspection.name=未使用的賦值
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個賦值合併
js.join.declaration.assignment.inspection.fix=聯接變數宣告和賦值
js.unused.global.symbol.inspection.name=未使用的全域符號
js.missing.await.symbol.inspection.name=異步函數調用缺少 await
js.missing.await.symbol.inspection.for.returns=始終對異步函數調用使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊跟踪
js.missing.await.symbol.inspection.for.generator.name=異步生成器應使用 for-await 迴圈進行迭代
jsx.missing.namespace.inspection.name=缺少 JSX 命名空間
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
tsx.missing.name.quick.fix.name="添加 {0} import 語句
js.destructuring.merge.inspection=正在析構具有相同鍵的屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的析構屬性
js.destructuring.merge.inspection.fix=合併析構屬性
js.nested.template.literal.inspection=模板文字中的冗餘嵌套
js.nested.template.literal.fix=內聯嵌套文字
js.redundant.await.inspection=冗餘 'await' 表達式
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.await.promise.resolve.fix=取代為 ''{0}''
js.top.level.await.expression.inspection=頂層 'await' 表達式
js.top.level.await.expression.inspection.description=使用了頂層 'await' 表達式
js.possibly.async.function.inspection=非異步函數中的 'await'
js.await.in.synchronous.function='await' 運算符只能在 'async' 函數中使用
js.possibly.async.function.quick.fix=令函數 {0} 為異步函數
js.possibly.async.function.quick.fix.family.name=將函數設為異步
js.property.can.be.replaced.with.shorthand=屬性可被取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可被取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.expand.shorthand.property.quick.fix=展開速記屬性
js.unresolved.function.inspection.name=未解析的 JavaScript 函數
ts.unresolved.function.inspection.name=未解析的 TypeScript 函數
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 賦值
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 賦值：'+=' 可能拼寫錯誤
js.suspicious.eq.plus.fix.name=取代為 '+='
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.potentially.invalid.constructor.usages.inspection.name=可能無效的構造函數用法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.invalid.type=類型語法無效
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的內容，但從未被查詢
collection.queried.but.not.update=查詢了集合 <code>#ref</code> 的內容，但從未寫入
javascript.constructor.with.lower.case.name.used.message=構造函數名稱通常以大寫字母開頭。拼寫錯誤？
interface.function.declaration.should.have.no.body=接口函數宣告不應有本體
javascript.ambient.declaration.should.have.no.body=環境宣告不應有本體
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始設定式
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始設定式必須是基元文字或文字枚舉引用
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 #loc
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.constructor.cant.have.return.type=構造函數不能有返回類型
invalid.identifier.value.0=無效關鍵字：''{0}''
js.suspicious.bind.with.arrow.function=箭頭函數 'bind' 用法可疑
javascript.change.signature.invalid.parameter.declaration=無效參數：''{0}''
javascript.change.signature.invalid.function.name.0=無效函數名稱：''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在生成器本體中使用 'yield' 表達式。
javascript.validation.new.target.not.in.function=僅允許函數宣告、函數表達式或構造函數的本體中有元屬性 'new.target'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中引用了 'this'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類實例上下文的情況下引用了'super'
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中引用了 'super'
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類 {0} 中的方法
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始設定式
javascript.fix.add.override.modifier=添加覆寫修飾符
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
js.code.style.tab.name=JavaScript
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.never=從不
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
typescript.code.style.tab.name=TypeScript
jsx.code.style.attribute.default.value=為 JSX 特性添加：
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.typebased=基於類型
javascript.formatting.options.panel.naming.conventions=命名約定
javascript.formatting.options.panel.comments=註釋
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非調用用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法會覆寫另一個方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的調用
js.undefined.property.assignment.inspection.name=未定義的屬性賦值
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.jquery.efficiency.inspection.name=可以最佳化 JQuery 選擇器
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.accessibility.check.inspection.name=已引用無法存取的 @private 和 @protected 成員
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 調用
js.consecutive.commas.in.array.literal.inspection.name=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.message=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果禁用，則所有未鍵入的參數均視為可選參數
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊跟踪功能
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函數調用前插入 'await' 有助於 V8 提供異步堆疊跟踪
js.file.references.inspection.name=未解析的檔案引用
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組依賴關係
js.inspection.promise.ignored.display.name=返回 promise 的方法調用結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.flowjs.group.name=Flow 類型檢查器
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.coverage.inspection.name=Flow 不涵蓋程式碼
js.flowjs.coverage.inspection.error.text=Flow 不涵蓋此元素
js.flowjs.config.inspection.to.project.path.name=向專案根中添加 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中添加 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中添加 .flowconfig
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.flag.comment.placement.inspection.name=位置錯誤的 @flow 標記
js.flowjs.flag.comment.placement.inspection.error=Flow 標誌註釋不在檔案起始處
js.flowjs.flag.comment.placement.inspection.fix=將 Flow 標誌註釋移至檔案起始處
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 #ref 可能導致意外類型強制 #loc
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.options.label=高亮顯示 '==' 和 '!=' 的用法：
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=添加“use strict”雜註
js.strict.mode.inspection.redundant.pragma="use strict"雜註冗餘
js.strict.mode.remove.pragma=移除“use strict”雜註
js.class.member.initialization.inspection.name=在 static 初始設定式中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 引用本身
js.assignment.used.as.condition.name=用作條件的賦值
js.assignment.used.as.condition.text=<code>#ref</code> 作為條件使用
js.assignment.used.as.condition.fix=將 ''='' 取代為 ''{0}''
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case：{0}
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解開 'switch' 語句
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=創建缺少的預設分支
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時引用錯誤
js.variable.problems.ignore.desc=對可變變數忽略
js.inspection.package.json.dependencies=package.json 中的依賴關係不符合
js.inspection.missing.amd.dependency=缺少 AMD 模組依賴關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組依賴關係
typescript.narrowed.to=範圍限縮至 ''{0}''
label.exclude.methods.classes=排除類方法:
dialog.title.add.classes=添加類
typescript.suspicious.constructor.parameter.assignment=構造函數中的參數賦值可疑。您忘了添加  'this.' 嗎？
typescript.suspicious.constructor.parameter.assignment.desc=已分配構造函數欄位參數
typescript.abstract.class.constructor.can.be.made.protected=abstract 類構造函數可以設為 protected
typescript.make.constructor.protected=將構造函數設為 protected
typescript.private.field.modifiers.mix=使用私有名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為最終
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類成員使用 static 修飾符
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.template.context.type=JavaSc&ript 和 TypeScript
interface.should.have.no.variable.declarations=接口不應有變量宣告
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.class.name.expected.here=此處應為類名
javascript.validation.message.circular.dependency=迴圈依賴關係
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.fix.remove.circular.dependency=移除迴圈依賴關係
js.void.function.result.used.name=使用了 void 函數返回值
js.void.function.result.used.description=使用了 void 函數返回值

# JSDoc validation
javascript.validation.message.interface.method.not.implemented=未實作來自於接口 {1} 的方法 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類 {1} 的 abstract set 存取器 {0}
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}

javascript.validation.message.class.method.incompatible=''{1}'' 類中的方法 ''{0}'' 不可分配給基類 ''{2}'' 中的同一方法
javascript.validation.message.class.property.incompatible=''{1}'' 類中的屬性 ''{0}'' 不可分配給基類 ''{2}'' 中的同一屬性
javascript.validation.message.class.method.not.implemented=未實作類 {1} 的方法 {0}
javascript.validation.message.class.property.not.implemented=未實作類 {1} 的屬性 {0}
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的調用簽名
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回類型
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.modifier=移除修飾符
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.implement.all.interfaces=實作所有成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.implement.members.abstract=實作 abstract 成員

# Symbols
javascript.parameter=參數
javascript.local.variable=局部變數
javascript.global.variable=全域變數
javascript.global.function=全域函數
javascript.local.function=局部函數
javascript.global.decorator=裝飾器
javascript.static.member.function=static 成員函數
javascript.static.member.variable=static 成員變數
javascript.instance.member.variable=實例成員變數
javascript.instance.member.function=實例成員函數
javascript.create.class.intention.name=創建類 ''{0}''
javascript.create.interface.intention.name=創建接口 ‘’{0}''
choose.class.to.import.title=要匯入的類
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類的方法
javascript.parser.message.expected.gt=應為 >
javascript.parser.message.expected.lbracket=應為 [
javascript.parser.message.expected.readonly=應為 'readonly'
javascript.module.name=模組名稱
javascript.exported.variable=匯出的變數
javascript.exported.function=匯出的函數
javascript.exported.class=匯出的類
javascript.fix.create.function.component.jsx.name=創建函數組件 ''{0}''
javascript.fix.create.function.component.jsx.family=創建函數組件
javascript.fix.create.class.component.jsx.name=創建類組件 ''{0}''
javascript.fix.create.class.component.jsx.family=創建類組件
typescript.module.name=模組名稱
typescript.type.alias.name=類型別名
typescript.type.guard.name=變數類型限縮為類型防護
typescript.type.guard.name.disable=禁用範圍限縮的類型的著色
typescript.primitive.types.name=基元類型
typescript.type.parameter=類型參數
typescript.remove.type.declaration=移除類型宣告

generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.to.string.chooser.title=選擇要在 toString 函數中使用的欄位
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
no.candidates=無候選項
no.methods.to.implement=找不到要實作的方法
no.members.to.implement=找不到要實作的成員
implement.members.abstract=實作 abstract 成員
no.methods.to.override=找不到要覆寫的方法
no.members.to.override=找不到要覆寫的成員
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
javascript.validation.unused.import=未使用的 import
javascript.validation.fqn.to.replace.with.import=限定名稱可被取代為 import 語句
javascript.fix.optimize.imports=最佳化 import
javascript.parser.message.expected.doc.tag.value=應為標記值
javascript.parser.message.expected.doc.tag.name=應為文檔標籤名稱
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.initializer.type.mismatch=初始設定式類型 {1} 不可分配給變數類型 {0}
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.term.does.not.evaluate.to.function=方法表達式不是函數類型
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函數調用
javascript.term.does.not.evaluate.to.function.line.break=表達式不可調用。如果這不應是調用，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.vector.literal.element.type.mismatch=矢量文字元素類型 {1} 不可分配給類型 {0}
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.no.call.signatures=分配的類型不包含調用簽名
javascript.known.props.only=物件文字只能指定已知屬性，但以下為額外屬性：{0}
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.insert.cast.fix=插入轉換
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
typescript.insert.cast.fix=插入類型斷言
es6.insert.await.fix=插入 await
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
typescript.insert.type.guard.fix.family=插入類型防護
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
cannot.modify.library.code=無法修改庫或 SDK 程式碼
javascript.extract.method.title=提取函數
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.duplicate.catch.block=重複 catch 塊 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.return.statement.required=非無效返回類型必需具備 return 語句
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
javascript.validation.message.unresolved.component=未解析的組件 {0}
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類構造函數調用應位於構造函數本體中
javascript.fix.remove.constructor=移除構造函數
javascript.metadata=元資料
javascript.class=類
javascript.interface=接口
javascript.label=標籤
javascript.function.arrow=箭頭函數
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.constructor.cannot.be.static=構造函數不能為 static
javascript.create.event.handler.intention.name=創建事件處理程序 ''{0}''
javascript.validation.message.missed.super.constructor.call=缺少超類構造函數調用
javascript.validation.message.this.before.super.call=超類構造函數調用前不允許有 'this'
javascript.validation.message.baseMethod.before.super.call=超類構造函數調用前不允許有 'super'
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生構造函數中調用基類構造函數
javascript.fix.create.constructor.invoke.super=創建符合 super 的構造函數
javascript.fix.create.invoke.super=插入超類構造函數調用
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.abstract.class.can.not.be.instantiated.message=無法實例化 abstract 類
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有參數
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回類型不應為 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.destructuring.without.initializer=析構宣告必須有初始設定式
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類和類方法
javascript.fix.remove.namespace.reference=移除命名空間引用
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
javascript.fix.remove.type.reference=移除類型引用
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.initializer=移除初始設定式
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.fix.initialize.parameter=初始化參數
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
js.validate.types.inspection.name=類型不符合
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始設定式
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.duplicate.typescript.union.inspection.name=聯合或相交類型組件重複
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.fix.add=添加泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.types.any.inspection.name='any' 類型的類型不符合
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice, 0#false|1#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
javascript.validate.imports.name=未解析的已匯入名稱
es6.validate.import.error=無法解析符號 ''{0}''
es6.prefer.short.import.name=可以縮短匯入
typescript.reference.to.umd.global=已引用的 UMD 全域變數
typescript.field.can.be.made.readonly=可以為唯讀欄位
javascript.suspicious.type.guard.desc=類型防護檢查不健全
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.suspicious.typeof.guard=''typeof'' 檢查無效：''{0}'' 不能具有類型 ''{1}''
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘：''{0}'' 始終具有類型 ''{1}''
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false：{0}'' 始終具有類型 ''{1}''
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效：''{0}'' 的類型與 ''{1}'' 無關
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘：''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘：''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
javascript.object.is.null={0} 為 null
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.undefined={0} 未定義
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.missing.augmentation.import=缺少增強匯入
typescript.explicit.member.type.inspection.name=顯式類型
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.config.options.fix=向 tsconfig.json 中添加 ''{0}''
typescript.config.inspection.fix.pattern=添加 ''{0}'' 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
typescript.specify.type.explicitly=顯式指定類型
typescript.specify.type.explicitly.from.hint=添加顯式類型註解
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.all.param.types.explicitly.from.hint=向所有參數中添加顯式類型註解
typescript.make.field.readonly=將欄位設為唯讀
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
js.validate.signature.inspection.name=簽名不符合
find.usages.of.base.interface={1} 的方法 {0}\n實作 {2} 的方法。\n要{3}基方法嗎?
find.usages.of.base.class={1} 的方法 {0}\n覆寫 {2} 的方法。\n要{3}基方法嗎?
javascript.fix.visibility.family=修復可見性問題
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.label.visibility.public=公共 (&B)
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
move.members.refactoring.name=移動成員
move.members.dialog.title=移動成員
class.0.cannot.be.created=無法創建目標類 {0}，因為存在同名的限定元素
# Used in JSFormatUtil.formatVisibility
javascript.visibility.public=public
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
entity.in.parent.description={0} ({1} 內)
package.description=軟體套件 {0}
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取

# Refactoring
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在賦值的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.inline.function.title=內聯函數
javascript.refactoring.cannot.find.usages.of.definition.to.inline=無法找到要內聯的定義的用法.
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的析構變數
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯析構 rest 變數
javascript.inline.element.is.not.used={0} 從未使用
javascript.refactoring.inline.dialog.title=內聯 {0}
javascript.refactoring.inline.all.message=內聯所有引用並移除 {0} ({1}) (&A)
javascript.refactoring.inline.this.only=僅內聯此引用並保留 {0}(&K)
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函數
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯引用實參的函數
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函數引用的 rest 參數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞歸函數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個退出點的函數
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式評估
javascript.refactoring.cannot.inline.constructor=無法內聯構造函數
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.function.to.es6.class.command=將函數 {0} 轉換為類
js.convert.to.es6.class=轉換為類
js.convert.to.es6.class.family.name=將函數及其成員宣告轉換為類
js.move.type.to.file.family=移至名稱符合的檔案
js.create.derived.type.family=創建派生類/實作接口
js.create.derived.type.class=創建派生類
js.create.switch.cases=創建缺少的 'switch' 分支
js.create.switch.cases.fix=創建缺少的分支：{0}
js.edit.object.literal=編輯物件文字屬性的值
js.create.derived.type.interface=實作接口
js.create.derived.type.abstract.class=實作 abstract 類
js.rename.file.to.match.type.name.family=重命名檔案以符合類型名稱
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.move.type.to.file.text=將 {0} 移至檔案 {1}
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告：將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”創建的屬性轉換為 ES6 語法可能會影響其可枚舉性和可設定性
rename.destructuring.property.title=重命名析構屬性
rename.destructuring.property.description=析構屬性引用多個成員。應重命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合、相交或映射類型用法。應重命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.destructuring.description=檢測到析構屬性中的用法。應重命名相關屬性，否則可能導致程式碼不一致。
make.private=設為 private
choose.destination.scope=選擇目標範圍
list.item.function.to.be.converted.to.class=要轉換為類的函數
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類成員的函數成員的宣告
tab.title.convert.to.class=轉換為類
tab.title.refactoring.preview=重構預覽
list.item.function.converted.to.class=轉換為類的函數
list.item.declarations.that.were.not.converted=未轉換的宣告
tab.title.refactoring.result=重構結果
extract.method.declare.static=宣告靜態 (&S)
extract.function.declare.functional.expression=宣告函數表達式(&F)
extract.function.return.type=返回類型(&T):
extract.function.parameters=參數
extract.function.signature.preview=簽名預覽
extract.function.function=函數
extract.function.name=名稱(&N):
extract.constant.type=類型(&T):
introduce.constant.target.class=目標類(&A):
introduce.field.type=類型(&T):
introduce.field.initialize.in=初始化位置
introduce.field.declaration=欄位宣告(&D)
introduce.field.current.method=當前方法(&M)
introduce.field.class.constructor=類構造函數(&C)
introduce.parameter.type=類型(&T):
introduce.parameter.optional=可選參數(&O)
introduce.variable.declaration=變數宣告
introduce.variable.const=const(&C)
introduce.variable.let=let(&L)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T):
introduce.variable.make.constant=設為常數(&C)
custom.template.variables=自訂模板變數(&C):

# Destructuring
javascript.find.usages.destructuring.target.dialog=速記析構變數使用 {0} 初始化。\n您想尋找哪些用法?
javascript.destructuring.initializer=初始設定式 {0}
javascript.destructuring.variable.only=僅析構變數
javascript.rename.destructuring.target.dialog.title=速記析構變數使用 {0} 初始化
javascript.rename.choose.target.message=您要重命名哪一個？
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.shorthand.property.description=屬性
javascript.rename.file.with.related.title=重命名檔案
javascript.rename.containing.file.message=是否也想將檔案及其用法重命名為 {0}?
javascript.rename.related.declaration.message=是否想將 {0} 及其用法重命名為 {1}?
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\n匯入和匯出中的用法、字串用法或動態引用無法取代為析構。
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的析構模式
dialog.message.unsupported.destructuring.container=不支持的析構容器: {0}
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\n無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列析構模式
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列析構不支持轉換多個嵌套模式

javascript.refactoring.asdoc.for.abstracts=摘要的 ASDoc
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函數宣告
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類宣告
javascript.illegal.variable.type.void=非法變數類型：'void'
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函數返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
javascript.kind.unknown=未知元素
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 #loc
js.unnecessary.semicolon.fix.name=移除不必要的分號
javascript.refactoring.extract.function.title=提取函數
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個退出點
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函數
javascript.refactoring.extract.function.already.exists.in.this.scope=此範圍中已存在 {0}
javascript.validation.message.constructor.cannot.have.custom.visibility=構造函數應為 public 或未指定可見性
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫 final 方法
top.level.package=頂層軟體套件
javascript.parser.message.expected.dot=應為 .
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較始終評估為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較始終評估為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(...)
js.constructor.returns.primitive.inspection.name=構造函數返回基元值
js.constructor.returns.primitive.inspection.problem=使用 'new' 調用時從構造函數返回的基元值將丟失
js.constructor.returns.primitive.inspection.quickfix=返回類型顯式設定為 {0}
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函數簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函數簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋

livetemplate.description.fori=創建迭代迴圈
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.ritar=以相反順序遍歷陣列的元素
livetemplate.description.us=插入 'use strict' 語句
livetemplate.description.ref=插入引用路徑註釋
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.moduleexports=匯出語句 - module.exports = a
livetemplate.description.arf=使用箭頭函數環繞

livetemplate.description.console.log=console.log()
livetemplate.description.console.warn=console.warn()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.assert=console.assert()

postfix.template.provider.name=JavaScript 和 TypeScript
postfix.template.condition.non.void.name=非 Void
postfix.template.condition.array.name=陣列

macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)

# Line markers
linemarker.implements.invalid=<無效>
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.implements.several=實作多種接口方法
linemarker.overridden=覆寫
linemarker.implemented=已實作
linemarker.overriding=覆寫
linemarker.implementing=實作
linemarker.javascript.typescript=JavaScript/TypeScript 行標記

js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的引用
javascript.expected.class.or.descendant=應為類 {0} 或後代
javascript.qualified.class.name.expected=應為限定的類名
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.set.method.type.is.different.from.getter=set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646：Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646：Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.fix.create.parameter=創建參數 ''{0}''
javascript.introduce.parameter.introduced.variable.value=值(&V):
0.is.not.a.legal.name=''{0}'' 不是合法的類名
item.already.exists={0} {1} 已存在
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
extract.subclass.command.name=從 {1} 提取子類 {0}
extract.interface.command.name=提取接口
extract.type.alias.command.name=提取類型別名
new.actionscript.class.dialog.title=新建 ActionScript 類
new.actionscript.interface.dialog.title=新建 ActionScript 接口
class.template.title=類
class.with.supers.template.title=包含 Super 的類
interface.template.title=接口
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 組件中提取超類。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回類型更改為預期類型
js.last.comma.in.array.literal.inspection.name=陣列文字中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件文字中的最後一個逗號多餘
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\n是否繼續？
return.type.is.not.resolved=返回類型 ''{0}'' 未解析。\n是否繼續？
change.signature.column.name.initializer=初始設定式
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.call.value=調用中的值
change.signature.parameter.table.empty.message=使用  '+' 按鈕添加新參數
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已添加。\n指定要用於此方法的所有現有調用的預設值。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已添加。\n指定要用於此方法的所有現有調用的預設值或值。
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用調用中的值。因為沒有為前面的參數指定它。
change.signature.usage.view.declarations.header=要重構的方法
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
invalid.return.type.expression=返回類型 ''{0}'' 無效
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
type.is.not.resolved=類型 ''{0}'' 未解析。\n是否繼續？
invalid.field.type.expression=無效欄位類型：''{0}''
choose.field.type=選擇欄位類型
new.field.action.text=欄位
new.field.action.description=在類中創建新字段
create.field.dialog.title=創建欄位
field.initializer.is.not.specified=未指定欄位初始設定式
new.method.action.text=方法
new.method.action.description=在類中創建新方法
create.method.dialog.title=創建方法
create.button.text=創建(&C)
class.already.contains.method.warning=類 ''{0}''''已經 {1, choice, 1# 包含|2#繼承] 方法 ''{2}()''。\n是否繼續？
class.already.contains.field.warning=類 ''{0}'' 已包含欄位 ''{1}''。\n是否繼續？
declare.static=宣告 static(&S)
new.constructor.action.text=構造函數
new.constructor.action.description=創建構造函數
create.constructor.dialog.title=創建構造函數
change.method.signature.fix.text=更改 {0} 簽名
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 調用和更新調用
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 調用和更新調用
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託調用

# Settings
settings.javascript.root.configurable.name=JavaScript
settings.typescript.root.configurable.name=TypeScript
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.autodetect.disabled=禁用 {0}(&D)
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 設定 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父資料夾位於同一資料夾中的 {2} 設定檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 設定 (&M)
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選鏈接的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.field.names.completion=為類欄位建議名稱 (&F)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.types=為建議的參數名稱添加類型註解(&T)
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types.for.params=具有函數參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.lang.templates.configurable.name=模板
es6.auto.import.options.completion.add.imports=在程式碼補全時添加 ES6 匯入
es6.auto.import.options.title=TypeScript / JavaScript
typescript.auto.import.options.add.imports=自動添加 TypeScript 匯入
typescript.auto.import.options.add.imports.on.the.fly=動態明確 import
typescript.auto.import.options.add.on.code.completion=程式碼補全
typescript.auto.import.options.show.popup=包含自動匯入工具提示
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入（Node 樣式模組解析）
js.import.options.use.explicit.js.extension=使用檔案副檔名:
js.add.members.to.type.desc=將成員添加到類或接口
js.add.members.to.type=將成員 {0} 添加到 ''{1}''
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對匯入排序
es6.import.options.paths=使用路徑別名：
es6.import.options.paths.help=This option configures the style of paths used in the import statements.<br><br>With "Always", the IDE always uses aliases from webpack, vite, or jsconfig.json configuration.<br><br>With "Only in files outside specified paths", the IDE uses relative paths for imports between the files for which an alias is defined. In all other files, path mappings are used. <br><br>With "Never", aliases are never used.
typescipt.import.options.paths.help=This option configures the style of paths used in the import statements.<br><br>With "Always", the IDE always uses aliases from tsconfig.json configuration. <br><br>With "Only" in files outside specified paths, the IDE uses relative paths for imports between the files for which an alias is defined. In all other files, path mappings are used.<br><br>With "Never", aliases are never used.
typescript.import.options.paths=使用 tsconfig.json 的路徑映射：
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
javascript.import.options.use.resource.root=使用相對於專案、資源或源根目錄的路徑
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F)：
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.services.label=為之使用 Flow 伺服器：
js.flow.enable.type.checking=類型檢查
js.flow.enable.other.services=導航、程式碼補全和類型提示
js.flow.enable.flow.service.error=\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯：{0}
js.flow.enable.flow.service.error.message={0}。禁用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning=只有儲存其他所有修改過的檔案時，Flow 才會檢查當前檔案。
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.caption=
js.dialect.settings.tableTitle=語言
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本？
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.empty.text=使用 + 按鈕添加目錄，並選擇 JavaScript 版本
js.dialects.customized.label=根據目錄自定義
configure.code.completion.settings=設定程式碼補全設定

# Bower
settings.javascript.bower.configurable.name=Bower
bower.packages.view.dependencies=依賴項:
bower.package=Bower 軟體套件(&B):
bower.json=bower.json (&O)：
bower.correct.path=請更正 {0} 的路徑
bower.package.name=Bower 軟體套件
bower.dialog.message.specify.package=指定正確的 bower 軟體套件: 未找到 "{0}" 檔案
bower.required.version.notification.content=要查看 bower 軟體套件，您需要 bower@1.0.0 或更高版本
bower.no_description_available.text=無可用描述
dialog.message.command.timed.out=指令 ''{0}'' 超時
dialog.message.command.cancelled=指令 ''{0}'' 已取消
dialog.message.command.finished.with.exit.code=指令 ''{0}'' 已完成，退出程式碼為 {1}。Stdout:\n{2}\n\nstderr:\n{3}

# JS language version management
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=已棄用特定於 Firefox 的 ECMAScript 實作。請考慮切換。
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015+、一些提案和 JSX
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java 中的 JavaScript 實作
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=ECMAScript 6 中的 Flow 和 JSX
js.language.version.label=JavaScript 語言版本
js.switch.to.jsx.inspection.dismiss=關閉
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.language.level.family=更改 JavaScript 語言版本

# JS library management
js.library.attach.debug=附加偵錯版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.unresolved.url.inspection.name=HTTP 鏈接缺少本地存儲的庫
js.library.download.fix=下載庫
js.library.downloading.library=正在下載庫
js.library.documentation=文檔
js.library.configurable.name=庫
js.library.download.stubs.label=TypeScript 社區存根
js.library.successfully.downloaded=已成功下載 {0}

choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法（找到 {1}）</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函數（找到 {1}）</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位（找到 {1}）</body></html>
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類或接口（找到 {1}）</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類（找到 {1}）</body></html>
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作（找到 {1}）</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
javascript.parser.message.expected.newline.or.semicolon=需要換行符或分號
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位引用
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中引用 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許引用 'arguments' 函數屬性
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制文字。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制文字已過時，不建議使用
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制文字
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制文字的警告
javascript.validation.message.only.one.default.is.allowed=\ switch 中只允許一個預設子句
javascript.fix.remove.default=移除預設子句
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函數中
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函數的頂層使用函數語句
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
choose.super.class.title=選擇超類
choose.base.component.title=選擇超類
choose.super.interface.title=選擇 Super 接口
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
javascript.constructor.call.without.new.message=沒有 new 的構造函數調用
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 #loc
javascript.element.is.not.accessible.message=元素不可存取 #loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.protected.constructor.is.not.accessible.message=protected 構造函數不可存取 #loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.export.only.member=元素僅匯出
javascript.private.constructor.is.not.accessible.message=private 構造函數不可存取 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.static.member.is.not.accessible.message=static 成員不可存取 #loc
javascript.instance.member.is.not.accessible.message=實例成員不可存取 #loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.member.from.unopened.namespace.message=未開啟命名空間的成員 #loc
javascript.property.is.read.only.message=唯讀屬性 #loc
javascript.property.is.write.only.message=只寫屬性 #loc
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函數是構造函數
javascript.not.a.constructor.call.message=不是構造函數調用
cannot.refactor.anonymous.function=現有非調用用法阻止調用站點分析。
change.signature.method.references.arguments=函數引用實參，更改簽名後代碼可能會中斷
change.signature.call.expression.contains.spreads=函數調用包含傳播實參。用法將保持不變。
change.signature.tagged.template.issue=無法更新標記的模板調用。用法將保持不變。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
javascript.missed.argument.for.parameter=參數 {0} 缺少實參

# Code folding settings
checkbox.collapse.object.literals=物件文字
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函數
checkbox.collapse.array.literals=陣列文字
checkbox.collapse.xml.literals=XML 文字
change.signature.value.column.title=值
change.signature.column.name.optional.flag=可選
change.signature.column.name.modifier=修飾符

# Flow general
js.flow.all.servers.action.restart=重啟所有 Flow 伺服器
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行高亮顯示
flow.js.get.type=Flow JS:Get 類型
flow.show.error.details=顯示錯誤詳情
can.t.find.flow.executable=找不到 Flow 可執行檔案
process.terminated=行程已終止
progress.text.modifying=正在修改 {0}
progress.text.initializing.opened.files=正在初始化開啟的檔案

# Code style settings
js.code.style.punctuation.tab.title=標點
space.before.name.value.separator=在屬性名稱-值分隔符 ':' 前面
space.after.name.value.separator=在屬性名稱-值分隔符 ':' 後面
space.before.function.left.parenth=在函數表達式中
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '...' 後面
space.after.dots.in.rest.spread=在 rest/spread 中的 '...' 後面
space.before.generator.mult=在生成器中的 '*' 前面 
space.after.generator.mult=在生成器中的 '*' 後面 
spaces.within.object.type.braces=物件文字類型大括號
space.before.type.colon=在類型引用冒號 ':' 前面
space.after.type.colon=在類型引用冒號 ':' 後面
space.before.class.lbrace=類的左大括號
space.before.class.interface.module.lbrace=類/接口/模組左大括號
spaces.within.object.literal.braces=物件文字大括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.array.initializer=陣列中括號
spaces.within.union.and.intersection=聯合和相交類型
spaces.within.type.assertion=類型斷言
spaces.arrow.function=箭頭函數(=>)
spaces.async.arrow.function=在異步箭頭函數中
spaces.within.interpolation.expressions=插值表達式
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.after.unary.not=在 'not' (!) 和 '!!' 後面
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
js.blank.lines.around.method=環繞方法:
js.blank.lines.around.function=Around 函數：
js.spaces.in.flow.category=在 Flow 中
js.wrap.settings.import=ES6 匯入/匯出
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.function.call.parentheses=函數調用括號
js.function.declaration.parentheses=函數宣告括號
js.function.brace.style=在函數宣告中
js.function.expression.brace.style=在函數表達式中
js.function.parameters.wrap=函數宣告參數
js.function.call.wrap=函數調用實參
js.space.before.function.left.brace=函數左大括號
js.format.cstyle.comments=對齊多行
js.chained.call.dot.on.next.line='.' 在新行
js.generated.use.public.modifier=使用 'public' 修飾符
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.explicit.types=此項的首選顯式類型：
js.generated.explicit.var.types=變數和欄位
js.generated.explicit.return.types=函數宣告返回
js.generated.explicit.return.expression.types=函數表達式返回
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時添加
js.extends.list.wrap=Extends 列表
js.align.multiline.extends.list=多行時對齊
js.extends.keyword.wrap=擴展關鍵字
js.wrap.settings.union.and.intersection.types=聯合和相交類型
js.code.style.object.literals.category.name=物件
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.wrap.settings.var.group.name=變數宣告
js.code.style.do.not.align.var.statement=不對齊
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中

js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
make.method.static=設為 'static'
typescript.fix.change.member.access=設為 ''{0}''
js.fix.change.member.access.to.sharp=使用 '#' 設為 private
declare.event.0=宣告事件 ''{0}''
js.variable.might.not.been.initialized=變數可能尚未初始化 #loc
js.variable.initializer.is.redundant=變數初始設定式冗餘 #loc
js.value.assigned.is.never.used=從未使用過所賦之值 #loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 #loc
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
change.signature.dialog.title=更改 {0} 的簽名
javascript.fix.add.enum.values=添加枚舉值
javascript.fix.add.string.enum.values=添加字串枚舉值
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.implement.family=在派生類中實作
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.chooser.all=所有類
javascript.fix.implement=實作 {0}
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.report.unused.properties=報告未使用的屬性
javascript.report.unused.definitions=報告未使用的定義
javascript.check.global.definitions=檢查全域範圍內的賦值
javascript.strictly.check.global.vars=將未宣告的全域變數報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.strictly.check.global.functions=將未宣告的全域函數報告為錯誤
change.signature.column.type=類型
change.signature.column.name=名稱
javascript.invalid.invoker.target=無效調用目標
js.declarations.at.scope.start.inspection='var' 未在函數開頭宣告
js.make.single.var.statement=設為單變數語句
js.declaration.is.not.at.scope.start=var 語句不在範圍開始
js.move.to.scope.start=將 var 語句移至範圍開始
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.replace.with.literal=取代為 {0} 文字
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號：{0}</html>
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號：{0}</html>

element.name.anonymous=<anonymous>
element.name.default=<預設>
duplicate.parameter.name=重複的參數名稱: {0}
rename.accessors.dialog.title=重命名欄位
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''？
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=添加 this 限定符
insert.class.fix.name=添加類名限定符
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
superclass.label.text=超類(&S):
varible.name.column.title=名稱
varible.value.column.title=值
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C)：
create.class.ok.button.text=創建
create.class.name.label=名稱(&N):
create.class.package.label=軟體套件:
create.class.template.label=模板(&T):
create.class.superclass.label=超類(&S):
create.class.interfaces.label=接口(&I):
action.structureview.show.object.inherited=從物件繼承

# JSHint
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.clear.field.to.disable=清除要禁用的欄位
jshint.illegal.integer=非法整數
jshint.use.config.files=使用設定檔案
jshint.version.label=版本(&V):
jshint.label.bundled.suffix=(捆綁)
jshint.tree.link.set=設定
jshint.label.no.version=無版本
jshint.exception.balloon.action.retry=<a href=''{0}''>重試</a>
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>設定 HTTP 代理</a>或<a href=''{1}''>重試</a>
filetype.jshint.config.description=JSHint 設定
filetype.jshint.config.display.name=JSHint 設定
jshint.suppress.text.suppress.for.line=禁止行
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.config.option.default.name=預設
jshint.config.default.description=<div style="padding-bottom:10px"><div><b>.jshintrc</b></div><div style="padding-left:10px; padding-top:4px;">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的資料夾開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style="padding-left:10px; padding-top:4px;">將您的設定添加到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.option.custom.name=自訂設定檔案
jshint.config.option.custom.browser.title=選擇 JSHint 設定檔案 （*.jshintrc）
jshint.config.failed.to.read=無法讀取 JSHint 設定
jshint.config.extends.cyclically=JSHint 設定迴圈擴展
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.error.cannot.locate.ext.config=JSHint: 無法定位擴展設定
jshint.config.error.cannot.parse.ext.config=JSHint: 無法解析擴展設定
jshint.latedef.false.text=不警告
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函數宣告。</body></html>
jshint.unused.false.text=不檢查任何內容
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函數參數
jshint.unused.strict.text=檢查所有變量和參數
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title=JSHint {0}
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.double.text=僅允許雙引號
jshint.inspection.message.duplicate.options=重複 JSHint 選項: {0}，{1}。
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.inspection.message.expected.values.x.or.y=預期值: {0} 或 {1}
jshint.inspection.message.expected.value=預期值: {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.config.not.found=未找到 JSHint 設定
jshint.inspection.message.malformed.config=JSHint 設定格式錯誤
jshint.inspection.message.prefix=JSHint:

jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.indent.description.short=縮排
jshint.option.quotmark.description.short=引號
jshint.option.predef.details=指定全域變數及其可分配狀態:\n<pre>DISQUS:true、jQuery:false</pre>\n<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的設定時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.immed.description.short=有關未使用括號將函數括起來而直接調用函數的警告
jshint.option.newcap.description.short=有關使用非大寫形式的構造函數的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nonbsp.description.short=有關“不間斷空格”字符的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.maxparams.description.short=函數中的最大參數數量
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxstatements.description.short=函數中的最大語句數量
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxlen.description.short=行的最大長度
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部賦值的警告
jshint.option.debug.description.short=禁止有關偵錯模式的警告
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.eqnull.description.short=禁止有關 <code>== null</code> 的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函數在迴圈內部的警告
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”構造的警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.noyield.description.short=禁止在生成器函數中無 yield 語句時有關生成器函數的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.devel.description.short=開發
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.typed.description.short=輸入的陣列
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.onevar.description.short=每個函數一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.predef.description.short=預定義(以 , 分隔)

# common linters
javascript.linter.import.error.timeout.processing.configuration.file=處理設定檔案時超時
javascript.linter.import.error.generic=套用設定檔案中的程式碼樣式規則時出錯，可能是設定檔案無效。
javascript.linter.import.error.package.not.found=無法找到 ''{0}'' 軟體套件
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.notification={0}：專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.rules.applied=套用了以下 {0}：{1}。
javascript.linter.import.notification.reset=重置
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已恢復
javascript.linter.import.translate.config.title=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.description=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.nothing.to.import={0}：已套用所有已知規則
javascript.linter.use.severity.from.config.label=使用設定檔案中的規則嚴重性
javascript.linter.configuration.file.title=設定檔案
javascript.linter.radio.button.configuration.file=設定檔案(&C):
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.no.such.file=沒有此類檔案
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.can.not.find.psi.file=無法找到 {0} 的 PSI 檔案
javascript.linter.error.can.not.find.document=無法找到 {0} 的文檔
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題:<br/>{1}
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
dialog.message.please.specify.stylelint.package.correctly=正確指定 Stylelint 軟體套件: 找不到 Stylelint 二進制檔案
stylelint.action.fix.problems.description=通過調用 'stylelint --fix' 修正 Stylelint 問題
stylelint.action.modal.title=Stylelint 修正
stylelint.action.background.title=正在執行 stylelint --fix…

javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.prompt=使用 {0} 重新格式化選定的檔案?
javascript.linter.action.fix.problems.file.text={0}：修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.progress.reformatting.with=正在使用 {0} 重新格式化…

javascript.linter.intention.name.details=詳細資訊
javascript.linter.intention.family.name.show.details={0}: 顯示詳細資訊

# eslint
settings.javascript.linters.eslint.configurable.name=ESLint
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E)：
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style="padding-top:8px">要使用 package.json，請將您的設定添加到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.label.working.directories=工作目錄(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=<html>路徑或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。</html>
eslint.configurable.config.select.config.text=選擇 ESLint 設定檔案（*.eslintrc.*）
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R)：
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O)：
eslint.run.for.files.label=為檔案執行(&F):
eslint.files.pattern.comment=<html>使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如，<code>{**/*,*}.{js,ts}</code></html>
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.action.fix.problems.description=通過調用 'eslint --fix' 修正 ESLint 問題
eslint.fix.problems.text.with.error.code={0}: 修復 ''{1}''
eslint.fix.problems.text.current={0}: 修復當前錯誤
eslint.fix.problems.family.name={0}: 修復當前錯誤
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.dismiss.text=否
eslint.code.style.apply.text=是
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.configuration.file.field.name=ESLint 設定檔案
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重程度: {0}\n主體:\n{1}

# standardJS
standardjs.name=標準程式碼樣式
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式？
standardjs.editor.notification.action=是
standardjs.editor.notification.do.not.show.text=否
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.codestyle.updated={0}: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 依賴項更新

# Actions
js.show.type.info.action.error=找不到表達式
javascript.ignore.unused.function.parameters=忽略未使用的參數:
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
remove.type.prefix=移除類型前綴
add.import.binding.to.import=將匯入綁定添加到匯入
add.import.specifier.to.import=將匯入說明符添加到匯入
create.js.file.description=從指定的模板創建 JavaScript 檔案
create.ts.file.description=創建新的 TypeScript 檔案
create.file.name=創建檔案 ''{0}''
create.file.name.with=使用 {1} 創建檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 創建檔案 ''{0}''
class.names={0,choice,1#類|2#類} {1}
function.names={1}{0,choice,1#函數|2#函數} 

# todo remove, has external usages
javascript.completion.several.definitions=（多個定義）

# File watchers
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉成 ECMAScript 5
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?

# Annotator
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的賦值
typescript.type.predicate.not.return=僅函數和方法的返回類型位置允許類型謂詞
typescript.type.this.predicate.not.return=僅類或接口成員、get 存取器或函數和方法的返回類型位置允許基於 'this' 類型的謂詞。
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.rest=類型謂詞不能引用 rest 參數
typescript.type.predicate.destructuring=類型謂詞不能引用綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
js.annotator.assignment.pattern.rhs=賦值模式必須位於賦值的左側
es6.generate.index.action=生成 index.js/index.ts
es6.generate.index.action.description=生成 index.js/index.ts
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議添加括號以解決歧義問題。

# Live templates
jsx.html.context.type=JSX HTML
js.expression.context.type=表達式
js.statement.context.type=語句
js.top.level.statement.context.type=頂級語句
js.class.context.type=類/接口
ecmascript.6.or.higher=ECMAScript 6 或更高版本

# Gulp
gulp.rc.gulpfile.label=Gulpfile (&F)：
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.tasks.label=任務(&T):
gulp.rc.arguments.label=參數 (&R)：
gulp.rc.nodeInterpreter.label=節點解釋器(&I):
gulp.rc.nodeOptions.label=節點選項(&O):
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G)：
gulp.rc.environmentVariables.label=環境(&E):
gulp.task.title=Gulp 任務
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.gulpfile.not.found=未找到 Gulpfile

# Grunt
grunt.rc.gruntfile.label=Gruntfile (&F)：
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.tasks.label=任務(&T):
grunt.rc.arguments.label=參數 (&R)：
grunt.rc.nodeInterpreter.label=Node 解釋器(&I):
grunt.rc.nodeOptions.label=節點選項(&O):
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P)：
grunt.rc.environmentVariables.label=環境(&E):
grunt.task.title=Grunt 任務
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
grunt.unspecified.gruntfile=未指定 Gruntfile
grunt.gruntfile.not.found=未找到 Gruntfile

# node
settings.nodejs.name=Node.js
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A)：
settings.nodejs.coding.assistance.manage.scopes.label=管理範圍…

node.interpreter.label=節點解釋器(&I):
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.package.manager.label=軟體套件管理器 (&M)：
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.multiple.packages.description=選擇 {0}
node.package.none=無軟體套件
node.package.dropDownList.select=選擇…

inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼協助已禁用
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=切換 Node.js 的編碼輔助

# npm
npm.rc.packageJson.label=package.json (&P)：
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.command.label=指令:(&C)
npm.rc.scripts.label=腳本 (&T)：
npm.rc.scriptsArguments.label=參數 (&R)：
npm.rc.nodeInterpreter.label=Node 解釋器(&I):
npm.rc.nodeOptions.label=節點選項：
npm.rc.environmentVariables.label=環境:
npm.task.title=NPM 腳本
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice, 0#腳本|1#腳本|2#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.no.scripts.found=未找到腳本
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件: 無此類目錄
dialog.message.invalid.npx.command=無效的 npx 指令
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件: Yarn 安裝的軟體套件格式為 ''yarn:[package.json 的相對路徑]:[軟體套件名稱]''。
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.unspecified.package.name=未指定軟體套件名稱。
enable.notifications.about.installing.dependencies.from.package.json=啟用有關從 package.json 安裝依賴項的通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知

# Build tools
buildTools.JsbtRunTaskAction.text=執行 Gulp/Grunt/npm 任務
buildTools.JsbtAddBuildfileAction.text=添加 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.searchEverywhere.text=執行 ''{0}'' 任務
buildTools.searchEverywhere.npm.text=執行 ''{0}'' npm 腳本
buildTools.ShowSettingsAction.text={0}設定…
buildTools.ShowSettingsAction.npm.text=編輯 npm 設定(&E)…
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.tree.sortBy.text=排序方式
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.no.tasks.found=未找到任務
buildTools.edit.run.configuration=編輯執行設定
buildTools.no.files.added=未添加檔案
buildTools.add.with=使用 {1} 添加 {0}
buildTools.no.such.file=沒有此類檔案
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊

# npm modules
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 依賴關係中未列出模組
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
package.json.install.types.fix.family.name=為軟體套件安裝 @types
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發依賴關係
node.js.quickfix.install.node.module.text=安裝 ‘’{0}''
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發依賴關係
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.run.command=執行 ''{0}''
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組：{0}
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組：請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.select.file=選擇 {0} 檔案
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
action.InstallNodeLocalDependencies.text=安裝 Node.js 依賴項
action.InstallNodeLocalDependencies$Root.text=為 {1} 執行 ''{0}''

typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
npm.modules.install.global.types.directory.error=無法創建所需的目錄
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義

typescript.types.union=聯合
typescript.types.intersection=相交
typescript.types.mapped=映射
typescript.types.key=鍵引用
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.type.member={0} 類型屬性
typescript.types.merged.parts=引用的屬性：

# Intentions
ts.generate.reference.path.name=生成引用路徑註釋
ts.add.import.statement.family.name=添加 import 語句
ts.add.import.statement.dialog.title=添加 import 語句
ts.add.import.all.family.name=添加所有明確的匯入
ts.add.import.hint.text=使用 {1} 添加 {0}
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 添加匯入
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.change.import.action.one.title=更改為 {0}
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.command=更改匯入
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.dialog.title=匯入自…
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
anonymous.to.named.intention.function.name=函數名稱：
initialize.fields.intention.visibility=可見性:
command.name.import=匯入 {0}
please.specify.package.manager=指定<a href="">軟體套件管理器</a>。
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 添加到 tsconfig.json
intention.name.import.augmentation=匯入增強 {0}

# Language Service
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.tracking.disabled=錯誤跟踪已禁用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.service.default.project.errors=顯示專案錯誤
javascript.service.node.error=Node 解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.start.timeout=啟動語言服務行程超時
javascript.language.service.cannot.start=無法啟動語言服務行程
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\n
tab.title.errors=錯誤
tab.title.project.errors=專案錯誤
tab.title.compile.errors=編譯錯誤
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
intention.name.loading.service.fixes=正在載入服務修正…

# TypeScript Compiler
typescript.compiler.notification.editor.configure=設定 TypeScript…
typescript.compiler.configurable.name=TypeScript
typescript.use.service.configurable.options.enable=TypeScript 語言服務
typescript.compiler.configurable.options.output.path=使用輸出路徑：
typescript.compiler.configurable.options.compile.main=僅編譯主檔案：
typescript.compiler.configurable.options.compile.main.error=主檔案的路徑不正確
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.generate.source.map=生成源映射
typescript.compiler.configurable.options.enable.no.config=也針對沒有 tsconfig.json 的專案
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.scope=編譯範圍：
typescript.compiler.configurable.options.command.line=選項:
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。設定檔案不正確。
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
typescript.compiler.structure.tab.title=結構
typescript.compiler.starting=TypeScript 正在啟動…

typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案引用


js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=查看所有 {0} 個錯誤
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.service.action.restart=重啟{0}
typescript.compiler.action.compile.all.compile.config=設定 {0} 的編譯檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案引用
typescript.compiler.before.run=編譯 TypeScript

typescript.language.service.clean=正在重置快取…
typescript.language.service.compile.file=正在編譯檔案... {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤... {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤... {0}
typescript.language.service.compile.project.open.file=正在開啟檔案... {0}

typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.path=設定檔案：
typescript.before.task.title=TypeScript 編譯設定
typescript.before.task.config.dialog.title=選擇 tsconfig.json

# Documentation
js.documentation.fires=觸發：
js.documentation.more.overload=其他 {0} 個多載
js.documentation.more.overloads=其他 {0} 個多載

node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器延伸模組。請啟用 {0} 中的延伸模組

# Module Dependencies
javascript.module.dependencies.got.it.title=模組依賴關係圖
javascript.module.dependencies.got.it.text=<div align='left'>此圖顯示所選檔案或目錄具有的模組依賴關係。<br/>要查看多個檔案或目錄的依賴關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.empty.got.it.text=<div align='left'>當前檔案或資料夾沒有任何依賴關係。<br/>請嘗試使用其他檔案或資料夾。</div>
modules.selected=選定

js.remove.redundant.initializer.fix=移除冗餘的初始設定式
js.remove.unused.assignment=移除未使用的賦值
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inject.dont.format.intention.text=禁用注入內容的格式設定


js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}：''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}：''{1}'' 位於 package.json 中。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}：設定檔案位於專案中。
js.linter.guesser.linter.disabled={0} 已禁用。

# Breadcrumbs
js.breadcrumbs.callback.for=\ {0}() 回調

typescript.extract.type.alias.name=類型別名…
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串插值
typescript.include.js.sources.action=包括 JavaScript 檔案
escape.pasted.text=在貼上字串文字時轉義文本
jsx.convert.html.attributes.to.jsx=將 HTML 貼上到 JSX 檔案時轉換特性

# Rename member
rename.prompt.do.you.want.to.rename.base.method=要重命名基方法嗎?
js.rename.base.member=重命名基{0}
js.rename.current.member=重命名當前 {0}
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫

# Generate dialog
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.filter.fields=欄位和屬性
generate.filter.button.tooltip=顯示 {0}
generate.filter.button.description=在列表中顯示 {0} 
codestyle.ui.field.prefix=欄位前綴 (&F)：
codestyle.ui.property.prefix=屬性前綴 (&P)：
codestyle.ui.file.name.style=檔案命名約定 (&N)：
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
inline.cannot.inline.references.this.type=無法內聯引用 'this' 類型的接口
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
generation.bindable.event=可綁定事件(&B):
generation.event.constant=事件常數(&E):

refactoring.extract.react.component.component.for.refactor.this=提取組件…
refactoring.extract.react.component.title=提取組件
refactoring.extract.react.component.no.expression=所選內容不構成 JSX 表達式
refactoring.extract.react.component.no.scope=找不到用於放置所創建組件的範圍
refactoring.create.react.component.title=創建組件
refactoring.react.function.to.class.refactoring.title=轉換為類組件
refactoring.react.function.to.class.intention.title=轉換為類組件
refactoring.react.function.to.class.used.in.new.conflict=\ ''new'' 表達式中使用了 {0}
refactoring.react.function.to.class.used.in.call.conflict=調用表達式中使用了 {0}
refactoring.react.class.to.function.conflict.used.with.ref={0} 與 ''ref'' 特性結合使用。無法為無狀態函數組件提供 ref
refactoring.react.class.to.function.refactoring.title=轉換為函數組件
refactoring.react.class.to.function.intention.title=轉換為函數組件
refactoring.react.could.not.find.in.template=無法重構。找不到名稱為 {0} 的元素。可能的程式碼模板 {1} 無效嗎？
react.function.to.class.caret.at.function=文字游標應置於要轉換的函數處
react.class.to.function.caret.at.class=文字游標應置於要轉換的類處
react.class.component.type.class=類
react.class.component.type.function=函數

js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函數初始化組欄位
intellilang.tagged.literal.injection.name.label=模式:
intellilang.tagged.literal.expression.border.title=模板標籤

refactoring.destructuring.vars.for.refactor.this=物件或陣列析構…
refactoring.destructuring.vars.intention.name=引入物件或陣列析構
refactoring.destructuring.vars.intention.name.object=引入物件析構
refactoring.destructuring.vars.intention.name.array=引入陣列析構
refactoring.destructuring.vars.intention.replace.object=取代為物件析構
refactoring.destructuring.vars.intention.replace.array=取代為數組析構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.propagate=傳播到析構宣告
refactoring.destructuring.vars.intention.depropagate=將析構取代為屬性和索引存取
refactoring.destructuring.vars.intention.deconstruct=生成析構模式
refactoring.destructuring.vars.intention.replace.shorthand=取代為析構和速記屬性
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，高亮顯示的 const 變數將轉換為 let 變數。\n要繼續嗎？
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.guard.conflict=通過類型防護將表達式類型限縮為 ''{0}''，該類型防護在重構後將不起作用
javascript.intention.add.export.family.name=添加匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.default.export.family.name=添加預設匯出
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.intention.promise.to.async.name=轉換為異步功能
javascript.intention.code.optimizations.text=正在最佳化生成的程式碼
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套調用取代為管道表達式
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套調用
javascript.intention.opt.chain.family=使用可選鏈接或空值合併
javascript.intention.opt.chain.chain.only=使用可選鏈接
javascript.intention.opt.chain.coalesce.only=使用空值合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.chain.and.coalesce=使用可選鏈接和空值合併
javascript.intention.expand.opt.chain.family=將可選鏈接或空值合併擴展到顯式檢查
javascript.intention.expand.opt.chain=展開可選鏈接
javascript.intention.expand.nullish.coalescing=展開 null 合併
javascript.intention.expand.or.coalescing=使用 ?: 運算符
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選鏈接和空值合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選鏈接並使用 ?: 運算符
javascript.intention.explicit.fields=宣告顯式類欄位
javascript.intention.explicit.fields.single=宣告顯式類欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位

js.param.hints.show.names.for.all.args=非文字實參
js.param.hints.show.names.for.tagged=標記的模板實參
js.param.hints.show.names.for.pipes=管道運算符
js.param.hints.blacklist.pattern.explanation=要禁用方法或函數提示，請使用下面的其中一種模式: <p style="margin-left: 5px"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 操作來添加模式。</p>

js.checkbox.make.readonly=設為唯讀(&R)

action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.ReactClassToFunctionComponentAction.description=轉換為函數組件
action.ReactFunctionToClassComponentAction.description=轉換為類組件
action.ReactExtractComponentAction.description=提取組件
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.SetAccessor.JavaScript.text=Setter
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.Constructor.JavaScript.text=構造函數
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
group.Editor.JSLibrariesMenu.LibraryList.text=使用庫
group.Editor.JSLibrariesMenu.LibraryList.description=設定使用的 JS 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.MyConfigurable.display.name=JSX
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多設定選項
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式調用
settings.code.style.semicolon.to.terminate.statements=分號終止語句(&S)
settings.code.style.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.Trailing.comma=尾隨逗號(&T):
settings.code.style.single=單
settings.code.style.double=雙
settings.code.style.in.new.code=(在新程式碼中)
settings.code.style.always=始終
settings.code.style.option.use=使用
settings.code.style.dont.use=不使用
checkbox.enable=啟用
create.react.app.name=React
create.react.app.description=<a href="https://github.com/facebookincubator/create-react-app">創建 React 套用</a>是官方支援的一種創建單頁 React 套用程序的新方法。它提供了沒有設定的現代建置設定。
create.react.app.scripts.version=腳本版本 (&V)
create.react.app.typescript.checkbox=創建 TypeScript 專案 (&T)
dialog.title.new.javascript.file=新建 JavaScript 檔案
list.item.javascript.file=JavaScript 檔案
dialog.title.new.typescript.file=新建 TypeScript 檔案
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
dialog.kind.0.file={0} 檔案
action.creates.new.file.description=創建新的 {0} 檔案
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
action.show.error.details.text=顯示錯誤詳細資訊
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.error.details=錯誤詳細資訊
dialog.message.failed.to.download.0.1=無法下載 {0}。{1}
dialog.title.download.error=下載錯誤
label.import.popup=自動匯入工具提示:
label.namespace=命名空間:
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.title.cannot.introduce.new.interface=無法引入新接口
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被禁用
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>顯示檢查設定</a>或<a href='undo'>撤消</a></html>
dialog.message.cannot.propagate.variable=無法傳播變數: {0}
dialog.title.cannot.propagate=無法傳播
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.title.cannot.convert=無法轉換
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於析構模式的變數沒有用法
button.continue=繼續
button.abort=中止
action.don.t.use.library.description=不使用庫
action.already.set.for.containing.folder.or.project.description=已針對包含的資料夾或專案進行設定。
action.use.library.description=使用庫
text.cannot.download=無法下載 {0}。{1}
notification.content.show.details=顯示詳細資訊
action.name.disable.category=禁用 {0}
progress.text.processing=正在處理 {0}{1}
label.path=路徑(&P):
border.title.inspection.export.results.capitalized.location=位置
border.title.inspection.description.title=描述:
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
action.jump.to.text=跳轉到…
dialog.title.select.navigation.target=選擇導航目標
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類的目標
dialog.message.component.name=組件名稱:
label.name=名稱: 
label.type=類型: 
label.minimum.language.level=最低語言級別:
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法創建實參存根: 調用的方法不是函數
action.show.structure.text=顯示結構
status.text.no.errors.in.current.file=當前檔案中沒有錯誤。
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
dialog.message.cannot.find.file=找不到檔案 {0}
radio.set.options.manually=手動設定選項
radio.use.tsconfig.json=使用 tsconfig.json
separator.deprecated.settings=棄用的設定
dialog.title.main.file=主檔案
label.choose.main.file=選擇主檔案
dialog.title.output.directory=輸出目錄
label.choose.output.directory=選擇輸出目錄
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
status.text.project.structure.isn.t.available=專案結構不可用
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
status.text.refresh.required=需要重新整理
dialog.message.cannot.find.module.for.import=無法建置用於匯入的模組路徑
action.js.tagged.literal.injection.text=JS 標記文字注入
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=添加
label.wsl.node.interpreter=WSL Node.js 解釋器(&N):
dialog.message.please.select.distribution=請選擇分發版
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
status.text.running.which.node=正在執行 `which node`…
progress.title.configuring.node.js.coding.assistance=正在設定 Node.js 編碼輔助…
action.PackageJsonNewFile.text={0}檔案
action.PackageJsonNewFile.description=創建 {0} 檔案
progress.title.install=安裝 {0}
progress.subtitle.install=正在通過 {1} 安裝 {0}…
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
dialog.title.missing.dependencies=缺少依賴項
button.install.update=安裝/更新
action.view.install.text=查看並安裝…
action.don.t.ask.again.text=不再詢問
dialog.title.configure.coding.assistance.for.node.js.api=設定 Node.js API 編碼輔助
action.Anonymous.text.configure=設定
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
popup.title.target.function=目標函數
popup.title.select.destructuring.assignment.target=選擇析構賦值目標
visibility.level.overview=概覽
visibility.level.details=詳細資訊
js.module.uml.presentable.name=JavaScript 模組依賴項
intention.family.name.run.npm.install=執行 'npm install'
intention.name.run.npm=執行 ''{0}''
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
intention.family.name.add.required.property=添加所需的屬性
intention.name.create.library.with.files.outside.project=使用專案外部的檔案創建庫
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unspecified=未指定的 {0}
dialog.message.no.such=沒有這樣的 {0}
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.command.supported.by={1} 不支持指令 ''{0}''
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
titled.separator.predefined=預定義
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
dialog.title.edit.run.debug.configuration=編輯執行/偵錯設定: ''{0}''
js.commandline.configure.language.version=為專案設定 JavaScript 語言版本
js.commandline.configure.nodejs=設定 NodeJS 解釋器並為 package.json 檔案安裝軟體套件

# Language features
js.language.feature.xml.tags=XML 標記
js.language.feature.for.each.statements=針對每條語句
js.language.feature.for.of.loops=for..of 迴圈
js.language.feature.let.definitions=Let 定義
js.language.feature.const.definitions=Const 定義
js.language.feature.generators=生成器
js.language.feature.destructuring.assignments=析構賦值
js.language.feature.let.statements=Let 語句
js.language.feature.array.comprehensions=陣列推導式
js.language.feature.top.level.yield.expressions=頂層 yield 表達式
js.language.feature.reference.namespace=引用命名空間
js.language.feature.default.parameter.values=預設參數值
js.language.feature.pipe.expressions=管道表達式
js.language.feature.decorator.declarations=裝飾器宣告
js.language.feature.throw.expressions=拋出表達式
js.language.feature.ecmascript.syntax.for.private.members=私有成員的 ECMAScript #- 語法
js.language.feature.class.member.visibility.modifiers=類成員可見性修飾符
js.language.feature.optional.chaining.operator=可選鏈接運算符
js.language.feature.arbitrary.precision.integers=任意精度整數
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=函數參數列表和調用中的尾隨逗號
js.language.feature.unicode.escapes.with.braces=使用大括號的 Unicode 轉義
js.language.feature.bind.expressions=綁定表達式
js.language.feature.optional.catch.bindings=可選 catch 綁定
js.language.feature.string.templates=字串模板
js.language.feature.method.definition.shorthands=方法定義速記形式
js.language.feature.computed.property.names=計算的屬性名稱
js.language.feature.shorthand.property.names=速記屬性名稱
js.language.feature.binary.0b.and.new.octal.0o.literals=二進制(0b)和新的八進制(0o)文字
js.language.feature.async.await=async/await
js.language.feature.types=類型
js.language.feature.annotations=註解
js.language.feature.interfaces=接口
js.language.feature.classes=類
js.language.feature.es6.export.declarations=ES6 匯出宣告
js.language.feature.es6.import.declarations=ES6 匯入宣告
js.language.feature.generics=泛型
js.language.feature.rest.parameters=rest 參數
js.language.feature.arrow.functions=箭頭函數
js.language.feature.getters.and.setters=getter 和 setter
js.language.feature.generator.expressions=生成器表達式
js.language.feature.expression.closures=表達式結束
js.language.feature.destructuring.parameters=析構參數

# Webpack
file.name.masks.to.skip.from.analysis=要在分析中跳過的文件名遮罩:

# Node
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.debug.cannot_connect_to_vm.error.message=無法連接到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 延伸模組
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組: 已超時
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組設定
node.core.navigate_action_text.text=設定 Node.js…
node.interpreter.field.add.item.text=添加…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
configure.node.interpreter.path=設定 Node.js 路徑…
node.interpreter.reference_not_found.text=未找到
node.interpreter.command_timed_out.dialog.message=''{0}'' 指令執行超時(>{1} ms)
node.package_documentation.installed_version.text=已安裝版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.packages.cannot_find_working_directory.text=無法確定 {0} 的工作目錄: {1}
node.package.field.not_found.text=未找到
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑: 無此類目錄 "{0}"
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處引用專案 npm 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
package_json.install_dependencies.notification.title=安裝依賴項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.install_dependencies.notification.content=來自 {0}
package_json.update_dependencies.notification.title=更新依賴項
package_json.notifications_are_disabled.notification.content=已禁用從 {0} 安裝依賴項的通知。<p>使用 "{1}" 操作重新啟用通知。
node.wsl.unavailable.dialog.message=WSL 不可用
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.package_manager_link.text=軟體套件管理器
yarn.package_requires_yarn.dialog.message=軟體套件 "{0}" 要求 Yarn {1}。

# Jest
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.snapshot.label=Jest 快照
filetype.jest.snapshot.description=Jest 快照
filetype.jest.snapshot.display.name=Jest 快照
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案

# Protractor
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器設定檔案

# Style guides
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.standard.style=JavaScript 標準樣式

# Inlay hints
method.return.types.in.call.chains=調用鏈中的函數返回類型
type.annotations=類型註解
parameters.in.parentheses=用括號括起來的參數
non.parenthesized.single.parameter=未使用括號括起來的單個參數
function.returns=函數返回類型
variables.and.fields=變數和欄位
command.name.add.explicit.value=添加顯式值 ''{0}''
numeric.enum.values=數值枚舉值

# Libraries
progress.title.downloading.library=正在下載庫
progress.title.downloading.documentation=正在下載文檔
successfully.downloaded=已成功下載
failed.to.download=無法下載
progress.title.downloading.typings=正在下載 typings
notify.urls.more=… 和另外 {0,number} 個

# Structural Search
structural.search.anonymous.functions=匿名函數
structural.search.functions=函數
structural.search.variables=變數
structural.search.function.calls=函數調用
structural.search.while.loops=While 迴圈
structural.search.constants=常數
structural.search.classes=類
structural.search.empty.functions=空函數
structural.search.console.log.calls=調用 console.log()
structural.search.with.statements=With 語句
structural.search.var.statements=Var 語句
structural.search.functions.with.boolean.parameters=使用布爾參數的函數
structural.search.comparison.to.self=與自身比較

# Project Generators
copying.files=正在複製檔案
project.generation=生成專案
notification.title.cannot.generate=無法生成 {0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
generating.0=正在生成 {0}

# Find Usages
js.show.dynamic.usages=顯示動態用法

# Test Runners
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown

# Diagrams
diagram.element.not.found={0} (未找到)

# Web frameworks
web.template.file-type.description={0} 模板
web.inspection.message.attribute.does.not.accept.value={0} 不接受任何值

# Other
command.name.create.javascript.file=創建 JavaScript 檔案 {0}
command.name.create.typescript.file=創建 TypeScript 檔案 {0}
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移動到欄位初始設定式
popup.title.choose.class=選擇類
multiple.inheritance=多重繼承
label.method.should.be.defined=方法應已定義
recursive.call=遞歸調用
command.name.extract.named.type=提取已命名類型
inspection.message.reference.includes.files.outside.project=引用包括專案範圍之外的檔案
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根添加到 {0}
label.name.injection=名稱(&N):
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
unwrap.with.kind=解開 ''{0}…''
header.declarations.to.be.refactored=要重構的宣告
filetype.yarn.lock.display.name=Yarn Lock
filetype.yarn.lock.description=Yarn lock



js.class.member.expression.context.type=類成員表達式
js.class.member.statement.context.type=類成員語句
javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
javascript.parser.message.missing.back.quote=缺少 `
eslint.run.on.save.disabled.comment=已禁用 ESLint 整合
eslint.run.on.save.auto.configuration.comment=自動 ESLint 設定
eslint.run.on.save.manual.configuration.comment=手動 ESLint 設定
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
node.execution.failed.to.prepare.target.environment.error=無法準備環境: {0}
node.interpreter.unavailable.target=不可用的目標: {0}
rename.react.hook.variable.title=重命名狀態變數
rename.react.hook.variable.description=將相關狀態變數重命名為:
web.inspection.message.attribute.value.no.valid={0} 不是 {1} 的有效值。預期值: {2}
add.variable.to.require=添加 require 調用的變數
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.regex.flag.d=符合索引 - 用於子字串符合的索引
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連接(可能被防火牆阻止)。\n要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
intention.category.javascript=JavaScript
intention.category.typescript=TypeScript
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.react=React
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
web.inspection.message.segment.missing=缺少 {0}
web.inspection.message.segment.unrecognized-identifier=無法識別的 {0}
web.inspection.message.segment.duplicated=重複的 {0}
web.inspection.message.segment.default-subject=名稱
not.installed.package=未安裝軟體套件
package.version.range.info={0, choice, 0#未安裝|1#已安裝: ?|2#已安裝: {1}}，最新: {2, choice, 0#正在載入…|1#未找到|2#{3}}
package.version.range.hint={0, choice, 0#允許|1#允許次要更新:|2#允許補丁更新:} {1} \\&gt;= 版本 \\&lt; {2}
env.variable.undefined={0} 未定義
env.variable.empty={0} 為空
jquery.documentation.not.found=找不到 jQuery 文檔
typescript.language.service.name=TypeScript 服務
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作生成器內部的關鍵字
linemarker.javascript.sources=JavaScript 源
linemarker.typescript.declaration=TypeScript 宣告
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
js.dot.property.access.context.type=點號屬性存取
javascript.library.built.in=內建
inlay.parameters.js.only.show.names.for.all.args=文字和非文字實參、調用表達式、物件和陣列初始設定式。
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>標記模板中的實參。<a><br>此設定僅對非文字實參生效，並且僅在啟用“非文字實參”選項時可用。
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.param.hints.show.names.for.all.args=方法調用中的文字和命名物件參數。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的文字和命名物件參數。
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a>
inlay.parameters.vuejs.show.names.for.all.args=文字和命名物件。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://v2.vuejs.org/v2/guide/filters.html'>篩選器(Vue 2)。</a>
js.url.import.usage.inspection.name=使用了 URL 匯入
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL:
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 依賴項更新為最新版本
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
node.package.empty.error.message=專案名稱為空
node.package.name.period.error.message=專案資料夾名稱不應以句點開頭
node.package.name.underscore.error.message=專案資料夾名稱不應以下劃線開頭
node.package.name.leading.or.trailing.spaces.error.message=專案資料夾名稱不應包含前導空格或尾隨空格
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.too.long.error.message=專案資料夾名稱不應超過 214 個字符
node.package.name.capital.letters.error.message=專案資料夾名稱不應包含大寫字母
node.package.name.special.characters.error.message=專案資料夾名稱不應包含特殊字符("~'!()*")
node.package.name.URL-friendly.characters.error.message=專案資料夾名稱應僅包含適用於 URL 的字符
javascript.parser.message.expected.identifier.string.literal.or.rbrace=應為關鍵字、字串文字或 }
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 ".js"
js.import.options.use.explicit.js.extension.no=從不
js.flow.process.log=Flow 流程日誌
flow.js.show.settings=設定 Flow…
flow.js.widget.name=Flow
flow.js.widget.display.name=Flow JS
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.insert.symbol.fix=插入{0}
node.js.configure.interpreter=設定 {0}
yarn.pnp.library_name=來自 {0} 的依賴項
typescript.enum.name=枚舉
typescript.enum.member.name=枚舉成員
icon.icons.nodes.readonlyMark.tooltip=readonly
notification.group.narrowed.types=JavaScript: 已禁用限縮的類型的著色
notification.group.nodejs.interpreter=Node.js 解釋器路徑已更新
notification.group.nodejs.assistance=Node.js 編碼輔助失敗
notification.group.package.json=來自 package.json 的依賴項可用
notification.group.package.json.disabled=來自 package.json 的依賴項: 通知已禁用
notification.group.linters=JavaScript linter
notification.group.project.generator=JavaScript 專案生成失敗
notification.group.grunt.console=Grunt 'watch' 任務狀態已變更
dialog.message.invalid.npm.package=無效的 {0} 軟體套件: 無此類檔案或目錄
notification.group.jest=Jest 測試執行失敗
node.package.selector.multiple.packages.binary.file.title=選擇 {0} 的軟體套件目錄或二進制檔案
node.package.binary.file.hint=指向 {0} 的二進制檔案的路徑
npm.failed_to_install_package.title.message=無法安裝 {0}
js.language.feature.enums=枚舉
web.bundler.failed.to.load=無法載入 {0}
web.bundler.analyzing.configs.progress=正在分析 Web Bundler 的設定檔案
web.bundler.cannot.analyze=無法分析 {0}: 編碼輔助將忽略此檔案中的模組解析規則。\n可能的原因: 此檔案不是有效的設定檔案，或者 IDE 目前不支持其格式。
inlay.hints.usages.text={0,choice, 0#無用法|1#1 個用法|2#{0,number} 個用法}
choose.overriding.method=<html><body>選擇 <b>{0}</b> 的覆寫方法(找到了 {1} 個)</body></html>
choose.overriding.function=<html><body>選擇 <b>{0}</b> 的覆寫函數(找到了 {1} 個)</body></html>
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number} 個實作}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number} 個覆寫}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
jsx.unresolved.component.name=未解析的 JSX 組件
jsx.syntax.used.name=已使用 JSX 語法
jsx.syntax.used.description=已使用 JSX 語法
intention.name.navigate.to=導航到 {0}
web.inspection.message.deprecated.symbol=#ref is deprecated, consult docs for better alternative
bundler.configuration.detect.description=檢測適合模組解析的 {0} 設定檔案:
bundler.configuration.manual=手動
bundler.configuration.automatic=自動
bundler.configuration.disabled=已禁用
bundler.configuration.automatic.how.it.works=運作方式
bundler.configuration.automatic.hint={0} 將使用當前檔案所在資料夾或其任意父資料夾中的 {1} 設定檔案內的模組解析規則。
bundler.configuration.field=設定檔案:
bundler.configuration.field.required.error=手動模式下需要設定檔案路徑
javascript.create.variable.holding.arrow.function.intention.name=Create variable ''{0}'' holding arrow function
javascript.create.constant.holding.arrow.function.intention.name=Create constant ''{0}'' holding arrow function
javascript.create.field.holding.arrow.function.intention.name=Create field ''{0}'' holding arrow function
javascript.create.property.holding.arrow.function.intention.name=Create property ''{0}'' holding arrow function
es6.import.options.exts.help=This option configures extensions in import statements. <br><br>With "Auto", the IDE adds extensions to the names of vue files, of files from projects that have "type": "module" in package.json, and of files with the .mjs or .cjs extensions. <br><br>With "Always", the IDE always adds extensions to file names. <br><br>With "Never", the IDE always uses file names without extensions.
es6.import.options.not.import.help=This option configures exact paths that IDE skips during automatic import of a symbol. Instead, IDE will look for alternative paths to import the symbol.
typescript.import.options.exts.help=This option configures extensions in import statements. <br><br>With "Auto" selected, the IDE always adds extensions to the names of vue files, of files from projects that have "module": "node16" or "module": "nodenext" in tsconfig.json and "type": "module" in package.json, and of files with the .mts extension. <br><br>With "Always", the IDE always adds the .js extension to TypeScript file names. <br><br>With "Never", the IDE always uses file names without extensions.
es6.import.options.blacklist.title=不要完全從此匯入：
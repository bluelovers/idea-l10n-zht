0.is.not.a.legal.name=''{0}'' 不是合法的類別名
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類別中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取
action.Anonymous.text.configure=組態
action.ES6.Generate.Index.description=生成 index.js/index.ts
action.ES6.Generate.Index.text=生成 index.js/index.ts
action.EnablePackageJsonMismatchedDependenciesNotification.text=啟用有關從 package.json 安裝相依項的通知
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式規則
action.EslintImportCodeStyle.text=套用 ESLint 程式碼樣式規則
action.ExplainNodeModulesLibrariesAction.text=解釋 node__modules 庫
action.FindDuplicatedIndexedFilesInNodeModulesAction.text=在 node__modules 中尋找重複的索引檔案
action.FlowJS.Restart.All.Servers.description=重啟所有 Flow 伺服器
action.FlowJS.Restart.All.Servers.text=重啟所有 Flow 伺服器
action.Generate.Constructor.JavaScript.text=建構函式
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
action.Generate.SetAccessor.JavaScript.text=Setter
action.InstallNodeLocalDependencies$Root.text=在專案根目錄中執行 'npm install'
action.InstallNodeLocalDependencies$Root.text.template=為 {1} 執行 ''{0}''
action.InstallNodeLocalDependencies.text=安裝 Node.js 相依項
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JSShowUsagesFloatingToolbar.description=顯示文字游標處符號的用法
action.JSShowUsagesFloatingToolbar.text=顯示用法(_S)
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JavaScript.SearchForComponentUsageAction.description=顯示當前所選組件的用法
action.JavaScript.SearchForComponentUsageAction.text=顯示組件用法
action.JavaScript.ShowComponentUsages.description=顯示當前所選組件的用法
action.JavaScript.ShowComponentUsages.text=顯示組件用法
action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.LearnWebstormAction.description=檢視自定義和程式碼編輯提示以充分利用 WebStorm
action.LearnWebstormAction.text=學習 WebStorm
action.NewJavaScriptFile.description=從指定的模板建立 JavaScript 檔案
action.NewJavaScriptFile.text=JavaScript 檔案
action.NewPackageJsonFile.description=建立 package.json 檔案
action.NewPackageJsonFile.text=package.json
action.NewTypeScriptFile.description=建立新的 TypeScript 檔案
action.NewTypeScriptFile.text=TypeScript 檔案
action.NodeServicesProfilerAction.text=啟動 Node.js 服務分析
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown
action.RestartEsLintServiceAction.description=停止執行 ESLint 服務，根據需要自動重啟
action.RestartEsLintServiceAction.text=根據需要停止和自動執行 ESLint 服務
action.RunJsbtTask.text=執行 Gulp/Grunt/npm 任務
action.StopSingleEsLintServiceAction.text=根據需要停止和自動執行服務
action.ToggleNodeCoreCodingAssistanceAction.text=切換 Node.js 的編碼輔助
action.TypeScript.Enable.Service.text=TypeScript 語言服務
action.TypeScript.Include.Sources.text=包括 JavaScript 檔案
action.TypeScript.Restart.Service.text=重啟 TypeScript 服務
action.TypeScript.Show.Structure.text=顯示 TypeScript 伺服器專案
action.TypeScript.Test.Slow.Server.text=測試慢速 TypeScript 伺服器
action.TypeScriptAddEnumTextInlayAction.text=新增枚舉顯式值
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.TypeScriptExtractTypeAlias.text=類型別名…
action.already.set.for.containing.folder.or.project.description=已針對包含的目錄或專案進行設定。
action.creates.new.file.description=建立新的 {0} 檔案
action.don.t.ask.again.text=不再詢問
action.don.t.use.library.description=不使用庫
action.js.tagged.literal.injection.text=JS 標記字面量注入
action.jump.to.text=跳轉到…
action.name.disable.category=停用 {0}
action.restart.service=重啟服務
action.show.error.details.text=顯示錯誤詳細資訊
action.show.structure.text=顯示結構
action.structureview.show.object.inherited=從物件繼承
action.use.library.description=使用庫
action.view.install.text=檢視並安裝…
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '…' 後面
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646: Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646: Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
activity.key.node.js.name=Node.js
activity.tracker.node.modules.name=node_modules 追蹤器
add.import.binding.to.import=將匯入綁定新增到匯入
add.import.specifier.to.import=將匯入說明符新增到匯入
add.variable.to.require=新增 require 呼叫的變數
advanced.setting.js.FindInFiles.with.library.files=在“在檔案中尋找”中選擇“目錄”時，在庫檔案中搜尋
advanced.setting.js.fallback.to.old.eval.outside.of.import.graph=使用來自伺服器的類型時，回退到 IDE 類型評估器以處理當前匯入圖之外的檔案。
advanced.setting.js.fallback.to.old.eval.outside.of.import.graph.description=IDE 可以嘗試評估不在當前 TypeScript 專案(tsconfig.json) import 圖內的檔案中的類型。在這種情況下，伺服器可以載入和解析大量新檔案來提供類型。回退到 IDE 評估器可以顯著提高大型專案的性能。
advanced.setting.js.js.advanced.annotator=進階 JavaScript 註解器
advanced.setting.js.js.advanced.annotator.description=JavaScript 註解器會檢查 JS / JSX 中的基本語意 JS 錯誤。進階註解器可以發現更多錯誤，但可能會消耗更多 CPU 資源。
advanced.setting.js.jsx.advanced.annotator=進階 JSX 註解器
advanced.setting.js.jsx.advanced.annotator.description=JSX 註解器會驗證 JSX 和 TSX 中的 JSX 標籤。進階註解器可以發現更多錯誤，但可能消耗更多 CPU 資源。如果您使用 TypeScript 語言服務，請考慮停用此選項。
advanced.setting.js.jsx.client.components=醒目提示顯示 JSX 客戶端組件
advanced.setting.js.jsx.client.components.description=對 JSX 伺服器/客戶端組件使用不同的顏色。可能會消耗額外的 CPU 資源
advanced.setting.js.semantic.highlighting.accuracy=語意醒目提示準確性
advanced.setting.js.semantic.highlighting.accuracy.basic=基本
advanced.setting.js.semantic.highlighting.accuracy.description=語意醒目提示會為程式碼元素指定不同的顏色，以區分本地和全域、函式和物件等。更高的準確性可以更深入地分析程式碼，但可能會消耗更多的 CPU 資源。
advanced.setting.js.semantic.highlighting.accuracy.high=高
advanced.setting.js.semantic.highlighting.accuracy.limited=有限
advanced.setting.js.semantic.highlighting.accuracy.normal=正常
advanced.settings.js=JavaScript 和 TypeScript
and.more=以及更多…
anonymous.to.named.intention.function.name=函式名稱:
automatically.replace.with.template.string.on.typing=輸入 '${' 時自動將字串字面量取代為模板字串
border.title.inspection.export.results.capitalized.location=位置
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.JsbtAddBuildfileAction.text=新增 {0}
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.ShowSettingsAction.npm.text=編輯 npm 組態(&E)…
buildTools.ShowSettingsAction.text={0}設定…
buildTools.add.with=使用 {1} 新增 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.edit.run.configuration=編輯執行組態
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.no.files.added=未新增檔案
buildTools.no.such.file=沒有此類別檔案
buildTools.no.tasks.found=未找到任務
buildTools.searchEverywhere.npm.text=執行 {0} npm 腳本
buildTools.searchEverywhere.text=執行“{0}”任務
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.tree.sortBy.text=排序方式
bundler.configuration.automatic=自動
bundler.configuration.automatic.hint={0} 將使用當前檔案所在目錄或其任意父目錄中的 {1} 組態檔案內的模組解析規則。
bundler.configuration.automatic.how.it.works=運作方式
bundler.configuration.detect.description=檢測適合模組解析的 {0} 組態檔案:
bundler.configuration.disabled=已停用
bundler.configuration.field=組態檔案:
bundler.configuration.field.required.error=手動模式下需要組態檔案路徑
bundler.configuration.manual=手動
button.abort=中止
button.continue=繼續
button.install.update=安裝/更新
can.t.find.flow.executable=找不到 Flow 可執行檔案
cannot.modify.library.code=無法修改庫或 SDK 程式碼
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\n
cannot.refactor.anonymous.function=現有非呼叫用法阻止呼叫點分析。
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託呼叫
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 呼叫和更新呼叫
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 呼叫和更新呼叫
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.fix.text=更改 {0} 簽名
change.signature.call.expression.contains.spreads=函式呼叫包含傳播實參。用法將保持不變。
change.signature.column.name=名稱
change.signature.column.name.call.value=呼叫中的值
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.initializer=初始設定式
change.signature.column.name.modifier=修飾符
change.signature.column.name.optional.flag=可選
change.signature.column.type=類型
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
change.signature.dialog.title=更改 {0} 的簽名
change.signature.method.references.arguments=函式參照實參，更改簽名後代碼可能會中斷
change.signature.parameter.table.empty.message=使用  '+' 按鈕新增新參數
change.signature.tagged.template.issue=無法更新標記的模板呼叫。用法將保持不變。
change.signature.usage.view.declarations.header=要重構的方法
change.signature.value.column.title=值
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
checkbox.collapse.array.literals=陣列字面量
checkbox.collapse.object.literals=物件字面量
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函式
checkbox.collapse.xml.literals=XML 字面量
checkbox.enable=啟用
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移至欄位初始設定式
choose.base.component.title=選擇超類別
choose.class.to.import.title=要匯入的類別
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
choose.destination.scope=選擇目標作用域
choose.field.type=選擇欄位類型
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作(找到 {1})</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
choose.overriding.function=<html><body>選擇 <b>{0}</b> 的覆寫函式(找到 {1} 個)</body></html>
choose.overriding.method=<html><body>選擇 <b>{0}</b> 的覆寫方法(找到 {1} 個)</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類別(找到 {1})</body></html>
choose.super.class.title=選擇超類別
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類別或接口(找到 {1})</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位(找到 {1})</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函式(找到 {1})</body></html>
choose.super.interface.title=選擇 Super 接口
choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法(找到 {1})</body></html>
class.0.cannot.be.created=無法建立目標類別 {0}，因為存在同名的限定元素
class.already.contains.field.warning=類別 ''{0}'' 已包含欄位 ''{1}''。\n是否繼續?
class.already.contains.method.warning=類別 ''{0}''已經 {1, choice, 1# 包含|2#繼承} 方法 ''{2}()''。\n是否繼續?
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
class.names={0,choice,1#類別|2#類別} {1}
class.template.title=類別
class.with.supers.template.title=包含 Super 的類別
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number} 個實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number} 個覆寫}
code.vision.performance.watcher.notification.configure=組態…
code.vision.performance.watcher.notification.disable.code.vision=停用提示
code.vision.performance.watcher.notification.message=停用 Code Vision 提示可以通過減少 CPU 負載來提高性能。
code.vision.performance.watcher.notification.title=Code Vision 提示評估緩慢
codestyle.ui.field.prefix=欄位前綴 (&F):
codestyle.ui.file.name.style=檔案命名約定 (&N):
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
codestyle.ui.property.prefix=屬性前綴 (&P):
collection.queried.but.not.update=查詢了集合 <code>#ref</code> 的內容，但從未寫入
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的內容，但從未被查詢
command.name.add.explicit.value=新增顯式值 ''{0}''
command.name.create.javascript.file=建立 JavaScript 檔案 {0}
command.name.create.typescript.file=建立 TypeScript 檔案 {0}
command.name.extract.named.type=提取已命名類型
command.name.import=匯入 {0}
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.MyConfigurable.display.name=JSX
configure.code.completion.settings=組態程式碼補全設定
configure.node.interpreter.path=組態 Node.js 路徑…
copying.files=正在複製檔案
create.button.text=建立(&C)
create.class.interfaces.label=接口(&I):
create.class.name.label=名稱(&N):
create.class.ok.button.text=建立
create.class.package.label=軟體套件:
create.class.superclass.label=超類別(&S):
create.class.template.label=模板(&T):
create.constructor.dialog.title=建立建構函式
create.field.dialog.title=建立欄位
create.file.name=建立檔案 ''{0}''
create.file.name.with=使用 {1} 建立檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 建立檔案 ''{0}''
create.method.dialog.title=建立方法
create.mobile.view=建立檢視 ''{0}''
create.react.app.warning.deprecated=不建議使用 <b>create-react-app</b> 建立 React 應用程式。在沒有框架的情況下使用 React 時，首選方式是使用帶 <a href="https://vitejs.dev/guide/#trying-vite-online">Vite Bundler</a> 的模板。
custom.template.variables=自訂模板變數(&C):
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C):
declare.event.0=宣告事件 ''{0}''
declare.static=宣告 static(&S)
diagram.element.not.found={0} (未找到)
dialog.kind.0.file={0} 檔案
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。組態檔案不正確。
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法建立實參存根: 呼叫的方法不是函式
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
dialog.message.cannot.find.file=找不到檔案 {0}
dialog.message.cannot.find.module.for.import=無法建置用於匯入的模組路徑
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器組態檔案
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.cannot.propagate.variable=無法傳播變數: {0}
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列解構模式
dialog.message.command.supported.by={1} 不支持指令 ''{0}''
dialog.message.component.name=組件名稱:
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.failed.to.download.0.1=無法下載 {0}。{1}
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的解構模式
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
dialog.message.invalid.npm.package=無效的 {0} 軟體套件: 無此類別檔案或目錄
dialog.message.invalid.npx.command=無效的 npx 指令
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件: 無此類別目錄
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
dialog.message.no.such=沒有這樣的 {0}
dialog.message.node.interpreter.is.located.in.another.wsl.distribution=Node.js 解釋器位於與指定專案路徑不同的 WSL 發行版中。
dialog.message.node.interpreter.must.be.located.in.wsl=Node.js 解釋器必須位於 WSL 中，並具有指定的專案路徑。
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件: Yarn 安裝的軟體套件格式為 ''yarn:[package.json 的相對路徑]:[軟體套件名稱]''。
dialog.message.please.select.distribution=請選擇發行版
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\n匯入和匯出中的用法、字串用法或動態參照無法取代為解構。
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\n無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列解構不支持轉換多個嵌套模式
dialog.message.unspecified=未指定的 {0}
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.unspecified.package.name=未指定軟體套件名稱。
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unsupported.destructuring.container=不支持的解構容器: {0}
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於解構模式的變數沒有用法
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.title.cannot.convert=無法轉換
dialog.title.cannot.introduce.new.interface=無法引入新接口
dialog.title.cannot.propagate=無法傳播
dialog.title.configure.coding.assistance.for.node.js.api=組態 Node.js API 編碼輔助
dialog.title.download.error=下載錯誤
dialog.title.edit.run.debug.configuration=編輯執行/偵錯組態: ''{0}''
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.missing.dependencies=缺少相依項
dialog.title.move.members=移動成員
dialog.title.new.javascript.file=新增 JavaScript 檔案
dialog.title.new.typescript.file=新增 TypeScript 檔案
dialog.title.select.navigation.target=選擇導覽目標
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類別的目標
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=新增
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
duplicate.parameter.name=重複的參數名稱: {0}
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?
element.name.anonymous=<匿名>
element.name.default=<預設>
entity.in.parent.description={0} ({1} 內)
env.variable.empty={0} 為空
env.variable.undefined={0} 未定義
environment.key.description.package_json.install.dependencies=指示 IDE 是否應安裝專案檔案中發現的 'package.json' 的相依項。\n值為 'true' 或 'false'
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
es6.auto.import.options.completion.add.imports=自動新增 JavaScript import
es6.auto.import.options.title=TypeScript / JavaScript
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用呼叫中的值。因為沒有為前面的參數指定它。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已新增。\n指定要用於此方法的所有現有呼叫的預設值或值。
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
es6.code.style.path.mapping.never=從不
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
es6.extract.super.destination.label=目標檔案 (&D):
es6.extract.super.different.name.expected=應為不同名稱
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類別中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類別中不允許沒有實作的多載宣告 {0}
es6.import.options.blacklist.title=不從指定路徑或路徑模式匯入:
es6.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會向 vue 檔案、來自在 package.json 中具有 "type": "module" 的專案的檔案，以及擴展名為 .mjs 或 .cjs 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向檔名新增副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
es6.import.options.not.import.help=此選項會組態 IDE 在自動匯入符號期間跳過的確切路徑。相反，IDE 將尋找替代路徑來匯入符號。路徑應符合 glob 模式規則。
es6.import.options.paths=使用路徑別名:
es6.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 webpack、vite 或 jsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中，使用路徑映射。<br><br>選擇“從不”時，則從不使用別名。
es6.insert.await.fix=插入 await
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函式呼叫前插入 'await' 有助於 V8 提供異步堆疊追蹤
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.refactoring.create.file=建立檔案
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\n是否要建立?
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標檔名在此作業系統中無效
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.field.from=從:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.references.local.message=選擇的 {0} 參照非匯出 {1}
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 參照未解析匯入 {1}
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.table.title=要移動的成員
es6.prefer.short.import.name=可以縮短匯入
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊追蹤功能
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
es6.validate.import.error=無法解析符號 ''{0}''
es6.validation.message.const.variable.without.initializer=不允許使用無初始設定式的 'const' 變數
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
escape.pasted.text=在貼上字串字面量時轉義文本
eslint.action.fix.problems.description=通過呼叫 'eslint --fix' 修正 ESLint 問題
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.apply.text=是
eslint.code.style.dismiss.text=否
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R):
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style="padding-top:8px">要使用 package.json，請將您的組態新增到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.config.select.config.text=選擇 ESLint 組態檔案(*.eslintrc.*)
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E):
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O):
eslint.configurable.label.working.directories=工作目錄(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=路徑或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。
eslint.configuration.file.field.name=ESLint 組態檔案
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.files.pattern.comment=使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如 <code>**/*.{js,ts}</code>
eslint.fix.problems.family.name={0}: 修復當前錯誤
eslint.fix.problems.text.current={0}: 修復當前錯誤
eslint.fix.problems.text.with.error.code={0}: 修復 ''{1}''
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重性: {0}\n主體:\n{1}
eslint.run.for.files.label=為檔案執行(&F):
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.run.on.save.auto.configuration.comment=自動 ESLint 組態
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
eslint.run.on.save.disabled.comment=已停用 ESLint 整合
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
eslint.run.on.save.manual.configuration.comment=手動 ESLint 組態
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
extract.constant.type=類型(&T):
extract.function.declare.arrow.function=&箭頭函式
extract.function.function=函式
extract.function.name=名稱(&N):
extract.function.parameters=參數
extract.function.return.type=返回值類型(&T):
extract.function.signature.preview=簽名預覽
extract.interface.command.name=提取接口
extract.method.declare.static=宣告 static(&S)
extract.subclass.command.name=從 {1} 提取子類別 {0}
extract.type.alias.command.name=提取類型別名
failed.to.download=無法下載
fetch.client.generator.title=JavaScript Fetch
field.initializer.is.not.specified=未指定欄位初始設定式
file.name.masks.to.skip.from.analysis=要在分析中排除的檔名遮罩:
filetype.actionscript.description=ActionScript
filetype.js.testing.snapshot.description=JavaScript 測試快照(Jest)
filetype.js.testing.snapshot.display.name=JavaScript 測試快照
filetype.jshint.config.description=JSHint 組態
filetype.jshint.config.display.name=JSHint 組態
filetype.yarn.lock.description=Yarn lock
filetype.yarn.lock.display.name=Yarn Lock
find.usages.of.base.class={1} 的方法 {0}\n覆寫 {2} 的方法。\n要{3}基方法嗎?
find.usages.of.base.interface={1} 的方法 {0}\n實作 {2} 的方法。\n要{3}基方法嗎?
flow.js.get.type=Flow JS:Get 類型
flow.js.show.settings=組態 Flow…
flow.js.version.not.supported=Flow JS 版本 {0} 不受支援
flow.js.widget.display.name=Flow JS
flow.js.widget.name=Flow
function.names={1}{0,choice,1#函式|2#函式} 
function.returns=函式返回值類型
function.returns.description=函式返回值類型
generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
generate.filter.button.description=在列表中顯示 {0} 
generate.filter.button.tooltip=顯示 {0}
generate.filter.fields=欄位和屬性
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.to.string.chooser.title=選擇要在 toString 函式中使用的欄位
generating.0=正在生成 {0}
generating.errors.cannot.generate=無法生成 {0}
generating.errors.in.console=檢視主控台中的錯誤(離開程式碼 {0}})
generating.installing.deps=正在安裝相依項…
generating.new.project=新增專案
generating.template.processing=模板處理
generating.with.tips=生成帶有入門提示的 Playground 專案
generating.with.tips.comment=基於 Vite 的計數器專案
generation.bindable.event=可綁定事件(&B):
generation.event.constant=事件常數(&E):
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
group.Floating.CodeToolbar.JS.Refactor.text=重構
group.Floating.CodeToolbar.JS.text=浮動程式碼工具列 Web
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
grunt.gruntfile.not.found=未找到 Gruntfile
grunt.rc.arguments.label=實參(&R):
grunt.rc.environmentVariables.label=環境(&E):
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P):
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.gruntfile.label=Gruntfile (&F):
grunt.rc.nodeInterpreter.label=Node 解釋器(&I):
grunt.rc.nodeOptions.label=Node 選項(&O):
grunt.rc.tasks.label=任務(&T):
grunt.task.title=Grunt 任務
grunt.unspecified.gruntfile=未指定 Gruntfile
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
gulp.gulpfile.not.found=未找到 Gulpfile
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.rc.arguments.label=實參(&R):
gulp.rc.environmentVariables.label=環境(&E):
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G):
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.gulpfile.label=Gulpfile (&F):
gulp.rc.nodeInterpreter.label=Node 解釋器(&I):
gulp.rc.nodeOptions.label=Node 選項(&O):
gulp.rc.tasks.label=任務(&T):
gulp.task.title=Gulp 任務
header.declarations.to.be.refactored=要重構的宣告
icon.icons.nodes.readonlyMark.tooltip=唯讀
ignore.unused.option.all=所有
ignore.unused.option.before.used=使用前
ignore.unused.option.none=無
implement.members.abstract=實作 abstract 成員
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多組態選項
initialize.fields.intention.visibility=可見性:
inlay.hints.max.one.usage.text={0,choice, 0#無用法|1#顯示用法}
inlay.hints.usages.text={0,choice, 0#無用法|1#1 個用法|2#{0,number} 個用法}
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的命名物件參數。<p style="padding-left: 5px; padding-top: 5px; font-size: 0.85em">注意: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.angular.show.names.for.literal.args=Angular HTML 模板中的字面量參數。<p style="padding-left: 5px; padding-top: 5px; font-size: 0.85em">注意: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a> <p style="padding-left: 5px; padding-top: 5px; font-size: 0.85em">注意: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.js.only.show.names.for.all.args=非字面量實參，例如參照和表達式。
inlay.parameters.js.only.show.names.for.literal.args=字面量實參，例如基元、物件和陣列初始設定式。
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>標記模板中的實參<a>。
inlay.parameters.js.param.hints.show.names.for.all.args=非字面量實參，例如參照和表達式。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.ts.param.hints.show.names.for.literal.args=字面量實參，例如基元、物件和陣列初始設定式。<p style="padding-left: 5px; padding-top: 5px; font-size: 0.85em">注意: 從 TypeScript v4.4 開始，啟用“非字面量實參”時，停用此選項沒有任何效果。</p>
inlay.parameters.vuejs.show.names.for.all.args=非字面量實參。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://v2.vuejs.org/v2/guide/filters.html'>篩選器(Vue 2)。</a>
inlay.parameters.vuejs.show.names.for.literal.args=字面量實參。
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
inline.cannot.inline.references.this.type=無法內聯參照 'this' 類型的接口
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
insert.class.fix.name=新增類別名限定符
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=新增 this 限定符
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼輔助已被停用
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.reference.includes.files.outside.project=參照包括專案範圍之外的檔案
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
intellilang.tagged.literal.expression.border.title=模板標籤
intellilang.tagged.literal.injection.name.label=模式:
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.javascript=JavaScript
intention.category.react=React
intention.category.typescript=TypeScript
intention.family.name.add.required.property=新增所需的屬性
intention.family.name.enable.web.types=啟用 HTMX 支援
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
intention.family.name.run.npm.install=執行 'npm install'
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
intention.family.name.surround.with.tag=使用標記包圍
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 新增到 tsconfig.json
intention.name.create.library.with.files.outside.project=使用專案外部的檔案建立庫
intention.name.import.augmentation=匯入擴大 {0}
intention.name.loading.service.fixes=正在載入服務修正…
intention.name.navigate.to=導覽到 {0}
intention.name.run.npm=執行 ''{0}''
intention.name.surround.with.tag=使用 <{0}> 包圍
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.template.title=接口
introduce.constant.target.class=目標類別(&A):
introduce.field.class.constructor=類別建構函式(&C)
introduce.field.current.method=當前方法(&M)
introduce.field.declaration=欄位宣告(&D)
introduce.field.initialize.in=初始化位置
introduce.field.type=類型(&T):
introduce.parameter.optional=可選參數(&O)
introduce.parameter.type=類型(&T):
introduce.variable.const=const(&C)
introduce.variable.declaration=變數宣告
introduce.variable.let=let(&L)
introduce.variable.make.constant=設為常數(&C)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T):
invalid.field.type.expression=無效欄位類型: ''{0}''
invalid.identifier.value.0=無效關鍵字: ''{0}''
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
invalid.return.type.expression=返回值類型 ''{0}'' 無效
item.already.exists={0} {1} 已存在
javascript.abstract.class.can.not.be.instantiated.message=無法實例化抽象類別
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始設定式必須是基元字面量或字面量枚舉參照
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始設定式
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函式是建構函式
javascript.auto.import.options.add.imports.on.the.fly=動態明確 import
javascript.auto.import.options.add.on.code.completion=程式碼補全時
javascript.auto.import.options.show.popup=包含自動匯入工具提示
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函式返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
javascript.change.language.level.family=更改 JavaScript 語言版本
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.signature.invalid.function.name.0=無效函式名稱: ''{0}''
javascript.change.signature.invalid.parameter.declaration=無效參數: ''{0}''
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已新增。\n指定要用於此方法的所有現有呼叫的預設值。
javascript.check.global.definitions=檢查全域作用域內的賦值
javascript.completion.several.definitions=(多個定義)
javascript.constructor.call.without.new.message=不帶 <code>new</code> 的建構函式呼叫
javascript.constructor.with.lower.case.name.used.message=建構函式名稱通常以大寫字母開頭。拼寫錯誤?
javascript.create.class.intention.name=建立類別 ''{0}''
javascript.create.constant.field.intention.name=建立常數欄位 ''{0}''
javascript.create.constant.holding.arrow.function.intention.name=建立含有常數 ''{0}'' 的箭頭函式
javascript.create.constant.intention.name=建立常數 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類別中建立建構函式
javascript.create.event.handler.intention.name=建立事件處理程序 ''{0}''
javascript.create.field.holding.arrow.function.intention.name=建立含有欄位 ''{0}'' 的箭頭函式
javascript.create.field.intention.name=建立欄位 ''{0}''
javascript.create.function.intention.family=建立 JavaScript 函式或方法
javascript.create.function.intention.name=建立函式 ''{0}''
javascript.create.function.property.intention.name=建立函式屬性 ''{0}''
javascript.create.get.property.intention.name=建立 ''get'' 屬性 ''{0}''
javascript.create.interface.intention.name=建立接口 ''{0}''
javascript.create.method.intention.name=建立方法 ''{0}''
javascript.create.property.holding.arrow.function.intention.name=建立含有屬性 ''{0}'' 的箭頭函式
javascript.create.property.intention.name=建立屬性 ''{0}''
javascript.create.set.property.intention.name=建立 ''set'' 屬性 ''{0}''
javascript.create.variable.holding.arrow.function.intention.name=建立含有變數 ''{0}'' 的箭頭函式
javascript.create.variable.intention.family=建立 JavaScript 變數或屬性
javascript.create.variable.intention.name=建立變數 ''{0}''
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 #loc
javascript.destructuring.initializer=初始設定式 {0}
javascript.destructuring.variable.only=僅解構變數
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.is.not.accessible.message=元素不可存取 #loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 #ref 可能導致意外類型強制 #loc
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
javascript.equality.comparison.with.coercion.options.label=醒目提示顯示 '==' 和 '!=' 的用法:
javascript.expected.class.or.descendant=應為類別 {0} 或後代
javascript.export.only.member=元素僅匯出
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.extract.method.title=提取函式
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false: {0}'' 始終具有類型 ''{1}''
javascript.find.usages.destructuring.target.dialog=速記解構變數使用 {0} 初始化。\n您想尋找哪些用法?
javascript.fix.add.enum.values=新增枚舉值
javascript.fix.add.override.modifier=新增覆寫修飾符
javascript.fix.add.string.enum.values=新增字串枚舉值
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.create.constructor.invoke.super=建立符合 super 的建構函式
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.create.invoke.super=插入超類別建構函式呼叫
javascript.fix.create.parameter=建立參數 ''{0}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.fix.implement=實作 {0}
javascript.fix.implement.chooser.all=所有類別
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.family=在派生類別中實作
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.fix.initialize.parameter=初始化參數
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回值類型更改為預期類型
javascript.fix.optimize.imports=最佳化 import
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.circular.dependency=移除迴圈相依關係
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.constructor=移除建構函式
javascript.fix.remove.default=移除預設子句
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.fix.remove.initializer=移除初始設定式
javascript.fix.remove.modifier=移除修飾符
javascript.fix.remove.namespace.reference=移除命名空間參照
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.fix.remove.type.reference=移除類型參照
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.visibility.family=修復可見性問題
javascript.formatting.options.panel.comments=註釋
javascript.formatting.options.panel.naming.conventions=命名約定
javascript.formatting.web.spacing.within.group=內部
javascript.formatting.web.spacing.within.interpolations=插值
javascript.formatting.web.wrapping.interpolations=插值
javascript.formatting.web.wrapping.new-line-after-start-delimiter=在 '{{' 後換行
javascript.formatting.web.wrapping.new-line-before-end-delimiter='}}' 前新起一行
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
javascript.ignore.unused.function.parameters=忽略未使用的參數:
javascript.illegal.variable.type.void=非法變數類型: 'void'
javascript.implement.all.interfaces=實作所有成員
javascript.implement.members.abstract=實作 abstract 成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.import.options.use.resource.root=使用相對於專案、資源或來源根目錄的路徑
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.initializer.type.mismatch=初始設定式類型 {1} 不可分配給變數類型 {0}
javascript.inline.element.is.not.used={0} 從未使用
javascript.insert.cast.fix=插入轉換
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.symbol.fix=插入{0}
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
javascript.instance.member.is.not.accessible.message=實例成員不可存取 #loc
javascript.intention.add.default.export.family.name=新增預設匯出
javascript.intention.add.export.family.name=新增匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套呼叫取代為管道表達式
javascript.intention.code.optimizations.text=正在最佳化生成的程式碼
javascript.intention.create.getter=為 ''{0}'' 建立 getter
javascript.intention.create.getter.desc=建立 getter
javascript.intention.create.getter.setter=為 ''{0}'' 建立 getter 和 setter
javascript.intention.create.getter.setter.desc=建立 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 建立 setter
javascript.intention.create.setter.desc=建立 setter
javascript.intention.expand.nullish.coalescing=展開 null 合併
javascript.intention.expand.opt.chain=展開可選鏈接
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選鏈接和 null 合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選鏈接並使用 ?: 運算符
javascript.intention.expand.opt.chain.family=將可選鏈接或 null 合併擴展到顯式檢查
javascript.intention.expand.or.coalescing=使用 ?: 運算符
javascript.intention.explicit.fields=宣告顯式類別欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.explicit.fields.single=宣告顯式類別欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位
javascript.intention.opt.chain.chain.and.coalesce=使用可選鏈接和 null 合併
javascript.intention.opt.chain.chain.only=使用可選鏈接
javascript.intention.opt.chain.coalesce.only=使用 null 合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.family=使用可選鏈接或 null 合併
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套呼叫
javascript.intention.promise.to.async.name=轉換為異步函式
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.introduce.breaks.operator.precedence=無法呼叫重構。\n通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\n選定的表達式類型無效。
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\n選定內容不構成表達式。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\n選定內容不是常數表達式。
javascript.introduce.constant.in.es5=無法呼叫重構。\n無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.constant.title=引入常數
javascript.introduce.element.already.exists=作用域中已存在同名的 {0}。
javascript.introduce.field.before.super.call=無法引入欄位。\n在"super"呼叫前無法存取"this"。
javascript.introduce.field.constructor=建構函式
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\n選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\n沒有封閉類別。
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\n選定內容不構成表達式。
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.initialize.in.scope=初始化位置(&I):
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.title=引入欄位
javascript.introduce.field.visibility=可見性(&V):
javascript.introduce.in.embedded.expression=無法呼叫重構。\n無法在嵌入式表達式中引入
javascript.introduce.incorrect.context=無法引入變數。\n選定內容包含對"this"的參照
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\n選定的表達式類型無效。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\n找不到要使用的包含函式。
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\n選定內容不構成表達式。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\n並非所有用法都包含在異步函式中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\n目標函式不是異步函式
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.introduced.variable.value=值(&V):
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.parameter.title=提取參數
javascript.introduce.throw.expressions.unsupported=無法呼叫重構。\n“提取”重構中當前不支持 throw 表達式。
javascript.introduce.variable.arrow.await.referenced=無法引入。\n選定內容包含 await 表達式
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\n選定內容包含對箭頭函式參數的參照
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\n選定的表達式類型無效。
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\n選定內容不構成表達式。
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.variable.make.constant=設為常數
javascript.introduce.variable.name.prompt=名稱(&N):
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入區域變數
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位參照
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.invalid.invoker.target=無效呼叫目標
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.kind.unknown=未知元素
javascript.known.props.only=物件字面量只能指定已知屬性，但以下為額外屬性: {0}
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
javascript.label.visibility.public=公共 (&B)
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.cannot.start=無法啟動語言服務程序
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.start.timeout=啟動語言服務程序超時
javascript.language.service.tracking.disabled=錯誤追蹤已停用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.simple.name=JavaScript
javascript.language.term.attribute=特性
javascript.language.term.attribute.value=特性值
javascript.language.term.class=類別
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.constructor=建構函式
javascript.language.term.decorator=裝飾器
javascript.language.term.default.export=預設匯出
javascript.language.term.definition=定義
javascript.language.term.destructuring.property=解構屬性
javascript.language.term.entity.name=實體名稱
javascript.language.term.enum=枚舉
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.external.module.reference=外部模組參照
javascript.language.term.field=欄位
javascript.language.term.file=檔案
javascript.language.term.function=函式
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.import.statement=import 語句
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.inner.class=內部類別
javascript.language.term.inner.function=內部函式
javascript.language.term.inner.interface=內部接口
javascript.language.term.interface=接口
javascript.language.term.jsdoc.tag=JSDoc 標記
javascript.language.term.label=標籤
javascript.language.term.local.const=區域常數
javascript.language.term.local.variable=區域變數
javascript.language.term.method=方法
javascript.language.term.module=模組
javascript.language.term.namespace=命名空間
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.package=軟體套件
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.shorthand.property=速記屬性
javascript.language.term.tag=標記
javascript.language.term.top.level=頂層
javascript.language.term.type.alias=類型別名
javascript.language.term.type.parameter=類型參數
javascript.language.term.variable=變數
javascript.language.term.xml.tag=xml 標籤
javascript.library.built.in=內建
javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.problems.file.text={0}: 修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.prompt=使用 {0} 重新設定所選檔案的格式?
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.configuration.file.title=組態檔案
javascript.linter.error.can.not.find.document=找不到 {0} 的文檔
javascript.linter.error.can.not.find.psi.file=找不到 {0} 的 PSI 檔案
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.no.such.file=沒有此類別檔案
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題:<br/>{1}
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.generic=套用組態檔案中的程式碼樣式規則時出錯，可能是組態檔案無效。
javascript.linter.import.error.package.not.found=找不到 ''{0}'' 軟體套件
javascript.linter.import.error.timeout.processing.configuration.file=處理組態檔案時超時
javascript.linter.import.nothing.to.import={0}: 已套用所有已知規則
javascript.linter.import.notification={0}: 專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.reset=重設
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已還原
javascript.linter.import.notification.rules.applied=套用了以下 {0}: {1}。
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.intention.family.name.show.details={0}: 顯示詳細資訊
javascript.linter.intention.name.details=詳細資訊
javascript.linter.progress.reformatting.with=正在使用 {0} 重新設定格式…
javascript.linter.radio.button.configuration.file=組態檔案(&C):
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.use.severity.from.config.label=使用組態檔案中的規則嚴重性
javascript.member.from.unopened.namespace.message=未開啟命名空間的成員 #loc
javascript.missed.argument.for.parameter=參數 {0} 缺少實參
javascript.missing.read.property=未解析的讀取屬性 #loc
javascript.missing.write.property=未解析的寫入屬性 #loc
javascript.module.dependencies.empty.got.it.text=<div align='left'>當前檔案或目錄沒有任何相依關係。<br/>請嘗試使用其他檔案或目錄。</div>
javascript.module.dependencies.got.it.text=<div align='left'>此圖顯示所選檔案或目錄具有的模組相依關係。<br/>要檢視多個檔案或目錄的相依關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.got.it.title=模組相依關係圖
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
javascript.no.call.signatures=分配的類型不包含呼叫簽名
javascript.not.a.constructor.call.message=不是建構函式呼叫
javascript.object.is.null={0} 為 null
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.undefined={0} 未定義
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制字面量已過時，不建議使用
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制字面量。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制字面量
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制字面量的警告
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函式的 'this.' 對類別欄位的參照存取可能無效
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.private.constructor.is.not.accessible.message=private 建構函式不可存取 #loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.property.is.read.only.message=唯讀屬性 #loc
javascript.property.is.write.only.message=只寫屬性 #loc
javascript.protected.constructor.is.not.accessible.message=protected 建構函式不可存取 #loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.qualified.class.name.expected=應為限定的類別名
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 #loc
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘: ''{0}'' 始終具有類型 ''{1}''
javascript.refactoring.asdoc.for.abstracts=abstract 的 ASDoc
javascript.refactoring.cannot.find.usages.of.definition.to.inline=找不到要內聯的定義的用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式求值
javascript.refactoring.cannot.inline.constructor=無法內聯建構函式
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯解構 rest 變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的解構變數
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函式
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯參照實參的函式
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函式參照的 rest 參數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個離開點的函式
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞迴函式
javascript.refactoring.extract.function.already.exists.in.this.scope=此作用域中已存在 {0}
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個離開點
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.title=提取函式
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.function.to.es6.class.command=將函式 {0} 轉換為類別
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告: 將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”建立的屬性轉換為 ES6 語法可能會影響其可枚舉性和可組態性
javascript.refactoring.inline.all.message=內聯所有參照並移除 {0} ({1}) (&A)
javascript.refactoring.inline.dialog.title=內聯{0}
javascript.refactoring.inline.function.title=內聯函式
javascript.refactoring.inline.this.only=僅內聯此參照並保留 {0}(&K)
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在賦值的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.rename.choose.target.message=您要重新命名哪一個?
javascript.rename.containing.file.message=是否還要將該檔案重命名為 {0}?\n{1} 的用法和 import 語句中的檔案路徑將進行相應更新。
javascript.rename.destructuring.target.dialog.title=速記解構變數使用 {0} 初始化
javascript.rename.element.with.related.elements.title=重新命名 {0}
javascript.rename.reference.intention.name=重新命名參照
javascript.rename.related.declaration.message=是否還要重新命名 {0}?\nimport 語句中的 {0} 用法將進行相應更新。
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.shorthand.target.option.both.label=兩者
javascript.rename.shorthand.target.option.property.label=屬性
javascript.rename.symbol.intention.name=重新命名符號
javascript.report.unused.definitions=報告未使用的定義
javascript.report.unused.properties=報告未使用的屬性
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.service.is.disabled.in.safe.mode=服務在安全模式下被停用
javascript.service.node.error=Node 解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.static.member.is.not.accessible.message=static 成員不可存取 #loc
javascript.strictly.check.global.vars=將未宣告的全域符號報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.surround.with.cast=Type(expr)
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.function=函式
javascript.surround.with.function.expression=函式表達式
javascript.surround.with.if=if
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else=if / else
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.object.literal=物件字面量
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.try.finally=try / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.suspicious.type.guard.desc=類型 guard 檢查不健全
javascript.suspicious.typeof.guard=''typeof'' 檢查無效: ''{0}'' 不能具有類型 ''{1}''
javascript.template.context.type=JavaScript(&R)
javascript.term.does.not.evaluate.to.function=方法表達式不是函式類型
javascript.term.does.not.evaluate.to.function.line.break=表達式不可呼叫。如果這不應是呼叫，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函式呼叫
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.undeclared.variable.name.message=隱式宣告變數 {0} #loc
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
javascript.unknown.metadata.attribute=未知元資料特性
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unresolved.circle.definition=匯入的圓定義
javascript.unresolved.file.or.dir=無法解析 {0} {1}
javascript.unresolved.function.name.message=未解析的函式或方法 <code>{0}()</code> #loc
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.type.name.message=未解析的類型 {0} #loc
javascript.unresolved.variable.name.message=未解析的變數 {0} #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null #loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 #loc
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.validate.imports.name=未解析的已匯入名稱
javascript.validation.destructuring.without.initializer=解構宣告必須有初始設定式
javascript.validation.fqn.to.replace.with.import=限定名稱可被取代為 import 語句
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在產生器正文中使用 'yield' 表達式。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始設定式
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類別 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類別 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類別 {1} 的 abstract set 存取器 {0}
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函式中
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
javascript.validation.message.assignment.to.const=嘗試分配給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生建構函式中呼叫基類別建構函式
javascript.validation.message.baseMethod.before.super.call=超類別建構函式呼叫前不允許有 'super'
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫 final 方法
javascript.validation.message.circular.dependency=迴圈相依關係
javascript.validation.message.class.method.incompatible=''{1}'' 類別中的方法 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一方法
javascript.validation.message.class.method.not.implemented=未實作類別 {1} 的方法 {0}
javascript.validation.message.class.name.expected.here=此處應為類別名
javascript.validation.message.class.property.incompatible=''{1}'' 類別中的屬性 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一屬性
javascript.validation.message.class.property.not.implemented=未實作類別 {1} 的屬性 {0}
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回值類型
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始設定式。以後無法賦予有意義的值。
javascript.validation.message.constructor.cannot.be.static=建構函式不能為 static
javascript.validation.message.constructor.cannot.have.custom.visibility=建構函式應為 public 或未指定可見性
javascript.validation.message.constructor.field.not.allowed=類別可能沒有名為 'constructor' 的非 static 欄位
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.duplicate.catch.block=重複 catch 塊 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.duplicate.declaration.fix.text=導覽到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導覽到上一個宣告
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類別宣告
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函式的頂層使用函式語句
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.validation.message.extend.final.class=無法擴展 final 類別 ''{0}''
javascript.validation.message.extend.multiple.classes=類別不能擴展多個類別
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類別和類別方法
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函式中使用
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回值類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類別 {0} 中的方法
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類別的方法
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回值類型不應為 {0}
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有形參
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的呼叫簽名
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為最終
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回值類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.interface.method.not.implemented=未實作來自接口 {1} 的方法 {0}
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}
javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
javascript.validation.message.missed.super.constructor.call=缺少超類別建構函式呼叫
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類別
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.message.only.one.default.is.allowed=\ switch 中只允許一個預設子句
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函式宣告
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.redeclaration.of.block.scope=不能重複宣告塊作用域變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊作用域變數不能與同一塊作用域中的"var"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 變數不能與其可見性作用域內的塊作用域變數使用相同的名稱
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.redundant.type=顯式類型實參 {0} 可被取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中參照 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許參照 'arguments' 函式屬性
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.return.outside.function.definition='return' 在函式定義外部
javascript.validation.message.return.statement.required=非無效返回值類型必需具備 return 語句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回值類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.set.method.type.is.different.from.getter=set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類別成員使用 static 修飾符
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類別建構函式呼叫應位於建構函式本體中
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中參照了 'super'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類別實例上下文的情況下參照了'super'
javascript.validation.message.this.before.super.call=超類別建構函式呼叫前不允許有 'this'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中參照了 'this'
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.unresolved.component=未解析的組件 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.new.target.not.in.function=僅允許函式宣告、函式表達式或建構函式的本體中有元屬性 'new.target'
javascript.validation.unused.import=未使用的 import
javascript.vector.literal.element.type.mismatch=矢量字面量元素類型 {1} 不可分配給類型 {0}
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
javascript.visibility.public=public
javascript.with.clause.assert.deprecated.message=import 特性的 'assert' 關鍵字已棄用。請改用 'with' 語法。
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率: 找不到 {0}。
jest.coverage.directory.not.found.notification.content=無法從 Jest 組態中讀取 coverageDirectory 選項
jest.coverage.notification.title=Jest 覆蓋率
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.rc.configurationFile.label=組態檔案(&C):
jest.rc.configurationFile.title=選擇 Jest 組態檔案
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env=jsdom
jest.rc.jestOptions.label=Jest 選項:
jest.rc.jestPackageField.label=Jest 軟體套件(&J):
jest.snapshot.label=Jest 快照
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jquery.documentation.not.found=找不到 jQuery 文檔
js.accessibility.check.inspection.name=已參照無法存取的 @private 和 @protected 成員
js.add.braces.to.arrow.function=向箭頭函式中新增大括號
js.add.members.to.type=將成員 {0} 新增到 ''{1}''
js.add.members.to.type.desc=將成員新增到類別或接口
js.add.then.fix=新增 '.then()'
js.align.multiline.extends.list=多行時對齊
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.annotator.assignment.pattern.rhs=賦值模式必須位於賦值的左側
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議新增括號以解決歧義問題。
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作產生器內部的關鍵字
js.anonymous.to.named.function=匿名函式轉換為命名函式
js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函式初始化的組欄位
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函式體周圍的大括號
js.arrow.function.braces.can.be.removed.key=箭頭函式體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函式體周圍的大括號
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.assignment.issues.group.name=賦值問題
js.assignment.used.as.condition.fix=將 ''='' 取代為 ''{0}''
js.assignment.used.as.condition.name=用作條件的賦值
js.assignment.used.as.condition.text=<code>#ref</code> 作為條件使用
js.await-using.in.synchronous.function='await using' 指令只能在 'async' 函式中使用
js.await.in.synchronous.function='await' 運算符只能在 'async' 函式中使用
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.resolve.fix=取代為 ''{0}''
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.blank.lines.around.function=Around 函式:
js.blank.lines.around.method=方法周圍:
js.breadcrumbs.callback.for=\ {0}() 回調
js.chained.call.dot.on.next.line='.' 在新行
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果停用，則所有未鍵入的參數均視為可選參數
js.checkbox.make.readonly=設為唯讀(&R)
js.class.context.type=類別/接口
js.class.member.expression.context.type=類別成員表達式
js.class.member.initialization.inspection.name=在 static 初始設定式中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 參照本身
js.class.member.statement.context.type=類別成員語句
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.invalid.type=類型語法無效
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.code.style.do.not.align.var.statement=不對齊
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.issues.group.name=程式碼樣式問題
js.code.style.object.literals.category.name=物件
js.code.style.punctuation.tab.title=標點
js.code.style.tab.name=JavaScript
js.code.vision.component.usages=組件用法
js.code.vision.component.usages.action=顯示組件用法
js.code.vision.component.usages.description=用於呼叫組件的“尋找用法”的可點擊提示。
js.code.vision.component.usages.tooltip=點擊檢視該組件的用法
js.command.name.auto-import-symbols=自動匯入外部符號
js.commandline.configure.language.version=為專案組態 JavaScript 語言版本
js.commandline.configure.nodejs=組態 NodeJS 解釋器並為 package.json 檔案安裝軟體套件
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函式簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函式簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較的求值結果始終為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較的求值結果始終為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(…)
js.component.usage.in.template.group.display.name=模板中的用法
js.component.usage.type.display.name=組件
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.consecutive.commas.in.array.literal.inspection.message=陣列字面量中的連續逗號
js.consecutive.commas.in.array.literal.inspection.name=陣列字面量中的連續逗號
js.constructor.cant.have.return.type=建構函式不能有返回值類型
js.convert.default.export.to.named.intention.family=將 default export 轉換為命名 export
js.convert.default.export.to.named.intention.working=將 default export 和 import 轉換為命名 export 和 import…
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 呼叫
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.map.to.for.of.intention.family=將 'map' 陣列呼叫取代為 'for..of' 迴圈
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.named.export.to.default.intention.family=Convert named export to default export
js.convert.named.export.to.default.intention.working=Converting Named Export and Imports to the Default…
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非呼叫用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法會覆寫另一個方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的呼叫
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”動作在內部作用域內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部作用域內轉換 require() (例如 'if' 語句或內部函式)
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.to.anonymous.function=轉換為匿名函式
js.convert.to.anonymous.function.family.name=箭頭函式轉換為匿名函式
js.convert.to.arrow.function=轉換為箭頭函式
js.convert.to.es6.class=轉換為類別
js.convert.to.es6.class.family.name=將函式及其成員宣告轉換為類別
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 呼叫
js.convert.to.named.function=轉換為命名函式
js.convert.to.named.function.to.class.method=轉換為類別方法
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”動作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函式器頂部。\n要在使用“全部修復”動作時停用此行為，請選中“保守轉換 var”選項。
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.var.to.let.text=轉換為 let
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.create.derived.type.abstract.class=實作抽象類別
js.create.derived.type.class=建立派生類別
js.create.derived.type.family=建立派生類別/實作接口
js.create.derived.type.interface=實作接口
js.create.switch.cases=建立缺少的 'switch' 分支
js.create.switch.cases.fix=建立缺少的分支: {0}
js.declaration.is.not.at.scope.start=var 語句不在作用域開始
js.declarations.at.scope.start.inspection='var' 未在函式開頭宣告
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.destructuring.merge.inspection=正在解構具有相同鍵的屬性
js.destructuring.merge.inspection.fix=合併解構屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的解構屬性
js.dialect.settings.caption=
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.empty.text=使用 + 按鈕新增目錄，並選擇 JavaScript 版本
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本?
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.tableTitle=語言
js.dialects.customized.label=根據目錄自定義
js.documentation.fires=觸發:
js.documentation.jsdoc.aliases=別名:
js.documentation.jsdoc.dialect=方言:
js.documentation.jsdoc.supported-also-by=還受以下物件的支援:
js.documentation.more.overload=其他 +{0} 個多載
js.documentation.more.overloads=其他 +{0} 個多載
js.dot.property.access.context.type=點號屬性存取
js.duplicate.declaration.inspection.name=重複宣告
js.edit.object.literal=編輯物件字面量屬性的值
js.expand.shorthand.property.quick.fix=展開速記屬性
js.expression.context.type=表達式
js.extends.keyword.wrap=擴展關鍵字
js.extends.list.wrap=Extends 列表
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.file.references.inspection.name=未解析的檔案參照
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉換成 ECMAScript 5
js.fix.change.member.access.to.sharp=使用 '#' 設為 private
js.flow.enable.flow.service.error=\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.message={0}。停用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯: {0}
js.flow.enable.other.services=導覽、程式碼補全和類型提示
js.flow.enable.type.checking=類型檢查
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行醒目提示
js.flow.process.log=Flow 流程日誌
js.flow.services.label=為之使用 Flow 伺服器:
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F):
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中新增 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中新增 .flowconfig
js.flowjs.config.inspection.to.project.path.name=向專案根目錄中新增 .flowconfig
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.flowjs.group.name=Flow 類型檢查器
js.format.cstyle.comments=對齊多行
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類別
js.function.brace.style=在函式宣告中
js.function.call.parentheses=函式呼叫括號
js.function.call.wrap=函式呼叫實參
js.function.declaration.parentheses=函式宣告括號
js.function.expression.brace.style=在函式表達式中
js.function.metrics.group.name=函式指標
js.function.parameters.wrap=函式宣告參數
js.generated.explicit.return.expression.types=函式表達式返回
js.generated.explicit.return.types=函式宣告返回
js.generated.explicit.types=此項的首選顯式類型:
js.generated.explicit.var.types=變數和欄位
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.use.public.modifier=使用 'public' 修飾符
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對 import 排序
js.import.options.use.explicit.js.extension=使用檔案副檔名:
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.no=從不
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 ".js"
js.import.options.use.import-type=在 import 中使用 type 修飾符:
js.import.options.use.import-type.always=始終使用 type
js.import.options.use.import-type.auto=自動
js.import.options.use.import-type.help=此選項用於組態匯入類型時 TypeScript 'import type' 語句或類型說明符的用法。<br><br>選擇“始終使用 type”時，會始終使用 'import type' 或類型說明符。<br> <br>選擇“從不”時，所有類型都會像值一樣匯入，沒有 'type' 關鍵字。<br><br>選擇“自動”時，IDE 會檢查 TypeScript 版本和 tsconfig.json 以選擇最合適的選項。
js.import.options.use.import-type.never=從不
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入(Node 樣式模組解析)
js.imports.dependencies.group.name=Import 和相依項
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice, 0#false|1#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
js.indexer.to.property.intention=取代為屬性存取
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型: 為唯讀檔案
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.inject.dont.format.intention.text=停用注入內容的格式設定
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組相依關係
js.inspection.async.group.name=Async 程式碼和 promise
js.inspection.bitwise.group.name=按位運算問題
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.function.expression.is.used.instead.of.arrow=使用了函式表達式而不是箭頭函式
js.inspection.group.name=一般
js.inspection.group.path=JavaScript 和 TypeScript
js.inspection.missing.amd.dependency=缺少 AMD 模組相依關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組相依關係
js.inspection.package.json.dependencies=package.json 中的相依關係不符合
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 相依項更新為最新版本
js.inspection.promise.ignored.display.name=返回 promise 的方法呼叫結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.inspection.switch.group.name=switch 語句問題
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.join.declaration.assignment.inspection.fix=聯接變數宣告和賦值
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個賦值合併
js.join.vars.intention=加入後續變數宣告
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.jquery.efficiency.inspection.name=可以最佳化 JQuery 選擇器
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.language.version.label=JavaScript 語言版本
js.last.comma.in.array.literal.inspection.name=陣列字面量中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件字面量中的最後一個逗號多餘
js.library.attach.debug=附加偵錯版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.configurable.name=庫
js.library.documentation=文檔
js.library.download.fix=下載庫
js.library.download.stubs.label=TypeScript 社區存根
js.library.downloading.library=正在下載庫
js.library.successfully.downloaded=已成功下載 {0}
js.library.unresolved.url.inspection.name=HTTP 鏈接缺少本地存儲的庫
js.linter.guesser.linter.disabled={0} 已停用。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}: 組態檔案位於專案中。
js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}: ''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}: ''{1}'' 位於 package.json 中。
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和組態檔案
js.linters.inspection.group.name=程式碼品質工具
js.make.single.var.statement=設為單變數語句
js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱:
js.missing.await.symbol.inspection.for.generator.name=異步產生器應使用 for-await 迴圈進行迭代
js.missing.await.symbol.inspection.for.returns=始終對異步函式呼叫使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊追蹤
js.missing.await.symbol.inspection.name=異步函式呼叫缺少 await
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case: {0}
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.module.uml.presentable.name=JavaScript 模組相依項
js.move.to.scope.start=將 var 語句移至作用域開始
js.move.type.to.file.family=移至名稱符合的檔案
js.move.type.to.file.text=將 {0} 移至檔案 {1}
js.named.to.anonymous.family.name=轉換為函式表達式
js.named.to.arrow.text=轉換為含有 {0} 的箭頭函式
js.named.to.function.expression.text=轉換為包含變數的函式表達式
js.named.to.function.hoisting.conflict.text=函式在宣告之前使用。轉換為變數後，將中斷使用
js.nested.template.literal.fix=內聯嵌套字面量
js.nested.template.literal.inspection=模板字面量中的冗餘嵌套
js.node.service.memory.configurable.autoIncrease=Automatically increase memory, if available
js.node.service.memory.configurable.autoIncrease.hint=When more memory is required, {0,number,#} MB will be added and LS will restart. Max limit is {1,number,#} MB
js.node.service.memory.configurable.footer=The setting applies to all TS language services running on <code>node</code>. <a href="{0}">Learn more about LS memory and troubleshooting.</a>
js.node.service.memory.configurable.header=Language Services Memory
js.node.service.memory.configurable.manualIncrease=Set memory limit:
js.node.service.memory.configurable.manualIncrease.MB=MB
js.node.service.memory.configurable.manualIncrease.addMB=Add {0,number,#} MB
js.node.service.memory.configurable.manualIncrease.validation.tooLarge=No available RAM of this size. Use value less than {0,number,#} MB
js.node.service.memory.oom.notification.actions.addMB=Add {0,number,#} MB
js.node.service.memory.oom.notification.actions.configure=組態…
js.node.service.memory.oom.notification.actions.disableAutoIncrease=Disable Auto-Increase
js.node.service.memory.oom.notification.actions.enableAutoIncrease=Enable Auto-Increase
js.node.service.memory.oom.notification.actions.howTo=How to fix manually
js.node.service.memory.oom.notification.autoIncreased=Memory size for Language Services was automatically increased by {0,number,#} MB for this project
js.node.service.memory.oom.notification.content=This impacts essential features, such as autocompletion and code analysis. To resolve the issue, increase the allocated memory.
js.node.service.memory.oom.notification.header=Language Service ran out of memory
js.node.services.profiler.disable=停止 Node.js 服務分析
js.node.services.profiler.enable=啟動 Node.js 服務分析
js.param.hints.blacklist.pattern.explanation=要停用方法或函式提示，請使用下面的其中一種模式: <p style="margin-left: 5px"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類別或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 動作來新增模式。</p>
js.param.hints.show.names.for.all.args=非字面量實參
js.param.hints.show.names.for.literal.args=字面量實參
js.param.hints.show.names.for.pipes=管道運算符
js.param.hints.show.names.for.tagged=標記的模板實參
js.possibly.async.function.inspection=非異步函式中的 'await'
js.possibly.async.function.quick.fix=令函式 {0} 為異步函式
js.possibly.async.function.quick.fix.family.name=將函式設為異步
js.potentially.invalid.constructor.usages.inspection.name=可能無效的建構函式用法
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類別中 'this' 的參照可能無效
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的參照可能無效
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.probable.bugs.group.name=可能的 bug
js.progress.title.auto-importing-symbols-on-paste=貼上時自動匯入外部符號…
js.property.can.be.replaced.with.shorthand=屬性可被取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可被取代為速記方法
js.property.to.indexer.intention=取代為索引器存取
js.pull.up.will.be.made.abstract=非 abstract {0}將被設為 abstract
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.quote=參照
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.unquote=取消參照
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.react.group.name=React
js.redundant.await.inspection=冗餘 'await' 表達式
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解包 'switch' 語句
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中參照可變變數
js.regex.flag.d=符合索引 - 用於子字串符合的索引
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.remove.digit.separators=移除數字分隔符
js.remove.redundant.initializer.fix=移除冗餘的初始設定式
js.remove.unused.assignment=移除未使用的賦值
js.rename.base.member=重新命名基{0}
js.rename.component.usage.provide.name.error=組件名稱應為有效的 JavaScript 關鍵字
js.rename.component.usage.provide.name.message=輸入新組件名稱
js.rename.component.usage.provide.name.title=重新命名組件
js.rename.current.member=重新命名當前 {0}
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.rename.file.to.match.type.name.family=重新命名檔案以符合類型名稱
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫
js.rename.search.for.component.usages=搜尋組件用法(&O)
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板字面量
js.replace.string.with.es6.template=取代為模板字串
js.replace.with.literal=取代為 {0} 字面量
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.search.for.default.imports=正在搜尋 default import…
js.search.for.named.imports=Searching for named imports…
js.searching.for.component.usages=正在搜尋組件用法…
js.separate.bytes=分隔位元組
js.separate.digits=分隔數字
js.separate.nibbles=分隔半位元組
js.separate.thousands=分隔千分位
js.separate.thousands.in.integer.part=分隔整數中的千分位
js.separate.words=分隔 16 位單詞
js.show.dynamic.usages=顯示動態用法
js.show.type.info.action.error=找不到表達式
js.space.before.function.left.brace=函式左大括號
js.spaces.in.flow.category=在 Flow 中
js.split.declarations=拆分宣告
js.split.into.multiple.declarations=拆分為多個宣告
js.statement.context.type=語句
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=新增“use strict”雜註
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.redundant.pragma="use strict"雜註冗餘
js.strict.mode.remove.pragma=移除“use strict”雜註
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.suspicious.bind.with.arrow.function=箭頭函式 'bind' 用法可疑
js.suspicious.eq.plus.fix.name=取代為 '+='
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 賦值: '+=' 可能拼寫錯誤
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 賦值
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=建立缺少的預設分支
js.switch.to.jsx.inspection.dismiss=關閉
js.testing.autoWatch.action.name=監視更改
js.testing.highlight.line=在測試程式碼中醒目提示失敗的行
js.testing.inspection.group.name=單元測試
js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=檢視所有 {0} 個錯誤
js.top.level.await.expression.inspection=頂層 'await' 表達式
js.top.level.await.expression.inspection.description=使用了頂層 'await' 表達式
js.top.level.statement.context.type=頂級語句
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時新增
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.undefined.property.assignment.inspection.name=未定義的屬性賦值
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始設定式跳過參照迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.unnecessary.semicolon.fix.name=移除不必要的分號
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 #loc
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.unresolved.variable.inspection.name=未解析的參照
js.unused.assignment.inspection.name=未使用的賦值
js.unused.es6.import.inspection.name=未使用的 import
js.unused.global.symbol.inspection.name=未使用的全域符號
js.unused.local.symbol.inspection.name=未使用的區域符號
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL:
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.name=使用了 URL 匯入
js.usage.type.call=函式呼叫中的用法
js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的參照
js.validate.signature.inspection.name=簽名不符合
js.validate.types.inspection.name=類型不符合
js.validity.issues.group.name=有效性問題
js.value.assigned.is.never.used=從未使用過所賦之值 #loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 #loc
js.variable.initializer.is.redundant=變數初始設定式冗餘 #loc
js.variable.might.not.been.initialized=變數可能尚未初始化 #loc
js.variable.problems.ignore.desc=對可變變數忽略
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時參照錯誤
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.void.function.result.used.description=使用了 void 函式返回值
js.void.function.result.used.name=使用了 void 函式返回值
js.wrap.settings.class.decorators=類別裝飾器
js.wrap.settings.class.field.decorators=類別欄位裝飾器
js.wrap.settings.class.method.decorators=類別方法裝飾器
js.wrap.settings.function.parameter.decorators=函式參數裝飾器
js.wrap.settings.import=ES6 匯入/匯出
js.wrap.settings.object.types=物件類型
js.wrap.settings.union.and.intersection.types=聯合體與相交類型
js.wrap.settings.var.group.name=變數宣告
jshint.clear.field.to.disable=清除要停用的欄位
jshint.config.default.description=<div style="padding-bottom:10px"><div><b>.jshintrc</b></div><div style="padding-left:10px; padding-top:4px;">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的目錄開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style="padding-left:10px; padding-top:4px;">將您的組態新增到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.error.cannot.locate.ext.config=JSHint: 無法定位擴展組態
jshint.config.error.cannot.parse.ext.config=JSHint: 無法解析擴展組態
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.extends.cyclically=JSHint 組態迴圈擴展
jshint.config.failed.to.read=無法讀取 JSHint 組態
jshint.config.option.custom.browser.title=選擇 JSHint 組態檔案 (*.jshintrc)
jshint.config.option.custom.name=自訂組態檔案
jshint.config.option.default.name=預設
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>組態 HTTP 代理</a>或<a href=''{1}''>重試</a>
jshint.exception.balloon.action.retry=<a href=''{0}''>重試</a>
jshint.illegal.integer=非法整數
jshint.inspection.message.config.not.found=未找到 JSHint 組態
jshint.inspection.message.duplicate.options=重複 JSHint 選項: {0}，{1}。
jshint.inspection.message.expected.value=預期值: {0}
jshint.inspection.message.expected.values.x.or.y=預期值: {0} 或 {1}
jshint.inspection.message.malformed.config=JSHint 組態格式錯誤
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.prefix=JSHint:
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.label.bundled.suffix=(捆綁)
jshint.label.no.version=無版本
jshint.latedef.false.text=不警告
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函式宣告。</body></html>
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部賦值的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.debug.description.short=禁止有關偵錯模式的警告
jshint.option.devel.description.short=開發
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的組態時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.eqnull.description.short=禁止有關 <code>== null</code> 的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.immed.description.short=有關未使用括號包裝函式而直接呼叫函式的警告
jshint.option.indent.description.short=縮排
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函式在迴圈內部的警告
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.maxlen.description.short=行的最大長度
jshint.option.maxparams.description.short=函式中的最大參數數量
jshint.option.maxstatements.description.short=函式中的最大語句數量
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.newcap.description.short=有關使用非大寫形式的建構函式的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.nonbsp.description.short=有關“不間斷空格”字元的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.noyield.description.short=禁止在產生器函式中無 yield 語句時有關產生器函式的警告
jshint.option.onevar.description.short=每個函式一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.predef.description.short=預定義(以 , 分隔)
jshint.option.predef.details=指定全域變數及其可分配狀態:\n<pre>DISQUS:true、jQuery:false</pre>\n<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.quotmark.description.short=引號
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”建構的警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.typed.description.short=輸入的陣列
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.progress.title=JSHint {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.quotmark.double.text=僅允許雙引號
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.suppress.text.suppress.for.line=禁止行
jshint.tree.link.set=設定
jshint.unused.false.text=不檢查任何內容
jshint.unused.strict.text=檢查所有變量和參數
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函式參數
jshint.use.config.files=使用組態檔案
jshint.version.label=版本(&V):
jsx.code.style.attribute.default.value=為 JSX 特性新增:
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.typebased=基於類型
jsx.convert.html.attributes.to.jsx=將程式碼貼上到 JSX 檔案時關閉 HTML 單一標記
jsx.convert.html.attributes.to.react=將程式碼貼上到 React JSX 檔案時轉換 HTML 特性名稱
jsx.convert.html.to.jsx.command.name=將 HTML 程式碼轉換為 JSX
jsx.convert.html.to.jsx.progress=正在將 HTML 程式碼轉換為 JSX…
jsx.dom.nesting.inspection.message=''{0}'' 不能作為 ''{1}'' 的子級出現
jsx.dom.nesting.inspection.message.text=文本節點不能顯示為 ''{0}'' 的子級
jsx.dom.nesting.inspection.message.tr=''{0}'' 不能作為 ''{1}'' 的子級出現。在您的程式碼中新增 <tbody>、<thead> 或 <tfoot> 以符合瀏覽器生成的 DOM 樹。
jsx.dom.nesting.inspection.name=無效的 DOM 元素嵌套
jsx.html.context.type=JSX HTML
jsx.missing.namespace.inspection.name=缺少 JSX 命名空間
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
jsx.syntax.used.description=已使用 JSX 語法
jsx.syntax.used.name=已使用 JSX 語法
jsx.unresolved.component.name=未解析的 JSX 組件
jsx.unresolved.prop.name=未解析的 JSX 屬性
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
label.exclude.methods.classes=排除類別方法:
label.import.popup=自動匯入工具提示
label.method.should.be.defined=方法應已定義
label.minimum.language.level=最低語言級別:
label.name.injection=名稱(&N):
label.namespace=命名空間:
label.path=路徑(&P):
label.wsl.node.interpreter=WSL Node.js 解釋器(&N):
linemarker.implemented=已實作
linemarker.implementing=實作
linemarker.implements.invalid=<無效>
linemarker.implements.several=實作多種接口方法
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.javascript.sources=JavaScript 源
linemarker.javascript.typescript=JavaScript/TypeScript 行標記
linemarker.overridden=覆寫
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.overriding=覆寫
linemarker.typescript.declaration=TypeScript 宣告
list.item.class.field=類別欄位
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類別成員的函式成員的宣告
list.item.declarations.that.were.not.converted=未轉換的宣告
list.item.function.converted.to.class=轉換為類別的函式
list.item.function.to.be.converted.to.class=要轉換為類別的函式
list.item.global.or.module.constant=全域或模組常數
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.file=JavaScript 檔案
list.item.javascript.jsx.file=JSX 檔案
list.item.javascript.standard.style=JavaScript 標準樣式
list.item.local.constant=區域常數
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
live.template.con.description=帶 props 實參的建構函式
live.template.fsc.description=React Flow 箭頭函式組件
live.template.fsf.description=React Flow 函式組件
live.template.props.description=this.props.
live.template.rcc.description=React 類別組件
live.template.rccp.description=帶有 PropTypes 的 React 類別組件
live.template.rcfc.description=帶有 PropTypes 和生存期方法的 React 類別組件
live.template.rsc.description=React 箭頭函式組件
live.template.rscp.description=帶有 propTypes 的 React 箭頭函式組件
live.template.rsf.description=React 函式組件
live.template.rsfp.description=帶有 propTypes 的 React 函式組件
live.template.rsi.description=帶有隱式 return 的 React 箭頭函式組件
live.template.state.description=this.state.
livetemplate.description.arf=使用箭頭函式包圍
livetemplate.description.console.assert=console.assert()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.log=console.log()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.warn=console.warn()
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.fori=建立迭代迴圈
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.moduleexports=匯出語句 - module.exports = a
livetemplate.description.ref=插入參照路徑註釋
livetemplate.description.ritar=以相反順序遍歷陣列的元素
livetemplate.description.us=插入 'use strict' 語句
lsp.executable.error=找不到 {0} 的可執行檔案。
lsp.interpreter.error=未組態本地或 WSL Node.js 解釋器。
macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)
make.method.static=設為 'static'
make.private=設為 private
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
merged.process.output.text={0}{2, choice, 0#\n\n標準錯誤:\n{1}|1#}{4, choice, 0#\n\n標準輸出:\n{3}|1#}\n\n{5}
method.return.types.in.call.chains=呼叫鏈中的函式返回值類型
modules.selected=選定
move.members.dialog.title=移動成員
move.members.refactoring.name=移動成員
multiple.inheritance=多重繼承
new.actionscript.class.dialog.title=新增 ActionScript 類別
new.actionscript.interface.dialog.title=新增 ActionScript 接口
new.constructor.action.description=建立建構函式
new.constructor.action.text=建構函式
new.field.action.description=在類別中建立新字段
new.field.action.text=欄位
new.method.action.description=在類別中建立新方法
new.method.action.text=方法
no.candidates=無候選項
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可執行檔案
no.members.to.implement=找不到要實作的成員
no.members.to.override=找不到要覆寫的成員
no.methods.to.implement=找不到要實作的方法
no.methods.to.override=找不到要覆寫的方法
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組: 已超時
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 延伸模組
node.core.navigate_action_text.text=組態 Node.js…
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組組態
node.debug.cannot_connect_to_vm.error.message=無法連線到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.download.broken.installation.error=Node.js 安裝損壞。
node.download.cannot_find_interpreter.error=找不到已下載的 Node.js 解釋器。
node.download.dialog.error.failed_to_fetch_versions=無法提取可用的 Node.js 版本
node.download.dialog.full.version.label=版本:
node.download.dialog.location.description=選擇下載 Node.js 的路徑:
node.download.dialog.location.error.blank=位置路徑為空
node.download.dialog.location.error.existing_non_empty_directory=位置指向現有的非空目錄
node.download.dialog.location.error.failed_to_resolve=無法解析位置
node.download.dialog.location.error.file.exists=位置指向現有檔案
node.download.dialog.location.label=位置:
node.download.dialog.major.version.label=發佈:
node.download.dialog.no_version.label=無版本
node.download.dialog.ok_text=下載
node.download.dialog.released_on.label={0} 發佈
node.download.dialog.unavailable.label=不可用
node.download.download.cancelled.error=動作已被取消。
node.download.editor.suggestion={0} 需要 Node.js 才能正常工作。
node.download.failure.notification=無法下載 Node.js {0}。{1}
node.download.fetching.version=正在提取 Node.js 版本…
node.download.node.archive=正在下載 Node.js {0}
node.download.open.settings=開啟設定
node.download.success.notification=Node.js {0} 已組態。
node.download.supported_later.platform=Node.js 在版本 {2} 或更高版本中支援 {0}，{1}
node.download.unsupported.platform=Node.js 不支持 {0}，{1}
node.execution.failed.to.prepare.target.environment.error=無法準備環境: {0}
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.interpreter.command_timed_out.dialog.message=''{0}'' 指令執行超時(>{1} 毫秒)
node.interpreter.download=下載 Node.js
node.interpreter.field.add.item.text=新增…
node.interpreter.field.popup.download.item=下載…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.label=Node 解釋器(&I):
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.interpreter.node_from_path.reference.name=node
node.interpreter.not.found=找不到 {0}
node.interpreter.project_node.reference.name=專案
node.interpreter.reference_not_found.text=未找到
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
node.interpreter.unavailable.target=不可用的目標: {0}
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_interpreter_with_link.dialog.message=指定 <a href="">Node.js 解釋器</a>
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.js.add.interpreter.action=新增{0}…
node.js.configure.interpreter=組態{0}
node.js.downloading=正在下載 Node.js {0}
node.js.inspection.group.name=Node.js
node.js.interpreters=Node.js 解釋器
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.missing.require=缺少 require() 語句
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發相依關係
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組: 請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組: {0}
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.text=安裝 ''{0}''
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發相依關係
node.js.quickfix.run.command=執行 ''{0}''
node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器延伸模組。請啟用 {0} 中的延伸模組
node.js.select.file=選擇 {0} 檔案
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.unresolved.api=未解析的 Node.js API
node.no.interpreter=無解釋器
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑: 無此類別目錄“{0}”
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.package_manager_link.text=軟體套件管理器
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處參照專案 npm 軟體套件
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.package.binary.file.hint=指向 {0} 的二進制檔案的路徑
node.package.cannot.find.bin.file.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
node.package.dropDownList.select=選擇…
node.package.empty.error.message=專案名稱為空
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.field.not_found.text=未找到
node.package.manager.label=軟體套件管理器 (&M):
node.package.name.URL-friendly.characters.error.message=專案目錄名稱應僅包含適用於 URL 的字元
node.package.name.capital.letters.error.message=專案目錄名稱不應包含大寫字母
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.leading.or.trailing.spaces.error.message=專案目錄名稱不應包含前導空格或尾隨空格
node.package.name.period.error.message=專案目錄名稱不應以句點開頭
node.package.name.special.characters.error.message=專案目錄名稱不應包含特殊字元("~'!()*")
node.package.name.too.long.error.message=專案目錄名稱不應超過 214 個字元
node.package.name.underscore.error.message=專案目錄名稱不應以下劃線開頭
node.package.none=無軟體套件
node.package.selector.multiple.packages.binary.file.title=選擇 {0} 的軟體套件目錄或二進制檔案
node.package.selector.multiple.packages.description=選擇 {0}
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package_documentation.installed_version.text=已安裝版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連線(可能被防火牆阻止)。\n要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
node.wsl.unavailable.dialog.message=WSL 不可用
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號: {0}</html>
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號: {0}</html>
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.parenthesized.single.parameter=未使用括號括起來的單個參數
non.parenthesized.single.parameter.description=未使用括號括起來的單個參數
not.installed.package=未安裝軟體套件
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>顯示檢查設定</a>或<a href='undo'>撤消</a></html>
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.show.details=顯示詳細資訊
notification.group.code.vision.performance.watcher=JavaScript: Code Vision 性能觀察程序
notification.group.grunt.console=Grunt 'watch' 任務狀態已更改
notification.group.jest=Jest 測試執行失敗
notification.group.linters=JavaScript linter
notification.group.narrowed.types=JavaScript: 已停用限縮的類型的著色
notification.group.nodejs.assistance=Node.js 編碼輔助失敗
notification.group.nodejs.interpreter=Node.js 解釋器路徑已更新
notification.group.package.json=來自 package.json 的相依項可用
notification.group.package.json.disabled=來自 package.json 的相依項: 通知已停用
notification.group.project.generator=JavaScript 專案生成失敗
notification.group.vitest=Vitest 測試執行失敗
notification.title.cannot.download.types.node=無法下載 @types/node
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.generate=無法生成 {0}
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被停用
notify.urls.more=…和其他 {0,number} 個
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice, 0#腳本|1#腳本|2#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.downloading_package=正在下載 {0}…
npm.failed_to_install_package.title.message=無法安裝 {0}
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 相依關係中未列出模組
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義
npm.modules.install.global.types.directory.error=無法建立所需的目錄
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
npm.no.scripts.found=未找到腳本
npm.rc.command.label=指令:(&C)
npm.rc.environmentVariables.label=環境:
npm.rc.nodeInterpreter.label=Node 解釋器(&I):
npm.rc.nodeOptions.label=Node 選項:
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.packageJson.label=package.json(&P):
npm.rc.scripts.label=腳本 (&T):
npm.rc.scriptsArguments.label=實參(&R):
npm.searching_for_previously_installed_package=正在搜尋先前安裝的 {0}…
npm.task.title=NPM 腳本
numeric.enum.values=數值枚舉值
package.description=軟體套件 {0}
package.downloader.create.package.directory=正在建立軟體套件目錄…
package.json.install.types.fix.family.name=為軟體套件安裝 @types
package.version.range.hint={0, choice, 0#允許|1#允許次要更新:|2#允許補丁更新} {1} ≤ 版本 \\&lt; {2}
package.version.range.info={0, choice, 0#未安裝|1#已安裝: ?|2#已安裝: {1}}，最新: {2, choice, 0#正在載入…|1#找不到|2#{3}}
package_json.install_dependencies.notification.content=來自 {0}
package_json.install_dependencies.notification.title=安裝相依項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.notifications_are_disabled.notification.content=已停用從 {0} 安裝相依項的通知。<p>使用“{1}”動作重新啟用通知。
package_json.update_dependencies.notification.title=更新相依項
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\n是否繼續?
parameters.in.parentheses=圓括號中的參數
parameters.in.parentheses.description=圓括號中的參數
please.specify.package.manager=指定<a href="">軟體套件管理器</a>。
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
popup.title.choose.class=選擇類別
popup.title.select.destructuring.assignment.target=選擇解構賦值目標
popup.title.target.function=目標函式
postfix.template.condition.array.name=陣列
postfix.template.condition.non.void.name=非 Void
postfix.template.provider.name=JavaScript 和 TypeScript
process.terminated=程序已終止
progress.subtitle.install=正在通過 {1} 安裝 {0}…
progress.text.initializing.opened.files=正在初始化開啟的檔案
progress.text.modifying=正在修改 {0}
progress.text.processing=正在處理 {0}{1}
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
progress.title.configuring.node.js.coding.assistance=正在組態 Node.js 編碼輔助…
progress.title.detect.overridden.methods=檢查覆寫方法
progress.title.downloading.documentation=正在下載文檔
progress.title.downloading.library=正在下載庫
progress.title.downloading.typings=正在下載 typings
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
progress.title.find.usages=正在尋找用法…
progress.title.install=安裝 {0}
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
project.generation=生成專案
protractor.rc.configurationFile.label=組態檔案(&C):
protractor.rc.configurationFile.title=選擇 Protractor 組態檔案
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement
protractor.rc.protractorOptions.label=Protractor 選項 (&O):
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P):
rc.browser.error.unspecified.url.text={0} 中未指定 URL
rc.browser.liveEdit.tab.name=瀏覽器 / Live Edit
rc.configuration.tab.name=組態
rc.environmentVariables.label=環境變數(&E):
rc.nodeOptions.label=Node 選項 (&O):
rc.testConfig.presentable.name={0} 中的所有測試
rc.testDirectory.presentable.name={0} 中的測試
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testOrSuiteScope.suite.label=套件名稱:
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.test.label=測試名稱:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.directory=目錄(&D)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.testRunScope.testDirectory.browseTitle=選擇測試目錄
rc.testRunScope.testDirectory.label=測試目錄:
rc.testRunScope.testFile=測試檔案(&F)
rc.testRunScope.testFile.browseTitle=選擇測試檔案
rc.testRunScope.testFile.label=測試檔案:
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.workingDirectory.label=工作目錄(&W):
recursive.call=遞迴呼叫
refactoring.destructuring.vars.for.refactor.this=物件或陣列解構…
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，醒目提示顯示的 const 變數將轉換為 let 變數。\n是否要繼續?
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.deconstruct=生成解構模式
refactoring.destructuring.vars.intention.depropagate=將解構取代為屬性和索引存取
refactoring.destructuring.vars.intention.guard.conflict=通過類型 guard 將表達式類型限縮為 ''{0}''，該類型 guard 在重構後將不起作用
refactoring.destructuring.vars.intention.name=引入物件或陣列解構
refactoring.destructuring.vars.intention.name.array=引入陣列解構
refactoring.destructuring.vars.intention.name.object=引入物件解構
refactoring.destructuring.vars.intention.propagate=傳播到解構宣告
refactoring.destructuring.vars.intention.replace.array=取代為數組解構
refactoring.destructuring.vars.intention.replace.object=取代為物件解構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.replace.shorthand=取代為解構和速記屬性
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
remove.type.prefix=移除類型前綴
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''?
rename.accessors.dialog.title=重新命名欄位
rename.css.definition.description=檢測到 CSS 類型宣告的用法。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.css.definition.title=重新命名類型宣告成員
rename.destructuring.property.description=解構屬性參照多個成員。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.destructuring.property.title=重新命名解構屬性
rename.prompt.do.you.want.to.rename.base.method=是否要重新命名基方法?
rename.react.hook.variable.description=將相關狀態變數重命名為:
rename.react.hook.variable.title=重新命名狀態變數
rename.type.members.destructuring.description=檢測到解構屬性中的用法。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重新命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合體、相交或映射類型用法。應重新命名相關屬性，否則可能導致程式碼不一致。
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
return.type.is.not.resolved=返回值類型 ''{0}'' 未解析。\n是否繼續?
service.configurable.default={0} (預設)
service.highlighting.progress={0} 服務醒目提示顯示
settings.code.style.Trailing.comma=尾隨逗號(&T):
settings.code.style.always=始終
settings.code.style.dont.use=不使用
settings.code.style.double=雙
settings.code.style.in.new.code=在 IDE 生成的程式碼中
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式呼叫
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.option.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.semicolon.to.terminate.statements=分號(&S)
settings.code.style.single=單
settings.code.style.use=使用
settings.javascript.field.names.completion=為類別欄位建議名稱 (&F)
settings.javascript.lang.templates.configurable.name=模板
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 組態 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父目錄位於同一目錄中的 {2} 組態檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 組態 (&M)
settings.javascript.linters.autodetect.disabled=停用 {0}(&D)
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.eslint.configurable.name=ESLint
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選鏈接的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.root.configurable.name=JavaScript
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types=為建議的參數名稱新增類型註解(&T)
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.for.params=具有函式參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A):
settings.nodejs.coding.assistance.manage.scopes.label=管理作用域…
settings.nodejs.name=Node.js
settings.typescript.root.configurable.name=TypeScript
space.after.dots.in.rest.spread=在 rest/spread 中的 '…' 後面
space.after.generator.mult=在產生器中的 '*' 後面 
space.after.name.value.separator=在屬性名稱-值分隔符 ':' 後面
space.after.type.colon=在類型參照冒號 ':' 後面
space.before.class.interface.module.lbrace=類別/接口/模組左大括號
space.before.class.lbrace=類別的左大括號
space.before.function.left.parenth=在函式表達式中
space.before.generator.mult=在產生器中的 '*' 前面 
space.before.name.value.separator=在屬性名稱-值分隔符 ':' 前面
space.before.type.colon=在類型參照冒號 ':' 前面
spaces.after.unary.not=在 'not' (!) 和 '!!' 後面
spaces.arrow.function=箭頭函式(=>)
spaces.async.arrow.function=在異步箭頭函式中
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
spaces.within.array.initializer=陣列中括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.interpolation.expressions=插值表達式
spaces.within.object.literal.braces=物件字面量大括號
spaces.within.object.type.braces=物件字面量類型大括號
spaces.within.type.assertion=類型斷言
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.within.union.and.intersection=聯合體與相交類型
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.codestyle.updated={0}: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 相依項更新
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.editor.notification.action=是
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式?
standardjs.editor.notification.do.not.show.text=否
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.name=標準程式碼樣式
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串內插
status.text.add.interpreter.with=使用 {0} 新增解釋器
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
status.text.javascript.language.service.suggestions=顯示建議
status.text.no.interpreters.added=未新增解釋器
status.text.project.structure.isn.t.available=專案結構不可用
status.text.running.which.node=正在執行 `which node`…
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
status.text.service.is.not.started=服務未啟動
structural.search.anonymous.functions=匿名函式
structural.search.classes=類別
structural.search.comparison.to.self=與自身比較
structural.search.console.log.calls=呼叫 console.log()
structural.search.constants=常數
structural.search.empty.functions=空函式
structural.search.function.calls=函式呼叫
structural.search.functions=函式
structural.search.functions.with.boolean.parameters=使用布爾參數的函式
structural.search.var.statements=Var 語句
structural.search.variables=變數
structural.search.while.loops=While 迴圈
structural.search.with.statements=With 語句
successfully.downloaded=已成功下載
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類別
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 組件中提取超類別。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類別
superclass.label.text=超類別(&S):
tab.title.compile.errors=編譯錯誤
tab.title.convert.to.class=轉換為類別
tab.title.project.errors=專案錯誤
tab.title.refactoring.preview=重構預覽
tab.title.refactoring.result=重構結果
template.add.imports=新增明確的 import
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根目錄新增到 {0}
testing.select.in.test.tree.name=在測試樹中選擇 ''{0}''
testing.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
testing.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
testing.snapshot.update.test.file.text=<link>點擊以更新 {0} 中所有失敗的快照</link>
text.cannot.download=無法下載 {0}。{1}
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
titled.separator.predefined=預定義
top.level.package=頂層軟體套件
ts.add.import.all.family.name=新增所有 import
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 新增匯入
ts.add.import.hint.text=使用 {1} 新增 {0}
ts.add.import.statement.dialog.title=新增 import 語句
ts.change.import.action.command=更改匯入
ts.change.import.action.dialog.title=匯入自…
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.one.title=更改為 {0}
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.generate.reference.path.name=生成參照路徑註釋
ts.param.hints.blacklist.pattern.explanation=<b>棄用通知</b>: <p style="margin-left: 5px">從 TypeScript 4.4 開始，<code>provideInlayHints</code> 服務方法用於呈現提示。該方法有自己的啟發式方法；因此，不再使用此排除列表。
ts.param.hints.show.names.for.literal.args=字面量實參
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
ts.unresolved.variable.inspection.name=未解析的 TypeScript 參照
type.annotations=類型註解
type.is.not.resolved=類型 ''{0}'' 未解析。\n是否繼續?
typescipt.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 tsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會為已定義別名的檔案之間的 import 使用相對路徑。在所有其他檔案中，將使用路徑映射。<br><br>選擇“從不”時，將從不使用別名。
typescript.abstract.class.constructor.can.be.made.protected=抽象類別建構函式可以設為 protected
typescript.auto.import.options.add.imports=自動新增 TypeScript import
typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.dialog.title=選擇 tsconfig.json
typescript.before.task.config.path=組態檔案:
typescript.before.task.title=TypeScript 編譯設定
typescript.code.style.tab.name=TypeScript
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.all.compile.config=組態 {0} 的編譯檔案
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.compile.with.ellipsis=編譯…
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案參照
typescript.compiler.before.run=編譯 TypeScript
typescript.compiler.configurable.name=TypeScript
typescript.compiler.configurable.options.command.line=選項:
typescript.compiler.configurable.options.command.line.localeNotSupportedForBundled=捆綁的 TypeScript 不支持區域設定
typescript.compiler.configurable.options.info.tsGo.local=<div>要使用本地克隆的 <a href='https://github.com/Microsoft/typescript-go/'>TypeScript-Go</a>，請先根據<a href='https://github.com/microsoft/typescript-go?tab=readme-ov-file#how-to-build-and-run'>說明</a>進行建置。</div><div>或者，您可以嘗試使用 <a href='https://github.com/microsoft/typescript-go?tab=readme-ov-file#preview'><code>@typescript/native-preview</code></a> 軟體套件。</div>
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.use.servicePoweredTypeEngine=啟用服務驅動的類型引擎
typescript.compiler.configurable.options.use.servicePoweredTypeEngine.comment=一種混合機制，結合了內部 IDE 模型<br>和語言服務的強大功能，以提高性能和類型推斷。<br>設定時需要啟用語言服務。
typescript.compiler.configurable.options.use.types.from.server=使用伺服器中的類型
typescript.compiler.configurable.options.use.types.from.server.description=啟用基於 TypeScript 編譯器的評估。
typescript.compiler.configurable.options.use.types.from.server.tsGoWarning=“啟用服務驅動的類型引擎”將被忽略，因為其尚不支持 TypeScript-Go
typescript.compiler.configurable.options.use.types.from.server.versionWarning=“啟用服務驅動的類型引擎”將被忽略，因為所選 TypeScript 版本低於 4.5
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.version.bundled=已捆綁
typescript.compiler.loading.project=正在載入專案 {0}
typescript.compiler.starting=TypeScript 正在啟動…
typescript.compiler.structure.tab.title=結構
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.config.inspection.config.options.fix=向 tsconfig.json 中新增 ''{0}''
typescript.config.inspection.fix.pattern=新增 ''{0}'' 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.duplicate.typescript.union.inspection.name=重複的聯合體或相交類型組件
typescript.explicit.member.type.inspection.name=顯式類型
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的賦值
typescript.field.can.be.made.readonly=可以為唯讀欄位
typescript.fix.change.member.access=設為 ''{0}''
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
typescript.go.bad.package=在 {0} 中找不到 TypeScript-Go 軟體套件
typescript.go.name=TypeScript-Go
typescript.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會始終向 vue 檔案、來自在 tsconfig.json 中具有 "module": "node16" 或 "module": "nodenext" 和在 package.json 中具有 "type": "module" 的專案的檔案，以及擴展名為 .mts 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向 TypeScript 檔名新增 .js 副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
typescript.import.options.paths=使用 tsconfig.json 的路徑映射:
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.insert.cast.fix=插入類型斷言
typescript.insert.type.guard.fix.family=插入類型 guard
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.inspection.group.name=TypeScript
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
typescript.language.service.clean=正在重設快取…
typescript.language.service.compile.file=正在編譯檔案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤… {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤… {0}
typescript.language.service.compile.project.open.file=正在開啟檔案… {0}
typescript.language.service.name=TypeScript 服務
typescript.language.simple.name=TypeScript
typescript.make.constructor.protected=將建構函式設為 protected
typescript.make.field.readonly=將欄位設為唯讀
typescript.missing.augmentation.import=缺少擴大匯入
typescript.narrowed.to=範圍限縮至 ''{0}''
typescript.private.field.modifiers.mix=使用不公開名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.reference.to.umd.global=已參照的 UMD 全域變數
typescript.remove.type.declaration=移除類型宣告
typescript.rename.dynamic.references=搜尋動態參照 (&D)
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案參照
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.type.explicitly=顯式指定類型
typescript.suspicious.constructor.parameter.assignment=建構函式中的參數賦值可疑。您是否忘記了新增 'this.'?
typescript.suspicious.constructor.parameter.assignment.desc=已分配建構函式欄位參數
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效: ''{0}'' 的類型與 ''{1}'' 無關
typescript.type.guard.name=變數類型限縮為類型 guard
typescript.type.guard.name.disable=停用範圍限縮的類型的著色
typescript.type.predicate.destructuring=類型謂詞不能參照綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.not.return=僅函式和方法的返回值類型位置允許類型謂詞
typescript.type.predicate.rest=類型謂詞不能參照 rest 參數
typescript.type.this.predicate.not.return=僅類別或接口成員、get 存取器或函式和方法的返回值類型位置允許基於 'this' 類型的謂詞。
typescript.types.intersection=相交
typescript.types.key=鍵參照
typescript.types.mapped=映射
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.merged.parts=參照的屬性:
typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
typescript.types.type.member={0} 類型屬性
typescript.types.union=聯合體
typescript.validate.generic.types.fix.add=新增泛型實參
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始設定式
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
typescript.validation.async.incorrect.type.annotation=異步函式不能有 ''{0}'' 類型註解
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參
typescript.validation.class.extend.constructor.return.not.class=基類別建構函式返回值類型 ''{0}'' 不是類別或接口類型。
typescript.validation.class.extend.cycled.definition=迴圈類別定義
typescript.validation.class.extend.many.constructors=基類別建構函式必須具有相同的返回值類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類別建構函式具有指定數量的類型實參
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是建構函式類型
typescript.validation.dissatisfies.type.annotation=類型 ''{0}'' 不滿足預期類型 ''{1}''
typescript.validation.expressionWithTypeArguments.compatibleSignatureNotFound=找不到相容的簽名
typescript.validation.generators.ambient=環境上下文中不允許使用產生器
typescript.validation.generators.async.no.yield=產生器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.no.yield=產生器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.overload=多載簽名無法被宣告為產生器
typescript.validation.incorrect.rhs.in.private.brand=右側必須是一個物件，實際為: ''{0}''
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符一起使用
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.class.be.created=無法建立抽象類別 ''{0}'' 的實例
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在抽象類別中
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=建構函式不能為 'abstract'
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.function.implementation.missing=缺少函式實作或此宣告之後未緊隨函式實作
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
typescript.validation.message.misordered.in.modifier='in' 修飾符必須在 'out' 修飾符之前。
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration=類型為 'unique symbol' 類型的類別的屬性必須同時為 'static' 和 'readonly'
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration.fix.add.static.readonly=新增 static 和 readonly 修飾符
typescript.validation.message.unique.symbol.mutable.property.signature=如果接口或類型字面量的類型是 'unique symbol' 類型，則其屬性必須為 'readonly'
typescript.validation.message.unique.symbol.mutable.variable=類型為 'unique symbol' 類型的變數必須為 'const'
typescript.validation.message.unique.symbol.wrong.usage=此處不允許使用 'unique symbol' 類型
typescript.validation.module.reference.with.extension=外部模組參照不能以擴展結束
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unresolved.project.interpreter.notification.content=要正常工作，{0} 需要 Node.js，但在您的計算機上找不到 Node.js。
unresolved.project.interpreter.notification.download.action.text=下載 Node.js
unresolved.project.interpreter.notification.download.action.url=https://nodejs.org/en/download
unwrap.with.kind=解包 ''{0}…''
variables.and.fields=變數和欄位
variables.and.fields.description=變數和欄位
varible.name.column.title=名稱
varible.value.column.title=值
visibility.level.details=詳細資訊
visibility.level.overview=概覽
vitest.coverage.cannot.copy.lcov.info.notification.content=無法顯示 Vitest 覆蓋率: 無法複製檔案。
vitest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Vitest 覆蓋率: 找不到 {0}。
vitest.coverage.directory.not.found.notification.content=無法從 Vitest 組態中讀取 coverageDirectory 選項
vitest.coverage.notification.title=Vitest 覆蓋率
vitest.coverage.presentable.text=Vitest 覆蓋率
vitest.rc.configurationFile.label=組態檔案(&C):
vitest.rc.configurationFile.title=選擇 Vitest 組態檔案
vitest.rc.vitestOptions.emptyText=CLI 選項，例如 --watch 或 --ui
vitest.rc.vitestOptions.label=Vitest 選項:
vitest.rc.vitestPackageField.label=Vitest 軟體套件(&V):
vitest.snapshot.update.rc.name=更新 {0} 的快照
web.bundler.analyzing.configs.progress=正在分析 Web 捆綁程序的組態檔案
web.bundler.cannot.analyze=無法分析 {0}: 編碼輔助將忽略此檔案中的模組解析規則。
web.bundler.error.details=錯誤詳細資訊: {0}
web.bundler.failed.to.load=無法載入 {0}
web.bundler.possible.reasons=可能的原因: 此檔案不是有效的組態檔案，或者 IDE 目前不支持其格式。
web.template.file-type.description={0} 模板
yarn.package_requires_yarn.dialog.message=軟體套件“{0}”要求 Yarn {1}。
yarn.pnp.library_name=來自 {0} 的相依項
yarn.pnp.requires.yarn.package_manager.dialog.message=Yarn PnP 需要 Yarn <a href="">軟體套件管理器</a>
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構
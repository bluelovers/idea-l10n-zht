# File Types
filetype.javascript.description=JavaScript
filetype.actionscript.description=ActionScript
filetype.typescript.description=TypeScript
filetype.typescript.jsx.description=TypeScript JSX
filetype.ecmascript6.description=ECMAScript 6
filetype.jsx.description=React JSX
filetype.jsx.display.name=React JSX
filetype.flow.description=Flow JS
filetype.flow.display.name=Flow JS
javascript.file=JavaScript 檔案
typescript.file=TypeScript 檔案
filetype.typescript.config.description=TypeScript 設定
filetype.typescript.config.display.name=TypeScript 設定

# Languages
javascript.language.simple.name=JavaScript
typescript.language.simple.name=TypeScript

# Language terms
javascript.language.term.function=函數
javascript.language.term.inner.function=內部函數
javascript.language.term.method=方法
javascript.language.term.constructor=構造函數
javascript.language.term.class=類
javascript.language.term.inner.class=內部類
javascript.language.term.interface=接口
javascript.language.term.inner.interface=內部接口
javascript.language.term.enum=枚舉
javascript.language.term.type.alias=類型別名
javascript.language.term.definition=定義
javascript.language.term.namespace=命名空間
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.variable=變數
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.local.variable=局部變數
javascript.language.term.local.const=局部常數
javascript.language.term.field=欄位
javascript.language.term.tag=標記
javascript.language.term.label=標籤
javascript.language.term.attribute=特性
javascript.language.term.decorator=裝飾器
javascript.language.term.attribute.value=特性值
javascript.language.term.package=軟體套件
javascript.language.term.module=模組
javascript.language.term.external.module.reference=外部模組引用
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.entity.name=實體名稱
javascript.language.term.jsdoc.tag=JSDoc 標籤
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.import.statement=import 語句
javascript.language.term.type.parameter=類型參數
javascript.language.term.destructuring.property=析構屬性
javascript.language.term.default.export=預設匯出
javascript.language.term.file=檔案
javascript.language.term.global=全域
javascript.language.term.xml.tag=xml 標籤

# Parser error messages
javascript.parser.message.expected.expression=應為表達式
javascript.parser.message.expected.xml.element=應為 XML 元素
javascript.parser.property.expected=應為屬性
javascript.parser.message.expected.lbrace=應為 {
javascript.parser.message.expected.at=應為 @
javascript.parser.message.expected.rbrace=應為 }
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=應為關鍵字、字串文字或數字文字
javascript.parser.message.expected.colon=應為 :
javascript.parser.message.expected.colon.or.comma=應為 : 或 ,
javascript.parser.message.expected.semicolon=應為 ;
javascript.parser.message.expected.lbrace.or.semicolon=應為 { 或 ;
javascript.parser.message.expected.rbracket=應為 ]
javascript.parser.message.expected.lparen=應為 (
javascript.parser.message.expected.rparen=應為 )
javascript.parser.message.expected.name=應為名稱
javascript.parser.message.expected.comma.or.rparen=應為 , 或 )
javascript.parser.message.expected.function.name=應為函數名稱
javascript.parser.message.expected.formal.parameter.name=應為參數名稱
javascript.parser.message.expected.statement=應為語句
javascript.parser.message.expected.parameter.name=應為參數名稱
javascript.parser.message.expected.property.name=應為屬性名稱
javascript.parser.message.expected.case.or.default=應為 'case' 或 'default'
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration='in' 前面應為左側表達式或變數宣告
javascript.parser.message.expected.forloop.in.or.semicolon=應為 'in' 或 ;
javascript.parser.message.expected.while.keyword=應為 'while'
javascript.parser.message.expected.comma=應為 ,
javascript.parser.message.expected.comma.or.rbrace=應為 , 或 }
javascript.parser.message.expected.variable.name=應為變數名稱
javascript.parser.message.expected.mult.or.lbrace=應為 * 或 {
javascript.parser.message.missing.rbrace=缺少 }
javascript.parser.message.missing.or_rbrace=缺少 |}
javascript.parser.message.missing.attribute.name=缺少特性名稱
javascript.parser.message.unexpected.end.of.file=意外的檔案結尾
javascript.parser.message.expected.type.name=應為類型名稱
javascript.parser.message.unclosed.string.literal=未閉合的字串文字
javascript.parser.message.unclosed.comment=未閉合註釋
javascript.parser.message.are.not.supported.by.dialect=當前 JavaScript 版本不支持 {0}
javascript.parser.message.expected.from=應為 'from'
javascript.parser.message.expected.typename=應為類型名稱
javascript.parser.message.expected.typename.or.*=* 應為 * 或類型名稱
javascript.parser.message.expected.name.or.lbrace=應為軟體套件名稱或 {
javascript.parser.message.expected.declaration=應為宣告
javascript.parser.message.expected.namespace=應為 'namespace'
javascript.parser.message.expected.string.literal=應為字串文字
javascript.parser.message.expected.xml=應為 XML 上下文關鍵字
javascript.parser.message.expected.equal=應為 =
javascript.parser.message.expected.identifier.lbrace.or.lbracket=應為關鍵字、{ 或 [
javascript.parser.message.expected.eqgt=應為 =>
javascript.parser.message.expected.identifier=應為關鍵字
javascript.parser.message.expected.instanceof=應為 'instanceof'
javascript.parser.message.expected.in=應為 'in'
javascript.parser.message.expected.value=應為值
javascript.parser.message.expected.identifier.or.value=應為關鍵字或值
javascript.parser.message.expected.as=應為 'as'
javascript.parser.message.expected.identifier.string.literal.or.lbrace=應為關鍵字、字串文字或 {
javascript.parser.message.expected.import.value=應為匯入綁定或說明符
javascript.parser.message.expected.import.specifier=應為匯入說明符
javascript.parser.message.expected.heredoc.closing.identifier=應為 heredoc 結束關鍵字
javascript.parser.message.expected.type.member=應為類型成員
javascript.parser.message.expected.tuple.comma.or.rbracket=應為 , 或 ]
javascript.parser.message.expected.target=僅接受 'target' 作為要新建的元屬性
javascript.parser.message.expected.meta=僅接受 'meta' 作為要匯入的元屬性
javascript.parser.message.expected.declare=應為 'declare'
javascript.parser.message.expected.exports=應為 'exports'
javascript.parser.message.expected.checks=應為 'checks'
javascript.parser.message.expected.type.keyword=應為 'type'
javascript.parser.message.expected.type=應為類型
javascript.parser.message.expected.question=應為 ?
javascript.parser.message.expected.class=應為 'class'

# Validation messages
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.redundant.type=顯式類型實參 {0} 可被取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.declaration.fix.text=導航到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導航到上一個宣告
javascript.validation.message.redeclaration.of.block.scope=無法重新宣告塊範圍變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊範圍變數不能與同一塊範圍中的"var"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 變數不能與其可見性範圍內的塊範圍變數使用相同的名稱
javascript.validation.message.assignment.to.const=嘗試分配給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始設定式。以後無法賦予有意義的值。
javascript.validation.message.constructor.field.not.allowed=類可能沒有名為 'constructor' 的非 static 欄位
es6.validation.message.const.variable.without.initializer=不允許使用無初始設定式的 'const' 變數
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.return.outside.function.definition='return' 在函數定義外部
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.extend.multiple.classes=類不能擴展多個類
javascript.validation.message.extend.final.class=無法擴展 final 類 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函數中使用
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符一起使用
typescript.validation.message.abstract.class.be.created=無法創建 abstract 類 ''{0}'' 的實例
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=構造函數不能為 'abstract'
typescript.validation.message.function.implementation.missing=缺少函數實作或此宣告之後未緊隨函數實作
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在 abstract 類中
typescript.validation.module.reference.with.extension=外部模組引用不能以擴展結束
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是構造函數類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類構造函數具有指定數量的類型實參
typescript.validation.class.extend.many.constructors=基類構造函數必須具有相同的返回類型
typescript.validation.class.extend.cycled.definition=迴圈類定義
typescript.validation.class.extend.constructor.return.not.class=基類構造函數返回類型 ''{0}'' 不是類或接口類型。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.async.incorrect.type.annotation=異步函數不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.overload=多載簽名無法被宣告為生成器
typescript.validation.generators.ambient=環境上下文中不允許使用生成器
typescript.validation.generators.no.yield=生成器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回類型。
typescript.validation.generators.async.no.yield=生成器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回類型。
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參


# Surround with names
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.if=if
javascript.surround.with.if.else=if / else
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.cast=Type(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.finally=try / finally
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.surround.with.function=函數
javascript.surround.with.function.expression=函數表達式
javascript.surround.with.object.literal=物件文字

# Introduce variable
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入局部變數
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\n選定內容不構成表達式。
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\n選定的表達式類型無效。
javascript.introduce.variable.name.prompt=名稱(&N):
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.element.already.exists=範圍中已存在同名的 {0}。
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\n選定內容包含對箭頭函數參數的引用
javascript.introduce.variable.arrow.await.referenced=無法引入。\n選定內容包含 await 表達式
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.introduce.incorrect.context=無法引入變數。\n選定內容包含對"this"的引用
javascript.introduce.field.title=引入欄位
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\n選定內容不構成表達式。
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\n選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\n沒有封閉類。
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.initialize.in.scope=初始化在(&I):
javascript.introduce.field.visibility=可見性(&V):
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.before.super.call=無法引入欄位。\n在"super"調用前無法存取"this"。
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.constructor=構造函數
javascript.introduce.constant.title=引入常數
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\n選定內容不構成表達式。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\n選定的表達式類型無效。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\n選定內容不是常數表達式。
javascript.introduce.parameter.title=提取參數
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\n選定內容不構成表達式。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\n找不到要使用的包含函數。
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\n選定的表達式類型無效。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\n並非所有用法都包含在異步函數中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\n目標函數不是異步函數
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.throw.expressions.unsupported=無法調用重構。\n"Extract"重構中當前不支持 Throw 表達式。
javascript.introduce.breaks.operator.precedence=無法調用重構。\n通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.in.es5=無法調用重構。\n無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.in.embedded.expression=無法調用重構。\n無法在嵌入式表達式中引入
javascript.introduce.variable.make.constant=設為常數
list.item.class.field=類欄位
list.item.global.or.module.constant=全域或模組常數
list.item.local.constant=局部常數

# Highlighting categories
javascript.keyword=關鍵字
javascript.string=字串
javascript.number=數字
javascript.linecomment=行註釋
javascript.doccomment=文檔註釋
javascript.blockcomment=塊註釋
javascript.regexp=正則表達式
javascript.operation=運算
javascript.parens=括號
javascript.brackets=中括號
javascript.braces=大括號
javascript.semicolon=分號
javascript.badcharacter=錯誤字符
jsdoc.text=JSDoc 文本
jsdoc.tag=JSDoc 標籤
jsdoc.tag.value=JSDoc 標記值
jsdoc.type=JSDoc 類型
javascript.doctag=文檔標籤
javascript.doctagvalue=文檔標記值
javascript.valid.string.escape=有效字串轉義
javascript.invalid.string.escape=無效字串轉義
javascript.comma=逗號
javascript.dot=點

# Errors with intentions
javascript.unresolved.function.name.message=未解析的函數或方法 {0}() #loc
javascript.unresolved.variable.name.message=未解析的變數 {0} #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null #loc
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined #loc
javascript.unresolved.type.name.message=未解析的類型 {0} #loc
javascript.unresolved.circle.definition=匯入的圓定義
javascript.missing.read.property=未解析的讀取屬性 #loc
javascript.missing.write.property=未解析的寫入屬性 #loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.file=找不到檔案 {0}
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unknown.metadata.attribute=未知元資料特性
javascript.undeclared.variable.name.message=隱式宣告變數 {0} #loc
javascript.create.function.intention.name=創建函數 ''{0}''
javascript.create.variable.intention.name=創建變數 ''{0}''
javascript.create.constant.intention.name=創建常數 ''{0}''
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.create.field.intention.name=創建欄位 ''{0}''
javascript.create.constant.field.intention.name=創建常數欄位 ''{0}''
javascript.create.method.intention.name=創建方法 ''{0}''
javascript.create.property.intention.name=創建屬性 ''{0}''
javascript.create.function.property.intention.name=創建函數屬性 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類中創建構造函數
javascript.create.get.property.intention.name=創建 ''get'' 屬性 ''{0}''
javascript.create.set.property.intention.name=創建 ''set'' 屬性 ''{0}''
javascript.create.function.intention.family=創建 JavaScript 函數或方法
javascript.create.variable.intention.family=創建 JavaScript 變數或屬性
javascript.intention.create.getter.setter=為 ''{0}'' 創建 getter 和 setter
javascript.intention.create.getter.setter.desc=創建 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 創建 setter
javascript.intention.create.setter.desc=創建 setter
javascript.intention.create.getter=為 ''{0}'' 創建 getter
javascript.intention.create.getter.desc=創建 getter
create.mobile.view=創建檢視 ''{0}''
javascript.rename.reference.intention.name=重命名引用
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.rename.dynamic.references=搜尋動態引用 (&D)
js.usage.type.call=函數調用中的用法
js.anonymous.to.named.function=匿名函數轉換為命名函數
js.convert.to.named.function=轉換為命名函數
js.convert.to.named.function.to.class.method=轉換為類方法
js.convert.to.arrow.function=轉換為箭頭函數
js.add.braces.to.arrow.function=向箭頭函數中添加大括號
js.inspection.function.expression.is.used.instead.of.arrow=使用了函數表達式而不是箭頭函數
js.arrow.function.braces.can.be.removed.key=箭頭函數體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函數體周圍的大括號
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函數體周圍的大括號
js.convert.to.anonymous.function.family.name=箭頭函數轉換為匿名函數
js.convert.to.anonymous.function=轉換為匿名函數
js.named.to.anonymous.family.name=轉換為函數表達式
js.named.to.function.expression.text = 轉換為包含變數的函數表達式
js.named.to.function.hoisting.conflict.text=函數在宣告之前使用。轉換為變數後，將中斷使用
js.named.to.arrow.text = 轉換為含有 {0} 的箭頭函數
js.split.into.multiple.declarations=拆分為多個宣告
js.remove.digit.separators=移除數字分隔符
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.separate.digits=分隔數字
js.separate.nibbles=分隔半字節
js.separate.bytes=分隔字節
js.separate.words=分隔 16 位單詞
js.separate.thousands=分隔千位數
js.separate.thousands.in.integer.part=將千位數分隔成整數
js.split.declarations=拆分宣告
js.replace.string.with.es6.template=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板文字
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.convert.var.to.let.text=轉換為 let
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”操作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函數器頂部。\n要在使用“全部修復”操作時禁用此行為，請選中“保守轉換 var”選項。
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”操作在內部範圍內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部範圍內轉換 require()（例如 'if' 語句或內部函數）
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.map.to.for.of.intention.family=將 'map' 陣列調用取代為 'for..of' 迴圈
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 調用
js.add.then.fix=添加 '.then()'
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.quote=引用
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.unquote=取消引用
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.property.to.indexer.intention=取代為索引器存取
js.indexer.to.property.intention=取代為屬性存取
js.join.vars.intention=加入後續變數宣告
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型：為唯讀檔案

# Move module members
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.table.title=要移動的成員
es6.move.module.members.refactoring.create.file=創建檔案
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\n要創建嗎?
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標文件名在此操作系統中無效
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.dialog.field.from=從:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 引用未解析匯入 {1}
es6.move.module.members.references.local.message=選擇的 {0} 引用非匯出 {1}
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
dialog.title.move.members=移動成員

js.pull.up.will.be.made.abstract=非 abstract {0} 將被設為 abstract
es6.extract.super.destination.label=目標檔案 (&D)：
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類中不允許沒有實作的多載宣告 {0}
es6.extract.super.different.name.expected=應為不同名稱

# Unit testing
js.testing.inspection.group.name=單元測試
js.testing.highlight.line=在測試程式碼中高亮顯示失敗的行
rc.environmentVariables.label=環境變數(&E)：
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.testFile=測試檔案(&F)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.nodeOptions.label=節點選項 (&O)：
rc.workingDirectory.label=工作目錄(&W):
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.suite.label=套件名稱:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testOrSuiteScope.test.label=測試名稱：
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testRunScope.testFile.label=測試檔案:
rc.testRunScope.testFile.browseTitle=選擇測試檔案

# Unit testing: Jest
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.rc.configurationFile.label=設定檔案(&C):
jest.rc.configurationFile.title=選擇 Jest 設定檔案
jest.rc.jestPackageField.label=Jest 軟體套件(&J)：
jest.rc.jestOptions.label=Jest 選項：
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env=jsdom
jest.coverage.notification.title=Jest 覆蓋率
jest.coverage.directory.not.found.notification.content=無法從 Jest 設定中讀取 coverageDirectory 選項
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率: 找不到 {0}。

# Unit testing: Protractor
protractor.rc.configurationFile.label=設定檔案(&C):
protractor.rc.configurationFile.title=選擇 Protractor 設定檔案
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P)：
protractor.rc.protractorOptions.label=Protractor 選項 (&O)：
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement

# Node.js
node.js.inspection.group.name=Node.js
node.js.missing.require=缺少 require() 語句
node.js.unresolved.api=未解析的 Node.js API
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.downloading=正在下載 Node.js {0}
node.js.interpreters=Node.js 解釋器
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.add.interpreter.action=添加{0}…
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.download.types.node=無法下載 @types/node
status.text.add.interpreter.with=使用 {0} 添加解釋器
status.text.no.interpreters.added=未添加解釋器
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
node.no.interpreter=無解釋器
node.interpreter.not.found=找不到 {0}
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可執行檔案
merged.process.output.text={0}{2, choice, 0#\n\n標準錯誤:\n{1}|1#}{4, choice, 0#\n\n標準輸出:\n{3}|1#}\n\n{5}
node.interpreter.download=下載 Node.js
node.interpreter.project_node.reference.name=專案
node.interpreter.node_from_path.reference.name=node

# Inspections
js.inspection.group.name=一般
typescript.inspection.group.name=TypeScript
js.inspection.bitwise.group.name=按位運算問題
js.code.style.issues.group.name=程式碼樣式問題
js.probable.bugs.group.name=可能的錯誤
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.switch.group.name=switch 語句問題
js.inspection.async.group.name=Async 程式碼和 promise
js.function.metrics.group.name=函數指標
js.validity.issues.group.name=有效性問題
js.imports.dependencies.group.name=Import 和依賴項
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.assignment.issues.group.name=賦值問題
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的引用可能無效
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類中 'this' 的引用可能無效
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函數的 'this.' 對類欄位的引用存取可能無效
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始設定式跳過引用迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中引用可變變數
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
js.unresolved.variable.inspection.name=未解析的 JavaScript 變數
ts.unresolved.variable.inspection.name=未解析的 TypeScript 變數
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.duplicate.declaration.inspection.name=重複宣告
# WI-11522 only the first word should start with uppercase letter
js.linters.inspection.group.name=程式碼品質工具
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和設定檔案
js.unused.local.symbol.inspection.name=未使用的局部符號
js.unused.es6.import.inspection.name=未使用的 import
js.unused.assignment.inspection.name=未使用的賦值
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個賦值合併
js.join.declaration.assignment.inspection.fix=聯接變數宣告和賦值
js.unused.global.symbol.inspection.name=未使用的全域符號
js.missing.await.symbol.inspection.name=異步函數調用缺少 await
js.missing.await.symbol.inspection.for.returns=始終對異步函數調用使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊跟踪
js.missing.await.symbol.inspection.for.generator.name=異步生成器應使用 for-await 迴圈進行迭代
jsx.missing.namespace.inspection.name=JSX 程式碼中缺少 'React' 命名空間匯入
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
tsx.missing.name.quick.fix.name="添加 {0} import 語句
js.destructuring.merge.inspection=正在析構具有相同鍵的屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的析構屬性
js.destructuring.merge.inspection.fix=合併析構屬性
js.nested.template.literal.inspection=模板文字中的冗餘嵌套
js.nested.template.literal.fix=內聯嵌套文字
js.redundant.await.inspection=冗餘 'await' 表達式
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.await.promise.resolve.fix=取代為 ''{0}''
js.top.level.await.expression.inspection= 頂層 'await' 表達式
js.top.level.await.expression.inspection.description= 使用了頂層 'await' 表達式
js.possibly.async.function.inspection=非異步函數中的 'await'
js.await.in.synchronous.function='await' 運算符只能在 'async' 函數中使用
js.possibly.async.function.quick.fix=令函數 {0} 為異步函數
js.possibly.async.function.quick.fix.family.name=將函數設為異步
js.property.can.be.replaced.with.shorthand=屬性可被取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可被取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.expand.shorthand.property.quick.fix=展開速記屬性
js.unresolved.function.inspection.name=未解析的 JavaScript 函數
ts.unresolved.function.inspection.name=未解析的 TypeScript 函數
js.unresolved.react.component.name=未解析的 React 組件
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 賦值
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 賦值：'+=' 可能拼寫錯誤
js.suspicious.eq.plus.fix.name=取代為 '+='
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.potentially.invalid.constructor.usages.inspection.name=可能無效的構造函數用法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.invalid.type=類型語法無效
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的內容，但從未被查詢
collection.queried.but.not.update=查詢了集合 <code>#ref</code> 的內容，但從未寫入
javascript.constructor.with.lower.case.name.used.message=構造函數名稱通常以大寫字母開頭。拼寫錯誤？
interface.function.declaration.should.have.no.body=接口函數宣告不應有本體
javascript.ambient.declaration.should.have.no.body=環境宣告不應有本體
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始設定式
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始設定式必須是基元文字或文字枚舉引用
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 #loc
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.constructor.cant.have.return.type=構造函數不能有返回類型
invalid.identifier.value.0=無效關鍵字：''{0}''
js.suspicious.bind.with.arrow.function=箭頭函數 'bind' 用法可疑
javascript.change.signature.invalid.parameter.declaration=無效參數：''{0}''
javascript.change.signature.invalid.function.name.0=無效函數名稱：''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在生成器本體中使用 'yield' 表達式。
javascript.validation.new.target.not.in.function=僅允許函數宣告、函數表達式或構造函數的本體中有元屬性 'new.target'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中引用了 'this'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類實例上下文的情況下引用了'super'
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中引用了 'super'
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類 {0} 中的方法
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始設定式
javascript.fix.add.override.modifier=添加覆寫修飾符
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
js.code.style.tab.name=JavaScript
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.never=從不
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
typescript.code.style.tab.name=TypeScript
jsx.code.style.attribute.default.value=為 JSX 特性添加：
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.typebased=基於類型
javascript.formatting.options.panel.naming.conventions=命名慣例
javascript.formatting.options.panel.comments=註釋
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非調用用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法會覆寫另一個方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的調用
js.undefined.property.assignment.inspection.name=未定義的屬性賦值
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.jquery.efficiency.inspection.name=可以最佳化 JQuery 選擇器
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.accessibility.check.inspection.name=已引用無法存取的 @private 和 @protected 成員
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 調用
js.consecutive.commas.in.array.literal.inspection.name=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.message=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果禁用，則所有未鍵入的參數均視為可選參數
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊跟踪功能
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函數調用前插入 'await' 有助於 V8 提供異步堆疊跟踪
js.file.references.inspection.name=未解析的檔案引用
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組依賴關係
js.inspection.promise.ignored.display.name=返回 promise 的方法調用結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.flowjs.group.name=Flow 類型檢查器
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.coverage.inspection.name=Flow 不涵蓋程式碼
js.flowjs.coverage.inspection.error.text=Flow 不涵蓋此元素
js.flowjs.config.inspection.to.project.path.name=向專案根中添加 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中添加 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中添加 .flowconfig
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.flag.comment.placement.inspection.name=位置錯誤的 @flow 標記
js.flowjs.flag.comment.placement.inspection.error=Flow 標誌註釋不在檔案起始處
js.flowjs.flag.comment.placement.inspection.fix=將 Flow 標誌註釋移至檔案起始處
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 #ref 可能導致意外類型強制 #loc
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.options.label=高亮顯示 '==' 和 '!=' 的用法：
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=添加“use strict”雜註
js.strict.mode.inspection.redundant.pragma="use strict"雜註冗餘
js.strict.mode.remove.pragma=移除“use strict”雜註
js.class.member.initialization.inspection.name=在 static 初始設定式中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 引用本身
js.assignment.used.as.condition.name=用作條件的賦值
js.assignment.used.as.condition.text=<code>#ref</code> 作為條件使用
js.assignment.used.as.condition.fix=將 ''='' 取代為 ''{0}''
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case：{0}
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解開 'switch' 語句
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=創建缺少的預設分支
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時引用錯誤
js.variable.problems.ignore.desc=對可變變數忽略
js.inspection.package.json.dependencies=package.json 中的依賴關係不符合
js.inspection.missing.amd.dependency=缺少 AMD 模組依賴關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組依賴關係
typescript.narrowed.to=範圍限縮至 ''{0}''
label.exclude.methods.classes=排除類方法:
dialog.title.add.classes=添加類
typescript.suspicious.constructor.parameter.assignment=構造函數中的參數賦值可疑。您忘了添加  'this.' 嗎？
typescript.suspicious.constructor.parameter.assignment.desc=已分配構造函數欄位參數
typescript.abstract.class.constructor.can.be.made.protected=abstract 類構造函數可以設為 protected
typescript.make.constructor.protected=將構造函數設為 protected
typescript.private.field.modifiers.mix=使用私有名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為最終
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類成員使用 static 修飾符
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.template.context.type=JavaSc&ript 和 TypeScript
interface.should.have.no.variable.declarations=接口不應有變量宣告
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.class.name.expected.here=此處應為類名
javascript.validation.message.circular.dependency=迴圈依賴關係
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.fix.remove.circular.dependency=移除迴圈依賴關係
react.jsx.syntax.used.name=已使用 React JSX 語法
react.jsx.syntax.used.description=已使用 React JSX 語法
js.void.function.result.used.name=使用了 void 函數返回值
js.void.function.result.used.description=使用了 void 函數返回值

# JSDoc validation
javascript.validation.message.interface.method.not.implemented=未實作來自於接口 {1} 的方法 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類 {1} 的 abstract set 存取器 {0}
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}

javascript.validation.message.class.method.incompatible= ''{1}'' 類中的方法 ''{0}'' 不可分配給基類 ''{2}'' 中的同一方法
javascript.validation.message.class.property.incompatible= ''{1}'' 類中的屬性 ''{0}'' 不可分配給基類 ''{2}'' 中的同一屬性
javascript.validation.message.class.method.not.implemented=未實作類 {1} 的方法 {0}
javascript.validation.message.class.property.not.implemented=未實作類 {1} 的屬性 {0}
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的調用簽名
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回類型
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.modifier=移除修飾符
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.implement.all.interfaces=實作所有成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.implement.members.abstract=實作 abstract 成員

# Symbols
javascript.parameter=參數
javascript.local.variable=局部變數
javascript.global.variable=全域變數
javascript.global.function=全域函數
javascript.local.function=局部函數
javascript.global.decorator=裝飾器
javascript.static.member.function=static 成員函數
javascript.static.member.variable=static 成員變數
javascript.instance.member.variable=實例成員變數
javascript.instance.member.function=實例成員函數
javascript.create.class.intention.name=創建類 ''{0}''
javascript.create.interface.intention.name=創建接口 ‘’{0}''
choose.class.to.import.title=要匯入的類
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類的方法
javascript.parser.message.expected.gt=應為 >
javascript.parser.message.expected.lbracket=應為 [
javascript.parser.message.expected.readonly=應為 'readonly'
javascript.module.name=模組名稱
javascript.exported.variable=匯出的變數
javascript.exported.function=匯出的函數
javascript.exported.class=匯出的類
javascript.fix.create.function.component.jsx.name=創建函數組件 ''{0}''
javascript.fix.create.function.component.jsx.family=創建函數組件
javascript.fix.create.class.component.jsx.name=創建類組件 ''{0}''
javascript.fix.create.class.component.jsx.family=創建類組件
typescript.module.name=模組名稱
typescript.type.alias.name=類型別名
typescript.type.guard.name=變數類型限縮為類型防護
typescript.type.guard.name.disable=禁用範圍限縮的類型的著色
typescript.primitive.types.name=基元類型
typescript.type.parameter=類型參數
typescript.remove.type.declaration=移除類型宣告

generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.to.string.chooser.title=選擇要在 toString 函數中使用的欄位
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
no.candidates=無候選項
no.methods.to.implement=找不到要實作的方法
no.members.to.implement=找不到要實作的成員
implement.members.abstract=實作 abstract 成員
no.methods.to.override=找不到要覆寫的方法
no.members.to.override=找不到要覆寫的成員
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
javascript.validation.unused.import=未使用的 import
javascript.validation.fqn.to.replace.with.import=限定名稱可被取代為 import 語句
javascript.fix.optimize.imports=最佳化 import
javascript.parser.message.expected.doc.tag.value=應為標記值
javascript.parser.message.expected.doc.tag.name=應為文檔標籤名稱
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.initializer.type.mismatch=初始設定式類型 {1} 不可分配給變數類型 {0}
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.term.does.not.evaluate.to.function=方法表達式不是函數類型
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函數調用
javascript.term.does.not.evaluate.to.function.line.break=表達式不可調用。如果這不應是調用，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.vector.literal.element.type.mismatch=矢量文字元素類型 {1} 不可分配給類型 {0}
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.no.call.signatures=分配的類型不包含調用簽名
javascript.known.props.only=物件文字只能指定已知屬性，但以下為額外屬性：{0}
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.insert.cast.fix=插入轉換
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
typescript.insert.cast.fix=插入類型斷言
es6.insert.await.fix=插入 await
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
typescript.insert.type.guard.fix.family=插入類型防護
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
cannot.modify.library.code=無法修改庫或 SDK 程式碼
javascript.extract.method.title=提取函數
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.duplicate.catch.block=重複 catch 塊 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.return.statement.required=非無效返回類型必需具備 return 語句
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
javascript.validation.message.unresolved.component=未解析的組件 {0}
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類構造函數調用應位於構造函數本體中
javascript.fix.remove.constructor=移除構造函數
javascript.metadata=元資料
javascript.class=類
javascript.interface=接口
javascript.label=標籤
javascript.function.arrow=箭頭函數
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.constructor.cannot.be.static=構造函數不能為 static
javascript.create.event.handler.intention.name=創建事件處理程序 ''{0}''
javascript.validation.message.missed.super.constructor.call=缺少超類構造函數調用
javascript.validation.message.this.before.super.call=超類構造函數調用前不允許有 'this'
javascript.validation.message.baseMethod.before.super.call=超類構造函數調用前不允許有 'super'
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生構造函數中調用基類構造函數
javascript.fix.create.constructor.invoke.super=創建符合 super 的構造函數
javascript.fix.create.invoke.super=插入超類構造函數調用
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.abstract.class.can.not.be.instantiated.message=無法實例化 abstract 類
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有參數
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回類型不應為 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.destructuring.without.initializer=析構宣告必須有初始設定式
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類和類方法
javascript.fix.remove.namespace.reference=移除命名空間引用
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
javascript.fix.remove.type.reference=移除類型引用
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.initializer=移除初始設定式
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.fix.initialize.parameter=初始化參數
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
js.validate.types.inspection.name=類型不符合
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始設定式
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.duplicate.typescript.union.inspection.name=聯合或相交類型組件重複
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.fix.add=添加泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.types.any.inspection.name='any' 類型的類型不符合
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice, 0#false|1#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
javascript.validate.imports.name=未解析的已匯入名稱
es6.validate.import.error=無法解析符號 ''{0}''
es6.prefer.short.import.name=可以縮短匯入
typescript.reference.to.umd.global=已引用的 UMD 全域變數
typescript.field.can.be.made.readonly=可以為唯讀欄位
javascript.suspicious.type.guard.desc=類型防護檢查不健全
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.suspicious.typeof.guard=''typeof'' 檢查無效：''{0}'' 不能具有類型 ''{1}''
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘：''{0}'' 始終具有類型 ''{1}''
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false：{0}'' 始終具有類型 ''{1}''
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效：''{0}'' 的類型與 ''{1}'' 無關
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘：''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘：''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
javascript.object.is.null={0} 為 null
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.undefined={0} 未定義
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.missing.augmentation.import=缺少增強匯入
typescript.explicit.member.type.inspection.name=顯式類型
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.config.options.fix=向 tsconfig.json 中添加 ''{0}''
typescript.config.inspection.fix.pattern=添加 ''{0}'' 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
typescript.specify.type.explicitly=顯式指定類型
typescript.specify.type.explicitly.from.hint=添加顯式類型註解
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.all.param.types.explicitly.from.hint=向所有參數中添加顯式類型註解
typescript.make.field.readonly=將欄位設為唯讀
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
js.validate.signature.inspection.name=簽名不符合
find.usages.of.base.interface={1} 的方法 {0}\n實作 {2} 的方法。\n要{3}基方法嗎?
find.usages.of.base.class={1} 的方法 {0}\n覆寫 {2} 的方法。\n要{3}基方法嗎?
javascript.fix.visibility.family=修復可見性問題
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.label.visibility.public=公共 (&B)
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
move.members.refactoring.name=移動成員
move.members.dialog.title=移動成員
class.0.cannot.be.created=無法創建目標類 {0}，因為存在同名的限定元素
# Used in JSFormatUtil.formatVisibility
javascript.visibility.public=public
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
entity.in.parent.description={0} ({1} 內)
package.description=軟體套件 {0}
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取

# Refactoring
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在賦值的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.inline.function.title=內聯函數
javascript.refactoring.cannot.find.usages.of.definition.to.inline=無法找到要內聯的定義的用法.
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的析構變數
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯析構 rest 變數
javascript.inline.element.is.not.used={0} 從未使用
javascript.refactoring.inline.dialog.title=內聯 {0}
javascript.refactoring.inline.all.message=內聯所有引用並移除 {0} ({1}) (&A)
javascript.refactoring.inline.this.only=僅內聯此引用並保留 {0}(&K)
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函數
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯引用實參的函數
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函數引用的 rest 參數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞歸函數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個退出點的函數
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式評估
javascript.refactoring.cannot.inline.constructor=無法內聯構造函數
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.function.to.es6.class.command=將函數 {0} 轉換為類
js.convert.to.es6.class=轉換為類
js.convert.to.es6.class.family.name=將函數及其成員宣告轉換為類
js.move.type.to.file.family=移至名稱符合的檔案
js.create.derived.type.family=創建派生類/實作接口
js.create.derived.type.class=創建派生類
js.create.switch.cases=創建缺少的 'switch' 分支
js.create.switch.cases.fix=創建缺少的分支：{0}
js.edit.object.literal=編輯物件文字屬性的值
js.create.derived.type.interface=實作接口
js.create.derived.type.abstract.class=實作 abstract 類
js.rename.file.to.match.type.name.family=重命名檔案以符合類型名稱
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.move.type.to.file.text=將 {0} 移至檔案 {1}
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告：將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”創建的屬性轉換為 ES6 語法可能會影響其可枚舉性和可設定性
rename.destructuring.property.title=重命名析構屬性
rename.destructuring.property.description=析構屬性引用多個成員。應重命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合、相交或映射類型用法。應重命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.destructuring.description=檢測到析構屬性中的用法。應重命名相關屬性，否則可能導致程式碼不一致。
make.private=設為 private
choose.destination.scope=選擇目標範圍
list.item.function.to.be.converted.to.class=要轉換為類的函數
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類成員的函數成員的宣告
tab.title.convert.to.class=轉換為類
tab.title.refactoring.preview=重構預覽
list.item.function.converted.to.class=轉換為類的函數
list.item.declarations.that.were.not.converted=未轉換的宣告
tab.title.refactoring.result=重構結果
extract.method.declare.static=宣告靜態 (&S)
extract.function.declare.functional.expression=宣告函數表達式(&F)
extract.function.return.type=返回類型(&T):
extract.function.parameters=參數
extract.function.signature.preview=簽名預覽
extract.function.function=函數
extract.function.name=名稱(&N):
extract.constant.type=類型(&T):
introduce.constant.target.class=目標類(&A):
introduce.field.type=類型(&T):
introduce.field.initialize.in=初始化位置
introduce.field.declaration=欄位宣告(&D)
introduce.field.current.method=當前方法(&M)
introduce.field.class.constructor=類構造函數(&C)
introduce.parameter.type=類型(&T):
introduce.parameter.optional=可選參數(&O)
introduce.variable.declaration=變數宣告
introduce.variable.const=const(&C)
introduce.variable.let=let(&L)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T):
introduce.variable.make.constant=設為常數(&C)
custom.template.variables=自訂模板變數(&C):

# Destructuring
javascript.find.usages.destructuring.target.dialog=速記析構變數使用 {0} 初始化。\n您想尋找哪些用法?
javascript.destructuring.initializer=初始設定式 {0}
javascript.destructuring.variable.only=僅析構變數
javascript.rename.destructuring.target.dialog.title=速記析構變數使用 {0} 初始化
javascript.rename.choose.target.message=您要重命名哪一個？
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.shorthand.property.description=屬性
javascript.rename.file.with.related.title=重命名檔案
javascript.rename.containing.file.message=是否也想將檔案及其用法重命名為 {0}?
javascript.rename.related.declaration.message=是否想將 {0} 及其用法重命名為 {1}?
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\n匯入和匯出中的用法、字串用法或動態引用無法取代為析構。
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的析構模式
dialog.message.unsupported.destructuring.container=不支持的析構容器: {0}
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\n無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列析構模式
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列析構不支持轉換多個嵌套模式

javascript.refactoring.asdoc.for.abstracts=摘要的 ASDoc
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函數宣告
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類宣告
javascript.illegal.variable.type.void=非法變數類型：'void'
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函數返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
javascript.kind.unknown=未知元素
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 #loc
js.unnecessary.semicolon.fix.name=移除不必要的分號
javascript.refactoring.extract.function.title=提取函數
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個退出點
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函數
javascript.refactoring.extract.function.already.exists.in.this.scope=此範圍中已存在 {0}
javascript.validation.message.constructor.cannot.have.custom.visibility=構造函數應為 public 或未指定可見性
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫 final 方法
top.level.package=頂層軟體套件
javascript.parser.message.expected.dot=應為 .
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較始終評估為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較始終評估為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(...)
js.constructor.returns.primitive.inspection.name=構造函數返回基元值
js.constructor.returns.primitive.inspection.problem=使用 'new' 調用時從構造函數返回的基元值將丟失
js.constructor.returns.primitive.inspection.quickfix=返回類型顯式設定為 {0}
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函數簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函數簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋

livetemplate.description.fori=創建迭代迴圈
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.ritar=以相反順序遍歷陣列的元素
livetemplate.description.us=插入 'use strict' 語句
livetemplate.description.ref=插入引用路徑註釋
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.moduleexports=匯出語句 - module.exports = a
livetemplate.description.arf=使用箭頭函數環繞

livetemplate.description.console.log=console.log()
livetemplate.description.console.warn=console.warn()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.assert=console.assert()

postfix.template.provider.name=JavaScript 和 TypeScript
postfix.template.condition.non.void.name=非 Void
postfix.template.condition.array.name=陣列

macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)

# Line markers
linemarker.implements.invalid=<無效>
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.implements.several=實作多種接口方法
linemarker.overridden=覆寫
linemarker.implemented=已實作
linemarker.overriding=覆寫
linemarker.implementing=實作
linemarker.javascript.typescript=JavaScript/TypeScript 行標記

js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的引用
javascript.expected.class.or.descendant=應為類 {0} 或後代
javascript.qualified.class.name.expected=應為限定的類名
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.set.method.type.is.different.from.getter=Set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646：Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646：Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.fix.create.parameter=創建參數 ''{0}''
javascript.introduce.parameter.introduced.variable.value=值(&V):
0.is.not.a.legal.name=''{0}'' 不是合法的類名
item.already.exists={0} {1} 已存在
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
extract.subclass.command.name=從 {1} 提取子類 {0}
extract.interface.command.name=提取接口
extract.type.alias.command.name=提取類型別名
new.actionscript.class.dialog.title=新建 ActionScript 類
new.actionscript.interface.dialog.title=新建 ActionScript 接口
class.template.title=類
class.with.supers.template.title=包含 Super 的類
interface.template.title=接口
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 組件中提取超類。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回類型更改為預期類型
js.last.comma.in.array.literal.inspection.name=陣列文字中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件文字中的最後一個逗號多餘
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\n是否繼續？
return.type.is.not.resolved=返回類型 ''{0}'' 未解析。\n是否繼續？
change.signature.column.name.initializer=初始設定式
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.call.value=調用中的值
change.signature.parameter.table.empty.message=使用  '+' 按鈕添加新參數
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已添加。\n指定要用於此方法的所有現有調用的預設值。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已添加。\n指定要用於此方法的所有現有調用的預設值或值。
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用調用中的值。因為沒有為前面的參數指定它。
change.signature.usage.view.declarations.header=要重構的方法
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
invalid.return.type.expression=返回類型 ''{0}'' 無效
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
type.is.not.resolved=類型 ''{0}'' 未解析。\n是否繼續？
invalid.field.type.expression=無效欄位類型：''{0}''
choose.field.type=選擇欄位類型
new.field.action.text=欄位
new.field.action.description=在類中創建新字段
create.field.dialog.title=創建欄位
field.initializer.is.not.specified=未指定欄位初始設定式
new.method.action.text=方法
new.method.action.description=在類中創建新方法
create.method.dialog.title=創建方法
create.button.text=創建(&C)
class.already.contains.method.warning=類 ''{0}''''已經 {1, choice, 1# 包含|2#繼承] 方法 ''{2}()''。\n是否繼續？
class.already.contains.field.warning=類 ''{0}'' 已包含欄位 ''{1}''。\n是否繼續？
declare.static=宣告 static(&S)
new.constructor.action.text=構造函數
new.constructor.action.description=創建構造函數
create.constructor.dialog.title=創建構造函數
change.method.signature.fix.text=更改 {0} 簽名
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 調用和更新調用
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 調用和更新調用
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託調用

# Settings
settings.javascript.root.configurable.name=JavaScript
settings.typescript.root.configurable.name=TypeScript
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.autodetect.disabled=禁用 {0}(&D)
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 設定 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父資料夾位於同一資料夾中的 {2} 設定檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 設定 (&M)
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選鏈接的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.field.names.completion=為類欄位建議名稱 (&F)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.types=為建議的參數名稱添加類型註解(&T)
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types.for.params=具有函數參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.lang.templates.configurable.name=模板
es6.auto.import.options.completion.add.imports=在程式碼補全時添加 ES6 匯入
es6.auto.import.options.title=TypeScript / JavaScript
typescript.auto.import.options.add.imports=自動添加 TypeScript 匯入
typescript.auto.import.options.add.imports.on.the.fly=動態明確 import
typescript.auto.import.options.add.on.code.completion=程式碼補全
typescript.auto.import.options.show.popup=包含自動匯入工具提示
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入（Node 樣式模組解析）
js.import.options.use.explicit.js.extension=使用檔案副檔名:
js.add.members.to.type.desc=將成員添加到類或接口
js.add.members.to.type=將成員 {0} 添加到 ''{1}''
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對匯入排序
es6.import.options.paths=使用路徑別名：
es6.import.options.paths.help=此選項設定 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 在添加匯入時始終使用來自 webpack、system.js 或 jsconfig.json 設定的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中使用路徑映射。<br><br>選擇“從不”時，則不使用別名。
typescipt.import.options.paths.help=此選項設定 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 在添加匯入時始終使用從 tsconfig.json 映射的路徑。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 針對為之定義了映射的檔案之間的匯入使用相對路徑。在所有其他檔案中使用路徑映射。<br><br>選擇“從不”時，則不使用路徑映射。
typescript.import.options.paths=使用 tsconfig.json 的路徑映射：
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
javascript.import.options.use.resource.root=使用相對於專案、資源或源根目錄的路徑
typescript.import.options.blacklist.title=不要完全從此匯入：
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F)：
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.services.label=為之使用 Flow 伺服器：
js.flow.enable.type.checking=類型檢查
js.flow.enable.other.services=導航、程式碼補全和類型提示
js.flow.enable.flow.service.error=\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯：{0}
js.flow.enable.flow.service.error.message={0}。禁用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning=只有儲存其他所有修改過的檔案時，Flow 才會檢查當前檔案。
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.caption=
js.dialect.settings.tableTitle=語言
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本？
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.empty.text=使用 + 按鈕添加目錄，並選擇 JavaScript 版本
js.dialects.customized.label=根據目錄自定義
configure.code.completion.settings=設定程式碼補全設定

# Bower
settings.javascript.bower.configurable.name=Bower
bower.packages.view.dependencies=依賴項:
bower.package=Bower 軟體套件(&B):
bower.json=bower.json (&O)：
bower.correct.path=請更正 {0} 的路徑
bower.package.name=Bower 軟體套件
bower.dialog.message.specify.package=指定正確的 bower 軟體套件: 未找到 "{0}" 檔案
bower.required.version.notification.content=要查看 bower 軟體套件，您需要 bower@1.0.0 或更高版本
bower.no_description_available.text=無可用描述
dialog.message.command.timed.out=指令 ''{0}'' 超時
dialog.message.command.cancelled=指令 ''{0}'' 已取消
dialog.message.command.finished.with.exit.code=指令 ''{0}'' 已完成，退出程式碼為 {1}。Stdout:\n{2}\n\nstderr:\n{3}

# JS language version management
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=已棄用特定於 Firefox 的 ECMAScript 實作。請考慮切換。
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015+、一些提案和 JSX
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java 中的 JavaScript 實作
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=ECMAScript 6 中的 Flow 和 JSX
js.language.version.label=JavaScript 語言版本
js.switch.to.jsx.inspection.dismiss=關閉
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.language.level.family=更改 JavaScript 語言版本

# JS library management
js.library.attach.debug=附加偵錯版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.unresolved.url.inspection.name=HTTP 鏈接缺少本地存儲的庫
js.library.download.fix=下載庫
js.library.downloading.library=正在下載庫
js.library.documentation=文檔
js.library.configurable.name=庫
js.library.download.stubs.label=TypeScript 社區存根
js.library.successfully.downloaded=已成功下載 {0}

choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法（找到 {1}）</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函數（找到 {1}）</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位（找到 {1}）</body></html>
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類或接口（找到 {1}）</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類（找到 {1}）</body></html>
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作（找到 {1}）</body></html>
choose.overridden.method=<html><body>選擇 <b>{0}</b> 的覆寫方法（找到 {1}）</body></html>
choose.overridden.function=<html><body>選擇 <b>{0}</b> 的覆寫函數（找到 {1}）</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
javascript.parser.message.expected.newline.or.semicolon=需要換行符或分號
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位引用
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中引用 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許引用 'arguments' 函數屬性
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制文字。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制文字已過時，不建議使用
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制文字
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制文字的警告
javascript.validation.message.only.one.default.is.allowed=\ switch 中只允許一個預設子句
javascript.fix.remove.default=移除預設子句
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函數中
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函數的頂層使用函數語句
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
choose.super.class.title=選擇超類
choose.base.component.title=選擇超類
choose.super.interface.title=選擇 Super 接口
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
javascript.constructor.call.without.new.message=沒有 new 的構造函數調用
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 #loc
javascript.element.is.not.accessible.message=元素不可存取 #loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.protected.constructor.is.not.accessible.message=protected 構造函數不可存取 #loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.export.only.member=元素僅匯出
javascript.private.constructor.is.not.accessible.message=private 構造函數不可存取 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.static.member.is.not.accessible.message=static 成員不可存取 #loc
javascript.instance.member.is.not.accessible.message=實例成員不可存取 #loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.member.from.unopened.namespace.message=未開啟命名空間的成員 #loc
javascript.property.is.read.only.message=唯讀屬性 #loc
javascript.property.is.write.only.message=只寫屬性 #loc
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函數是構造函數
javascript.not.a.constructor.call.message=不是構造函數調用
cannot.refactor.anonymous.function=現有非調用用法阻止調用站點分析。
change.signature.method.references.arguments=函數引用實參，更改簽名後代碼可能會中斷
change.signature.call.expression.contains.spreads=函數調用包含傳播實參。用法將保持不變。
change.signature.tagged.template.issue=無法更新標記的模板調用。用法將保持不變。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
javascript.missed.argument.for.parameter=參數 {0} 缺少實參

# Code folding settings
checkbox.collapse.object.literals=物件文字
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函數
checkbox.collapse.array.literals=陣列文字
checkbox.collapse.xml.literals=XML 文字
change.signature.value.column.title=值
change.signature.column.name.optional.flag=可選
change.signature.column.name.modifier=修飾符

# Flow general
js.flow.all.servers.action.restart=重啟所有 Flow 伺服器
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行高亮顯示
flow.js.get.type=Flow JS:Get 類型
flow.show.error.details=顯示錯誤詳情
can.t.find.flow.executable=找不到 Flow 可執行檔案
process.terminated=行程已終止
progress.text.modifying=正在修改 {0}
progress.text.initializing.opened.files=正在初始化開啟的檔案

# Code style settings
js.code.style.punctuation.tab.title=標點
space.before.name.value.separator=在屬性名稱-值分隔符 ':' 前面
space.after.name.value.separator=在屬性名稱-值分隔符 ':' 後面
space.before.function.left.parenth=在函數表達式中
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '...' 後面
space.after.dots.in.rest.spread=在 rest/spread 中的 '...' 後面
space.before.generator.mult=在生成器中的 '*' 前面 
space.after.generator.mult=在生成器中的 '*' 後面 
spaces.within.object.type.braces=物件文字類型大括號
space.before.type.colon=在類型引用冒號 ':' 前面
space.after.type.colon=在類型引用冒號 ':' 後面
space.before.class.lbrace=類的左大括號
space.before.class.interface.module.lbrace=類/接口/模組左大括號
spaces.within.object.literal.braces=物件文字大括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.array.initializer=陣列中括號
spaces.within.union.and.intersection=聯合和相交類型
spaces.within.type.assertion=類型斷言
spaces.arrow.function=箭頭函數(=>)
spaces.async.arrow.function=在異步箭頭函數中
spaces.within.interpolation.expressions=插值表達式
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.after.unary.not=在 'not' (!) 和 '!!' 後面
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
js.blank.lines.around.method=環繞方法:
js.blank.lines.around.function=Around 函數：
js.spaces.in.flow.category=在 Flow 中
js.wrap.settings.import=ES6 匯入/匯出
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.function.call.parentheses=函數調用括號
js.function.declaration.parentheses=函數宣告括號
js.function.brace.style=在函數宣告中
js.function.expression.brace.style=在函數表達式中
js.function.parameters.wrap=函數宣告參數
js.function.call.wrap=函數調用實參
js.space.before.function.left.brace=函數左大括號
js.format.cstyle.comments=對齊多行
js.chained.call.dot.on.next.line='.' 在新行
js.generated.use.public.modifier=使用 'public' 修飾符
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.explicit.types=此項的首選顯式類型：
js.generated.explicit.var.types=變數和欄位
js.generated.explicit.return.types=函數宣告返回
js.generated.explicit.return.expression.types=函數表達式返回
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時添加
js.extends.list.wrap=Extends 列表
js.align.multiline.extends.list=多行時對齊
js.extends.keyword.wrap=擴展關鍵字
js.wrap.settings.union.and.intersection.types=聯合和相交類型
js.code.style.object.literals.category.name=物件
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.wrap.settings.var.group.name=變數宣告
js.code.style.do.not.align.var.statement=不對齊
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中

js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
make.method.static=設為 'static'
typescript.fix.change.member.access=設為 ''{0}''
js.fix.change.member.access.to.sharp=使用 '#' 設為 private
declare.event.0=宣告事件 ''{0}''
js.variable.might.not.been.initialized=變數可能尚未初始化 #loc
js.variable.initializer.is.redundant=變數初始設定式冗餘 #loc
js.value.assigned.is.never.used=從未使用過所賦之值 #loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 #loc
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
change.signature.dialog.title=更改 {0} 的簽名
javascript.fix.add.enum.values=添加枚舉值
javascript.fix.add.string.enum.values=添加字串枚舉值
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.implement.family=在派生類中實作
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.chooser.all=所有類
javascript.fix.implement=實作 {0}
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.report.unused.properties=報告未使用的屬性
javascript.report.unused.definitions=報告未使用的定義
javascript.check.global.definitions=檢查全域範圍內的賦值
javascript.strictly.check.global.vars=將未宣告的全域變數報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.strictly.check.global.functions=將未宣告的全域函數報告為錯誤
change.signature.column.type=類型
change.signature.column.name=名稱
javascript.invalid.invoker.target=無效調用目標
js.declarations.at.scope.start.inspection='var' 未在函數開頭宣告
js.make.single.var.statement=設為單變數語句
js.declaration.is.not.at.scope.start=var 語句不在範圍開始
js.move.to.scope.start=將 var 語句移至範圍開始
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.replace.with.literal=取代為 {0} 文字
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號：{0}</html>
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號：{0}</html>

element.name.anonymous=<anonymous>
element.name.default=<預設>
duplicate.parameter.name=重複的參數名稱: {0}
rename.accessors.dialog.title=重命名欄位
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''？
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=添加 this 限定符
insert.class.fix.name=添加類名限定符
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
superclass.label.text=超類(&S):
varible.name.column.title=名稱
varible.value.column.title=值
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C)：
create.class.ok.button.text=創建
create.class.name.label=名稱(&N):
create.class.package.label=軟體套件:
create.class.template.label=模板(&T):
create.class.superclass.label=超類(&S):
create.class.interfaces.label=接口(&I):
action.structureview.show.object.inherited=從物件繼承

# JSHint
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.clear.field.to.disable=清除要禁用的欄位
jshint.illegal.integer=非法整數
jshint.use.config.files=使用設定檔案
jshint.version.label=版本(&V):
jshint.label.bundled.suffix=(捆綁)
jshint.tree.link.set=設定
jshint.label.no.version=無版本
jshint.exception.balloon.action.retry=<a href=''{0}''>重試</a>
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>設定 HTTP 代理</a>或<a href=''{1}''>重試</a>
filetype.jshint.config.description=JSHint 設定
filetype.jshint.config.display.name=JSHint 設定
jshint.suppress.text.suppress.for.line=禁止行
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.config.option.default.name=預設
jshint.config.default.description=<div style="padding-bottom:10px"><div><b>.jshintrc</b></div><div style="padding-left:10px; padding-top:4px;">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的資料夾開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style="padding-left:10px; padding-top:4px;">將您的設定添加到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.option.custom.name=自訂設定檔案
jshint.config.option.custom.browser.title=選擇 JSHint 設定檔案 （*.jshintrc）
jshint.config.failed.to.read=無法讀取 JSHint 設定
jshint.config.extends.cyclically=JSHint 設定迴圈擴展
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.error.cannot.locate.ext.config=JSHint: 無法定位擴展設定
jshint.config.error.cannot.parse.ext.config=JSHint: 無法解析擴展設定
jshint.latedef.false.text=不警告
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函數宣告。</body></html>
jshint.unused.false.text=不檢查任何內容
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函數參數
jshint.unused.strict.text=檢查所有變量和參數
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title=JSHint {0}
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.double.text=僅允許雙引號
jshint.inspection.message.duplicate.options=重複 JSHint 選項: {0}，{1}。
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.inspection.message.expected.values.x.or.y=預期值: {0} 或 {1}
jshint.inspection.message.expected.value=預期值: {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.config.not.found=未找到 JSHint 設定
jshint.inspection.message.malformed.config=JSHint 設定格式錯誤
jshint.inspection.message.prefix=JSHint:

jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.indent.description.short=縮排
jshint.option.quotmark.description.short=引號
jshint.option.predef.details=指定全域變數及其可分配狀態:\n<pre>DISQUS:true、jQuery:false</pre>\n<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的設定時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.immed.description.short=有關未使用括號將函數括起來而直接調用函數的警告
jshint.option.newcap.description.short=有關使用非大寫形式的構造函數的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nonbsp.description.short=有關“不間斷空格”字符的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.maxparams.description.short=函數中的最大參數數量
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxstatements.description.short=函數中的最大語句數量
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxlen.description.short=行的最大長度
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部賦值的警告
jshint.option.debug.description.short=禁止有關偵錯模式的警告
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.eqnull.description.short=禁止有關 <code>== null</code> 的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函數在迴圈內部的警告
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”構造的警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.noyield.description.short=禁止在生成器函數中無 yield 語句時有關生成器函數的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.devel.description.short=開發
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.typed.description.short=輸入的陣列
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.onevar.description.short=每個函數一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.predef.description.short=預定義(以 , 分隔)

#common linters
javascript.linter.import.error.timeout.processing.configuration.file=處理設定檔案時超時
javascript.linter.import.error.generic=套用設定檔案中的程式碼樣式規則時出錯，可能是設定檔案無效。
javascript.linter.import.error.package.not.found=無法找到 ''{0}'' 軟體套件
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.notification={0}：專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.rules.applied=套用了以下 {0}：{1}。
javascript.linter.import.notification.reset=重置
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已恢復
javascript.linter.import.translate.config.title=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.description=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.nothing.to.import={0}：已套用所有已知規則
javascript.linter.use.severity.from.config.label=使用設定檔案中的規則嚴重性
javascript.linter.configuration.file.title=設定檔案
javascript.linter.radio.button.configuration.file=設定檔案(&C):
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.no.such.file=沒有此類檔案
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.can.not.find.psi.file=無法找到 {0} 的 PSI 檔案
javascript.linter.error.can.not.find.document=無法找到 {0} 的文檔
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題:<br/>{1}
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
dialog.message.please.specify.stylelint.package.correctly=正確指定 Stylelint 軟體套件: 找不到 Stylelint 二進制檔案
stylelint.action.fix.problems.description=通過調用 'stylelint --fix' 修正 Stylelint 問題
stylelint.action.modal.title=Stylelint 修正
stylelint.action.background.title=正在執行 stylelint --fix…

javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.prompt=使用 {0} 重新格式化選定的檔案?
javascript.linter.action.fix.problems.file.text={0}：修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.progress.reformatting.with=正在使用 {0} 重新格式化…

javascript.linter.intention.name.details=詳細資訊
javascript.linter.intention.family.name.show.details={0}: 顯示詳細資訊

# eslint
settings.javascript.linters.eslint.configurable.name=ESLint
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E)：
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style="padding-top:8px">要使用 package.json，請將您的設定添加到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.label.working.directories=工作目錄(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=<html>路徑或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。</html>
eslint.configurable.config.select.config.text=選擇 ESLint 設定檔案（*.eslintrc.*）
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R)：
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O)：
eslint.run.for.files.label=為檔案執行(&F):
eslint.files.pattern.comment=<html>使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如，<code>{**/*,*}.{js,ts}</code></html>
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.action.fix.problems.description=通過調用 'eslint --fix' 修正 ESLint 問題
eslint.fix.problems.text.with.error.code={0}: 修復 ''{1}''
eslint.fix.problems.text.current={0}: 修復當前錯誤
eslint.fix.problems.family.name={0}: 修復當前錯誤
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.dismiss.text=否
eslint.code.style.apply.text=是
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.configuration.file.field.name=ESLint 設定檔案
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重程度: {0}\n主體:\n{1}

#standardJS
standardjs.name=標準程式碼樣式
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式？
standardjs.editor.notification.action=是
standardjs.editor.notification.do.not.show.text=否
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.codestyle.updated={0}: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 依賴項更新

# Actions
js.show.type.info.action.error=找不到表達式
javascript.ignore.unused.function.parameters=忽略未使用的參數:
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
remove.type.prefix=移除類型前綴
add.import.binding.to.import=將匯入綁定添加到匯入
add.import.specifier.to.import=將匯入說明符添加到匯入
create.js.file.description=從指定的模板創建 JavaScript 檔案
create.ts.file.description=創建新的 TypeScript 檔案
create.file.name=創建檔案 ''{0}''
create.file.name.with=使用 {1} 創建檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 創建檔案 ''{0}''
class.names={0,choice,1#類|2#類} {1}
function.names={1}{0,choice,1#函數|2#函數} 

# todo remove, has external usages
javascript.completion.several.definitions=（多個定義）

# File watchers
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉成 ECMAScript 5
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?

# Annotator
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的賦值
typescript.type.predicate.not.return=僅函數和方法的返回類型位置允許類型謂詞
typescript.type.this.predicate.not.return=僅類或接口成員、get 存取器或函數和方法的返回類型位置允許基於 'this' 類型的謂詞。
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.rest=類型謂詞不能引用 rest 參數
typescript.type.predicate.destructuring=類型謂詞不能引用綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
js.annotator.assignment.pattern.rhs=賦值模式必須位於賦值的左側
es6.generate.index.action=生成 index.js/index.ts
es6.generate.index.action.description=生成 index.js/index.ts
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議添加括號以解決歧義問題。

# Live templates
jsx.html.context.type=JSX HTML
js.expression.context.type=表達式
js.statement.context.type=語句
js.top.level.statement.context.type=頂級語句
js.class.context.type=類/接口
ecmascript.6.or.higher=ECMAScript 6 或更高版本

# Gulp
gulp.rc.gulpfile.label=Gulpfile (&F)：
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.tasks.label=任務(&T):
gulp.rc.arguments.label=參數 (&R)：
gulp.rc.nodeInterpreter.label=節點解釋器(&I):
gulp.rc.nodeOptions.label=節點選項(&O):
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G)：
gulp.rc.environmentVariables.label=環境(&E):
gulp.task.title=Gulp 任務
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.gulpfile.not.found=未找到 Gulpfile

# Grunt
grunt.rc.gruntfile.label=Gruntfile (&F)：
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.tasks.label=任務(&T):
grunt.rc.arguments.label=參數 (&R)：
grunt.rc.nodeInterpreter.label=Node 解釋器(&I):
grunt.rc.nodeOptions.label=節點選項(&O):
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P)：
grunt.rc.environmentVariables.label=環境(&E):
grunt.task.title=Grunt 任務
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
grunt.unspecified.gruntfile=未指定 Gruntfile
grunt.gruntfile.not.found=未找到 Gruntfile

#node
settings.nodejs.name=Node.js
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A)：
settings.nodejs.coding.assistance.manage.scopes.label=管理範圍…

node.interpreter.label=節點解釋器(&I):
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.package.manager.label=軟體套件管理器 (&M)：
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.multiple.packages.description=選擇 {0}
node.package.none=無軟體套件
node.package.dropDownList.select=選擇…

inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼協助已禁用
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=切換 Node.js 的編碼輔助

# npm
npm.rc.packageJson.label=package.json (&P)：
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.command.label=指令:(&C)
npm.rc.scripts.label=腳本 (&T)：
npm.rc.scriptsArguments.label=參數 (&R)：
npm.rc.nodeInterpreter.label=Node 解釋器(&I):
npm.rc.nodeOptions.label=節點選項：
npm.rc.environmentVariables.label=環境:
npm.task.title=NPM 腳本
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice, 0#腳本|1#腳本|2#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.no.scripts.found=未找到腳本
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件: 無此類目錄
dialog.message.invalid.npx.command=無效的 npx 指令
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件: Yarn 安裝的軟體套件格式為 ''yarn:[package.json 的相對路徑]:[軟體套件名稱]''。
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.unspecified.package.name=未指定軟體套件名稱。
enable.notifications.about.installing.dependencies.from.package.json=啟用有關從 package.json 安裝依賴項的通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知

# Build tools
buildTools.JsbtRunTaskAction.text=執行 Gulp/Grunt/npm 任務
buildTools.JsbtAddBuildfileAction.text=添加 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.searchEverywhere.text=執行 ''{0}'' 任務
buildTools.searchEverywhere.npm.text=執行 ''{0}'' npm 腳本
buildTools.ShowSettingsAction.text={0}設定…
buildTools.ShowSettingsAction.npm.text=編輯 npm 設定(&E)…
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.tree.sortBy.text=排序方式
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.no.tasks.found=未找到任務
buildTools.edit.run.configuration=編輯執行設定
buildTools.no.files.added=未添加檔案
buildTools.add.with=使用 {1} 添加 {0}
buildTools.no.such.file=沒有此類檔案
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊

#npm modules
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 依賴關係中未列出模組
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
package.json.install.types.fix.family.name=為軟體套件安裝 @types
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發依賴關係
node.js.quickfix.install.node.module.text=安裝 ‘’{0}''
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發依賴關係
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.run.command=執行 ''{0}''
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組：{0}
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組：請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.select.file=選擇 {0} 檔案
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
action.InstallNodeLocalDependencies.text=安裝 Node.js 依賴項
action.InstallNodeLocalDependencies$Root.text=為 {1} 執行 ''{0}''

typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
npm.modules.install.global.types.directory.error=無法創建所需的目錄
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義

typescript.types.union=聯合
typescript.types.intersection=相交
typescript.types.mapped=映射
typescript.types.key=鍵引用
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.type.member={0} 類型屬性
typescript.types.merged.parts=引用的屬性：

# Intentions
ts.generate.reference.path.name=生成引用路徑註釋
ts.add.import.statement.family.name=添加 import 語句
ts.add.import.statement.dialog.title=添加 import 語句
ts.add.import.all.family.name=添加所有明確的匯入
ts.add.import.hint.text=使用 {1} 添加 {0}
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 添加匯入
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.change.import.action.one.title=更改為 {0}
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.command=更改匯入
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.dialog.title=匯入自…
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
anonymous.to.named.intention.function.name=函數名稱：
initialize.fields.intention.visibility=可見性:
command.name.import=匯入 {0}
please.specify.package.manager=指定<a href="">軟體套件管理器</a>。
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 添加到 tsconfig.json
intention.name.import.augmentation=匯入增強 {0}

# Language Service
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.tracking.disabled=錯誤跟踪已禁用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.service.default.project.errors=顯示專案錯誤
javascript.service.node.error=Node 解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.start.timeout=啟動語言服務行程超時
javascript.language.service.cannot.start=無法啟動語言服務行程
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\n
tab.title.errors=錯誤
tab.title.project.errors=專案錯誤
tab.title.compile.errors=編譯錯誤
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
intention.name.loading.service.fixes=正在載入服務修正…

# TypeScript Compiler
typescript.compiler.notification.editor.configure=設定 TypeScript…
typescript.compiler.configurable.name=TypeScript
typescript.use.service.configurable.options.enable=TypeScript 語言服務
typescript.compiler.configurable.options.output.path=使用輸出路徑：
typescript.compiler.configurable.options.compile.main=僅編譯主檔案：
typescript.compiler.configurable.options.compile.main.error=主檔案的路徑不正確
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.generate.source.map=生成源映射
typescript.compiler.configurable.options.enable.no.config=也針對沒有 tsconfig.json 的專案
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.scope=編譯範圍：
typescript.compiler.configurable.options.command.line=選項:
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。設定檔案不正確。
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
typescript.compiler.structure.tab.title=結構
typescript.compiler.starting=TypeScript 正在啟動…

typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案引用


js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=查看所有 {0} 個錯誤
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.service.action.restart=重啟{0}
typescript.compiler.action.compile.all.compile.config=設定 {0} 的編譯檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案引用
typescript.compiler.before.run=編譯 TypeScript

typescript.language.service.clean=正在重置快取…
typescript.language.service.compile.file=正在編譯檔案... {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤... {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤... {0}
typescript.language.service.compile.project.open.file=正在開啟檔案... {0}

typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.path=設定檔案：
typescript.before.task.title=TypeScript 編譯設定
typescript.before.task.config.dialog.title=選擇 tsconfig.json

# Documentation
js.documentation.fires=觸發：
js.documentation.more.overload=其他 {0} 個多載
js.documentation.more.overloads=其他 {0} 個多載

node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器延伸模組。請啟用 {0} 中的延伸模組

# Module Dependencies
javascript.module.dependencies.got.it.title=模組依賴關係圖
javascript.module.dependencies.got.it.text=<div align='left'>此圖顯示所選檔案或目錄具有的模組依賴關係。<br/>要查看多個檔案或目錄的依賴關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.empty.got.it.text=<div align='left'>當前檔案或資料夾沒有任何依賴關係。<br/>請嘗試使用其他檔案或資料夾。</div>
modules.selected=選定

js.remove.redundant.initializer.fix=移除冗餘的初始設定式
js.remove.unused.assignment=移除未使用的賦值
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inject.dont.format.intention.text=禁用注入內容的格式設定

js.webpack.config.highlighting.name=Webpack 設定符合 JSON 架構

js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}：''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}：''{1}'' 位於 package.json 中。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}：設定檔案位於專案中。
js.linter.guesser.linter.disabled={0} 已禁用。

# Breadcrumbs
js.breadcrumbs.callback.for=\ {0}() 回調

typescript.extract.type.alias.name=類型別名…
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串插值
typescript.include.js.sources.action=包括 JavaScript 檔案
escape.pasted.text=在貼上字串文字時轉義文本
jsx.convert.html.attributes.to.jsx=將 HTML 貼上到 JSX 檔案時轉換特性

# Rename member
rename.prompt.do.you.want.to.rename.base.method=要重命名基方法嗎?
js.rename.base.member=重命名基{0}
js.rename.current.member=重命名當前 {0}
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫

# Generate dialog
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.filter.fields=欄位和屬性
generate.filter.button.tooltip=顯示 {0}
generate.filter.button.description=在列表中顯示 {0} 
codestyle.ui.field.prefix=欄位前綴 (&F)：
codestyle.ui.property.prefix=屬性前綴 (&P)：
codestyle.ui.file.name.style=檔案命名慣例 (&N)：
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
inline.cannot.inline.references.this.type=無法內聯引用 'this' 類型的接口
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
generation.bindable.event=可綁定事件(&B):
generation.event.constant=事件常數(&E):

refactoring.extract.react.component.component.for.refactor.this=提取組件…
refactoring.extract.react.component.title=提取組件
refactoring.extract.react.component.no.expression=所選內容不構成 JSX 表達式
refactoring.extract.react.component.no.scope=找不到用於放置所創建組件的範圍
refactoring.create.react.component.title=創建組件
refactoring.react.function.to.class.refactoring.title=轉換為類組件
refactoring.react.function.to.class.intention.title=轉換為類組件
refactoring.react.function.to.class.used.in.new.conflict=\ ''new'' 表達式中使用了 {0}
refactoring.react.function.to.class.used.in.call.conflict=調用表達式中使用了 {0}
refactoring.react.class.to.function.conflict.used.with.ref={0} 與 ''ref'' 特性結合使用。無法為無狀態函數組件提供 ref
refactoring.react.class.to.function.refactoring.title=轉換為函數組件
refactoring.react.class.to.function.intention.title=轉換為函數組件
refactoring.react.could.not.find.in.template=無法重構。找不到名稱為 {0} 的元素。可能的程式碼模板 {1} 無效嗎？
react.function.to.class.caret.at.function=文字游標應置於要轉換的函數處
react.class.to.function.caret.at.class=文字游標應置於要轉換的類處
react.class.component.type.class=類
react.class.component.type.function=函數

js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函數初始化組欄位
intellilang.tagged.literal.injection.name.label=模式:
intellilang.tagged.literal.expression.border.title=模板標籤

refactoring.destructuring.vars.for.refactor.this=物件或陣列析構…
refactoring.destructuring.vars.intention.name=引入物件或陣列析構
refactoring.destructuring.vars.intention.name.object=引入物件析構
refactoring.destructuring.vars.intention.name.array=引入陣列析構
refactoring.destructuring.vars.intention.replace.object=取代為物件析構
refactoring.destructuring.vars.intention.replace.array=取代為數組析構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.propagate=傳播到析構宣告
refactoring.destructuring.vars.intention.depropagate=將析構取代為屬性和索引存取
refactoring.destructuring.vars.intention.deconstruct=生成析構模式
refactoring.destructuring.vars.intention.replace.shorthand=取代為析構和速記屬性
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，高亮顯示的 const 變數將轉換為 let 變數。\n要繼續嗎？
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.guard.conflict=通過類型防護將表達式類型限縮為 ''{0}''，該類型防護在重構後將不起作用
javascript.intention.add.export.family.name=添加匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.default.export.family.name=添加預設匯出
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.intention.promise.to.async.name=轉換為異步功能
javascript.intention.code.optimizations.text=正在最佳化生成的程式碼
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套調用取代為管道表達式
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套調用
javascript.intention.opt.chain.family=使用可選鏈接或空值合併
javascript.intention.opt.chain.chain.only=使用可選鏈接
javascript.intention.opt.chain.coalesce.only=使用空值合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.chain.and.coalesce=使用可選鏈接和空值合併
javascript.intention.expand.opt.chain.family=將可選鏈接或空值合併擴展到顯式檢查
javascript.intention.expand.opt.chain=展開可選鏈接
javascript.intention.expand.nullish.coalescing=展開 null 合併
javascript.intention.expand.or.coalescing=使用 ?: 運算符
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選鏈接和空值合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選鏈接並使用 ?: 運算符
javascript.intention.explicit.fields=宣告顯式類欄位
javascript.intention.explicit.fields.single=宣告顯式類欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位

js.param.hints.show.names.for.all.args=非文字實參
js.param.hints.show.names.for.tagged=標記的模板實參
js.param.hints.show.names.for.pipes=管道運算符
js.param.hints.blacklist.pattern.explanation=要禁用方法或函數提示，請使用下面的其中一種模式: <p style="margin-left: 5px"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 操作來添加模式。</p>

js.checkbox.make.readonly=設為唯讀(&R)

action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.ReactClassToFunctionComponentAction.description=轉換為函數組件
action.ReactFunctionToClassComponentAction.description=轉換為類組件
action.ReactExtractComponentAction.description=提取組件
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.SetAccessor.JavaScript.text=Setter
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.Constructor.JavaScript.text=構造函數
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
group.Editor.JSLibrariesMenu.LibraryList.text=使用庫
group.Editor.JSLibrariesMenu.LibraryList.description=設定使用的 JS 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.MyConfigurable.display.name=JSX
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多設定選項
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式調用
settings.code.style.semicolon.to.terminate.statements=分號終止語句(&S)
settings.code.style.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.Trailing.comma=尾隨逗號(&T):
settings.code.style.single=單
settings.code.style.double=雙
settings.code.style.in.new.code=(在新程式碼中)
settings.code.style.always=始終
settings.code.style.option.use=使用
settings.code.style.dont.use=不使用
checkbox.enable=啟用
webpack.configuration.title=Webpack
webpack.configuration.detect.description=檢測適合模組解析的 {0} 設定檔案:
webpack.configuration.manual=手動
webpack.configuration.automatic=自動
webpack.configuration.disabled=已禁用
webpack.configuration.automatic.how.it.works=運作方式
webpack.configuration.automatic.hint={0} 將使用當前檔案所在資料夾或其任意父資料夾中的 {1} 設定檔案內的模組解析規則。
webpack.configuration.field=設定檔案:
webpack.configuration.field.required.error=手動模式下需要設定檔案路徑
create.react.app.name=React
create.react.app.description=<a href="https://github.com/facebookincubator/create-react-app">創建 React 套用</a>是官方支援的一種創建單頁 React 套用程序的新方法。它提供了沒有設定的現代建置設定。
create.react.app.scripts.version=腳本版本 (&V)
create.react.app.typescript.checkbox=創建 TypeScript 專案 (&T)
dialog.title.new.javascript.file=新建 JavaScript 檔案
list.item.javascript.file=JavaScript 檔案
dialog.title.new.typescript.file=新建 TypeScript 檔案
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
dialog.kind.0.file={0} 檔案
action.creates.new.file.description=創建新的 {0} 檔案
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
action.show.error.details.text=顯示錯誤詳細資訊
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.error.details=錯誤詳細資訊
dialog.message.failed.to.download.0.1=無法下載 {0}。{1}
dialog.title.download.error=下載錯誤
label.import.popup=自動匯入工具提示:
label.namespace=命名空間:
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.title.cannot.introduce.new.interface=無法引入新接口
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被禁用
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>顯示檢查設定</a>或<a href='undo'>撤消</a></html>
dialog.message.cannot.propagate.variable=無法傳播變數: {0}
dialog.title.cannot.propagate=無法傳播
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.title.cannot.convert=無法轉換
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於析構模式的變數沒有用法
button.continue=繼續
button.abort=中止
action.don.t.use.library.description=不使用庫
action.already.set.for.containing.folder.or.project.description=已針對包含的資料夾或專案進行設定。
action.use.library.description=使用庫
text.cannot.download=無法下載 {0}。{1}
notification.content.show.details=顯示詳細資訊
action.name.disable.category=禁用 {0}
progress.text.processing=正在處理 {0}{1}
label.path=路徑(&P):
border.title.inspection.export.results.capitalized.location=位置
border.title.inspection.description.title=描述:
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
action.jump.to.text=跳轉到…
dialog.title.select.navigation.target=選擇導航目標
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類的目標
dialog.message.component.name=組件名稱:
label.name=名稱: 
label.type=類型: 
label.minimum.language.level=最低語言級別:
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法創建實參存根: 調用的方法不是函數
action.show.structure.text=顯示結構
status.text.no.errors.in.current.file=當前檔案中沒有錯誤。
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
dialog.message.cannot.find.file=找不到檔案 {0}
radio.set.options.manually=手動設定選項
radio.use.tsconfig.json=使用 tsconfig.json
separator.deprecated.settings=棄用的設定
dialog.title.main.file=主檔案
label.choose.main.file=選擇主檔案
dialog.title.output.directory=輸出目錄
label.choose.output.directory=選擇輸出目錄
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
status.text.project.structure.isn.t.available=專案結構不可用
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
status.text.refresh.required=需要重新整理
dialog.message.cannot.find.module.for.import=無法建置用於匯入的模組路徑
action.js.tagged.literal.injection.text=JS 標記文字注入
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=添加
label.wsl.node.interpreter=WSL Node.js 解釋器(&N):
dialog.message.please.select.distribution=請選擇分發版
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
status.text.running.which.node=正在執行 `which node`…
progress.title.configuring.node.js.coding.assistance=正在設定 Node.js 編碼輔助…
action.PackageJsonNewFile.text={0}檔案
action.PackageJsonNewFile.description=創建 {0} 檔案
progress.title.install=安裝 {0}
progress.subtitle.install=正在通過 {1} 安裝 {0}…
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
dialog.title.missing.dependencies=缺少依賴項
button.install.update=安裝/更新
action.view.install.text=查看並安裝…
action.don.t.ask.again.text=不再詢問
dialog.title.configure.coding.assistance.for.node.js.api=設定 Node.js API 編碼輔助
action.Anonymous.text.configure=設定
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
popup.title.target.function=目標函數
popup.title.select.destructuring.assignment.target=選擇析構賦值目標
visibility.level.overview=概覽
visibility.level.details=詳細資訊
js.module.uml.presentable.name=JavaScript 模組依賴項
intention.family.name.run.npm.install=執行 'npm install'
intention.name.run.npm=執行 ''{0}''
intention.family.name.navigate.to.package.json=導航到 package.json
intention.name.navigate.to.0.package.json=導航到 {0}/package.json
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
intention.family.name.add.required.property=添加所需的屬性
intention.name.create.library.with.files.outside.project=使用專案外部的檔案創建庫
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unspecified=未指定的 {0}
dialog.message.no.such=沒有這樣的 {0}
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.command.supported.by={1} 不支持指令 ''{0}''
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
titled.separator.predefined=預定義
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
dialog.title.edit.run.debug.configuration=編輯執行/偵錯設定: ''{0}''
js.commandline.configure.language.version=為專案設定 JavaScript 語言版本
js.commandline.configure.nodejs=設定 NodeJS 解釋器並為 package.json 檔案安裝軟體套件

# Language features
js.language.feature.xml.tags=XML 標記
js.language.feature.for.each.statements=針對每條語句
js.language.feature.for.of.loops=for..of 迴圈
js.language.feature.let.definitions=Let 定義
js.language.feature.const.definitions=Const 定義
js.language.feature.generators=生成器
js.language.feature.destructuring.assignments=析構賦值
js.language.feature.let.statements=Let 語句
js.language.feature.array.comprehensions=陣列推導式
js.language.feature.top.level.yield.expressions=頂層 yield 表達式
js.language.feature.reference.namespace=引用命名空間
js.language.feature.default.parameter.values=預設參數值
js.language.feature.pipe.expressions=管道表達式
js.language.feature.decorator.declarations=裝飾器宣告
js.language.feature.throw.expressions=拋出表達式
js.language.feature.ecmascript.syntax.for.private.members=私有成員的 ECMAScript #- 語法
js.language.feature.class.member.visibility.modifiers=類成員可見性修飾符
js.language.feature.optional.chaining.operator=可選鏈接運算符
js.language.feature.arbitrary.precision.integers=任意精度整數
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=函數參數列表和調用中的尾隨逗號
js.language.feature.unicode.escapes.with.braces=使用大括號的 Unicode 轉義
js.language.feature.bind.expressions=綁定表達式
js.language.feature.optional.catch.bindings=可選 catch 綁定
js.language.feature.string.templates=字串模板
js.language.feature.method.definition.shorthands=方法定義速記形式
js.language.feature.computed.property.names=計算的屬性名稱
js.language.feature.shorthand.property.names=速記屬性名稱
js.language.feature.binary.0b.and.new.octal.0o.literals=二進制(0b)和新的八進制(0o)文字
js.language.feature.async.await=async/await
js.language.feature.types=類型
js.language.feature.annotations=註解
js.language.feature.interfaces=接口
js.language.feature.classes=類
js.language.feature.es6.export.declarations=ES6 匯出宣告
js.language.feature.es6.import.declarations=ES6 匯入宣告
js.language.feature.generics=泛型
js.language.feature.rest.parameters=rest 參數
js.language.feature.arrow.functions=箭頭函數
js.language.feature.getters.and.setters=getter 和 setter
js.language.feature.generator.expressions=生成器表達式
js.language.feature.expression.closures=表達式結束
js.language.feature.destructuring.parameters=析構參數

# Webpack
file.name.masks.to.skip.from.analysis=要在分析中跳過的文件名遮罩:

# Node
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.debug.cannot_connect_to_vm.error.message=無法連接到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 延伸模組
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組: 已超時
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組設定
node.core.navigate_action_text.text=設定 Node.js…
node.interpreter.field.add.item.text=添加…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
configure.node.interpreter.path=設定 Node.js 路徑…
node.interpreter.reference_not_found.text=未找到
node.interpreter.command_timed_out.dialog.message=''{0}'' 指令執行超時(>{1} ms)
node.package_documentation.installed_version.text=已安裝版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.packages.cannot_find_working_directory.text=無法確定 {0} 的工作目錄: {1}
node.package.field.not_found.text=未找到
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑: 無此類目錄 "{0}"
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處引用專案 npm 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
package_json.install_dependencies.notification.title=安裝依賴項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.install_dependencies.notification.content=來自 {0}
package_json.update_dependencies.notification.title=更新依賴項
package_json.notifications_are_disabled.notification.content=已禁用從 {0} 安裝依賴項的通知。<p>使用 "{1}" 操作重新啟用通知。
node.wsl.unavailable.dialog.message=WSL 不可用
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.package_manager_link.text=軟體套件管理器
yarn.package_requires_yarn.dialog.message=軟體套件 "{0}" 要求 Yarn {1}。

# Jest
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.snapshot.label=Jest 快照
filetype.jest.snapshot.description=Jest 快照
filetype.jest.snapshot.display.name=Jest 快照
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案

# Protractor
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器設定檔案

# Style guides
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.standard.style=JavaScript 標準樣式

# Inlay hints
method.return.types.in.call.chains=調用鏈中的函數返回類型
type.annotations=類型註解
parameters.in.parentheses=用括號括起來的參數
non.parenthesized.single.parameter=未使用括號括起來的單個參數
function.returns=函數返回類型
variables.and.fields=變數和欄位
command.name.add.explicit.value=添加顯式值 ''{0}''
numeric.enum.values=數值枚舉值

# Libraries
progress.title.downloading.library=正在下載庫
progress.title.downloading.documentation=正在下載文檔
successfully.downloaded=已成功下載
failed.to.download=無法下載
progress.title.downloading.typings=正在下載 typings
notify.urls.more=… 和另外 {0,number} 個

# Structural Search
structural.search.anonymous.functions=匿名函數
structural.search.functions=函數
structural.search.variables=變數
structural.search.function.calls=函數調用
structural.search.while.loops=While 迴圈
structural.search.constants=常數
structural.search.classes=類
structural.search.empty.functions=空函數
structural.search.console.log.calls=調用 console.log()
structural.search.with.statements=With 語句
structural.search.var.statements=Var 語句
structural.search.functions.with.boolean.parameters=使用布爾參數的函數
structural.search.comparison.to.self=與自身比較

# Project Generators
copying.files=正在複製檔案
project.generation=生成專案
notification.title.cannot.generate=無法生成 {0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
generating.0=正在生成 {0}

# Find Usages
js.show.dynamic.usages=顯示動態用法

# Test Runners
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown

# Diagrams
diagram.element.not.found={0} (未找到)

# Web frameworks
web.template.file-type.description={0} 模板
web.inspection.message.attribute.does.not.accept.value={0} 不接受任何值

# Other
command.name.create.javascript.file=創建 JavaScript 檔案 {0}
command.name.create.typescript.file=創建 TypeScript 檔案 {0}
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移動到欄位初始設定式
popup.title.choose.class=選擇類
multiple.inheritance=多重繼承
label.method.should.be.defined=方法應已定義
recursive.call=遞歸調用
command.name.extract.named.type=提取已命名類型
inspection.message.reference.includes.files.outside.project=引用包括專案範圍之外的檔案
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根添加到 {0}
label.name.injection=名稱(&N):
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
unwrap.with.kind=解開 ''{0}…''
header.declarations.to.be.refactored=要重構的宣告
filetype.yarn.lock.display.name=Yarn Lock
filetype.yarn.lock.description=Yarn lock



javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
javascript.parser.message.missing.back.quote=缺少 `
node.interpreter.unavailable.target=不可用的目標: {0}
rename.react.hook.variable.title=重命名狀態變數
rename.react.hook.variable.description=將相關狀態變數重命名為:
web.inspection.message.attribute.value.no.valid={0} 不是 {1} 的有效值。預期值: {2}
add.variable.to.require=添加 require 調用的變數
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.regex.flag.d=符合索引 - 用於子字串符合的索引
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連接(可能被防火牆阻止)。\n要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
intention.category.javascript=JavaScript
intention.category.typescript=TypeScript
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.react=React
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
web.inspection.message.segment.missing=缺少 {0}
web.inspection.message.segment.unrecognized-identifier=無法識別的 {0}
web.inspection.message.segment.duplicated=重複的 {0}
web.inspection.message.segment.default-subject=名稱
not.installed.package=未安裝軟體套件
package.version.range.info={0, choice, 0#未安裝|1#已安裝: ?|2#已安裝: {1}}，最新: {2, choice, 0#正在載入…|1#未找到|2#{3}}
package.version.range.hint={0, choice, 0#允許|1#允許次要更新:|2#允許補丁更新:} {1} \\&gt;= 版本 \\&lt; {2}
env.variable.undefined={0} 未定義
env.variable.empty={0} 為空
jquery.documentation.not.found=找不到 jQuery 文檔
typescript.language.service.name=TypeScript 服務
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作生成器內部的關鍵字
linemarker.javascript.sources=JavaScript 源
linemarker.typescript.declaration=TypeScript 宣告
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
js.dot.property.access.context.type=點號屬性存取
javascript.library.built.in=內建
inlay.parameters.js.only.show.names.for.all.args=文字和非文字實參、調用表達式、物件和陣列初始設定式。
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>標記模板中的實參。<a><br>此設定僅對非文字實參生效，並且僅在啟用“非文字實參”選項時可用。
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.param.hints.show.names.for.all.args=方法調用中的文字和命名物件參數。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的文字和命名物件參數。
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a>
inlay.parameters.vuejs.show.names.for.all.args=文字和命名物件。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://v2.vuejs.org/v2/guide/filters.html'>篩選器(Vue 2)。</a>
js.url.import.usage.inspection.name=使用了 URL 匯入
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL:
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 依賴項更新為最新版本
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
node.package.empty.error.message=專案名稱為空
node.package.name.period.error.message=專案資料夾名稱不應以句點開頭
node.package.name.underscore.error.message=專案資料夾名稱不應以下劃線開頭
node.package.name.leading.or.trailing.spaces.error.message=專案資料夾名稱不應包含前導空格或尾隨空格
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.too.long.error.message=專案資料夾名稱不應超過 214 個字符
node.package.name.capital.letters.error.message=專案資料夾名稱不應包含大寫字母
node.package.name.special.characters.error.message=專案資料夾名稱不應包含特殊字符("~'!()*")
node.package.name.URL-friendly.characters.error.message=專案資料夾名稱應僅包含適用於 URL 的字符
javascript.parser.message.expected.identifier.string.literal.or.rbrace=應為關鍵字、字串文字或 }
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 ".js"
js.import.options.use.explicit.js.extension.no=從不
js.flow.process.log=Flow 流程日誌
flow.js.show.settings=設定 Flow…
flow.js.widget.name=Flow
flow.js.widget.display.name=Flow JS
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.insert.symbol.fix=插入{0}
node.js.configure.interpreter=設定 {0}
yarn.pnp.library_name=來自 {0} 的依賴項
typescript.enum.name=枚舉
typescript.enum.member.name=枚舉成員
icon.icons.nodes.readonlyMark.tooltip=readonly
notification.group.narrowed.types=JavaScript: 已禁用限縮的類型的著色
notification.group.nodejs.interpreter=Node.js 解釋器路徑已更新
notification.group.nodejs.assistance=Node.js 編碼輔助失敗
notification.group.package.json=來自 package.json 的依賴項可用
notification.group.package.json.disabled=來自 package.json 的依賴項: 通知已禁用
notification.group.linters=JavaScript linter
notification.group.project.generator=JavaScript 專案生成失敗
notification.group.grunt.console=Grunt 'watch' 任務狀態已變更
dialog.message.invalid.npm.package=無效的 {0} 軟體套件: 無此類檔案或目錄
notification.group.webpack=Webpack 設定分析失敗
notification.group.jest=Jest 測試執行失敗
node.package.selector.multiple.packages.binary.file.title=選擇 {0} 的軟體套件目錄或二進制檔案
node.package.binary.file.hint=指向 {0} 的二進制檔案的路徑
npm.failed_to_install_package.title.message=無法安裝 {0}
js.language.feature.enums=枚舉
js.class.member.expression.context.type=類成員表達式
js.class.member.statement.context.type=類成員語句
eslint.run.on.save.disabled.comment=已禁用 ESLint 整合
eslint.run.on.save.auto.configuration.comment=自動 ESLint 設定
eslint.run.on.save.manual.configuration.comment=手動 ESLint 設定
node.execution.failed.to.prepare.target.environment.error=無法準備環境: {0}
vite.configuration.title=Vite
web.bundler.failed.to.load=無法載入 {0}
web.bundler.analyzing.configs.progress=正在分析 Web Bundler 的設定檔案
web.bundler.cannot.analyze=無法分析 {0}: 編碼輔助將忽略此檔案中的模組解析規則。\n可能的原因: 此檔案不是有效的設定檔案，或者 IDE 目前不支持其格式。
notification.group.vite=Vite 設定分析失敗
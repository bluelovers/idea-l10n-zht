method=方法
function=函數
block=塊
lambda=Lambda
callable.type.title=可調用類型
annotator.type.literals.are.not.supported=編譯器不支持 {0} 文字
extract.category.dialog=提取類別
extract.category.unable.create.file=無法創建檔案
extract.unavailable.for.protocols=此操作不適用於協議
extract.method.selected.block.hint=所選塊應代表一組語句或表達式
extract.method.cannot.determine.hint=無法確定所選表達式的類型
extract.class.use.protocol.instead=改用“提取超級協議”
extract.class.element.not.located.hint=所選元素是一個不在專案內部的類上的類別
extract.subclass.dialog.title=提取子類
extract.symbol.already.exist={0} 已存在
create.file.title=檔案
create.file.description=創建新檔案

create.field.name.category=類別名稱(&N):

create.field.language=語言(&L):
create.field.class=類(&C):
create.class.title=Objective-C 類
create.class.dialog.title=新建 Objective-C 類
create.class.objc=Objective-C (.m)
create.class.objcpp=Objective-C++ (.mm)
create.class.description=創建新的 Objective-C 類和標頭檔
create.protocol.title=Objective-C 協議
create.protocol.description=創建新的 Objective-C 協議
create.protocol.dialog.title=新建 Objective-C 協議
create.category.title=Objective-C 類別
create.category.description=創建新的 Objective-C 類別
create.category.dialog.title=新建 Objective-C 類別
create.checkbox.category.interface=創建接口檔案(&I)
create.category.no.class.dialog=找不到類 ''{0}''。\n要創建類別嗎?
create.category.no.class.dialog.title=類無效
create.implementation.title=實作
create.implementation.description=創建新的實作
create.interface.title=接口
create.interface.description=創建新的接口
codeassists.surroundwith.expression=環繞方式
copy.files.handler.fail=無法將檔案複製到 ''{0}''
code.style.remember.choice=記住選擇
refactoring.categoryElement.not.in.project=所選元素位於不在專案內部的類上的類別中
refactoring.category.not.in.project=所選元素是一個不在專案內部的類上的類別
navigation.import.hierarchy.including.title=包含 {0} 的檔案
navigation.import.hierarchy.including.action=包含層次結構
navigation.import.hierarchy.including.action.description=切換到包含層次結構
navigation.import.hierarchy.included.title={0} 包含的檔案
navigation.import.hierarchy.included.action=已包含的層次結構
navigation.import.hierarchy.included.action.description=切換到已包含的層次結構
navigation.import.hierarchy.next.occurence=轉到下一個檔案
navigation.import.hierarchy.previous.occurence=轉到上一個檔案
navigation.goto.please.wait=請稍候…
navigation.goto.resolving.target=正在解析目標…
naming.convention.title=命名慣例
naming.convention.header.guard.style.help=您可以使用預定義變數，例如:<br><b>${PROJECT_NAME}</b>、 <b>${PROJECT_REL_PATH}</b>、 <b>${FILE_NAME}</b>、 <b>${EXT}</b> 和 <b>${UUID}</b>。<br>所有來自<i>編輯器/檔案和程式碼模板</i> (<i>“檔案”頁籤</i>)<br>的預定義變數也可用(例如 <b>${USER}</b>、<b>${DATE}</b> 等)
naming.convention.entity.kind=實體種類
naming.convention.visibility=可見性
naming.convention.specifier=說明符
naming.convention.entity.any=任意
naming.convention.entity.namespace=命名空間
naming.convention.entity.macro=巨集
naming.convention.entity.class=類
naming.convention.entity.struct=結構
naming.convention.entity.enumeration=枚舉
naming.convention.entity.union=聯合
naming.convention.entity.typedef=Typedef
naming.convention.entity.global.function=全域函數
naming.convention.entity.global.variable=全域變數
naming.convention.entity.class.member.function=類成員函數
naming.convention.entity.struct.member.function=結構成員函數
naming.convention.entity.class.member.field=類成員欄位
naming.convention.entity.struct.member.field=結構成員欄位
naming.convention.entity.enumerator=枚舉器
naming.convention.entity.parameter=參數
naming.convention.entity.local.variable=局部變數
naming.convention.prefix=前綴
naming.convention.suffix=後綴
refactoring.convertIvarUsagesToProperties=將 ivar 用法轉換為屬性(&C)
refactoring.ambiguous=不明確的函數無法被重構
title.function.return.type.group=函數返回類型之後
title.function.top.return.type=在全域和命名空間範圍中
title.function.nontop.return.type=在類範圍中
title.function.parameters.group=函數宣告參數
title.function.call.arguments.group=函數調用實參
title.template.decl.class.group=模板類宣告
title.template.decl.func.group=模板函數宣告
title.template.parameters.group=模板宣告參數
title.template.call.arguments.group=模板實例化實參
title.ctor.init.list.group=構造函數初始化列表
title.superclass.list.group=基類列表
title.shift.operators.group='<<', '>>' 運算符
title.capture.list.group=Lambda 捕獲列表
wrapping.new.line.after.lt=在 '<' 後換行
wrapping.gt.on.new.line=將 '>' 置於新行中
wrapping.align.multiline.parentheses=對齊多行括號
wrapping.align.multiline.brackets=對齊多行中括號
wrapping.align.multiline.lt.gt=對齊多行 '<','>'
wrapping.keep.simple.case.inline=將簡單 case 保持在同一行
wrapping.keep.simple.methods.in.one.line=簡單函數在同一行
wrapping.keep.simple.methods.in.one.line.oc=簡單方法和函數在同一行
wrapping.keep.simple.blocks.in.one.line=簡單的 lambda 在同一行
wrapping.keep.simple.blocks.in.one.line.oc=簡單塊和 lambda 在同一行
wrapping.keep.nested.namespaces.in.one.line=將嵌套命名空間保持在同一行
wrapping.keep.directive.at.first.column=指令在第一列
wrapping.brace.placement.class.declaration=在類和結構中
wrapping.property.declaration.oc=@property 宣告
wrapping.try.statement='try' 語句
wrapping.catch.on.new.line='catch' 在新行
wrapping.array.initializer=初始設定式列表
wrapping.array.initializer.oc=集合文字和初始設定式列表
wrapping.align.multiline.fields.groups=變數組
wrapping.align.in.columns=列中對齊
wrapping.structures.in.one.line=類和結構在同一行
wrapping.before.brace.namespace=在命名空間中
wrapping.ternary.short.inline='a ?: b' 中的 '?:' 不換行
wrapping.try.statement.oc='@try' 語句
wrapping.catch.on.new.line.oc='@catch' 在新行
wrapping.finally.on.new.line.oc='@finally' 在新行
wrapping.array.initializer.lbrace.on.next.line.oc=在'{'、'[' 後換行
wrapping.array.initializer.rbrace.on.next.line.oc=將 '}'、']' 置於新行中
wrapping.method.brace.placement=在方法中
wrapping.function.brace.placement=在函數中
wrapping.block.brace.placement=在 lambda 中
wrapping.block.brace.placement.oc=在塊和 lambda 中
wrapping.method.parameters.align.by.colons=通過冒號對齊
wrapping.method.call.arguments.special.dictionary.pairs.treatment=特殊 NSDictionary 初始化處理
wrapping.indent.template.body.if.wrapped=若換行則縮排模板主體
wrapping.new.line.after.colon=在 ':' 後換行
wrapping.new.line.before.colon=將 ':' 置於新行中
wrapping.new.line.never=從不
wrapping.new.line.always=始終
wrapping.new.line.if.long=如果過長
align.dictionary.values=對齊列中的字典值
align.init.list.values=對齊列中的初始設定式列表值
space.within.empty.code.blocks=空程式碼大括號
space.within.template=在 <...> 內
space.within.empty.diamond=在空 <> 內
space.within.template.double.gt=在模板中防止 >> 串聯
space.within.bracket=陣列中括號
space.within.array.initializer.braces=初始設定式列表大括號
space.within.array.empty.initializer.braces=空初始設定式列表大括號
space.within.array.initializer.braces.oc=集合文字和初始設定式列表大括號
space.within.array.empty.initializer.braces.oc=空集合文字和初始設定式列表大括號
space.within.function.declaration.parentheses=函數宣告圓括號
space.within.empty.function.declaration.parentheses=空函數宣告括號
space.within.function.call.parentheses=函數調用圓括號
space.within.empty.function.call.parentheses=空函數調用括號
space.within.lambda.capture.list.brackets=Lambda 捕獲列表中括號
space.within.empty.lambda.capture.list.brackets=空 lambda 捕獲列表中括號
space.within.catch.parentheses.oc='@catch' 圓括號
space.within.synchronized.parentheses.oc='@synchronized' 括號
space.within.protocols.brackets.oc=協議列表中括號
space.within.property.attributes.parentheses.oc='@property' 特性括號
space.within.method.return.type.parentheses.oc=方法返回類型括號
space.within.method.parameter.type.parentheses.oc=方法參數類型括號
space.within.send.message.brackets.oc=發送訊息中括號
space.within.template.declaration=在模板宣告中
space.within.template.inst=在模板實例化中
space.within.class=在類/結構中
space.before.initialization.lists.colon=構造函數初始化列表冒號之前
space.after.initialization.lists.colon=構造函數初始化列表冒號之後
space.before.lt.template=在 '<' 前面
space.before.function.call.parentheses=函數調用圓括號
space.before.function.parentheses=函數宣告圓括號
space.before.class.lbrace=類/結構左大括號
space.before.method.lbrace=函數左大括號
space.before.method.lbrace.oc=方法/函數左大括號
space.before.namespace.lbrace=命名空間左大括號
space.before.init.list.lbrace=初始設定式列表左大括號
space.before.superclass.colon=基類冒號之前
space.before.pointer.in.declaration=宣告中的 '*' 之前
space.before.reference.in.declaration=宣告中的 '\\&' 之前
space.before.catch.parentheses.oc='@catch' 圓括號
space.before.try.lbrace.oc='@try' 左大括號
space.before.catch.lbrace.oc='@catch' 左大括號
space.before.finally.lbrace.oc='@finally' 左大括號
space.before.synchronized.lbrace.oc='@synchronized' 左大括號
space.before.catch.keyword.oc='@catch' 關鍵字
space.before.finally.keyword.oc='@finally' 關鍵字
space.before.synchronized.parentheses.oc='@synchronized' 括號
space.before.autorelease.pool.lbrace.oc='@autoreleasepool' 左大括號
space.before.category.parentheses.oc=類別括號之前
space.before.protocols.brackets.oc=協議列表中括號之前
space.before.chained.send.message.oc=鏈式訊息發送之前
space.before.property.attributes.parentheses.oc='@property' 特性括號
space.before.dictionary.literal.colon=位欄位中的冒號之前
space.before.dictionary.literal.colon.oc=字典文字 'key:value' 對中的冒號和位欄位之前
space.after.superclass.colon=基類冒號之後
space.after.structures.rbrace=結構中的右大括號之後
space.after.pointer.in.declaration=宣告中的 '*' 之後
space.after.reference.in.declaration=宣告中的 '\\&' 之後
space.after.reference.in.rvalue=取消引用和 address-of 之後
space.after.method.return.type.parentheses.oc=方法返回類型括號之後
space.after.method.parameter.type.parentheses.oc=方法參數類型括號之後
space.after.visibility.sign.in.method.declaration.oc=方法宣告中的 +/- 之後
space.after.colon.in.selector.oc=選擇器中的冒號之後
space.after.cup.in.blocks.oc=塊中的 '^' 之後
space.after.dictionary.literal.colon=位欄位中的冒號之後
space.after.dictionary.literal.colon.oc=字典文字 'key:value' 對中的冒號和位欄位之後
space.between.adjacent.brackets=在相同類型的中括號之間保持空格
space.between.operator.punctuator='operator' 關鍵字和標點符號之間
space.discharged.short.ternary.operator='?' 與 'a ? : b' 中的 ':' 之間空格
space.around.relational.operators=關係運算符 (<, >, <=, >=, <=>)
space.around.shift.operators=移位運算符 (<<, >>)
space.around.lambda.arrow='->' 在返回類型中
space.around.pm.operators=指針成員運算符(->、 .、->*、.*)
blank.lines.before.includes=include 前:
blank.lines.after.includes=include 後:
blank.lines.around.classes=類/結構周圍:
blank.lines.after.class.header=類/結構頭之後:
blank.lines.around.member.variable=環繞欄位:
blank.lines.around.member.variable.oc=實例變數/欄位周圍:
blank.lines.around.global.variable=全域變數周圍:
blank.lines.around.function.declaration=函數宣告周圍:
blank.lines.around.function.declaration.oc=方法/函數宣告周圍:
blank.lines.around.function.definition=函數定義周圍:
blank.lines.around.function.definition.oc=方法/函數定義周圍:
blank.lines.before.function.body=函數主體之前:
blank.lines.before.function.body.oc=方法/函數主體之前:
completion.press.keyboard.shortcut.for.all.methods.selectors=為所有方法選擇器再次按 {0}
completion.press.keyboard.shortcut.to.filter.results.by.type=按 {0} 按類型篩選結果
completion.press.keyboard.shortcut.for.non.imported.symbols=為未匯入的符號再次按 {0}
completion.press.keyboard.shortcut.for.global.symbols=為全域符號再次按 {0}
completion.press.shortcut.again.for.non.public.members=為非 public 成員 {1, choice, 0#|1#再次} 按 {0}
completion.press.shortcut.again.for.non.imported.members=為非匯入的成員和 NSObject 類別的成員 {1, choice, 0#|1#再次}按 {0}
collapse.ivars=實例變數
collapse.synthesizes=合成語句
collapse.localized.strings=已本地化的字串
collapse.multiline.comments=多行註釋
collapse.block.expressions.oc=塊和 lambda
collapse.block.expressions=Lambda
collapse.conditionally.non-compiled=有條件的未編譯程式碼
collapse.template.param.list=模板參數
collapse.new.line.before.lbrace=如果摺疊，則在 '{' 之前用空格代替換行
color.this.keywords='this' 關鍵字
color.preprocessor.directive=預處理程序//指令
color.preprocessor.path=預處理程序//頭路徑
color.format.string.token=字串實參中的格式說明符
color.conditionally.non-compiled=有條件的未編譯程式碼
color.macro.name=巨集名稱
color.macro.parameter=巨集參數
color.global.variable=全域變數
color.extern.variable=extern 變數
color.struct.union.oc=Struct/enum/union
color.struct.union=類/結構/枚舉/聯合
color.struct.field=結構欄位
color.concept=概念
color.template.type=模板類型
color.template.value=模板值
color.namespace=命名空間
color.enum.const=枚舉常數
color.function.declaration=函數宣告
color.function.call=函數調用
color.overloaded.operator=大括號和運算符//多載運算符
color.typedef=Typedef
color.label=標籤
color.dependent_code=依賴程式碼
color.deduction_guide=推導指南
color.this.keywords.oc='self'、'super'、'this' 關鍵字
color.instance.variable.oc=實例變數
color.method.declaration.oc=方法宣告
color.method.call.oc=方法調用
color.property.oc=屬性
color.property.attribute.oc=屬性特性
color.class.reference.oc=類
color.protocol.reference.oc=協議
color.generic.parameter.oc=泛型參數
indent.namespace=縮排命名空間成員
indent.interface.protocol=縮排 '@interface' 和 '@protocol' 成員
indent.not.ivar=實例變數列表除外
indent.implementation=縮排 '@implementation' 成員
indent.visibility.keywords=縮排類/結構中的可見性關鍵字
indent.block=在 lambda 中縮排
indent.block.oc=在塊和 lambda 中縮排
indent.c.struct=縮排純結構成員和枚舉
indent.class=縮排類成員
indent.class.oc=縮排 C++ 類成員
indent.preprocessor.directive=預處理程序指令縮排
indent.preprocessor.directive.as.code=遵循程式碼縮排
#indent.preprocessor.directive.after.hash=Indent after #
inline.handler.check.for.validness=正在驗證…
checkbox.block.comment.indent=在塊註釋中縮排新行
override.implement.show.no.optional.members=顯示可選成員(無可選項)
override.implement.show.only.optional.members=顯示可選成員(僅可選項)
override.implement.show.no.synthesized.accessors=顯示合成存取器(無存取器)
override.implement.show.only.synthesized.accessors=顯示合成存取器(僅存取器)
override.implement.cpp.action.title=覆寫/實作函數
override.implement.cpp.action.name=覆寫函數…
override.implement.cpp.action.memberChooserTitle=選擇要覆寫/實作的函數
override.implement.cpp.action.noMember={0} 沒有要覆寫/實作的函數
override.implement.cpp.action.noParent=沒有要覆寫/實作的函數
override.implement.cpp.action.insertOverride=插入“override”特性(&I)
override.implement.cpp.action.showNonVirtual=顯示非虛擬函數(&N)
override.implement.cpp.action.insertVirtualWithOverride=將“virtual”特性與“override”一起插入
implement.cpp.action.name=實作函數…
implement.cpp.action.memberChooserTitle=選擇要實作的函數
implement.cpp.action.noMember={0} 沒有要實作的函數
implement.cpp.action.noParent=沒有要實作的函數
changeSignature.usages.cantBeUnnamed=參數 {0} 已被使用，不能取消命名
changeSignature.usages.cantBeRemoved=參數 {0} 已被使用，不能移除
changeSignature.usages.cantConvertSelectorToFuncBlock=無法將選擇器表達式轉換為函數/塊
changeSignature.usages.cantConvertToBlock=無法轉換為塊:
changeSignature.usages.cantConvertLanguage=無法轉換 {0} 程式碼中的用法
#changeSignature.usages.ambiguousReference=Function {0} is ambiguously referenced
changeSignature.usages.noUsagesFound=找不到用法
changeSignature.usages.moreThan1Found=找到超過 1 個用法
changeSignature.usages.usageInsideFunction=用法在函數/方法內部
changeSignature.usages.functionHasSeveralDefinitions=函數 ''{0}'' 具有多個定義
changeSignature.usages.atLeasTwoParams=至少兩個參數的名稱為 ''{0}''
changeSignature.usages.conflictsWithNewParameter={0} 與新參數衝突
changeSignature.usages.unrelatedSelector=可能不相關的同名選擇器將被重命名
changeSignature.usages.willConflictWith={0} 將與 {1} 衝突
changeSignature.usages.willConflictWithMethod={0} 將與 {1} 中的方法衝突
changeSignature.targetNotFound=文字游標應置於函數、方法或塊處
changeSignature.dialog.containing.class=包含類:
changeSignature.dialog.callable.type=可調用類型:
changeSignature.parameter.selector.part=選擇器部分:
rename.renameAssociatedFiles=同時重命名關聯的檔案?
rename.renameContainingFile=同時重命名包含檔案?
rename.renameAssociatedClass=同時重命名關聯的類/結構
find.existing.operators.progress.title=正在搜尋現有的運算符
generate.definitions.intention.familyName=生成定義
generate.definitions.intention.outsideText=生成定義
generate.definitions.intention.inlineText=就地生成定義
generate.definitions.action.name=生成定義…
generate.definitions.action.title=生成定義
generate.definitions.action.memberChooserTitle=選擇要為其生成定義的函數
generate.definitions.action.noParent=沒有要為其生成定義的函數
generate.definitions.action.noMembers={0} 沒有要為其生成定義的函數
generate.definitions.quickfix.inlineText=就地為 {0} 生成定義
generate.definitions.quickfix.outsideText=為 {0} 生成定義
generate.definitions.progress.text=正在尋找現有定義…
generate.comparison.operators.action.title=生成比較運算符
generate.comparison.operators.action.title.eq=生成相等運算符
generate.comparison.operators.action.title.rel=生成關係運算符
generate.comparison.operators.member.chooser.title=選擇要使用的欄位
generate.comparison.operators.as.member.option=作為類成員生成(&M)
generate.comparison.operators.use.std.tie=使用 std::&tie
generate.comparison.operators.additional.eq.option=將 != 與 == 一起生成(&W)
generate.comparison.operators.additional.eq.option.desc=將 != 與 == 一起生成
generate.comparison.operators.additional.rel.option=將 >、<=、>= 與 < 一起生成(&W)
generate.comparison.operators.additional.rel.option.desc=將 >、<=、>= 與 < 一起生成
generate.comparison.operators.usages.all.defined=所有運算符均已定義。
generate.comparison.operators.usages.some.defined=部分運算符已定義。
generate.comparison.operators.usages.existing.text=現有運算符
generate.getter.add.prefix=將 get/is 前綴添加到 getter
generate.setter.add.prefix=將 set 前綴添加到 setter
generate.stream.output.action.title=生成流輸出運算符
generate.stream.output.member.chooser.title=選擇要使用的欄位
generate.stream.output.usages.all.defined=流輸出運算符已定義
generate.stream.output.usages.existing.text=現有運算符
generate.configurable.retain.parameters=在 initWith 中保留物件參數…
generate.configurable.use.property.setters=在 initWith 中使用屬性 setter…
generate.configurable.put.ivars=盡可能將 ivars 放入實作
generate.configurable.semicolon.after.method=實作中方法簽名後的分號
generate.configurable.use.nsinteger.and.cgfloat=在引入變數中使用 NSInteger 和 CGFloat
generate.configurable.instance.variable.prefix=實例變數的前綴:
generate.configurable.instance.variable.suffix=實例變數的後綴:
generate.configurable.add.brief.tag=添加 @brief 標記
generate.configurable.const.volatile.placement=const/volatile 限定符位置
generate.configurable.top.level.declarations.order=頂層宣告順序
generate.configurable.ivars.release.style=Ivars 釋放樣式(對於 'dealloc')
generate.configurable.ivars.generation=為屬性生成 ivar 宣告
generate.configurable.ivars.generation.always=始終生成
generate.configurable.ivars.generation.never=從不生成
generate.configurable.ivars.generation.ask=詢問
generate.configurable.tag.prefix.comments=行註釋中的標記前綴
generate.configuralble.tag.prefix.block.comments=塊註釋中的標記前綴
generate.configurable.documentation.title=文檔註釋
inspections.templateArguments.tooFew=模板實參過少，應為 {0} 個
inspections.templateArguments.tooFewAtLeast=模板實參過少，應為至少 {0} 個
inspections.templateArguments.tooMany=模板實參過多，應為 {0} 個
inspections.templateArguments.tooManyAtMost=模板實參過多，應為至多 {0} 個
inspections.templateArguments.valueInsteadOfType=應為值而不是類型
inspections.templateArguments.typeInsteadOfValue=應為類型而不是值
inspections.typeChecks.volatileConflict=正在將非 volatile 結構分配至 volatile 結構
inspections.duplicate.explicitInstantiation=重複的顯式實例化
inspections.typeChecks.neitherNumericNorPointer=類型 ''{0}'' 的表達式既不是數字也不是指針
inspections.typeChecks.notNumeric=類型 ''{0}'' 的表達式不是數字
inspections.fileChecks.outOfProject=此檔案不屬於任何專案目標；程式碼洞察功能可能無法正常工作。
inspections.fileChecks.allContextsUnloaded=編制索引已對此目標的所有可用解析上下文禁用；程式碼洞察功能可能無法正常工作。
inspections.fileChecks.sourceTooLarge=檔案大小({0})超出了為 {1} 設定的限制({2})。程式碼洞察功能不可用。
inspections.fileChecks.headerTooLarge=檔案包含長度({0})超出為 {1} 設定的限制({2})的內聯頭({3})。頭未解析。
inspections.fileChecks.headerTooLargePlatform=檔案包含長度({0})超出設定限制({1})的內聯頭({2})。頭未解析。
checkbox.allow.import.in.completion=在補全中自動匯入
group.option.predefine=在 .m 內的 .h/Import 中預宣告 
group.option.import=在 .h 中匯入
progressbar.long.resolve.description=解析操作需要更多時間…\n如果您取消，則依賴於解析的編輯器操作將不可用
action.invalid.title=無效
change.signature.convert.action=選擇要轉換為{0}的實作
header.source.looking.for.the.best.file=正在尋找關聯檔案
resolve.contexts.select.automatically=自動選擇
oc.inlay.hints.blacklist.pattern.explanation=要禁用方法提示，請使用相應模式: <p> <code><b>(*info)<b></code> - 參數名稱以 info 結尾的單參數方法<br> <code><b>(key, value)<b></code> - 包含參數鍵和值的方法<br> <code><b>*::put(key, value)<b></code> - 包含鍵和值參數的 put 方法<br> </p>
oc.inlay.hints.show.hints.for.enum.constants=顯示枚舉常數提示
oc.inlay.hints.show.hints.for.constructors=顯示構造函數表達式提示
oc.inlay.hints.show.amp.nonconst.references=為非常數引用顯示 '\\&'
include.cpp.message='#include <C++>' 一個面向對 C++ 感興趣的開發者的全球性、包容性和多元化社區
include.cpp.url=https://www.includecpp.org/
include.cpp.intention.text=了解詳情
usage.properties.search.message.delete=也要刪除 {0} 嗎?
usage.properties.search.message.find.usages=也要尋找 {0} 的用法嗎?
usage.properties.search.title=屬性搜尋
usage.instance.variables.search.message.delete=也要刪除 {0} 嗎?
usage.instance.variables.search.message.find.usages=也要尋找 {0} 的用法嗎?
usage.instance.variables.search.title=實例變數搜尋
usage.method.search.title=方法搜尋
usage.method.search.message.delete={0}\n\n要刪除基{1}嗎?
usage.method.search.message.find.usages={0}\n\n要尋找基{1}的用法嗎?
usage.delete.out.of.project.title=警告
usage.delete.out.of.project.message={0} 要繼續執行重構嗎?
usage.overrides.message={0} 覆寫 {2} 中的 {1}。
usage.overrides.out.of.project.message={0} 覆寫專案外的 {2} 中的 {1}。
usage.include.property.checkbox.text=包含 {0}
usage.include.ivar.checkbox.text=包含 {0}
usage.include.derived.classes.checkbox.text=包含派生類
switch.header.source.popup.title=轉到頭/源
switch.header.source.no.results=無相關檔案
command.line.parser.unknown.exception=命令行解析期間出錯
command.line.parser.cancellation.exception=命令行解析被中斷
command.line.parser.invalid.exception=無法解析命令行:\n{0}\n選項 #{1} 中出錯: ''{2}''
configurable.OCGenerateCodeConfigurable.display.name=程式碼生成
abstract.extract.dialog.class.name={0} 名稱:
abstract.extract.dialog.unable.create.file=無法創建檔案
browse.include.hierarchy.action=匯入層次結構
escalate.visibility=升級可見性
escalate.visibility.description=是否要升級以下成員的可見性?
dump.file.symbol.stats=檔案符號統計資訊
dump.symbol.stats=符號統計資訊
highlighter.change.file.length.limit=更改最大檔案長度
highlighter.change.file.length.limit.input=以字符為單位輸入 {0} 檔案的新最大長度
highlighter.max.file.length.title=最大檔案長度
if.responds.to.surround.error.hint=所選程式碼中沒有發送訊息表達式
quickfixes.implement.missing.getter=實作缺少的 getter 方法
quickfixes.implement.missing.setter=實作缺少的 setter 方法
quickfixes.import.symbol=匯入符號
quickfixes.make.function.virtual=使函數為虛擬
quickfixes.make.property.dynamic=使 {0} 為 @dynamic
quickfixes.synthesize=合成{0}
move.dialog.move.members.to.class=將成員移至類(現有或新的):
move.dialog.move.declarations.to.file=將宣告移至檔案(現有或新的):
move.dialog.put.to.namespace=置於命名空間(現有或新的):
move.dialog.move.declarations=移動宣告
move.dialog.destination=目標:
move.dialog.target.file.does.not.exist=目標檔案 ''{0}'' 尚不存在。
move.dialog.create.new.file=創建新檔案
move.dialog.create.new.class=創建新類
move.processor.skip=跳過
push.down.members.dialog=將{0}的成員下推至:
push.down.dialog.searching.inheritors=搜尋繼承者
resolve.show.related.contexts=僅顯示相關上下文
resolve.show.all.contexts=顯示所有上下文…
symbol.table.activity.building.symbols=正在建置符號…
symbol.table.activity.loading.symbols=正在載入符號…
symbol.table.activity.updating.symbols=正在更新符號…
symbol.table.activity.loading.header.maps=正在載入標頭映射…
symbol.table.dump.stats.action=統計資訊寫入{0}
# action names
action.CIDR.DebugDumpBuildingSymbols.text=C/C++: 轉儲符號建置狀態
action.CIDR.Lang.Format.Extractor.text=提取程式碼格式
action.CIDR.Lang.DropPsiForOpenedFiles.text=刪除開啟的檔案的 PSI
action.CIDR.Lang.RemoveBodiesAndComments.text=移除函數主體和註釋
action.CIDR.Lang.DumpFileSymbolStats.text=轉儲檔案符號統計資訊
action.CIDR.Lang.DumpSymbolStats.text=轉儲一般符號統計資訊
action.CIDR.Lang.CompactSymbols.text=更新/壓縮符號
action.CIDR.Lang.ImportsHierarchy.text=匯入層次結構
action.CIDR.Lang.ObjC.GenerateSharedInstance.text=+sharedInstance
action.CIDR.Lang.ObjC.GenerateSharedInstance.description=生成共享實例
action.CIDR.Lang.ObjC.GenerateDescription.text=-description…
action.CIDR.Lang.ObjC.GenerateDescription.description=從類成員生成 -description
action.CIDR.Lang.ObjC.GenerateIsEqualAndHash.text=-isEqual: 和 -hash…
action.CIDR.Lang.ObjC.GenerateIsEqualAndHash.description=從類成員生成 -isEqual: 和 -hash
action.CIDR.Lang.ObjC.GenerateCopy.text=-copyWithZone:…
action.CIDR.Lang.ObjC.GenerateCopy.description=從類成員生成 -copyWithZone:
action.CIDR.Lang.ObjC.GenerateEncode.text=-init/encodeWithCoder:…
action.CIDR.Lang.ObjC.GenerateEncode.description=從類成員生成 -encodeWithCoder: 和 initWithCoder:
action.CIDR.Lang.ObjC.GenerateInitWith.text=-initWith…
action.CIDR.Lang.ObjC.GenerateInitWith.description=從類成員生成 -initWith…
action.CIDR.Lang.Cpp.GenerateDefinitions.text=生成定義…
action.CIDR.Lang.Cpp.GenerateDefinitions.description=生成定義
action.CIDR.Lang.Cpp.GenerateStreamOutputOperator.text=流輸出運算符
action.CIDR.Lang.Cpp.GenerateStreamOutputOperator.description=生成流輸出運算符
action.CIDR.Lang.Cpp.GenerateRelationalOperators.text=關係運算符
action.CIDR.Lang.Cpp.GenerateRelationalOperators.description=生成關係運算符
action.CIDR.Lang.Cpp.GenerateEqualityOperators.text=相等運算符
action.CIDR.Lang.Cpp.GenerateEqualityOperators.description=生成相等運算符
action.CIDR.Lang.Cpp.GenerateGetterAndSetter.text=Getter 和 Setter
action.CIDR.Lang.Cpp.GenerateGetterAndSetter.description=為欄位生成 getter 和 setter 函數
action.CIDR.Lang.Cpp.GenerateSetter.text=Setter
action.CIDR.Lang.Cpp.GenerateSetter.description=為欄位生成 setter 函數
action.CIDR.Lang.Cpp.GenerateGetter.text=Getter
action.CIDR.Lang.Cpp.GenerateGetter.description=為欄位生成 getter 函數
action.CIDR.Lang.Cpp.GenerateDestructor.text=析構函數
action.CIDR.Lang.Cpp.GenerateDestructor.description=生成析構函數
action.CIDR.Lang.Cpp.GenerateConstructor.text=構造函數
action.CIDR.Lang.Cpp.GenerateConstructor.description=從類成員生成構造函數
action.CIDR.Lang.ObjC.Synthesize.text=@synthesize…
action.CIDR.Lang.ObjC.Synthesize.description=生成合成變數和實例變數(可選)
action.CIDR.Lang.ObjC.DeclareMembers.text=宣告成員…
action.CIDR.Lang.ObjC.DeclareMembers.description=宣告接口或私有類別中的類成員
action.CIDR.Lang.ObjC.ConvertToIvar.text=轉換為實例變數…
action.CIDR.Lang.ObjC.ConvertToIvar.description=將屬性轉換為實例變數
action.CIDR.Lang.ObjC.ConvertToProperty.text=轉換為屬性…
action.CIDR.Lang.ObjC.ConvertToProperty.description=將實例變數轉換為屬性
action.CIDR.Lang.ObjC.ConvertToBlock.text=轉換為塊…
action.CIDR.Lang.ObjC.ConvertToBlock.description=轉換為塊
action.CIDR.Lang.ObjC.ConvertToFunction.text=轉換為函數…
action.CIDR.Lang.ObjC.ConvertToFunction.description=轉換為函數
action.CIDR.Lang.ObjC.ConvertToMethod.text=轉換為方法…
action.CIDR.Lang.ObjC.ConvertToMethod.description=轉換為方法
action.CIDR.Lang.ObjC.ExtractCategory.text=類別…
action.CIDR.Lang.ObjC.ExtractCategory.description=將成員提取到新類別
action.CIDR.Lang.ObjC.ExtractProtocol.text=協議…
action.CIDR.Lang.ObjC.ExtractProtocol.description=將成員提取到新協議
action.CIDR.Lang.ObjC.ExtractSubclass.text=子類…
action.CIDR.Lang.ObjC.ExtractSubclass.description=將成員提取到新子類
action.CIDR.Lang.ObjC.ExtractBlock.text=塊參數…
action.CIDR.Lang.ObjC.ExtractBlock.description=提取塊參數
action.CIDR.Lang.Cpp.ExtractLambda.text=Lambda 參數…
action.CIDR.Lang.Cpp.ExtractLambda.description=提取 Lambda 參數
action.CIDR.Lang.IntroduceTypedef.text=Typedef…
action.CIDR.Lang.IntroduceTypedef.description=引入 Typedef
action.CIDR.Lang.IntroduceDefine.text=定義…
action.CIDR.Lang.IntroduceDefine.description=引入 Define
action.CIDR.Lang.IntroduceParameter.text=參數…
action.CIDR.Lang.IntroduceParameter.description=引入參數
action.CIDR.Lang.ObjC.IntroduceProperty.text=屬性…
action.CIDR.Lang.ObjC.IntroduceProperty.description=引入屬性
action.CIDR.Lang.ObjC.IntroduceIvar.text=實例變數…
action.CIDR.Lang.ObjC.IntroduceIvar.description=引入實例變數
action.CIDR.Lang.IntroduceConstant.text=常數…
action.CIDR.Lang.IntroduceConstant.description=引入常數
action.CIDR.Lang.IntroduceVariable.text=變數…
action.CIDR.Lang.IntroduceVariable.description=引入變數
action.CIDR.Lang.SwitchHeaderSourceDebug.text=偵錯頭/源
action.CIDR.Lang.SwitchHeaderSource.text=頭/源
action.CIDR.Lang.Wrap.By.Pragma.Region=#pragma region...endregion
action.CIDR.Lang.goto.definition.declaration=轉到定義/宣告
action.CIDR.Lang.goto.super.definition=超定義(&U)
action.CIDR.Lang.goto.definition=定義(&E)
loading.module.maps=正在載入模組映射…
saving.module.maps=正在儲存模組映射…
building.module.maps=正在建置模組映射…
processing.module.maps=正在處理模組映射…
loading.headers.search.roots=正在載入標頭搜尋根…
goto.definition.settings.title=前往宣告或用法
goto.definition.settings.toggle.assoc.title=對包含預宣告的符號調用時:
goto.definition.settings.toggle.assoc.on=跳轉到預宣告
goto.definition.settings.toggle.assoc.off=顯示用法彈出視窗
goto.symbol=轉到
goto.symbol.ellipsis=轉到…
goto.related.symbol.name1=轉到定義
goto.related.symbol.name2=轉到 ''{1}'' 的{0}
goto.related.symbol.name3=轉到{0}的預定義
goto.related.symbol.name4=轉到{0}的定義
goto.related.symbol.name5=轉到{0}的宣告
goto.related.symbol.name6=轉到相關{0}
goto.super.type.name1=轉到{1}中的父{0}
goto.super.type.name2=轉到{0}中的基函數
goto.super.type.name3=轉到父類型
goto.subclass=轉到子類
goto.overridden=轉到被覆寫的{0}…
goto.overridden.methods=轉到被覆寫的方法…
goto.overridden.functions=轉到被覆寫的函數…
saving.symbols=正在儲存符號…
progress.text.updating.symbols=正在更新符號…
inspection.message.function.not.implemented={0} 未實作
command.name.add.parameter.to.constructor=將參數添加到構造函數
dialog.title.select.constructor.to.update=選擇要更新的構造函數
command.name.add.parameter.to.initwith=將參數添加到 'initWith…'
dialog.title.select.initwith.method.to.update=選擇要更新的 'initWith…' 方法
dialog.message.objc.do.you.want.to.generate.instance.variables.for.chosen.properties=要為所選屬性生成實例變數嗎?
dialog.title.objc.generate.instance.variables=生成實例變數
dialog.message.do.you.want.to.move.class.member.definitions=要移動類成員定義嗎?
dialog.title.move.refactoring.adding.imports=正在添加 import
filetype.asm.description=程序集語言檔案
filetype.qt.ui.designer.form.description=Qt UI Designer 窗體
statement.name=語句
expression.name=表達式
declaration.name=宣告

surround.with.block.expression.template=^{ return expr; }
surround.with.do.while.template=do / while
surround.with.for.template=for
surround.with.while.template=while
surround.with.if.else.template=if / else
surround.with.if.template=if
surround.with.not.expr.template=!(expr)
surround.with.parenthesis.template=(expr)
surround.with.if.respondsToSelector.template=if respondsToSelector
refactoring.dialog.no.target.file.selected=未選擇目標檔案
refactoring.dialog.file.name.invalid=文件名無效
refactoring.dialog.file.not.located.inside.project=檔案“{0}”不在專案內部
refactoring.dialog.source.and.target.should.be.different=源和目標應該不同
refactoring.dialog.target.namespace.name.invalid=目標命名空間名稱無效
refactoring.dialog.target.ns.is.part.of.qualified.ns=目標命名空間是限定命名空間的一部分
refactoring.dialog.can.t.move.to.itself=無法將 {0} 移至自身
inspection.name.is.never.used={0} 從未使用

element.description.provider.symbol.of.parent={1} 的 {0}
element.description.provider.predefinition.of={0} 的預定義

qdoc.definition=定義:
qdoc.declared.in=宣告位置:
qdoc.replacement=取代:
qdoc.description.copied.from=描述複製自:

formatter.item.allman.braces=Allman 大括號
formatter.item.kr.braces=K\\&R 大括號
formatter.item.whitesmiths.braces=Whitesmiths 大括號
formatter.item.stroustrup.braces=Stroustrup
formatter.title.code.generation=程式碼生成

settings.title.objective.c.class.order=Objective-C 類順序
settings.prefix.must.start.with.letter.or.symbol=前綴必須以字母或 '_' 符號開頭
settings.hint.choice.prefix.suffix.must.contain.only.letters.or.digits.or.symbols={0, choice, 0#前綴|1#後綴}必須只包含字母或數字或 '_' 符號
settings.title.naming.convention=命名慣例
settings.naming.convention=命名慣例
resolve.contexts.all.contexts=已列出所有專案上下文
resolve.contexts.available=可用解析上下文
resolve.contexts.current.file=當前 {0} 檔案在 ''{1}'' 的上下文中解析
resolve.contexts.file.resolved.in=此檔案將在所選上下文中解析
resolve.contexts.loading=正在載入解析上下文…
resolve.contexts.name=解析上下文
resolve.contexts.no.context=<無上下文>
resolve.contexts.prefix.no.context=當前檔案無解析上下文
resolve.contexts.prefix=上下文
resolve.contexts.unindexed.contexts=未索引的上下文
hmap.description={0} 頭映射

search.scope.project.source.files=專案源文件
search.scope.project.non.source.files=專案非源文件

header.search.root.custom.headers=自訂頭
header.search.root.frameworks=框架
header.search.root.explicit.frameworks=顯式框架

find.usages.unknown.type=未知

switch.header.source.separator.headers=頭
switch.header.source.separator.sources=源
new.definition.dialog.title.create.new.constructor=創建新構造函數
new.definition.dialog.title.create.new.function=創建新函數
new.definition.button.create=創建
new.definition.dialog.title.create.new.method=創建新方法
action.context.file.name=檔案 ''{0}''
oc.declare.members.implementation.undeclared=實作(未宣告)
dialog.message.some.members.are.defined=部分已定義
dialog.message.all.members.are.defined=全部均已定義
tab.title.existing=現有
label.copy.depth=深度
copy.depths.option.deep=深層
copy.depths.option.shallow=淺層
button.generate=生成
other.categories.and.inherited.members=其他類別和繼承的成員
action.show.inherited.text=顯示繼承項
action.show.inherited.members.members.in.other.categories.description=顯示繼承的成員和其他類別的成員
polymorphic.call=(多態調用)
label.or.in.objective.c.code=或在 Objective-C 程式碼中

symbol.kind.name.uppercase.type=類型
symbol.kind.name.uppercase.enum.constant=枚舉常數
symbol.kind.name.uppercase.field=欄位
symbol.kind.name.uppercase.function=函數
symbol.kind.name.uppercase.constructor=構造函數
symbol.kind.name.uppercase.parameter=參數
symbol.kind.name.uppercase.global.variable=全域變數
symbol.kind.name.uppercase.built.in.symbol=內建符號
symbol.kind.name.uppercase.local.variable=局部變數
symbol.kind.name.uppercase.exception.variable=異常變數
symbol.kind.name.uppercase.implementation=實作
symbol.kind.name.uppercase.instance.variable=實例變數
symbol.kind.name.uppercase.interface=接口
symbol.kind.name.uppercase.label=標籤
symbol.kind.name.uppercase.macro=巨集
symbol.kind.name.uppercase.macro.parameter=巨集參數
symbol.kind.name.uppercase.import=匯入
symbol.kind.name.uppercase.compatibility.alias=相容性別名
symbol.kind.name.uppercase.method1=方法
symbol.kind.name.uppercase.block=塊
symbol.kind.name.uppercase.lambda=Lambda
symbol.kind.name.uppercase.property=屬性
symbol.kind.name.uppercase.synthesize.statement=合成語句
symbol.kind.name.uppercase.protocol=協議
symbol.kind.name.uppercase.struct=結構
symbol.kind.name.uppercase.union=聯合
symbol.kind.name.uppercase.enum=枚舉
symbol.kind.name.uppercase.namespace=命名空間
symbol.kind.name.uppercase.type.parameter=類型參數
symbol.kind.name.uppercase.template.parameter=模板參數
symbol.kind.name.uppercase.using=Using
symbol.kind.name.uppercase.localized.string=已本地化的字串
symbol.kind.name.uppercase.expression=表達式
symbol.kind.name.uppercase.generic.parameter=泛型參數
symbol.kind.name.uppercase.concept=概念
symbol.kind.name.uppercase.keyword=關鍵字
symbol.kind.name.uppercase.file=檔案
symbol.kind.name.uppercase.folder=資料夾
symbol.kind.name.uppercase.default=符號

symbol.kind.name.lowercase.type=類型
symbol.kind.name.lowercase.enum.constant=枚舉常數
symbol.kind.name.lowercase.field=欄位
symbol.kind.name.lowercase.function=函數
symbol.kind.name.lowercase.constructor=構造函數
symbol.kind.name.lowercase.parameter=參數
symbol.kind.name.lowercase.global.variable=全域變數
symbol.kind.name.lowercase.built.in.symbol=內建符號
symbol.kind.name.lowercase.local.variable=局部變數
symbol.kind.name.lowercase.exception.variable=異常變數
symbol.kind.name.lowercase.implementation=實作
symbol.kind.name.lowercase.instance.variable=實例變數
symbol.kind.name.lowercase.interface=接口
symbol.kind.name.lowercase.label=標籤
symbol.kind.name.lowercase.macro=巨集
symbol.kind.name.lowercase.macro.parameter=巨集參數
symbol.kind.name.lowercase.import=匯入
symbol.kind.name.lowercase.compatibility.alias=相容性別名
symbol.kind.name.lowercase.method1=方法
symbol.kind.name.lowercase.block=塊
symbol.kind.name.lowercase.lambda=lambda
symbol.kind.name.lowercase.property=屬性
symbol.kind.name.lowercase.synthesize.statement=合成語句
symbol.kind.name.lowercase.protocol=協議
symbol.kind.name.lowercase.struct=struct
symbol.kind.name.lowercase.union=union
symbol.kind.name.lowercase.enum=enum
symbol.kind.name.lowercase.namespace=命名空間
symbol.kind.name.lowercase.type.parameter=類型參數
symbol.kind.name.lowercase.template.parameter=模板參數
symbol.kind.name.lowercase.using=using
symbol.kind.name.lowercase.localized.string=已本地化的字串
symbol.kind.name.lowercase.expression=表達式
symbol.kind.name.lowercase.generic.parameter=泛型參數
symbol.kind.name.lowercase.concept=概念
symbol.kind.name.lowercase.keyword=關鍵字
symbol.kind.name.lowercase.file=檔案
symbol.kind.name.lowercase.folder=資料夾
symbol.kind.name.lowercase.default=符號
command.name.codestylesettings.extractor=程式碼樣式設定提取程序
symbol.kind.name.uppercase.destructor=析構函數
symbol.kind.name.uppercase.class=類
symbol.kind.name.lowercase.destructor=析構函數
symbol.kind.name.lowercase.class=類
popup.title.element.found.singular={0} (已找到 {1} 元素)
popup.title.elements.found.plural={0} (已找到 {1} 元素)

resource.language.unknown=未知

color.doxygen.comment=註釋//Doxygen//文本
color.doxygen.tag=註釋//Doxygen//標記
color.doxygen.tag.value=註釋//Doxygen//標記值
oc.inlay.hints.type.name=類型
oc.inlay.hints.type.for.variables=變數
oc.inlay.hints.type.for.lambdas=Lambda
oc.inlay.hints.type.deduced.return.types=推導的返回類型
oc.inlay.hints.type.main.checkbox=顯示類型提示:
completion.no.suggestions.press.for.not.imported=無建議，對於未匯入的成員按 {0}
color.std.initializer.list.oc=大括號和運算符//初始設定式列表
action.CIDR.Lang.goto.definition.declaration.tooltip=轉到定義/宣告
goto.related.symbol.name1.tooltip=轉到定義
goto.related.symbol.name2.tooltip=轉到 ''{1}'' 的{0}
goto.related.symbol.name3.tooltip=轉到 {0} 的預定義
goto.related.symbol.name4.tooltip=轉到 {0} 的定義
goto.related.symbol.name5.tooltip=轉到 {0} 的宣告
goto.related.symbol.name6.tooltip=轉到相關 {0}
goto.subclass.title=轉到子類
goto.overridden.title=轉到被覆寫的{0}
goto.overridden.methods.title=轉到被覆寫的方法
goto.overridden.functions.title=轉到被覆寫的函數
oc.inlay.hints.show.settings=提示設定…
cache.downloader.updating.title=更新快取
cache.downloader.not.now.option=在本地建置快取
cache.downloader.download.option=下載
cache.downloader.always.download.option=始終下載
oc.inlay.hints.type.obvious.types=明顯類型
checkbox.local.files.with.quotes=使用引號自動匯入本地檔案
popup.title.element.found.so.far.singular={0} (目前已找到 {1} 個元素)
popup.title.elements.found.so.far.plural={0} (目前已找到 {1} 個元素)
space.before.colon.in.foreach='for' 冒號之前
space.after.colon.in.foreach='for' 冒號之後
action.CIDR.Lang.QualifiedNames.text=組限定名稱
action.CIDR.Lang.QualifiedNames.description=組限定名稱
checkbox.try.to.sort=對 include 排序
rename.searchForMacros=是否在全域範圍內搜尋巨集 ''{0}''(包含重命名的元素)的用法?
checkbox.try.to.sort.tooltip=通過 .clang-format 程式碼樣式啟用
oc.inlay.hints.show.array.indices=顯示陣列索引的提示
oc.inlay.hints.disable.function=禁用{0, choice, 0#方法|1#函數|2#構造函數} ''{1}'' 的提示
title.structured.binding.list.group=結構化綁定列表
space.within.structured.binding.list.brackets=結構化綁定列表中括號
inlay.parameters.oc.clangd.namehints.enums=顯示枚舉常數提示
inlay.parameters.oc.clangd.namehints.construct.expr=顯示各種形式的初始化的構造函數表達式的提示 (...)、{...} ...。
inlay.parameters.oc.clangd.namehints.non.const.references=顯示 '\\&' 而不是參數名稱。此選項會在二者之間切換，但 '\\&' 始終顯示，而參數名稱可能會被隱藏(比如，由於前面的註釋)。
inlay.parameters.oc.clangd.namehints.array.indices=顯示陣列索引。不提示指定的初始設定式。
inlay.oc.type.hints.variables=顯示具有推導類型的變數的提示
inlay.oc.type.hints.lambdas=顯示 lambda 調用運算符簽名的提示
inlay.oc.type.hints.return.types=顯示推匯出的函數返回類型的提示。還會影響省略的 lambda 返回類型
inlay.oc.type.hints.obvious.types=顯示明顯類型的提示。這包括類似構造函數的表達式、顯式轉換、文字、新表達式、限定範圍的枚舉值、純整數類型
action.create.new.jsp.tag.library.descriptor.tld.file.description=創建新 JSP 標記庫描述符(.tld 檔案)
action.extract.jsp.tag.text=提取 JSP 標記
action.jsp.tag.library.descriptor.text=JSP 標記庫描述符
attribute.should.be.inside.custom.or.standard.action=jsp:attribute 應在標準操作或自訂操作中
attribute.should.have.empty.content={0} 的內容應為空
attribute.should.not.contain.scripting.elements=JSP 特性不應包含腳本元素
border.title.jsp=JSP
cannot.resolve.taglib.uri=無法解析包含 uri {0} 的 taglib
checkbox.add.unambiguous.imports.on.fly=動態添加明確的 import
column.name.attribute=特性
column.name.fix=修復
column.name.namespace=命名空間
column.name.tag=標記
command.name.introduce.jsp.parameter=引入 JSP 參數
configurable.name.jsp=JSP
configurable.name.jspx=JSPX
context.chooser.context.folder=上下文資料夾
context.chooser.panel.title=檔案上下文
create.tagfile.attribute.family=創建標記檔案特性
create.tagfile.attribute.text=創建標記檔案特性 {0}
dialog.message.does.not.exist.do.you.want.to.create.it={0} 不存在。要創建嗎?
dialog.message.name.should.not.be.empty=名稱不應為空
dialog.message.tag.name.should.not.be.empty=標記名稱不應為空
dialog.title.directory.not.exist=目錄不存在
dialog.title.error=錯誤
dialog.title.introduce.tag.parameter=引入標記參數
dialog.title.select.location=選擇位置
duplicate.attribute.error.message=特性 {0} 重複
edit.template=編輯模板(&T)…
either.uri.or.tagdir.attribute.should.be.specified=應指定 uri 或 tagdir 特性
el.declare.variable.find.acceptable.class=找到可接受的類
el.declare.variable.intention.family=宣告變數作為外部資料
el.declare.variable.via.comment.annotation.intention.name=宣告外部變數在註解
el.declare.variable.via.usebean.intention.name=宣告外部變數作為<jsp:useBean />
enter.new.attribute.s.name=輸入新特性名稱(&N):
exception.during.tei.processing.occured.with.error.error.message=TEI 處理期間發生異常: {0}
fragment.attribute.should.not.have.rtexprvalue.attribute.error.message=片段特性不應具有 rtexprvalue 特性(JSP 2.0 規範，第 8.5.2 節，表 JSP8-3)
fragment.attribute.should.not.have.type.attribute.error.message=片段特性不應具有類型特性(JSP 2.0 規範，第 8.5.2 節，表 JSP8-3)
fragment.attribute.value.should.be.specified.with.jsp.attribute=片段特性值應使用 jsp:attribute 指定
inspection.message.absolute.paths.not.recommended.in.jsps=建議不要在 JSP 中使用絕對路徑
inspection.message.deferred.expression.syntax.required.here=推遲表達式(#{} 語法)在此處為必填項
inspection.message.dynamic.expression.syntax.required.here=動態表達式(${} 語法)在此處為必填項
inspection.message.no.content.allowed.inside.tags.with.empty.content.type=在使用 'empty' 內容類型的標記內，不允許包含內容
inspection.message.scripting.not.allowed.inside.tags.with.scriptless.content.type=在使用 'scriptless' 內容類型的標記內，不允許使用腳本
inspection.message.unescaped.el.expression=未轉義的 EL 表達式
inspection.problem.classes.from.the.default.package.must.not.be.referenced.from.jsp.file.text=不得從 JSP 檔案引用預設軟體套件中的類
inspection.problem.jsp.file.must.not.include.itself=JSP 檔案不得包含自身
intention.family.name.remove.scriptlet.s=移除 Scriptlet
intention.name.add.dynamic.prefix=添加動態前綴
intention.name.register.all.tags.from.as.safe=將 {0} 中的所有標記註冊為安全
intention.name.register.as.safe.place=將 <{0} {1}=""> 註冊為安全地點
intention.name.register.tag.as.safe.place=將 <{0}> 標記註冊為安全地點
intention.name.replace.syntax=將 ${} 語法取代為 #{}
intention.name.replace.syntax.with=將 #{} 語法取代為 ${}
intention.name.wrap.in.jstl.escapexml.function=在 JSTL escapeXml() 函數中包裝
intention.name.wrap.in.tag=在{0} <{1}> 標記中包裝
invalid.reference.to.javabean.type.error.message=對 Java Bean 類型的引用無效
item.text.none.context=<無>
jsf.el.out.of.attribute=JSF EL 在特性外 #loc
jsf.method.call.is.nonstd.extension=方法調用是標準擴展 #loc
jsp.documentation.message.can.have.runtime.value=可以具有執行時值:\\&nbsp;{0}
jsp.documentation.message.custom.attribute.name=自訂特性名稱
jsp.documentation.message.custom.function.name=自訂函數名稱
jsp.documentation.message.custom.tag.name=自訂標記名
jsp.documentation.message.description=描述:\\&nbsp;{0}
jsp.documentation.message.example.of.use=使用範例:<br><pre>{0}</pre>
jsp.documentation.message.fragment=片段:\\&nbsp;{0}
jsp.documentation.message.required=必選:\\&nbsp;{0}
jsp.documentation.message.type=類型:\\&nbsp;{0}

jsp.import=JSP 匯入
jsp.smart.key.insert.pair.greater.on.enter=在 JSP 中按 Enter 時插入對 %>
jsp.taglib.method.reference.error.class.is.not.public=類不為 public
jsp.taglib.method.reference.error.class.is.not.valid=類無效
jsp.taglib.method.reference.error.different.return.type=不同的返回類型
jsp.taglib.method.reference.error.method.should.be.public.or.static=方法應為 public 或 static
jsp.taglib.method.reference.error.no.such.method=沒有這樣的方法
jsp.taglib.method.reference.error.signature.is.different=簽名是不同的
label.choose.jsp.context.text=已包含到
location=位置(&L):
method.does.not.match=方法 ''{0}'' 不符合 ''{1}''
name=名稱(&N):
name.from.attribute.should.be.java.lang.String=通過 name-from-attribute 定義的變數應引用 java.lang.String 類型的特性
name.from.attribute.should.be.required=通過 name-from-attribute 定義的變數應引用所需特性
name.from.attribute.should.not.be.rtexprvalue=通過 name-from-attribute 定義的變數不應引用執行時特性
namespace.alias=taglib
radio.prefer.comma.separated.import.list=首選逗號分隔的匯入列表
radio.prefer.one.import.statement.per.page.directive=每個頁面指令首選一條 import 語句
replace.with.jsp.comment.intention=取代為 JSP 註釋
safe.tags=安全標記:
suggest.jstl.escapexml.as.fix=建議 JSTL escapeXml() 為修復(&S)
tag.should.be.used.in.tag.file.error.message=應在標記檔案中使用標記
tag.should.not.be.used.in.tag.file.error.message=不應在標記檔案中使用標記
template.node.jsp.files=JSP 檔案
title.choose.jsp.file.text=選擇 JSP 檔案
title.jsp.imports.layout=JSP 匯入布局
title.preview=預覽
variable.name.from.attribute=通過特性 {0} 值的定義的變數
wrong.tag.data.error.message=TEI 驗證錯誤: {0}

live.template.description.jspa=JSP 標記特性
live.template.description.jspxa=JSPX 標記特性
no.description.provided.for.tag.file=沒有為標記檔案提供描述
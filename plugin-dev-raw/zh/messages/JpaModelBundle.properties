AddAttributeItem.attributeAlreadyExist.description=已在 {1} 實體中定義 {0} 特性
AddAttributeItem.attributeAlreadyExist.title={0} 特性已定義
AddAttributeItem.idAlreadyExist=主鍵已存在
AddAttributeItem.idAlreadyExistDescr=已在 {0} 實體中定義 ID 特性
AssociationType.JoinColumnMappedBy=雙向 JoinColumn
AssociationType.JoinColumnUnidirectional=單向 JoinColumn
AssociationType.JoinTableMappedBy=雙向 JoinTable
AssociationType.JoinTableMtM=單向 JoinTable
AssociationType.MappedByJoinColumn=雙向 mappedBy
AssociationType.MappedByJoinTable=雙向 mappedBy
AssociationType.WithoutJoinColumnOtM=單向 JoinTable
AttributeDeleteDialog.safeDeleteField=搜尋用法
AttributeOverridesValidator.emptyName.errorMessage=提供特性名稱以生成特性覆寫。
AttributeOverridesValidator.errorMessage=列名 {0} 在 {1} 實體中重複。
AttributePropertiesPanel.TableGeneratorName=生成器表
AttributePropertiesPanel.allocationSize=分配大小
AttributePropertiesPanel.asc=ASC
AttributePropertiesPanel.associationType=映射類型
AttributePropertiesPanel.associationType.hint.joinColumnMappedByUpdater={0}\#{1} 上的 @JoinColumn 和 {4}\#{5} 上的 @{2}(mappedBy\={3})
AttributePropertiesPanel.associationType.hint.joinColumnUpdater={0}\#{1} 上的 @JoinColumn
AttributePropertiesPanel.associationType.hint.joinTableMappedByUpdater={0}\#{1} 上的 @JoinTable 和 {4}\#{5} 上的 @{2}(mappedBy\={3})
AttributePropertiesPanel.associationType.hint.joinTableUpdater={0}\#{1} 上的 @JoinTable
AttributePropertiesPanel.associationType.hint.mappedByJoinColumnUpdater={0}\#{1} 上的 @{2}(mappedBy\={3}) 和 {4}\#{3} 上的 @JoinColumn
AttributePropertiesPanel.associationType.hint.mappedByJoinTableUpdater={0}\#{1} 上的 @{2}(mappedBy\={3}) 和 {4}\#{3} 上的 @JoinTable
AttributePropertiesPanel.associationType.hint.oneToManyWithoutJoinColumnUpdater={0}\#{1} 上的 @JoinTable
AttributePropertiesPanel.attributeExists=有一個名為“{0}”的繼承特性
AttributePropertiesPanel.attributeOverrides=特性覆寫
AttributePropertiesPanel.cardinality=基數
AttributePropertiesPanel.cardinality.empty=請選擇基數
AttributePropertiesPanel.cardinality.manyToMany=多對多
AttributePropertiesPanel.cardinality.manyToMany.hint=多個 ''{0}'' 物件與多個{1}物件關聯
AttributePropertiesPanel.cardinality.manyToOne=多對一
AttributePropertiesPanel.cardinality.manyToOne.mandatoryHint=多個 ''{0}'' 物件與一個{1}物件關聯
AttributePropertiesPanel.cardinality.manyToOne.nonMandatoryHint=多個 ''{0}'' 物件與零個或一個{1}物件關聯
AttributePropertiesPanel.cardinality.oneToMany=一對多
AttributePropertiesPanel.cardinality.oneToMany.hint=一個 ''{0}'' 物件與多個{1}物件關聯
AttributePropertiesPanel.cardinality.oneToOne=一對一
AttributePropertiesPanel.cardinality.oneToOne.mandatoryHint=一個 ''{0}'' 物件與一個{1}物件關聯
AttributePropertiesPanel.cardinality.oneToOne.nonMandatoryHint=一個 ''{0}'' 物件與零個或一個{1}物件關聯
AttributePropertiesPanel.cardinality.singleValue=單一值
AttributePropertiesPanel.cascade=級聯類型
AttributePropertiesPanel.collection=集合
AttributePropertiesPanel.collectionTable=集合表
AttributePropertiesPanel.collectionTableJoinColumn=聯接列
AttributePropertiesPanel.collectionType=集合類型
AttributePropertiesPanel.column=列
AttributePropertiesPanel.columnDefinition=列定義
AttributePropertiesPanel.conversionType=大小寫轉換
AttributePropertiesPanel.converter=轉換器
AttributePropertiesPanel.createField=建立欄位
AttributePropertiesPanel.createMappedAttribute=建立映射的特性
AttributePropertiesPanel.currencyValue=貨幣
AttributePropertiesPanel.ddl=列 DDL
AttributePropertiesPanel.decimalSep=小數分隔符
AttributePropertiesPanel.dependsOnProperties=相關特性
AttributePropertiesPanel.desc=DESC
AttributePropertiesPanel.disableUniqueField=無法建立唯一約束，因為實體已被軟刪除，但實體表中沒有 'delete_ts' 列
AttributePropertiesPanel.elementCollection=元素集合
AttributePropertiesPanel.enterAttributeName=輸入特性名稱
AttributePropertiesPanel.enumType=枚舉類型
AttributePropertiesPanel.errorIntPositive={0} 必須 > 0
AttributePropertiesPanel.errorPrecision=建立屬性
AttributePropertiesPanel.errorPrecisionBiggerScale=精度必須大於或等於小數位數
AttributePropertiesPanel.errorScaleZero=小數位數必須 >\= 0
AttributePropertiesPanel.fetchMode=提取模式
AttributePropertiesPanel.fetchType=提取類型
AttributePropertiesPanel.fkConstraintAction=FK 約束動作
AttributePropertiesPanel.generateAttributeOverrides=生成特性覆寫
AttributePropertiesPanel.generateEqualsAndHashCode=生成 Equals 和 HashCode
AttributePropertiesPanel.generatedStrategy=ID 生成
AttributePropertiesPanel.generatorName=產生器名稱
AttributePropertiesPanel.goTo=轉到
AttributePropertiesPanel.groupSep=組分隔符
AttributePropertiesPanel.id=ID
AttributePropertiesPanel.idAttribute=ID 特性
AttributePropertiesPanel.indexColumns=列
AttributePropertiesPanel.indexName=名稱
AttributePropertiesPanel.indexUnique=唯一
AttributePropertiesPanel.initialValue=初始值
AttributePropertiesPanel.insertable=可插入
AttributePropertiesPanel.inverseAttribute.msg=找不到合適的反向特性。是否要進行建立?
AttributePropertiesPanel.inverseAttribute.title=反向特性
AttributePropertiesPanel.inverseAttributeCreated=反向特性已建立，相關實體已儲存
AttributePropertiesPanel.inverseJoinColumnLengthError={0} 上的<b>反向聯接列</b>名稱不得超過 {1} 個字元
AttributePropertiesPanel.inverseJoinColumnName=反向聯接列
AttributePropertiesPanel.inverseJoinColumnReferencedColumnName=反向參照列
AttributePropertiesPanel.jdbcTypeCode=JDBC 類型程式碼
AttributePropertiesPanel.joinColumnLengthError={0} 上的<b>聯接列</b>名稱不得超過 {1} 個字元
AttributePropertiesPanel.joinColumnName=聯接列
AttributePropertiesPanel.joinColumnReferencedColumnName=參照列
AttributePropertiesPanel.joinTable=聯接表
AttributePropertiesPanel.joinTableLengthError={0} 上的<b>聯接表</b>名稱必須不超過 {1} 個字元
AttributePropertiesPanel.joinTableName=聯接表
AttributePropertiesPanel.length=長度
AttributePropertiesPanel.lengthFieldUnlimited=無限制
AttributePropertiesPanel.lob=大型物件
AttributePropertiesPanel.lookupActions=尋找動作
AttributePropertiesPanel.lookupType=尋找類型
AttributePropertiesPanel.mandatory=強制
AttributePropertiesPanel.mappedBy=映射方式
AttributePropertiesPanel.mappingType=特性類型
AttributePropertiesPanel.mutable=可變
AttributePropertiesPanel.name=名稱
AttributePropertiesPanel.newType=類型
AttributePropertiesPanel.numberFormat=數字格式
AttributePropertiesPanel.numberFormatExample=例如\: \#,\#\#\#,\#\#\#,\#\#\#.\#\#
AttributePropertiesPanel.numberFormatIsRequired=特性 ''{0}'' 需要“數字格式”欄位
AttributePropertiesPanel.numberFormatStyle=數字格式樣式
AttributePropertiesPanel.onDelete=刪除時
AttributePropertiesPanel.onDelete.cascade.hint=刪除 ''{0}'' 物件後，自動刪除關聯的{1}物件
AttributePropertiesPanel.onDelete.cascade.hintInverse=刪除關聯的{1}物件時自動刪除 ''{0}'' 物件
AttributePropertiesPanel.onDelete.default.hint=刪除 ''{0}'' 物件後，關聯的{1}物件保持原樣
AttributePropertiesPanel.onDelete.default.hintInverse=刪除關聯的{1}物件時，''{0}'' 物件保持原樣
AttributePropertiesPanel.onDelete.deny.hint=如果 ''{0}'' 物件與{1}物件關聯，則阻止刪除該物件
AttributePropertiesPanel.onDelete.deny.hintInverse=阻止刪除與 ''{0}'' 物件關聯的{1}物件
AttributePropertiesPanel.onDelete.unlink.hint=刪除 ''{0}'' 物件後，清除{1}物件的關聯鏈接
AttributePropertiesPanel.onDelete.unlink.hintInverse=刪除關聯的{1}物件後，清除 ''{0}'' 物件的鏈接
AttributePropertiesPanel.onDeleteInverse=刪除反向時
AttributePropertiesPanel.orderBy=排序方式
AttributePropertiesPanel.orderByExample=範例\: order.date DESC, name, age DESC
AttributePropertiesPanel.orphanRemoval=孤立項移除
AttributePropertiesPanel.owner=擁有方
AttributePropertiesPanel.persistAttrCreated=相關實體 ID 特性已建立
AttributePropertiesPanel.persistRelatedId.msg=您已建立對來自不同資料存儲的實體的參照。是否要建立持久特性來存儲相關實體 ID?
AttributePropertiesPanel.persistRelatedId.title=相關實體 ID 特性
AttributePropertiesPanel.precision=精度
AttributePropertiesPanel.readOnly=唯讀
AttributePropertiesPanel.renameAttribute=重新命名特性
AttributePropertiesPanel.scale=小數位數
AttributePropertiesPanel.sequenceGeneratorName=序列名稱
AttributePropertiesPanel.sequenceOrTableGeneratorName=序列名稱
AttributePropertiesPanel.sequenceType=生成類型
AttributePropertiesPanel.smartRefactoring=智能重構
AttributePropertiesPanel.sort=排序
AttributePropertiesPanel.targetEntity=目標實體
AttributePropertiesPanel.temporalType=Temporal
AttributePropertiesPanel.timeZoneColumn=時區列類型
AttributePropertiesPanel.timeZoneStorageType=時區存儲
AttributePropertiesPanel.transient=瞬時
AttributePropertiesPanel.transientCardinality=基數
AttributePropertiesPanel.transientWarning=該屬性將被轉換為 Transient，所有不相容的註解將被移除。
AttributePropertiesPanel.type=類型
AttributePropertiesPanel.unique=唯一
AttributePropertiesPanel.updatable=可更新
AttributePropertiesPanel.version=版本
AttributePropertiesPanel.warning.caption=警告
AttributePropertiesPanel.warningMappedBy=關聯“MANY_TO_MANY”的所有特性都不是擁有方。特性 {0}
AttributePropertiesPanel.warningOwningSide=關聯的所有特性都不是擁有方。\n是否要使對方成為所有者?
AttributePropertiesPanel.warningRemovePropertyFromView=如果在更改特性類型後儲存實體，該特性將從以下檢視中移除\:
BasicRepositoryAttribute.Nullability.NonNull=NonNull
BasicRepositoryAttribute.Nullability.NotSet=-
BasicRepositoryAttribute.Nullability.Nullable=可為 null
CollectionDatatype.Collection=集合
CollectionDatatype.LinkedHashSet=LinkedHashSet
CollectionDatatype.Map=映射
CollectionDatatype.Set=設定
CreateAttributeWindow.addColumnToExistConstraintOrIndex=將列“{0}”新增到現有索引/約束
CreateAttributeWindow.chooseExistingIndex=選擇現有索引/約束
CreateAttributeWindow.createConstraintByAttribute=按特性“{0}”建立約束
CreateAttributeWindow.createIndexByAttribute=按特性“{0}”建立索引
CreateAttributeWindow.createIndexOrConstraintByAttribute=按特性“{0}”的索引/約束
CreateAttributeWindow.createInverseAttribute=建立反向特性
CreateAttributeWindow.createInverseAttributeWithParams=建立反向特性 {0}
CreateAttributeWindow.createPersistRelatedIdAttribute=建立持久的相關 ID 特性
CreateAttributeWindow.indexesAndConstraints=索引和約束
CustomTypeEditorDialog.parametrized=參數化
DataSourceEditor.caption=資料庫連線
DataSourceEditor.database.properties=資料庫屬性
DataStoreEditor.name=資料庫連線名稱\:
DataStoreEditor.nameEmpty=請輸入資料庫連線名稱
Datastore.notification.provideCredentials=請提供資料庫憑證
EntityCreator.write.command.create=建立
EntityPropertiesPanel.EmbeddedField=嵌入式類別
EntityPropertiesPanel.IdField=ID
EntityPropertiesPanel.SequenceField=生成類型
EntityPropertiesPanel.addPersistenceUnit=新增到持久性
EntityPropertiesPanel.catalog=目錄
EntityPropertiesPanel.changePackage=更改軟體套件
EntityPropertiesPanel.className=名稱
EntityPropertiesPanel.createAttributeCaption=新增特性
EntityPropertiesPanel.createAttributeWithParametersCaption=新增 {0} 特性
EntityPropertiesPanel.discriminator=判別器值
EntityPropertiesPanel.discriminatorColumnName=判別器列
EntityPropertiesPanel.discriminatorLength=判別器長度
EntityPropertiesPanel.discriminatorType=判別器類型
EntityPropertiesPanel.entityType=實體類型
EntityPropertiesPanel.inheritanceType=繼承
EntityPropertiesPanel.learnMore=了解詳情…
EntityPropertiesPanel.name=實體名稱
EntityPropertiesPanel.optimizations=建議的最佳化
EntityPropertiesPanel.optimizations.fix.generateEqualsAndHashCodeFix=生成 equals() 和 hashCode()
EntityPropertiesPanel.optimizations.fix.makeAttributeNotOwnerFix=將 mappedBy 與另一側的 OneToMany 一起使用
EntityPropertiesPanel.optimizations.fix.setWithoutEqualsAndHashCodeInfo=集合類型為 ‘Set\\&lt;{0}\\&gt;’，但 ‘{0}’ 實體未實作 equals()/hashCode() 方法。\nSet 在底層使用這些方法，預設實作可能會導致實體比較出現問題。\n例如，使用不同 Hibernate 會話提取的具有相同 ID 的兩個實體將不相等。
EntityPropertiesPanel.optimizations.fix.useJoinColumnTypeFix=新增 @JoinColumn 註解
EntityPropertiesPanel.optimizations.fix.useSetCollectionTypeFix=改用 Set<>
EntityPropertiesPanel.package=軟體套件
EntityPropertiesPanel.packageName=軟體套件
EntityPropertiesPanel.packageSelector.title=選擇實體軟體套件
EntityPropertiesPanel.parent=父項
EntityPropertiesPanel.performance.manyToManyCollectionInfo=當 Collection 用於映射 ManyToMany 關聯時，Hibernate 無法有效地從聯接表中移除此類別關聯。\n相反，它會移除與擁有實體關聯的所有記錄並重新插入剩餘記錄。將集合類型更改為 Set 可以減少刪除所需的查詢數量。
EntityPropertiesPanel.performance.manyToManyListInfo=使用 List 來映射 ManyToMany 關聯時，Hibernate 無法有效地從聯接表中刪除此類別關聯。
EntityPropertiesPanel.performance.oneToManyJoinColumnInfo=帶有 @JoinColumn 的單向 OneToMany 可能會導致額外的查詢。\n由於聯接列不存在於參照的 JPA 實體中而僅存在於資料庫中，Hibernate 會在單獨的查詢中更新它。\n使關聯成為雙向可以解決此問題。
EntityPropertiesPanel.performance.oneToManyJoinTableListInfo=帶 @JoinTable 的單向 OneToMany 會引入一個新表，該表需要額外的 insert/delete 查詢並佔用空間。\n可以使用單個 @JoinColumn 表達相同的關聯。
EntityPropertiesPanel.performanceWarning=此映射宣告效率不高，可能會導致性能問題。
EntityPropertiesPanel.persistenceUnit=持久性單元
EntityPropertiesPanel.primaryKeyJoinColumnDefinition=PK 聯接列定義
EntityPropertiesPanel.primaryKeyJoinColumnName=PK 聯接列
EntityPropertiesPanel.referenceType=參照類型
EntityPropertiesPanel.renameClass=重新命名類別名
EntityPropertiesPanel.schema=架構
EntityPropertiesPanel.table=表
EntityPropertyPathReference.inspection.unresolvedMessagePattern=屬性路徑“{0}”對於實體類別“{1}”無效
EntitySettingsWindow.jpb.title=新增實體
EntityType.EMBEDDABLE=可嵌入
EntityType.MAPPED_SUPERCLASS=映射的超類別
EntityType.PERSISTENT=實體
ExistingAttributeNameValidator.errorMessage=具有相同名稱的特性已存在
ExistingColumnNameValidator.attributeNameEqualsDiscriminatorColumn=列名稱為 {0} 的特性等於類別 {1} 的判別器列名
ExistingColumnNameValidator.discriminatorNameNotUnique=判別器列名 ''{0}'' 對於 ''{1}'' 實體不唯一
ExistingColumnNameValidator.errorMessageEmbedded=實體 {1} 有一個列名為 {0} 的嵌入式特性
ExistingColumnNameValidator.errorMessageInherited=存在列名為 {0} 的繼承特性
ExistingColumnNameValidator.errorMessageNamed=列名為 {0} 的特性已存在
ExistingSequenceNameValidator.errorMessage=具有相同名稱的序列已存在
HibernateCustomTypeDialog.title=建立自訂類型
HibernateCustomTypeDialog.type=類型
IndexesEditor.availableColumns.title=可用列
IndexesEditor.selectedColumns.title=所選列
IndexesEditor.validation.makeManyToOneFix=建立 {0} 多對一關聯
IndexesEditor.validation.makeOneToOneFix=建立 {0} 一對一關聯
JpaConverterEditorDialog.autoApply=自動套用
JpaConverterEditorDialog.dbType=資料庫列類型
JpaConverterEditorDialog.entityType=實體特性類型
JpaPalette.createdDate=建立日期
JpaPalette.equalsAndHashCode=equals 和 hashCode
JpaPalette.toString=ToString
LombokPropertiesPanel.getter=Getter
LombokPropertiesPanel.isLombokAllArgsConstructor=AllArgsConstructor
LombokPropertiesPanel.isLombokBuilder=Builder
LombokPropertiesPanel.isLombokNoArgsConstructor=NoArgsConstructor
LombokPropertiesPanel.isLombokSuperBuilder=SuperBuilder
LombokPropertiesPanel.onlyExplicitlyIncluded=僅顯式包含
LombokPropertiesPanel.setter=Setter
LombokPropertiesPanel.toString=ToString
LombokPropertiesPanel.toStringInclude=包含到 ToString 中
OrmStructurePanel.attributes=特性
OrmStructurePanel.persistenceUnits=持久性單元
OrmStructurePanel.referencedBy=參照者
OrmToolwindow.title=持久性
PersistenceUnitEditor.create.title=建立持久性單元
PersistenceUnitEditor.edit.title=編輯持久性單元
PersistenceUnitEditor.package.chooser.title=選擇持久性單元軟體套件
PersistenceUnitEditor.select.entity=選擇實體
PersistenceUnitEditor.validation.indexing=當索引編制正在進行時，無法完成
PersistenceUnitEditor.validation.name.empty=名稱不應為空
PersistenceUnitEditor.validation.name.unique=名稱應唯一
PersistenceUnitValidationDialog.proceed=繼續
PersistenceUnitValidationDialog.title=空持久性單元
PrimitiveTypeValidator.errorMessage=類型不應為基元
ProjectPropertiesPage.connection=測試連線
ProjectPropertiesPage.connectionSuccessful=已成功連線到 ''{0}''
ProjectPropertiesPage.connectionTestCaption=測試
ProjectPropertiesPage.dbConnectionParams=連線參數
ProjectPropertiesPage.dbPassword=密碼
ProjectPropertiesPage.dbPassword.showCheckBox=顯示密碼
ProjectPropertiesPage.dbType=資料庫類型
ProjectPropertiesPage.dbUrl=資料庫 URL
ProjectPropertiesPage.dbUser=資料庫使用者
ProjectPropertiesPage.emptyUrl=無法使用空 URL 進行連線
ProjectPropertiesPage.incorrectDbHost=無效的資料庫主機值\: ''{0}''。\n主機必須僅類似於 localhost[\:port]。
ProjectPropertiesPage.integratedSecurity=整合安全性
ProjectPropertiesPage.integratedSecurityInstruction=<html>要使 MSSQL Integrated Security 正常工作\:<ol><li>下載 <a href\="{0}">Windows 身份驗證庫歸檔</a></li><li>將下載的 jar 檔案解壓到“{1}”目錄</li><li>重啟 IDEA</li></ol>
ProjectPropertiesPage.testConnection.title=正在建立連線
ProjectPropertiesPage.validation.empty=空值
RelatedAttributeRemover.attributeDeleted=特性 {0}.{1} 已被移除
RelatedAttributeRemover.dialogMessage=<html>實體 <b>{0}</b> 包含相關特性 <b>{1}</b>。是否將其移除?</html>
RelatedAttributeRemover.dialogTitle=相關特性移除
RepositoryAttribute.OperatorType.And=And
RepositoryAttribute.OperatorType.NotSet=-
RepositoryAttribute.OperatorType.Or=Or
RepositoryConditionType.EQUALS=Equals
RepositoryConditionType.ING_POSTFIX=-ing
RepositoryConditionType.IS=Is
RepositoryConditionType.IS_ING=Is + -ing
RepositoryConditionType.NONE=無
RepositoryConditionType.SIMPLE=簡單
SerializableType.NoSerializable=非 Serializable
SerializableType.Serializable=Serializable
SerializableType.SerializableWithVersionUID=帶版本 UID 的 Serializable
SubDtoType.EXIST_CLASS=現有類別
SubDtoType.FLAT=扁平
SubDtoType.NEW_CLASS=新類別
SubDtoType.NEW_NESTED_CLASS=新嵌套類別
Validation.blankOrEmptyClassName=類別名為空白或為空
Validation.converterExists=指定的軟體套件中已存在使用此名稱的{0}
Validation.dtoExists=指定的軟體套件中已存在使用此名稱的 DTO 類別
Validation.embeddedRequired=欄位嵌入式類別為必需項
Validation.entityExists=指定的軟體套件中已存在使用此名稱的實體
Validation.hibernateEventListener=指定的軟體套件中已存在使用此名稱的 Hibernate 事件偵聽器
Validation.indexColumns={0} 必須至少包含一列
Validation.indexExists=已存在使用此名稱的{0}
Validation.invalidRepoEntityType=不支持嵌入式實體的儲存庫
Validation.language.null=未指定語言
Validation.mapperExists=指定的軟體套件中已存在使用此名稱的 mapper
Validation.notQualifiedName=這不是有效的 Java 限定名稱
Validation.notValidClassName=這不是有效的類別名
Validation.notValidType=這不是有效的類型
Validation.package.empty=軟體套件名稱不能為空
Validation.package.invalid=軟體套件名稱只應包含數字、字母或下劃線，並且不應以點結尾
Validation.projectionExists=指定的軟體套件中已存在使用此名稱的投影
Validation.repositoryExists=指定的軟體套件中已存在使用此名稱的儲存庫
Validation.repositoryExists.name=指定的軟體套件中已存在具有相同名稱“{0}”的儲存庫
Validation.reservedName=這是 JPA 註解的保留名稱
Validation.select.repository=選擇至少一個儲存庫
ViewPropertiesPanel.collapseAll=全部摺疊
ViewPropertiesPanel.expandAll=全部展開
ViewPropertiesPanel.openInView=在持久性檢視中選擇
ViewPropertiesPanel.selectAll=全選
ViewPropertiesPanel.selectBasicAttributes=選擇所有基本特性
ViewPropertiesPanel.showLibrariesClasses=顯示庫中的類別
ViewPropertiesPanel.unselectAll=取消全選
action.OpenInOrmToolwindowAction.text=在持久性檢視中選擇
action.browse.text=瀏覽
action.ddl.sql.ddl=DDL
action.editor.and.preview.text=編輯器和預覽
action.editor.text=編輯器
action.preview.text=預覽
action.select.action.text=選擇動作
action.text.open.settings=開啟設定
actions=動作
add=新增
add.attributes.dto=將特性新增到 DTO
add.entity.attribute=新增實體特性
add.index=新增索引
add.lifecycle.callback.method=新增生存期回調方法
add.listener=新增偵聽器
add.log=新增記錄器
add.named.query=新增命名查詢
add.order.by.attribute=新增按特性排序({0})
add.query.condition=新增查詢條件({0})
add.spring.repos.derived.method=新增 Spring 儲存庫派生方法
add.spring.repos.query.method=新增 Spring 儲存庫查詢方法
add.update.value.assignment=新增更新值賦值({0})
addAllArgs.fix=新增 @AllArgsConstructor 註解
addAllArgsAndNoArgs.fix=新增 @NoArgsConstructor 和 @AllArgsConstructor 註解
addConstructor.family=新增建構函式
addJpaConverterAnnotation.fix=新增 @Converter 註解
addModifyingAnnotation.fix=新增 @Modifying 註解
addModifyingAnnotation.fix.command=新增 @Modifying 註解
addNoArgs.fix=新增 @NoArgsConstructor 註解
addSimpleAllArgsConstructor.fix=將 {0} 全實參建構函式新增到 {1}
addSimpleConstructors.fix=將全實參和無實參建構函式新增到 {0}
additional.db.drivers=其他資料庫驅動程序
additional.part.of.method.name=方法中綴
advanced=進階
aggregate.root=聚合根
all.args.constructor=全實參建構函式
all.args.constructor.and.mutable.unselect=DTO 必須有一個全實參建構函式或者為可變，否則無法設定其屬性
all.ignore.case=全部忽略大小寫
artifact.drivers.files.unload=無法載入驅動程序資訊。請檢查您的互聯網連線。
assignJpaConverter.fix=指定 JPA 轉換器/Hibernate 類型
async=異步
attribute=特性
attribute.comment.text=/*\nTODO [逆向工程]會建立欄位來映射 ''{0}'' 列\n可用動作\:
attribute.name=特性名稱
attribute.type=特性類型
attributes.mapped.super.class=提取特性
audit.fields=審核欄位
audit.type.validation=指定型的審核器類別不正確
audited=已審核
auditing.entity.listener.not.found=<html>無法通過您的實體類別檢測到 AuditingEntityListener。如果未指定此偵聽器或類似偵聽器，則不會填充審核欄位。 <a href\='\#ADD_IT'>新增 AuditingEntityListener</a> 或在使用自訂審核偵聽器的情況下<a href\='\#HIDE_IT'>忽略此警告</a>。</html>
auditor.aware.inheritor.not.found.info=未檢測到 AuditorAware{0} 的實作。您可以手動指定任何審核器類型並稍後建立相應的 AuditAware 實作。
auditor.type=審核器類型
blaze.persistence.entity.view=Blaze 持久性實體檢視
calculation.of.structure.section=樹部分 {0} 的計算持續時間為 {1} 秒
cancel=取消
cancel.selection=取消選擇
cancel.selection.description=表的選擇將被清除。<br>是否要繼續?
caption=標題
cardinality=基數
cascade.remove.warning=CascadeType.REMOVE 最終刪除的內容可能會超出預期
cast.event.entity=應用於實體
choose.attribute=選擇特性
choose.class=選擇類別
choose.hibernate.entity=選擇實體
choose.hibernate.event.listener=選擇 Hibernate 事件 {0}
choose.package=選擇軟體套件
choose.table.or.view=選擇表或檢視
class=類別
class.name=類別名
class.name.validation.error=指定的軟體套件中已存在使用此名稱的類別
column.definition.not.found=找不到列定義
column.name.name=名稱
column.name.value=值
columnWidth=欄位寬度
command.name.create.entity=建立實體
command.name.create.enum=建立枚舉
command.name.update.entity.attribute=更新實體特性\: {0}
comment.saving.strategy.annotation=@Comment 註解
comment.saving.strategy.ignore=忽略
comment.saving.strategy.javaDoc=Java 文檔
connecting.to.dataSource=正在連線到 ''{0}''
continue=繼續
could.not.parse.repository.method.name=無法解析儲存庫方法名稱。\n請檢查“{0}”是否使用 Spring Data 方法命名約定。
creatable=可建立
create.blaze.persistence.entity.view=建立 Blaze 持久性實體檢視
create.count.method=建立 Count 方法
create.delete.method=建立 Delete 方法
create.dto=建立 DTO
create.dto.action.text=建立 DTO…
create.dto.or.projection.class=建立 DTO 或投影類別
create.entities.and.attributes=建立實體和特性…
create.entity.attributes=建立實體特性
create.entity.indicator=建立實體“{0}”
create.entity.models=建立實體模型
create.exists.method=建立 Exists 方法
create.find.collection.method=建立 Find Collection 方法
create.find.instance.method=建立 Find Instance 方法
create.new.dto.class=建立新的 DTO 類別
create.new.mapped.superclass=新增 MappedSuperclass
create.new.projection.class=建立新的 Projection 類別
create.projection=建立 Spring Data 投影
create.query.count.method=建立 @Query Count 方法
create.query.delete.method=建立 @Query Delete 方法
create.query.exists.method=建立 @Query Exists 方法
create.query.find.collection.method=建立 @Query Find Collection 方法
create.query.find.instance.method=建立 @Query Find Instance 方法
create.query.repository.method=建立 Query 儲存庫方法 ''{0}''
create.query.update.method=建立 @Query Update 方法
create.revision.entity=建立修訂實體
create.revision.listener=建立修訂偵聽器
create.spring.data.repository=建立 Spring Data 儲存庫
create.spring.data.repository.method=建立 Spring Data 儲存庫方法
createDbConnection=建立資料庫連線
createJpaConverter.fix=建立自訂類型
createPageableParameter.fix=將 Pageable 參數新增到方法簽名中
created.by=建立者
created.date=建立日期
criteria.api.specification=標準 API 規範
data.source=資料來源
database=資料庫
database.driver.not.selected=未選擇資料庫驅動程序
database.drivers=資料庫驅動程序
date.type=日期類型
date.type.validation=指定的日期類型不正確
db.connection=資料庫連線
db.connection.delete=刪除
db.connection.save=儲存
db.connection.updated=資料庫連線“{0}”已成功更新。
db.connection.was.deleted=資料庫連線“{0}”已刪除
db.driver.column.name.path=路徑
db.driver.download.version=下載 {0}
db.driver.switchToVersion=切換到 {0}
db.driver.title.downloading=正在下載 {0}
db.driver.version=驅動程序版本
db.driver.version.not.set=未設定\!
db.generated.id.description=<ul><li><b>NONE</b> - 資料庫和 ORM 均不提供 ID 值。ID 應在原始碼中明確指定。</li><li><b>IDENTITY</b> - ID 由資料庫管理。適用於自動增量類型以及使用 `nextval("sequence_name")` 或任何其他函式作為 ID 列的預設值的情況。</li><li><b>SEQUENCE</b> - ID 由 ORM 管理。該策略需要資料庫端的序列。針對批量插入進行了最佳化。</li></ul>
db.generated.id.description.uuid=<ul><li><b>NONE</b> - 資料庫和 ORM 均不提供 ID 值。ID 應在原始碼中明確指定。</li><li><b>UUID</b> - ID 由客戶端管理。可以使用 Hibernate 生成器、欄位初始化或自訂工廠來指定該值。對於在全球部署了多個應用程式和資料庫實例的分布式系統來說，這是唯一的選擇。</li></ul>
db.generated.id.jpa.entity=JPA 實體中資料庫生成的 ID
db.snapshot.help.description=如果進行逆向工程時未更改資料庫架構，我們建議啟用資料庫架構快取。否則，每次逆向工程使用時都會從資料庫載入資料庫架構。如果啟用快取，將為臨時目錄中的所選資料庫建立快照檔案 - <code>{0}</code>
db.view.without.id.columns=未選擇任何列用作主鍵
db.views.without.id.columns.msg=未選擇任何列用作以下關係的主鍵。<br><ul>{0}</ul>所有 JPA 實體都必須有一個 ID。是否要建立沒有 ID 的實體?
ddl.type=DDL 類型
declare.new=宣告新
default.db.connection=資料庫連線
default.method.name.will.be.generated=將生成預設方法名稱
define.entity.graph=定義實體圖
defined.target.java.type=定義目標 Java 類型
delete.db.connection=是否刪除資料庫連線“{0}”?
dialog.message.attribute.name.reserved.keyword=特性名稱為保留關鍵字
dialog.message.duplicates.are.found.for.items=找到了以下條目的重複項 \:{0}
dialog.message.entity.attribute.should.have.name.written.in.camelcase.naming.convention=實體特性的名稱應採用駝峰式命名法命名約定
dialog.message.field.required=欄位 {0} 為必需項
dialog.message.must.not.be.empty={0} 不得為空
dialog.message.parameters.with.blank.names.are.not.allowed=不允許使用名稱為空的參數
dialog.message.there.inherited.attribute.with.such.name=存在使用此名稱的繼承特性
dialog.title.choose.class=選擇類別
dialog.title.downloading.driver.files=正在下載驅動程序檔案
dialog.title.params=參數
dialog.title.select.item=選擇條目
diff.scope.all.places=所有位置
diff.scope.count=\ {0}/{1}
diff.scope.project=專案
diff.scope.project.and.libraries=專案和庫
diff.scope.project.and.tests=專案和測試
diff.scope.selected.entities=所選實體
diff.scope.test=僅測試
director.of.class.not.found=找不到“{0}”類別的目錄
directory=目錄
distinct=Distinct
domain.entity=域實體
down=下
download.driver.files=下載驅動程序檔案
download.missing.driver.files=<a href\="{0}">下載</a>缺少的驅動程序檔案
downloading.driver.files=正在下載驅動程序檔案
driver.0.not.found=找不到驅動程序 {0}\!
driver.class=驅動程序類別
driver.files.not.found=找不到驅動程序檔案
driver.files.were.not.loaded=驅動程序檔案未載入
dto=DTO
dto.and.spring.data.projections=DTO 和 Spring Data 投影
dto.class=DTO 類別
dto.class.already.exists=<html>這樣的類別已經存在。<br>選擇類型“現有類別”或為該類提供唯一的名稱。
dto.class.name=DTO 類別名
dto.class.not.exists=所選類別不存在
dto.type=DTO 類型
duplicate.attribute.name=重複的特性名稱“{0}”
duplicate.db.connection.name=資料庫連線名稱“{0}”在專案中必須唯一
duplicate.query.mapping=重複的查詢映射名稱“{0}”。實體 -“{1}”
dynamic.projection=動態投影
edit=編輯
elementCreationDialog.scaffoldingLanguage=語言\:
empty.db.connection=資料庫連線不應為空
empty.generation.type.value=生成類型不能為空
enable.jpa.auditing.info=<html>未檢測到 @EnableJpaAuditing 註解。無法組態 Spring 審核。請確保 Spring 審核已在您的應用程式中正確組態。<a href\='https\://docs.spring.io/spring-data/jpa/docs/current/reference/html/\#jpa.auditing.configuration'>在此處閱讀有關其組態的更多資訊…</a></html>
enable.mongo.auditing.info=<html>未檢測到 @EnableMongoAuditing 註解。無法組態 Spring 審核。請確保 Spring 審核已在您的應用程式中正確組態。<a href\='https\://docs.spring.io/spring-data/mongodb/docs/current/reference/html/\#mongo.auditing'>在此處閱讀有關其組態的更多資訊…</a></html>
entities=實體
entities.from.db=資料庫中的{0}
entity=用於實體
entity.attribute.from.db=資料庫中的{0}
entity.class=實體類別
entity.graph=實體圖
entity.graph.field=實體圖
entity.graph.type.fetch=<html>使用 javax.persistence.fetchgraph 屬性指定實體圖時，<br>由實體圖的特性節點指定的特性<br>會被視為 FetchType.EAGER，<br>而未指定的特性會作為 FetchType.LAZY 進行處理。<br><br></html>
entity.graph.type.load=<html>使用 javax.persistence.loadgraph 屬性指定實體圖時，<br>由實體圖的特性節點指定的特性<br>會被視為 FetchType.EAGER，<br>而未指定的特性會根據其指定或預設 FetchType 進行處理。<br><br></html>
entity.listener.class=實體偵聽器類別
entity.package=目標軟體套件
entity.projection.or.dto.return.type=實體、Spring 投影或 DTO 類別
entity.view.class.name=實體視圖類別名
entity.view.type=實體視圖類型
equals.hash.code=equals() 和 hashCode()
error=錯誤
excludeLazyField.fix=從 @ToString 中排除此欄位。
excludeLazyFields.fix=使用 @ToString.Exclude 排除所有延遲載入欄位。
excludeLazyFieldsFromHeader.fix=排除所有延遲載入的欄位。
existing.db.upgrade=現有資料庫更新(差異)
existing.parent.class=現有父類別
extract.and.configure.jpql.query=提取 JPQL 查詢並組態…
extract.jpql.query=提取 JPQL 查詢
extract.mapped.super.class=提取到 MappedSuperclass
extract.mapped.super.class.from=提取自
extract.mapped.super.class.to=提取到
extracting.jpql.using.limit.query=無法使用“Top”或“First”選項從方法中提取 JPQL 查詢
extracting.jpql.using.updateOrDelete.query=無法從“Update”或“Delete”查詢中提取 JPQL 查詢
extracting.warning=正在提取警告
extracting.warning.msg=其中一個提取方法中使用的某些特性/方法將不會被提取到父類別，因為您尚未選擇它們。這可能會導致無法編譯的程式碼。是否仍要繼續?
field.name=欄位名稱
field.required=欄位 ''{0}'' 為必需項
file.name=檔名
find=尋找
find.first=尋找第一個
fixes.create.jpa.projection=建立 Spring 投影
fluent.help.description=生成的 setter 將返回 `this` 而不是 `void`。如果您想鏈接多個方法呼叫，此類別 setter 會很有幫助。
fluent.setters=Fluent setter
found.override.properties=是否要覆寫這些屬性?
from.existing.attributes=從現有特性
from.parent=從父項
generate.columns.from.db=從資料庫生成列
generate.ddl.by.entities=通過實體生成 DDL…
generate.ddl.by.entity=通過{0}生成 DDL
generate.equals.and.hashcode.already.defined.warning=已為類別 {0} 定義方法 ''boolean equals(Object)'' 或 ''int hashCode()''。是否要刪除這些方法並繼續?
generate.equals.and.hashcode.already.defined.warning.anonymous=已為匿名類別定義方法 'boolean equals(Object)' 或 'int hashCode()'。是否要刪除這些方法並繼續?
generate.equals.and.hashcode.composite.warning={0} {1} 必須實作 equals 和 hashcode 方法。要生成它們嗎?
generate.equals.and.hashcode.several.warning=找到多個密鑰。是否要在 equals() 和 hashCode() 方法中使用?
generate.equals.and.hashcode.several.warning.title=選擇生成策略
generate.tostring.already.defined.title=生成 toString()
generate.tostring.already.defined.warning=已為類別 {0} ''String toString()'' 定義方法。是否要刪除這些方法並繼續?
generate.tostring.composite.warning=是否要在 {0} 類別中實作 toString() 方法?
generateEqualsAndHashCode.fix=生成 equals()、hashCode() 和 toString()
generateNoArgsConstructor.fix=將無實參建構函式新增到類別
generated.ddl=生成的 DDL
go.to.domain.entity=轉到“{0}”域實體
graph=圖
graph.fetch.type=提取類型
graph.fields.load=要載入的欄位
group.com.intellij.orm.structure.popup.new.text=新
group.names.jpa.issues=JPA
hibernate=Hibernate
hibernate.ddl.auto=DDL 自動
hibernate.entity.field.tooltip=實體的名稱。如有多個則用逗號分隔
hibernate.event=Hibernate 事件
hibernate.event.listener=Hibernate 事件 {0}
hibernate.events.field.tooltip=Hibernate 事件的名稱。如有多個則用逗號分隔
hibernate.format.sql=設定 SQL 格式
hibernate.show.sql=顯示 SQL
id=ID
id.generated.strategy=ID 生成
idea.data.source.refresh.exception=IDEA 資料來源重新整理異常
incorrect.attribute.value=實體特性的名稱應採用駝峰式命名法命名約定
incorrect.length.value=不正確的長度值\: {0}
inspection.LombokAllArgsInspection=對沒有定義無實參建構函式的 JPA 實體使用 @AllArgsConstructor 會破壞 JPA 規範。
inspection.LombokBuilderAllArgsInspection=Lombok @Builder 需要針對此類別的適當建構函式
inspection.LombokBuilderInspection=對沒有定義無實參建構函式的 JPA 實體使用 @Builder 會破壞 JPA 規範。
inspection.ManyToManyCascadeRemove=對於 @ManyToMany 關聯，REMOVE 實體狀態過渡沒有級聯意義，因為它將傳播到鏈接表之外。
inspection.OneToOneWithLazyFetchType=為 @OneToOne 關聯的非擁有方指定 FetchType.LAZY 不會影響載入。相關實體仍將被載入，就像定義了 FetchType.EAGER 一樣。
inspection.associationFieldHasColumnAnnotation.name=使用 @Colum 標記的關聯欄位
inspection.associationFieldHasColumnAnnotation.replaceFix=將 @Column 更改為 @JoinColumn
inspection.associationFieldHasColumnAnnotation.warning=不允許在{0}屬性上使用 @Column
inspection.associationNotMarkedInspection=實體特性未使用關聯註解標記
inspection.converterNotAnnotated=JPA 轉換器必須使用 @Converter 進行註解
inspection.message.unknown.column=未知列 {0}
inspection.moreThanOneId=實體有多個 ID 特性。
inspections.replaceAnnotation=取代為 {0}
invalid.attribute.name=列\:“{0}”。特性名稱的 Java 關鍵字無效或為保留關鍵字\:“{1}”
invalid.class.name=無效類別名
invalid.domain.entity.class=無效的域實體類別“{0}”
invalid.field.name=實體特性“{0}”的欄位名稱無效
invalid.field.name.changed=<html>使用 MapStruct mapper 生成時，無法更改 Collection 類型的特性的屬性名稱。<br/>此類別屬性的名稱已被重設。</html>
invalid.or.empty.domain.entity.class=域實體類別無效或為空
invalid.or.empty.dto.class=DTO 類別值無效或為空
invalid.package.name=無效的軟體套件名稱
invalid.parent.class=無效的父類別
invalid.subDto.type=<html>無效的 subDto 類型特性“{0}”。<br/>不支持建立具有超過 1 個嵌套級別的扁平<br/>集合特性的 mapper。</html>
invalid.subEntityView.type=<html>子實體視圖類型特性“{0}”無效。<br/>不支持建立具有超過 1 個嵌套級別的扁平<br/>集合特性的實體檢視。</html>
java.record=Java 記錄
java.type.is.empty=列\:“{0}”。Java 類型為必需項
jpa.buddy.common.notifications=JPA Buddy 常見通知
jpa.buddy.logs=JPA Buddy 日誌
jpa.buddy.template.group=JPA Buddy
jpa.converter.or.hibernate.type=JPA 轉換器/Hibernate 類型
jpa.converters=JPA 轉換器
jpa.entities=JPA 實體
jpa.entity=JPA 實體
jpa.entity.attributes=實體特性
jpa.persistence.unit=持久性單元
json.ignore.unknown.properties=忽略 JSON 反序列化的未知屬性
last.modified.by=最後修改者
last.modified.date=上次修改日期
last.update=(在以下位置捕獲了資料庫的實際狀態\: {0})
learn.more=了解詳情
limit=限制
limit.prefix=限制前綴
limit.size=限制大小
listener.class.not.selected=未選擇實體偵聽器類別。請選擇一個類別。
loading.database.model=正在載入資料庫模型…
loading.time=載入時間 - {0} 秒
lock.mode=鎖定模式
logical.orm.attribute.column.mappings=列映射
logical.orm.attribute.maps=映射
logical.orm.embedded.usages=用法
logical.orm.superclass.implementations=實作
makeCompositeClassSerializable.fix=使 {0} 類別實作 Serializable
makeTransient.fix=標記為 @Transient
mandatory.attribute.not.added=強制特性將不會新增到實體
mapStruct.collectionMappingCollection=為集合建立 mapper 方法
mapStruct.collectionMappingStream=使用 stream().map(…)
mapStruct.createMapStructClassCaption=建立 MapStruct 接口
mapStruct.mapper=MapStruct 接口
mapStruct.mapperClassName=Mapper 類別名
mapStruct.mapperParentInterface=父接口
mapStruct.packageChooserDialogCaption=選擇 MapStruct Mapper 軟體套件
mapped.columns=映射的列
mapped.relations=映射的關係
mapped.super.class.extract.generator=將 @SequenceGenerator 宣告提取到 {0} 中
mapped.super.class.generator.name=產生器名稱
mapped.super.class.name=MappedSuperclass 名稱
mapper.methodName=方法名稱
mapper.methods=Mapper 方法
mapper.naming.options.collection=使用集合類型後綴
mapper.naming.options.plural=使用複數形式
mapper.naming.options.singular=使用單數形式
mapping.java.type=映射 Java 類型
mapping.settings=映射設定
mapping.types=映射類型
menuItem=選單
method=方法
method.infix.help=這是位於 "{0}" 前綴和 "By" 條件之間的方法名稱段。它支援簡潔的方法命名，並且可用於針對同一查詢條件返回多種資料類型。
method.name=方法名稱
method.prefix=方法前綴
methods.mapped.super.class=提取方法
microsoft.sql.server=Microsoft SQL Server
microsoft.sql.server.jtds=Microsoft SQL Server (jtds)
migrate.default.values=遷移預設值
migrate.indexes.and.constraints=遷移索引和約束
migrate.other.columns=將其他列遷移到實體
missing.primary.key.columns=缺少主鍵列
modifying=正在修改
module=在模組中
mutable=可變
name=名稱
named.parameters=命名參數
named.query=命名查詢
named.query.attr.name.empty=特性名稱為必需項。表行\: {0}
named.query.creation.error=命名查詢建立錯誤
new.attribute=新特性
new.dto=新增 DTO
new.mapper.class=新增 MapStruct 接口
no.attributes=無特性
no.attributes.detected=未檢測到特性
no.attributes.selected=未選擇任何特性
no.auditor.aware.classes.info=<html>未檢測到 AuditorAware 接口的實作。您可以手動指定審核器類型並稍後建立相應的 AuditAware 實作。</html>
no.columns.for.reverse.engineering=沒有用於逆向工程的列
no.driver.files.configured=未組態驅動程序檔案。<a href\="{0}">切換</a>至 {1}
no.entities=無實體
notification.content.exception.during.create.directory=建立目錄期間出現異常\: {0}
notification.content.please.select.directory.for.create.action=請選擇用於建立動作的目錄
notification.title.exception.during.creation.projection=建立投影期間出現異常
notification.title.exception.when.entity.column.name.calculating.column.name.template=計算實體列名時出現異常。列名模板\: {0}
notification.title.exception.when.entity.name.calculating.entity.name.template=計算實體名稱時出現異常。實體名稱模板\: {0}
notification.title.exception.when.entity.table.name.calculating.table.name.template=計算實體表名時出現異常。表名模板\: {0}
notification.title.project.not.contains.modules=專案不包含模組
nullability=為 null 性
nullable=可為 null
open.db.connection=開啟資料庫連線
order.by.attributes=按特性排序
other=其他
other.settings=其他設定
override.properties=覆寫屬性
packageName=軟體套件
pageable=Pageable
parent=父項
persistence.unit.file=persistence.xml 檔案
persistence.unit.manuallyAdded=手動新增
persistence.unit.scanAllPackages=掃描所有軟體套件
persistenceUnit=映射上下文
please.check.internet.connection=請檢查您的互聯網連線
pojo.class=POJO 類別
presentation=表示
progress.details.extracting=正在提取 {0}
progress.loadDriversTitle=正在載入資料庫驅動程序列表…
progress.text.choice.downloading.resolving={0, choice, 0\#正在下載 |1\#正在解析 }{1}
project.jdk.select.title=選擇專案 SDK
project.sdk.not.defined=未定義專案 JDK
projection=投影
projection.class.name=投影類別名
projection.type=投影類型
property.name=屬性名稱
pu.without.entities.error=所選持久性單元不包含實體。這可能是由於最近對軟體套件名稱進行了重構或在 persistence.xml 中進行了更改。如果應該包含實體，請編輯持久性單元，或者繼續生成 drop 語句。點擊“取消”以選擇其他持久性單元。
query=查詢
query.conditions=查詢條件
query.options=查詢選項
query.string=查詢字串
radio.hibernate.custom.type=Hibernate 自訂類型
radio.jpa.converter=JPA 轉換器
references=參照
refers.to.entities=參照實體
refresh.idea.data.source=重新整理 IDEA 資料來源
relation.panel.loadParents=正在載入父實體
remove=移除
remove.column.mapping=移除列映射
remove.listener=移除偵聽器
removeAnnotation.fix=移除 @{0} 註解。
removeCascadeType.fix=移除實參 CascadeType.REMOVE
removeLazyForOneToOneAnnotation.fix=移除實參 FetchType.LAZY
replaceCascadeTypeAll.fix=將級聯上除 CascadeType.REMOVE 之外的所有類型取代為 CascadeType.ALL
replaceData.fix=將 @Data 取代為安全註解和自動生成的 equals() 和 hashCode()
replaceEqualsAndHashCode.fix=將 @EqualsAndHashCode 取代為推薦的 equals() 和 hashCode() 實作。
replacePageToList.fix=將 {0} 取代為 {1}
replaceToString.fix=將 @ToString 取代為推薦的 toString() 實作。
repositories=儲存庫
repository.creation.dialog.entity=實體
repository.method.overridden=在基類別中找到了具有相同名稱“{0}”的方法\! 該方法已被覆寫。
repository.name=程式碼庫名稱
repository.query.method=儲存庫查詢方法
result=結果
return.type=返回值類型
revision.listener=修訂偵聽器
revision.number=修訂號
revision.repository=修訂儲存庫
revision.timestamp=修訂時間戳
run.action=執行動作
save.entity.indicator=儲存實體“{0}”
scan.packages=掃描軟體套件
scratch.db.initialization=資料庫架構初始化
select.any.dto.type=選擇任意 DTO 類型
select.any.entity.attribute.type=選擇任意實體特性類型
select.any.entity.view.type=選擇任意實體檢視類型
select.any.projection.type=選擇任意投影類型
select.at.least.one.entity=至少選擇一個實體來建立自訂作用域
select.columns.for.id.attribute=選擇要用作主鍵的列
select.entities=選擇自訂作用域的實體
select.id.attributes=選擇主鍵特性
select.id.columns=選擇主鍵列
select.repository=選擇儲存庫
select.repository.method.type=選擇儲存庫方法類型
sequence=序列
sequence.field.required=欄位序列為必需項
serializable=Serializable
settings=設定
several.auditor.aware.classes.info=<html>已檢測到 AuditorAware 接口的多個實作。確保您選擇的審核器類型與 Spring 審核組態中使用的審核器類型相對應。</html>
shorten.method.name=縮短方法名稱
show.basic.attributes=顯示基本特性
signature=簽名
snapshot.file.not.exists=快照檔案不存在
snapshot.incorrect.message=無法從資料庫架構快取讀取資料。請嘗試重新整理或將其關閉。
snapshot.incorrect.title=快照讀取錯誤
sort.table.unavailable=<b>排序方式</b>表不可用。先選擇<b>尋找第一個</b>選項。
sortable=Sortable
source.class=源類型
source.root=來源根
source.scope=源作用域
specification=規範
spring.data.repositories=Spring Data 儲存庫
start.text.todo.reverse.engineering=TODO [逆向工程]
start.text.todo.reverse.engineering.odd=TODO 逆向工程
success=標準螢幕已成功建立
table=表
table.name=表名
table.view=表/檢視
tables=表
target.class=目標類型
to.string=toString()
todo.comment=TODO
todo.java.type.render=此欄位將在稍後生成
todo.reverse.engineering=//TODO [逆向工程] 從資料庫生成列
transactional.read.only=Transactional readOnly
tree.persistence.units.missing.package.tooltip=持久性單元參照缺少的軟體套件
type.migration.label=將{0} "{1}" 遷移到
uncomment.as.is=按原樣取消註釋
unselect.columns=取消選擇列
unselect.table.has.usages=<html>表 <b>{0}</b> 具有無法安全取消選擇的用法\: <ul>{1}</ul>
up=上
updatable=可更新
update.re.mappings=映射更新
update.re.mappings.message=您剛剛更改了命名規則和/或列到特性類型映射。是否要立即套用新設定? 請注意，所做的所有映射設定都將被重設。
update.values=更新值
update.values.attribute.is.empty=“更新值”表中的特性為空
update.values.is.empty=指定至少一個更新值
usages.detected=檢測到用法
use.named.parameters=使用命名參數
use.table.schema=使用表架構
used.by=使用物件\:
validation.attributes.and.order.by.empty=查詢條件和排序方式特性為空
validation.attributes.empty=查詢條件為空
validation.delete.update.join=方法不應在條件中包含相關實體特性
validation.delete.void.id=Void 是 deleteById() 方法唯一可能的返回值類型。
validation.duplicate.repository.method.name=<html>已存在具有相同名稱“{0}”的方法。</html>
validation.duplicate.repository.method.name.action=<html><a href\=''\#ADD_IT''>套用返回值類型名稱作為中綴並使用“{0}”作為方法名稱</a></html>
validation.incorrect.pageable.return.type=返回分頁資料的方法必須具有以下返回值類型之一\: Page<T>、Slice<T>、List<T>
validation.incorrect.repository.return.type=不正確的儲存庫返回值類型
validation.repository.method.have.pageable.and.sort=方法不能同時為 Pageable 和 Sortable。請在 Pageable 上改用排序功能。
validation.repository.not.selected=未選擇儲存庫
validation.update.only.basic=方法不應更新相關實體特性
value=值
value.type=值類型
velocity.template=Velocity 模板
view=檢視
views=檢視
wrap.type=包裝類型

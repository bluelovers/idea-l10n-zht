action.AddToISuite.text=新增到 JUnit 模式套件
action.excludeFromSuite.text=從套件中排除
action.text.test.category={0} 的測試
action.text.test.tags={0} 的測試
action.text.test.unknown.target=未知
async.stack.trace.for.exceptions.name=列印異常的異步堆疊追蹤
cannot.browse.test.inheritors.dialog.title=無法瀏覽TestCase繼承器
category.interface.dialog.title=類別接口
category.is.not.specified.error.message=未指定類別
category.label=類別
change.list.label=更改列表
class.isnt.inheritor.of.testcase.error.message={0}沒有繼承人的TestCase
class.not.test.error.message=類別 ''{0}'' 不是測試
combobox.changelists.all=所有
configuration.not.specified.message=組態測試類型未指定\: {0}
create.setup.dialog.message=方法 setUp 已存在，但未使用 {0} 註解。是否註解?
create.setup.dialog.title=建立 setUp 方法
default.junit.config.empty.category=無效
default.junit.config.name.all.in.module={0}中的所有
default.junit.config.name.all.in.package.in.module={1}中的{0}
default.junit.config.name.category=@Category({0})
default.junit.config.name.tags=標記({0})
default.junit.config.name.temp.suite=臨時套件
default.junit.config.name.whole.project=整個專案
default.junit.configuration.name=<無名稱>
dialog.message.failed.to.resolve.maven.id=無法解析 {0}
dialog.message.no.unique.id.specified.exception=未指定唯一 ID
dialog.title.preparing.test=正在準備測試
directory.0.is.not.found.error.message=找不到目錄 ''{0}''
directory.is.not.specified.error.message=未指定目錄
directory.label=目錄
directory.not.found.error.message=未找到目錄 ''{0}''
expected.exception.never.thrown.display.name=從未在測試方法正文中拋出預期異常
expected.exception.never.thrown.problem.descriptor=從未在 ''{0}()'' 的正文中拋出預期 <code>\#ref</code> \#loc
fix.data.provider.create.method.fix.name=建立資料提供程序方法 '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.multiple.methods.problem=類別 <code>\#ref</code> 中存在多個 @Parameters 資料提供程序方法
fix.data.provider.signature.family.name=修正資料提供程序方法簽名
fix.data.provider.signature.fix.name=將方法簽名更改為 ''{0}''
fix.data.provider.signature.incorrect.problem=資料提供程序方法 <code>\#ref()</code> 的簽名不正確
fix.data.provider.signature.missing.method.problem=參數化測試類別 <code>\#ref</code> 缺少用 '@Parameters' 註解的資料提供程序方法
fork.mode.label=複刻模式(&F)\:
fork.mode.name=複刻模式
inspection.parameterized.parameters.static.collection.display.name=沒有資料提供程序方法的參數化測試類別
junit.config.with.parameter.0=帶有參數“{0}”
junit.configuration.across.module.dependencies.radio=跨模組相依項
junit.configuration.class.label=類別\:
junit.configuration.description=JUnit 測試組態
junit.configuration.display.name=JUnit
junit.configuration.fork.mode.class=類別
junit.configuration.fork.mode.method=方法
junit.configuration.fork.mode.none=無
junit.configuration.fork.mode.repeat=重複
junit.configuration.in.single.module.radio=在單一模組
junit.configuration.in.whole.project.radio=在整個專案
junit.configuration.kind.all.in.directory=目錄中的所有
junit.configuration.kind.all.in.package=軟體套件中的所有
junit.configuration.kind.by.pattern=模式
junit.configuration.kind.by.tags=標記
junit.configuration.kind.by.unique.id=UniqueId
junit.configuration.kind.category=類別
junit.configuration.kind.class=類別
junit.configuration.kind.method=方法
junit.configuration.method.label=方法\:
junit.configuration.package.label=包\:
junit.configuration.repeat.mode.n.times=N 次
junit.configuration.repeat.mode.once=一次
junit.configuration.repeat.mode.until.failure=直至失敗
junit.configuration.repeat.mode.until.stopped=直至停止
junit.configuration.repeat.mode.until.success=直到成功
junit.configuration.search.for.tests.label=搜尋測試\:
junit.entry.point.suggest.package.private.visibility.junit5=建議 Junit 5 測試的 package-private 可見性級別
junit.inspections.group.name=JUnit
junit.not.found.in.module.error.message=在模組''{0}''中未找到JUnit
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 類別中的舊樣式 JUnit 測試方法
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 類別中的舊樣式 JUnit 測試方法 <code>\#ref()</code> \#loc
junit5.migration.description=將 JUnit 4 測試註解遷移到新的 Jupiter 註解中時，可能會導致出現紅色程式碼\! 斷言不會遷移。請參閱“JUnit 問題 | JUnit 4 測試可能為 JUnit 5”檢查，只遷移可以完全自動轉換的測試。
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>\#ref()</code> 可能是 'assertSame()' \#loc
jvm.inspections.junit.assertequals.on.array.display.name=在陣列上呼叫了 'assertEquals()'
jvm.inspections.junit.assertequals.on.array.problem.descriptor=在陣列上呼叫了 <code>\#ref()</code> \#loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=測試類別 ''{0}'' 已被{1, choice, 1\#|2\#無理由}忽略/停用 \#loc
jvm.inspections.junit.ignored.test.display.name=使用 '@Ignore'/'@Disabled' 註解的 JUnit 測試
jvm.inspections.junit.ignored.test.ignore.reason.option=只報告沒有原因的註解
jvm.inspections.junit.ignored.test.method.problem.descriptor=測試方法 ''{0}()'' 已被{1, choice, 1\#|2\#無理由}忽略/停用 \#loc
jvm.inspections.junit.malformed.annotated.double.descriptor=使用 ''@{1}'' 註解的{0, choice, 0\#欄位|1\#方法} <code>\#ref</code> 應為 {2} 和 {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0\#欄位|1\#方法} <code>\#ref</code> 應為 {2}、{3} 且類型應為 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 應為 {1}，{2}，且不應宣告參數 ''{3}'' 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 應為 {1}，{2}，且不應宣告參數 ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 應為 {1}，{2}，類型應為 ''{3}''，且不應宣告參數 {4} 和 ''{5}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 應為 {1}，{2}，類型應為 ''{3}''，且不應宣告參數 ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 不應宣告參數 {1} 和 ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 不應宣告參數 ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 應為 {1} 且不應宣告參數 ''{2}'' 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 應為 {1} 且不應宣告參數 ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 應為 {1}，類型應為 ''{2}''，且不應宣告參數 {3} 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 應為 {1}，類型應為 ''{2}''，且不應宣告參數 ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 的類型應為 ''{1}''，且不應宣告參數 {2} 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 的類型應為 ''{1}'' 且不應宣告參數 ''{2}''
jvm.inspections.junit.malformed.annotated.single.descriptor=使用 ''@{1}'' 註解的{0, choice, 0\#欄位|1\#方法} <code>\#ref</code> 應為 {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0\#欄位|1\#方法} <code>\#ref</code> 應為 {2} 且類型應為 ''{3}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=使用 ''@{0}'' 註解的方法 <code>\#ref</code> 不應為掛起函式
jvm.inspections.junit.malformed.annotated.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0\#欄位|1\#方法} <code>\#ref</code> 類型應為 ''{2}''
jvm.inspections.junit.malformed.declaration.name=JUnit 格式錯誤的宣告
jvm.inspections.junit.malformed.extension.class.level.descriptor=應在類別級別註冊{0}
jvm.inspections.junit.malformed.fix.class.signature=修正類別簽名
jvm.inspections.junit.malformed.fix.class.signature.descriptor=修正 ''{0}'' 類別簽名
jvm.inspections.junit.malformed.fix.class.signature.multi=修正類別簽名
jvm.inspections.junit.malformed.fix.field.signature=修正欄位簽名
jvm.inspections.junit.malformed.fix.field.signature.descriptor=修正 ''{0}'' 欄位簽名
jvm.inspections.junit.malformed.fix.method.signature=修復方法簽名
jvm.inspections.junit.malformed.fix.method.signature.descriptor=修復 ''{0}'' 方法簽名
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=不會執行嵌套類別中的測試
jvm.inspections.junit.malformed.no.arg.descriptor=方法 <code>\#ref</code> 應為 {0}、{1}{2, choice, 0\#且無形參|1\#，無形參，且類型為 void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=由以下物件註解時忽略測試參數\:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=重複的 'enum' 常數名稱
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' 無法向方法提供實參，因為方法具有不受支援的 ''{1}'' 類型的參數
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=必須恰好提供一種類型的輸入
jvm.inspections.junit.malformed.param.file.source.descriptor=無法解析檔案源\: ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=未找到將 ''{0}'' 轉換為 ''{1}'' 的隱式轉換
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=方法源 ''{0}'' 不應有參數
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=方法源 ''{0}'' 必須具有以下其中一種返回值類型\: ''Stream<?>''、''Iterator<?>''、''Iterable<?>'' 或 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=方法源 ''{0}'' 必須為 static
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=無法解析目標方法源\: ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=''@{0}'' 只能提供一個參數
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=沒有提供源，套件將為空
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=未定義值源
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=無法解析 'enum' 常數參照。
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=必須在 'Arguments' 中包裝多個參數
jvm.inspections.junit.malformed.repetition.number.descriptor=重複次數必須大於零
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' 無法向方法提供實參，因為方法沒有參數
jvm.inspections.junit.malformed.suspend.function.descriptor=方法 <code>\#ref</code> 不應為掛起函式
jvm.inspections.junit.malformed.test.combination.descriptor=可疑的 {0} 與 ''@{1}'' 組合
jvm.inspections.junit.mixed.annotations.junit.descriptor=擴展 JUnit {1} TestCase 的類別內使用 ''@{0}'' 註解的方法 <code>\#ref()</code> \#loc
jvm.inspections.junit.mixed.annotations.name=在單個 TestCase 中使用多個版本的 JUnit API
jvm.inspections.junit3.super.teardown.display.name=未從 'finally' 塊呼叫 JUnit 3 'super.tearDown()'
jvm.inspections.junit3.super.teardown.problem.descriptor=未從 'finally' 塊呼叫 <code>\#ref()</code> \#loc
jvm.inspections.junit4.converter.display.name=JUnit 3 測試可以是 JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>\#ref</code> 可以轉換為 JUnit4 測試用例
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=如果 {1} 被轉換為 JUnit 4，方法呼叫 {0} 將不編譯
jvm.inspections.junit4.converter.quickfix.conflict.name=方法 {0} 將與其 super 方法發生名稱衝突
jvm.inspections.junit4.converter.quickfix.conflict.semantics=如果 {1} 被轉換為 JUnit 4，方法呼叫 {0} 可能會更改語意
jvm.inspections.junit4.converter.quickfix.conflict.suite={0} 的 suite 方法的遷移有副作用，將被刪除
jvm.inspections.junit4.converter.quickfix.name=轉換為 JUnit 4 測試用例
jvm.inspections.junit4.inherited.runwith.display.name='@RunWith' 註解已存在於父類別中
jvm.inspections.junit4.inherited.runwith.problem.descriptor=''@RunWith'' 註解已存在於{0}類別中
jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 已廢棄斷言
jvm.inspections.junit5.assertions.converter.familyName=取代為 JUnit 5 相容呼叫
jvm.inspections.junit5.assertions.converter.problem.descriptor=對來自 ''{0}'' 的 <code>\#ref()</code> 的呼叫應取代為對來自 ''{1}'' 的方法的呼叫 \#loc
jvm.inspections.junit5.assertions.converter.quickfix=取代為 ''{0}'' 方法呼叫
jvm.inspections.junit5.converter.display.name=JUnit 4 測試可以為 JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=\#ref 可以為 JUnit 5 測試
jvm.inspections.junit5.converter.quickfix=遷移到 JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=由於存在不相容的繼承者，類別 {0} 無法轉換為 JUnit 5\: {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=轉換斷言
jvm.inspections.migrate.assert.to.matcher.description=斷言表達式 <code>\#ref</code> 可被取代為 ''{0}'' 呼叫 \#loc
jvm.inspections.migrate.assert.to.matcher.option=靜態匯入符合程序的方法
jvm.inspections.migrate.assertion.name=JUnit 斷言可以是 'assertThat()' 呼叫
jvm.inspections.unconstructable.test.case.junit3.descriptor=測試類別 <code>\#ref</code> 不可建構，因為它沒有 'public' 無實參或單個 'String' 參數建構函式 \#loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=測試類別 <code>\#ref</code> 不可建構，因為它應當正好有一個 'public' 無實參建構函式 \#loc
jvm.inspections.unconstructable.test.case.not.public.descriptor=測試類別 <code>\#ref</code> 不可建構，因為它不是 'public' \#loc
method.name.not.specified.error.message=未指定方法名稱
module.does.not.exists=模組''{0}''不存在於專案''{1}''
module.to.choose.classpath.not.specified.error.message=未指定從中選擇類別路徑的模組
multiple.exceptions.declared.on.test.method.display.name=在測試方法上宣告的多個異常
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>\#ref</code> 可被取代為 'throws Exception' \#loc
no.module.selected.error.message=未選擇模組
no.pattern.error.message=未選擇模式
no.test.class.specified.error.text=未指定測試類別
package.does.not.exist.error.message=軟體套件 ''{0}'' 不存在
pattern.label=模式
progress.title.download.additional.dependencies=下載其他相依項…
repeat.count.label=重複計數(&R)\:
repeat.label=重複(&R)\:
repeat.name=重複
running.tests.disabled.during.index.update.error.message=執行測試在索引更新期間處於停用狀態
search.scope.module=在單個模組中
search.scope.module.deps=在模組相依項中
search.scope.name=搜尋測試
search.scope.project=在整個專案中
tag.expression.label=標記表達式
tag.name.0.must.be.syntactically.valid.warning=標記名稱 [{0}] 的語法必須有效
tags.are.not.specified.error.message=未指定標記
test.class.hint=包含測試的類別的完全限定名稱
test.discovery.by.all.changes.combo.item=所有
test.group=測試
test.kind.hint=用於搜尋測試的資源類型
test.method.doesnt.exist.error.message=測試方法''{0}''不存在
test.method.hint=測試方法的完全限定名稱
test.package.hint=包含測試的軟體套件的名稱
test.pattern.hint=用於符合包含測試的類別的名稱的正則表達式
uniqueid.label=UniqueId
unused.declaration.junit.test.entry.point=JUnit 測試用例
usage.of.obsolete.assert.display.name=使用廢棄的 'junit.framework.Assert' 方法
use.of.obsolete.assert.problem.descriptor=對來自 ''{0}'' 的 <code>\#ref()</code> 的呼叫應被取代為對來自 ''org.junit.Assert'' 的方法的呼叫 \#loc
use.of.obsolete.assert.quickfix=取代為 'org.junit.Assert' 方法呼叫

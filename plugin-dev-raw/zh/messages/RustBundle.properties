0.2.choice.0.is.in.progress.1.on.the.fly.analysis.is.turned.1={0}{2, choice, 0\# 正在進行|1\# 即時分析已\: {1}}
0.abi={0} ABI
0.for.1=`{1}` 的 `{0}`
0.lines.covered=已覆蓋 {0}% 的行
0.naming.convention={0}命名約定
0.of.1.files={0}/{1} 個檔案
0.of.1.files.covered=已覆蓋 {0}/{1} 個檔案
0.to.execute=<{0}> 以執行
1.lines.covered=已覆蓋 <1% 的行
abbreviated.month.name.always.3.letters.jul=(Jul) 月份名稱縮寫。始終為 3 個字母。
abbreviated.weekday.name.always.3.letters.sun=(Sun) 星期名稱縮寫。始終為 3 個字母。
action.Cargo.AttachCargoProject.text=附加 Cargo 專案
action.Cargo.DetachCargoProject.text=分離 Cargo 專案
action.Cargo.RefreshCargoProject.description=更新 Cargo 專案資訊並下載新的相依項
action.Cargo.RefreshCargoProject.text=重新整理 Cargo 專案
action.Cargo.RunCargoCommand.text=執行 Cargo 指令
action.Cargo.RunExternalLinter.text=執行外部 Linter
action.Cargo.RustfmtCargoProject.description=Reformat Cargo project with Rustfmt
action.Cargo.RustfmtCargoProject.text=使用 Rustfmt 重新格式化 Cargo 專案
action.Cargo.RustfmtFile.default.text=使用 Rustfmt 重新設定檔案格式
action.Cargo.RustfmtFile.description=使用 Rustfmt 重新格式化當前檔案
action.Cargo.RustfmtFile.file.text=使用 Rustfmt 重新格式化{0}
action.Cargo.RustfmtFile.progress.default.text=正在使用 Rustfmt 重新設定檔案格式…
action.Cargo.RustfmtFile.progress.file.text=正在使用 Rustfmt 重新格式化{0}…
action.Cargo.RustfmtFile.text=Reformat File with Rustfmt
action.Cargo.ShowSettings.description=編輯當前項目的 Cargo 設定
action.Cargo.ShowSettings.text=Cargo 設定
action.Cargo.ToggleExternalLinterOnTheFlyAction.text=即時執行外部 Linter (Cargo Check/Clippy)
action.Rust.Build.description=建置專案
action.Rust.Build.text=建置
action.Rust.ConsoleREPL.text=Rust REPL
action.Rust.CreateNewIssue.description=在 https\://youtrack.jetbrains.com/issues/RUST 中建立新問題
action.Rust.CreateNewIssue.text=向 Rust 團隊報告問題
action.Rust.GenerateConstructor.text=建構函式
action.Rust.GenerateDictionaries.text=生成 Rust 拼寫檢查器字典
action.Rust.GenerateGetter.text=Getter
action.Rust.GenerateSetter.text=Setter
action.Rust.NewCargoCrate.description=建立一個新的 Cargo crate
action.Rust.NewCargoCrate.text=Cargo Crate
action.Rust.NewRustFile.description=建立一個新的 Rust 檔案
action.Rust.NewRustFile.text=Rust 檔案
action.Rust.RebuildAllDefMaps.text=為所有 crate 重建 DefMap
action.Rust.RebuildCurrentDefMap.text=為當前檔案重建 DefMap
action.Rust.ReexpandMacrosAction.text=重新展開所有 Rust 巨集
action.Rust.RsConvertToNamedFields.description=將元組結構轉換為命名欄位
action.Rust.RsConvertToNamedFields.text=轉換為命名欄位
action.Rust.RsConvertToTuple.description=將結構轉換為元組
action.Rust.RsConvertToTuple.text=轉換為元組
action.Rust.RsDowngradeModuleToFile.description=將此模組移至單獨的檔案
action.Rust.RsDowngradeModuleToFile.text=將模組降級為檔案
action.Rust.RsExtractEnumVariant.description=將枚舉變體提取到單獨的結構中
action.Rust.RsExtractEnumVariant.text=提取枚舉變體
action.Rust.RsExtractStructFields.choose.fields.title=選擇要提取的欄位
action.Rust.RsExtractStructFields.choose.name.dialog.invalid.name=結構名稱無效
action.Rust.RsExtractStructFields.choose.name.dialog.title=為新結構命名
action.Rust.RsExtractStructFields.command.name=正在提取結構欄位
action.Rust.RsExtractStructFields.description=將所選結構欄位提取到單獨的結構中
action.Rust.RsExtractStructFields.intention.text=提取結構欄位
action.Rust.RsExtractStructFields.text=提取結構欄位…
action.Rust.RsExtractTrait.description=從所選 `impl` 提取特徵
action.Rust.RsExtractTrait.dialog.title=提取特徵
action.Rust.RsExtractTrait.text=提取特徵…
action.Rust.RsPromoteModuleToDirectoryAction.description=將模組移至專用目錄
action.Rust.RsPromoteModuleToDirectoryAction.text=將模組提升到目錄
action.Rust.ShareInPlayground.confirmation=是否要將{0}上傳到 Rust Playground 並將其公開?
action.Rust.ShareInPlayground.confirmation.selected.text=是否要將所選文本上傳到 Rust Playground 並將其公開?
action.Rust.ShareInPlayground.description=在 Rust Playground (https\://play.rust-lang.org/)上共享程式碼
action.Rust.ShareInPlayground.notification.copy.url.text=將 URL 複製到剪貼簿
action.Rust.ShareInPlayground.notification.error=無法將程式碼共享到 Rust Playground
action.Rust.ShareInPlayground.notification.text=檔案已在 Rust Playground 中共享\: <a href\="{0}">{0}</a>
action.Rust.ShareInPlayground.notification.title=在 Rust Playground 中共享
action.Rust.ShareInPlayground.progress.title=正在將程式碼發佈到 Rust Playground…
action.Rust.ShareInPlayground.text=在 Playground 中共享
action.Rust.ShowRecursiveMacroExpansionAction.text=顯示遞迴巨集展開
action.Rust.ShowSingleStepMacroExpansionAction.text=顯示巨集展開
action.all.features.description={0}所有功能
action.all.features.text={0}所有功能
action.enable.text=開啟
action.enter.type.name.text=輸入類型名稱…
action.install.text=安裝
action.rerun.text=重新執行 `{0}`
action.run.on.fly.text=即時執行 {0}
action.run.rustup.update.text=執行 ''rustup update {0}''
action.rust.coverage.text=Rust 覆蓋率
action.show.rust.feedback.dialog.text=顯示 Rust 反饋對話框
action.show.variables.text=顯示變數
action.shows.active.console.variables.description=顯示有效主控台變數
action.stop.console.text=停止 Rust REPL
action.stop.rust.console.description=Stop Rust REPL
action.while.expr.text=while expr
action.while.text=while { }
adt.const.params=adt const params
advanced.setting.org.rust.cargo.test.tool.window=在“測試”工具視窗中顯示測試結果
advanced.setting.org.rust.cargo.test.tool.window.description=顯示結構化測試結果。由於可能存在不一致，不建議在使用 Rust 1.70.0+ 穩定工具鏈時使用。
advanced.setting.org.rust.convert.json.to.struct=在貼上時啟用 JSON 到 Rust 的轉換
advanced.setting.org.rust.external.doc.url=外部文檔的基 URL
advanced.setting.org.rust.macros.maximum.recursion.limit=巨集展開的最大遞迴限制
advanced.setting.org.rust.macros.maximum.recursion.limit.description=減小數量以防出現性能問題
advanced.setting.org.rust.show.attach.projects.dialog=Show Attach Cargo Projects dialog each time a new project is opened
advanced.setting.org.rust.show.attach.projects.dialog.on.file.opened=Show Attach Cargo Projects dialog each time an unattached file is opened
advanced.setting.rust.group=Rust
am.or.pm.in.12.hour.clocks=12 小時制的上午或下午。
am.or.pm.in.12.hour.clocks2=12 小時制的上午或下午。
and.impls=和 impl
apply.compiler.fix.command.name=套用編譯器修正
apply.compiler.fix.tooltip=套用修正
associated.type.defaults=關聯類型預設值
attach.file=將檔案附加到模組
attach.projects.dialog.dont.show.again.button=Don't Show Again
attach.projects.dialog.explanation=<html>The following Cargo.toml files are not attached to the project model.<br/>Select the files to attach\:</html>
attach.projects.dialog.ok.button=Attach Selected
attach.projects.dialog.title=Attach Cargo Projects
attribute.0=特性{0}
backtrace=反向追蹤(&T)\:
border.title.inline=內聯{0}
border.title.inline.type.alias=內聯類型別名
border.title.project.template=專案模板
box.expression.syntax=`box` 表達式語法
box.pattern.syntax=box 模式語法
build=建置
build.event.message.={0} {1}
build.event.message.cargo.project.update.failed.no.rust.toolchain=無法更新 Cargo 專案\:\nRust 工具鏈缺失
build.event.message.compiling=正在編譯
build.event.message.compiling.0=正在編譯{0}
build.event.message.fetching.cargo.config.failed=無法提取 Cargo 組態\n\n{0}
build.event.message.fetching.target.specific.cfg.options.failed.fallback.to.host.options=無法提取針對特定目標的 `cfg` 選項。請考慮回退到主機選項。\n\n{0}
build.event.message.fresh=Fresh
build.event.message.internal.compiler.error=內部編譯器錯誤\:
build.event.message.project.directory.does.not.exist.consider.detaching.project.from.cargo.tool.window=專案目錄 `{0}` 不存在。\n請考慮從 Cargo 工具視窗中分離專案 `{1}`。
build.event.message.running={0}正在執行…
build.event.title.build.scripts.evaluation=建置腳本評估
build.event.title.build.scripts.evaluation.failed=建置腳本評估失敗
build.event.title.cargo=Cargo
build.event.title.failed.to.fetch.rustc.version=無法提取 rustc 版本
build.event.title.failed.to.fetch.stdlib.package.info=無法提取 stdlib 軟體套件資訊
build.event.title.failed.to.load.stdlib.dependencies=無法載入 stdlib 相依項
build.event.title.fetching.cargo.config=正在提取 Cargo 組態檔案
build.event.title.fetching.target.specific.cfg.options=正在提取針對特定目標的 `cfg` 選項
build.event.title.run.cargo.command=執行 Cargo 指令
build.event.title.sync.project=同步 {0} 專案
c.str.literals=`c".."` 文字
c.variadic.functions=C 可變函式
cargo=Cargo
cargo.command.run.configuration=Cargo 執行組態
cargo.commandline.description=在給定目錄下組態 Gradle 專案
cargo.commands=Cargo 指令
cargo.test=cargo 測試
cargo.toml=Cargo.toml
cargo.toml.schema=Cargo.toml 架構
checkbox.async=異步
checkbox.build.on.remote.target=在遠端目標上建置
checkbox.convert.all.usages=轉換所有用法
checkbox.emulate.terminal.in.output.console=在輸出主控台中模擬終端
checkbox.enable.inspection.only.if.procedural.macros.are.enabled=只有過程巨集啟用時才執行檢查
checkbox.i.want.to.receive.rustrover.product.news=我想收到 RustRover 的產品訊息
checkbox.ignore.unresolved.references.with.possibly.high.false.positive.rate=忽略誤報率可能較高的未解析的參照
checkbox.ignore.unused.imports.in.doctests=忽略 doctest 中未使用的 import
checkbox.implicitly.add.required.features.if.possible=盡可能自動新增必選功能
checkbox.run.with.administrator.privileges=以管理員權限執行
checkbox.run.with.root.privileges=以 root 權限執行
checkbox.unsafe=非安全
checkbox.use.all.features.in.tests=啟用測試和基準的所有功能
code.vision.disable.hints.message=\n            要停用函式的提示，請使用適當的模式\:<br />\n            <b>std\:\:*</b> ? 標準庫函數<br />\n            <b>std\:\:fs\:\:*(*, *)</b> ? <i>std\:\:fs</i> 模組中接受兩個參數的函式<br />\n            <b>(*_)</b> ? 參數名稱以 <i>_</i> 結尾的單參數函式<br />\n            <b>(key, value)</b> ? 包含 <i>key</i> 和 <i>value</i> 參數的函式<br />\n            <b>*.put(key, value)</b> ? 包含 <i>key</i> 和 <i>value</i> 參數的 <i>put</i> 函式\n
coerced.type=強制類型
column.name.apply.to=應用於
column.name.covered=已覆蓋，%
column.name.file=檔案
column.name.item.or.module=條目或模組
column.name.mutable=可變
column.name.pattern=模式\:
column.name.scope=範圍
command=指令(&C)\:
command.name.choose.constant.name=選擇一個常數名稱
command.name.choose.field.name=選擇欄位名稱
command.name.choose.parameter=選擇參數
command.name.choose.struct.name=選擇結構名稱
command.name.choose.variable=選擇一個變數
command.name.converting.to.named.fields=正在將 `{0}` 轉換為命名欄位
command.name.converting.to.tuple=正在將 `{0}` 轉換為元組
command.name.extract.trait=提取特徵
command.name.extracting.variant=正在提取變體 {0}
command.name.inline=內聯{0} {1}
command.name.inline.function=內聯函式 `{0}`
command.name.inline.type.alias=內聯類型別名 `{0}`
command.name.introduce.local.variable=引入區域變數
command.name.move.items=移動條目
command.name.postfix.let.template=後綴 `let` 模板
command2=指令\:
completion.unavailable.during.index.loading=Cargo 註冊表索引載入期間補全受限
configurable.name.rust.external.linter=Rust 外部 Linter
configurable.name.rust.resolve.context=Rust 解析上下文
console.is.not.enabled=Rust REPL 已停用
const.closures=const 閉包
const.fn.trait.bound=const fn 特徵邊界
const.generics.defaults=const 泛型預設值
const.trait.impls=const 特徵 impl
constants.equal.to.1=常數等於 1
copy.paste.convert.json.to.struct.dialog.text=插入的文本似乎是 JSON 物件。是否要用它來生成 Rust 結構?
copy.paste.convert.json.to.struct.dialog.title=從 JSON 生成 Rust 結構
copy.paste.import.dialog.explanation=<html>您貼上的程式碼段引入了新的匯入。<br/>在下方選擇您要移除的任何匯入。</html>
copy.paste.import.dialog.title=選擇要移除的匯入
copy.paste.reference.notification=<html>{0} {0, choice, 1\#匯入|2\#匯入}已新增<p><span><a href\=''show''>審查…</a></span></html>
corrupted.standard.library.0=已損壞的標準庫\: {0}
crate.in.paths=路徑中的 `crate`
dangling.else=懸空 `else`
day.month.year.format.same.as.e.b.y=(8-Jul-2001)日-月-年格式。與 %e-%b-%Y 相同。
day.number.01.31.zero.padded.to.2.digits=(08)日數字(01?31)，在前面填充零，變成 2 位數。
day.of.the.year.001.366.zero.padded.to.3.digits=(189)一年中的第幾天(001?366)，在前面填充零，變成 3 位數。
dbg.usage=`\#[dbg]` 用法
default.parameter.value=預設參數值
deprecated.item=已棄用的條目
details=詳細資訊\:
dialog.create.project.custom.add.template.action.add=新增
dialog.create.project.custom.add.template.name=名稱\:
dialog.create.project.custom.add.template.title=新增自訂模板
dialog.create.project.custom.add.template.url=模板 URL\:
dialog.create.project.custom.add.template.url.description=該模板將使用 <a href\="https\://cargo-generate.github.io/cargo-generate/index.html">cargo-generate</a> 生成。您可以提供任何 GitHub 專案的鏈接。
dialog.message.can.not.generate.coverage.report=無法生成覆蓋率報告\: {0}
dialog.message.can.t.create.new.rust.file.or.attach.it.to.module.tree=無法建立新的 Rust 檔案或將其附加到模組樹
dialog.message.can.t.detect.target.process.id=無法解析目標程序 ID
dialog.message.can.t.find.binary=找不到二進制檔案
dialog.message.can.t.get.output.perf.data.file=無法定位輸出 perf.data 檔案
dialog.message.cannot.change.signature.function.in.foreign.crate=無法更改外部 crate 中函式的簽名
dialog.message.cannot.inline.constant.without.expression=無法在沒有表達式的情況下內聯常數
dialog.message.cannot.inline.empty.function=無法內聯空函式
dialog.message.cannot.inline.function.with.more.than.one.exit.points=無法內聯有多個退出點的函式
dialog.message.cannot.inline.function.with.recursive.calls=無法通過遞迴呼叫內聯函式
dialog.message.cannot.inline.multiline.function.into.while.loop.condition=無法將多行函式內聯到 `while` 迴圈條件中
dialog.message.cannot.inline.variable.without.expression=無法在沒有表達式的情況下內聯變數
dialog.message.cannot.inline.variable.without.identifier=無法內聯沒有關鍵字的變數
dialog.message.caret.should.be.positioned.at.function.or.method=文字游標應放置在函式或方法處
dialog.message.cargo.generate.needed.to.create.project.from.custom.template=要從自訂模板建立專案，請確保已安裝 cargo-generate
dialog.message.channel.cannot.be.set.explicitly.because.rustup.not.available=無法顯式設定通道，因為 rustup 不可用
dialog.message.channel.set.explicitly.with.no.rustup.available=通道 `{0}` 已顯式設定，但沒有可用的 rustup
dialog.message.debug.toolchain.not.configured=未組態偵錯工具鏈
dialog.message.default.value.entered.for.parameter.invalid=參數 {0} 的預設值無效
dialog.message.directory.already.exists=目錄 {0} 已存在
dialog.message.do.you.want.to.find.usages.base.declaration=是否要尋找基宣告的用法?
dialog.message.enter.custom.type.name.type.parameters.are.not.supported=輸入自訂類型名稱。不支持類型參數。
dialog.message.error.during.creating.new.rust.file=建立新 Rust 檔案時出錯\: {0}
dialog.message.failed.to.prepare.remote.environment=無法準備遠端環境\: {0}
dialog.message.file.not.found=找不到檔案\: {0}
dialog.message.file.will.not.be.included.in.module.tree.after.move.continue=一旦移動，該檔案將不再包含在模組樹中。要繼續嗎?
dialog.message.function.name.must.be.valid.rust.identifier=函式名稱必須是有效的 Rust 關鍵字
dialog.message.function.return.type.must.be.valid.rust.type=函式的返回值類型必須是有效的 Rust 類型
dialog.message.function.visibility.must.be.valid.visibility.specifier=函式可見性必須是有效的可見性說明符
dialog.message.gnu.debugger.cannot.be.used.with.msvc.rust.toolchain=GNU 偵錯器不能與 MSVC Rust 工具鏈一起使用
dialog.message.gnu.toolchain.not.supported.please.use.msvc.toolchain=不支持 GNU 工具鏈。請改用 MSVC 工具鏈。
dialog.message.html.body.br.b.b.body.html=<html><body>{0}{1}<br/><b>{2}</b> {3}</body></html>\n
dialog.message.html.coverage.report.has.been.successfully.saved.as.file.br.use.instruction.in.href.to.generate.html.output.html=<html>覆蓋率報告已儲存為 `{0}`。<br>按照<a href\="{1}">{2}</a>中的說明生成 HTML 輸出。</html>
dialog.message.html.local.debugger.cannot.be.used.with.wsl.br.use.href.https.www.jetbrains.com.help.clion.how.to.use.wsl.development.environment.in.product.html.instructions.to.configure.wsl.toolchain.html=<html>本地偵錯器不能與 WSL 一起使用。<br>請遵循 <a href\="https\://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-product.html">CLion 文檔中的說明</a>組態 WSL。</html>
dialog.message.illegal.path=非法路徑\: {0}
dialog.message.input.file.doesn.t.exist=輸入檔案不存在
dialog.message.input.file.not.valid=輸入檔案無效
dialog.message.internal.error.can.t.find.process.starter=內部錯誤\: 找不到程序啟動器
dialog.message.invalid.identifier=無效關鍵字
dialog.message.invalid.toolchain=無效的工具鏈\: {0}
dialog.message.more.than.one.binary.was.produced.please.specify.bin.lib.test.or.example.flag.explicitly=產生了多個二進制檔案。請指定 `--bin`、`--lib`、`--test` 或 `--example` 標誌。
dialog.message.msvc.debugger.cannot.be.used.with.gnu.rust.toolchain=MSVC 偵錯器不能與 GNU Rust 工具鏈一起使用
dialog.message.msvc.toolchain.not.supported.please.use.gnu.toolchain=不支持 MSVC 工具鏈。請改用 GNU 工具鏈。
dialog.message.name.cannot.be.used.as.crate.name=`{0}` 不能用作 crate 名稱
dialog.message.name.cannot.be.used.as.crate.name2=`{0}` 不能用作 crate 名稱
dialog.message.name.reserved.windows.filename=檔名 `{0}` 由 Windows 保留
dialog.message.no.command.specified=未指定指令
dialog.message.no.rust.toolchain.specified=未指定 Rust 工具鏈
dialog.message.no.suitable.function.to.extract.parameter.found=找不到封閉函式
dialog.message.no.working.directory.specified=工作目錄無效
dialog.message.package.name.can.t.be.empty=軟體套件名稱不能為空
dialog.message.package.names.should.contain.only.letters.digits=軟體套件名稱只能包含字母、數字、連字元(`-`)和下劃線(`_`)
dialog.message.package.names.starting.with.digit.cannot.be.used.as.crate.name=軟體套件名稱不能以數字開頭
dialog.message.parameter.has.invalid.pattern=參數 {0} 具有無效模式
dialog.message.perf.profiler.not.available.for.selected.toolchain=Perf 分析器不能與所選工具鏈一起使用
dialog.message.perf.profiler.not.available.for.selected.wsl.distribution.try.updating.wsl.to.newer.one=Perf 分析器不能與所選 WSL 分發版一起使用。請嘗試更新 WSL。
dialog.message.please.choose.target.directory.different.from.current=目標目錄不能與當前目錄相同
dialog.message.please.enter.type.for.parameter=指定參數 {0} 的類型
dialog.message.profiler.connection.error.can.t.detect.target.process.id=連線到分析器時出錯\: 無法解析目標程序 ID
dialog.message.run.targets.cannot.be.used.alongside.with.wsl.toolchain=“執行目標”功能與 WSL 工具鏈不相容
dialog.message.rust.toolchain.is.not.set=未組態 Rust 工具鏈
dialog.message.target.file.must.be.rust.file=目標檔案必須是 Rust 檔案
dialog.message.this.cargo.package.already.part.attached.workspace=此 Cargo 軟體套件已是附加工作區的一部分
dialog.message.type.entered.for.parameter.invalid=為參數 {0} 輸入的類型無效
dialog.message.wsl.debugger.cannot.be.used.with.non.wsl.rust.toolchain=WSL 偵錯器不能與非 WSL Rust 工具鏈一起使用
dialog.message.wsl.toolchain.not.supported=不支持 WSL 工具鏈
dialog.title.choose.destination.file=選擇目標檔案
dialog.title.convert.to.named.fields.settings=轉換為命名欄位
dialog.title.convert.to.tuple=轉換為元組
dialog.title.coverage.report.generation=覆蓋率報告生成
dialog.title.download.debugger=下載偵錯器
dialog.title.enter.type.name=輸入類型名稱
dialog.title.extract.function=提取函式
dialog.title.find.usages=尋找用法
dialog.title.implement.members=實作成員
dialog.title.installing.cargo.generate=正在安裝 cargo-generate
dialog.title.move=移動
dialog.title.move.module.items=移動模組條目
dialog.title.move.rust=移動(Rust)
dialog.title.new.cargo.crate=新增 Cargo Crate
dialog.title.select.cargo.toml=附加 Cargo.toml
dialog.title.select.module=選擇模組
dialog.title.unable.to.attach.cargo.project=無法附加 Cargo 專案
dialog.title.unable.to.build=建置失敗
dialog.title.unable.to.run.debugger=無法執行偵錯器
dialog.title.unable.to.run.profiler=無法執行分析器
dialog.title.unable.to.run.valgrind=無法執行 Valgrind
disable=停用
disabling.the.test.tool.window=停用“測試”工具視窗
discriminant.on.a.non.unit.variant=判別式位於非單元變體上
documentation.raw.byte.string.literals.def=<h3>原始位元組字串文字</h3>
documentation.raw.byte.string.literals.p1=<p>原始字串文字不處理任何轉義。它們以字元 <code class\="hljs">U+0062</code> (<code class\="hljs">b</code>)開頭，後跟 <code class\="hljs">U+0072</code> (<code class\="hljs">r</code>)，後跟少於 256 個字元 <code class\="hljs">U+0023</code> (<code class\="hljs">\#</code>)和一個 <code class\="hljs">U+0022</code> (雙引號)字元。<em>原始字串主體</em>可以包含任何 ASCII 字元序列，並且只能以另一個 <code class\="hljs">U+0022</code> (雙引號)字元結尾，後跟位於左 <code class\="hljs">U+0022</code> (雙引號)字元之前的相同數量的 <code class\="hljs">U+0023</code> (<code class\="hljs">\#</code>)字元。原始位元組字串文字不能包含任何非 ASCII 位元組。</p>
documentation.raw.byte.string.literals.p2=<p>原始字串主體中包含的所有字元都表示其 ASCII 編碼。字元 <code class\="hljs">U+0022</code> (雙引號) (除非後跟至少與用於開始原始字串文字一樣多的 <code class\="hljs">U+0023</code> (<code class\="hljs">\#</code>)字元)或 <code class\="hljs">U+005C</code> (<code class\="hljs"></code>)沒有任何特殊含義。</p>
documentation.raw.byte.string.literals.p3=<p>位元組字串文字範例\:</p>
documentation.raw.string.literals.def=<h3>原始字串文字</h3>
documentation.raw.string.literals.p1=<p>原始字串文字不處理任何轉義。它們以字元 <code>U+0072</code> (<code>r</code>)開頭，後跟少於 256 個字元 <code>U+0023</code> (<code>\#</code>)和一個 <code>U+0022</code> (雙引號)字元。<em>原始字串主體</em>可以包含任何 Unicode 字元序列，並且只能以另一個 <code>U+0022</code> (雙引號)字元結尾，後跟位於左 <code>U+0022</code> (雙引號)字元之前的相同數量的 <code>U+0023</code> (<code>\#</code>)字元</p>
documentation.raw.string.literals.p2=<p>原始字串主體中包含的所有 Unicode 字元都表示其自身。字元 <code>U+0022</code> (雙引號) (除非後跟至少與用於開始原始字串文字一樣多的 <code>U+0023</code> (<code>\#</code>)字元)或 <code>U+005C</code> (<code></code>)沒有任何特殊含義。</p>
documentation.raw.string.literals.p3=<p>字串文字範例\:</p>
don.t.show.again=不再顯示
double.negation=雙重求反
download.failed.0=下載失敗\: {0}
drop.reference=丟棄參照
duplicated.trait.method.parameter.binding=重複的特徵方法參數綁定
dyn.keyword=`dyn` 關鍵字
empty.0=空 `{0}`
enum=enum
error.message.struct.inheritance.is.not.supported=Rust 不支持結構繼承
exclusive.range.patterns=獨佔範圍模式
expected.0.found.1=應為 `{0}`，但實際為 `{1}`
explain.move.highlights.code.elements.that.resulted.in.this.error=Highlights code elements that resulted in this error.
explain.move.value.moved.here=Value{0, choice, 0\#|1\# partially} moved{1, choice, 0\#|1\# into closure} here{2, choice, 0\#|1\# by the macro call} {3, choice, 0\#|1\#, in the previous iteration of loop}
explain.move.was.moved={0} was moved
extern.crate.self=extern crate self
extern.types=extern 類型
external.linter=外部 Linter
failed.to.get.project.sysroot=無法提取專案 sysroot
failed.to.run.cargo=無法執行 Cargo
feature.0=功能{0}
feedback.notification.thanks.feedback.content=您正在幫助改進 RustRover\!
feedback.user.dialog.cancel.label=不，謝謝
feedback.user.dialog.description=您開始使用 RustRover 已經有一段時間了。我們很想聽聽您的經驗！
feedback.user.dialog.like_most.label=您最喜歡 RustRover 的哪些方面？
feedback.user.dialog.ok.label=發送反饋
feedback.user.dialog.problems.label=請告訴我們任何問題或缺失的功能
feedback.user.dialog.satisfaction.label=您總體上是否對 RustRover 感到滿意？
feedback.user.dialog.title=分享關於 RustRover 的反饋
feedback.user.dialog.top.title=反饋
fetching.actual.stdlib.info.failed.hardcoded.stdlib.structure.will.be.used=無法提取最新的 stdlib 資訊。將改用硬編碼的 stdlib 結構。
file=檔案
fn.0=fn {0}
from=從\:
full.month.name.july=(July)月份的完整名稱。
full.weekday.name.sunday=(Sunday)星期的完整名稱。
function=函式
gen.syntax=`gen` 語法
generic.associated.types=泛型關聯類型
go.to.class.kind.text=類型
go.to.class.kind.text.pluralized=類型
group.Rust.MacroExpansionActions.text=顯示巨集展開
group.Rust.Tools.text=Rust
gutter.rust.generated.typescript.declarations.name=生成的 TypeScript 宣告
gutter.rust.generated.typescript.declarations.popup.title=生成的宣告
gutter.rust.generated.typescript.declarations.tooltip=轉到生成的宣告
gutter.rust.implemented.item.name=Implemented item
gutter.rust.implemented.item.tooltip=具有實作
gutter.rust.implementing.item=實作條目
gutter.rust.open.documentation.for=開啟 `{0}` 的文檔
gutter.rust.open.documentation.name=開啟文檔
gutter.rust.open.documentation.toml.name=開啟文檔(TOML)
gutter.rust.overriding.item=覆寫條目
gutter.rust.recursive.call.name=遞迴呼叫
half.open.range.patterns=半開範圍模式
has.0.occurrences=有 {0} 個匹配項
has.1.occurrence=有 1 個匹配項
highlighter.action.text.go.to.implementations=轉到實作
highlighter.name.implementations=實作
hint.text.crates.local.index.not.ready.yet=crate 本地索引尚未準備就緒
hint.text.no.members.to.implement.have.been.found=沒有要實作的成員
hint.text.please.convert.innermost.impl.trait.first=請先轉換最裡面的 `impl Trait`
hint.text.select.expression=選擇表達式
hint.text.some.elements.that.action.going.to.change.exist.only.in.macro.expansion.so.cannot.be.changed.by.action=某些要更改的元素僅存在於巨集展開中，且無法通過此動作更改
hour.minute.format.same.as.h.m=(00\:34)小時-分鐘格式。與 %H\:%M 相同。
hour.minute.second.format.in.12.hour.clocks.same.as.i.m.s.p=(12\:34\:60 AM)12 小時制的小時-分鐘-秒格式。與 %I\:%M\:%S %p 相同。
hour.minute.second.format.same.as.h.m.s=(00\:34\:60)小時-分鐘-秒格式。與 %H\:%M\:%S 相同。
hour.number.00.23.zero.padded.to.2.digits=(00)小時數字(00?23)，在前面填充零，變成 2 位數。
hour.number.in.12.hour.clocks.01.12.zero.padded.to.2.digits=(12) 12 小時制小時數字(01?12)，在前面填充零，變成 2 位數。
html.head.0.style.body.background.1.text.align.center.style.head.body.2.body.html=\n        <html>\n        <head>\n            {0}\n            <style>body `{`background\: \#{1}; text-align\: center; `}`</style>\n        </head>\n        <body>\n            {2}\n        </body>\n        </html>\n
if.let.guard=`if let` guard
impl.keyword=`impl` 關鍵字
inherent.associated.types=固有關聯類型
inline.const=inline const
inline.const.pat=inline const pat
inspection.DoubleMustUse.FixRemoveMustUseAttr.name=從函式中移除 `\#[must_use]`
inspection.DoubleMustUse.description=此函式具有 `\#[must_use]` 特性，但返回已標記為 `\#[must_use]` 的類型
inspection.PathStatementsInspection.description.drops.value=路徑語句丟棄值
inspection.PathStatementsInspection.description.no.effect=路徑語句不起任何作用
inspection.RedundantSemicolons.description.multiple=不必要的尾隨分號
inspection.RedundantSemicolons.description.single=不必要的尾隨分號
inspection.RedundantSemicolons.fix.name=移除不必要的尾隨分號
inspection.UnusedLabels.description=未使用的標籤
inspection.UnusedMustUse.AddAwaitFix.name=新增 `.await`
inspection.UnusedMustUse.FixAddExpect.family.name=新增 `.expect("")`
inspection.UnusedMustUse.FixAddLetUnderscore.name=新增 `let _ \=`
inspection.UnusedMustUse.FixAddUnwrap.name=新增 `.unwrap()`
inspection.UnusedMustUse.description.function.attribute=必須使用但未使用的 `{0}` 返回值
inspection.UnusedMustUse.description.type.attribute=必須使用但未使用的{0}
inspection.can.be.replaced.with.local.stable.method=`with` 呼叫可被取代為執行緒區域穩定方法
inspection.cargo.toml.cyclic.feature.display.name=迴圈功能相依關係
inspection.crate.not.found.display.name=找不到 crate
inspection.crate.version.invalid.display.name=crate 版本無效
inspection.duplicated.key.display.name=重複鍵
inspection.message.={0}\: {1}
inspection.message.0.1.2.and.other.fields=`{0}`、`{1}`、`{2}` 和其他 {3} 個{4, choice, 0\#欄位|1\#欄位}
inspection.message.0.1.and.2=`{0}`、`{1}` 和 `{2}`
inspection.message.0.and.1=`{0}` 和 `{1}`
inspection.message.a.field.type.must.be.specified=Field type is required
inspection.message.access.field.on.primitive.type=`{0}` cannot have fields as it is a primitive type
inspection.message.access.nonexistent.field=類型 `{1}` 中沒有欄位 `{0}`
inspection.message.access.to.union.field.unsafe.requires.unsafe.function.or.block=只允許在 `unsafe` 塊或函式內部進行聯合欄位存取
inspection.message.align.argument.must.be.power.two=`align` 實參必須是 2 的冪
inspection.message.align.argument.must.be.unsuffixed.integer=傳遞至 `align` 的實參必須是無後綴的整數
inspection.message.align.argument.must.not.be.larger.than=傳遞至 `align` 的實參不能超過 2^29
inspection.message.align.needs.argument=`align` 修飾符需要一個實參
inspection.message.align.takes.exactly.one.argument.in.parentheses=`align` 修飾符需要一個括在圓括號中的實參
inspection.message.all.versions.matching.for.crate.are.yanked=與 crate `{1}` 的 {0} 符合的所有版本均被移除
inspection.message.anonymous.functions.parameters.are.deprecated.rfc=匿名函式參數已棄用(RFC 1685)
inspection.message.approximate.value.found.consider.using.it.directly=找到了 `{0}` 的近似值
inspection.message.are.not.allowed.inside=不允許在{2}內使用 `{0}`
inspection.message.argument.never.used=實參從未使用
inspection.message.array.index.out.of.bounds=索引超出界限\: 陣列長度為 {0}，但索引為 {1}
inspection.message.array.size.cannot.refer.to.static=static `{0}` 不能用作陣列大小
inspection.message.assert.b.can.be.b=`assert\!(a {0} b)` 可被取代為 `{1}\!(a, b)`
inspection.message.associated.type.not.found.for=找不到 `{1}` 的關聯類型 `{0}`
inspection.message.async.non.move.closures.with.parameters.are.currently.not.supported=目前不支持帶參數的 `async` 非 `move` 閉包
inspection.message.at.least.one.trait.required.for.object.type=物件類型至少需要一個特徵
inspection.message.attribute.should.be.applied.to.enum=`{0}` 特性只能應用於枚舉
inspection.message.attribute.should.be.applied.to.function.or.closure=特性只能應用於函式或閉包
inspection.message.attribute.should.be.applied.to.struct.enum.or.union=`{0}` 特性只能應用於結構、枚舉或聯合
inspection.message.attribute.should.be.applied.to.struct.or.union=`{0}` 特性只能應用於結構或聯合
inspection.message.attributes.on.function.parameters.experimental=`attributes on function parameters` 是實驗性功能
inspection.message.await.only.allowed.inside.async.functions.blocks=只允許在 `async` 函式和塊內使用 `await`
inspection.message.binary.assignment.operation.cannot.be.applied.to.type=二元賦值運算 `{0}` 不能應用於類型 `{1}`
inspection.message.binary.operation.cannot.be.applied.to.type=二元運算 `{0}` 不能應用於類型 `{1}`
inspection.message.binding.never.used=綁定 `{0}` 從未使用
inspection.message.boolean.expression.can.be.simplified=布爾表達式可以簡化
inspection.message.bounds.on.have.no.effect={0} 上的邊界不起任何作用
inspection.message.break.with.value.from.loop=`break` with a value is not allowed in `{0}` loops
inspection.message.c.variadic.function.must.have.compatible.calling.convention.like.c.or.cdecl=C 可變函式應使用相容的呼叫約定，例如 `C` 或 `cdecl`
inspection.message.call.to.std.mem.drop.with.reference.argument.dropping.reference.does.nothing=使用參照實參呼叫 std\:\:mem\:\:drop 不起任何作用
inspection.message.call.to.unsafe.function=呼叫非安全函式
inspection.message.call.to.unsafe.function.requires.unsafe.function.or.block=只允許在 `unsafe` 塊或函式內呼叫非安全函式
inspection.message.calls.in.constants.are.limited.to.constant.functions.tuple.structs.tuple.variants=常數表達式只能包含常數函式、元組結構和元組變體
inspection.message.can.be.replaced.with=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.literal.suffix=可被取代為文字後綴
inspection.message.can.be.replaced.with.random=可被取代為 `random{0}()`
inspection.message.can.impl.only.struct.s.enum.s.union.s.trait.objects=只能為結構、枚舉、聯合和特徵物件新增固有 `impl` 塊
inspection.message.can.t.capture.dynamic.environment.in.fn.item=無法捕獲 `fn` 條目中的動態環境
inspection.message.can.t.find.crate.for=找不到 crate `{0}`
inspection.message.cannot.add.to=無法將 `{0}` 新增到 `{1}`
inspection.message.cannot.apply.unary.operator.to.type=無法將一元運算符 `{0}` 應用於類型 `{1}`
inspection.message.cannot.assign.to=無法將新值賦給 `{0}`
inspection.message.cannot.assign.twice.to.immutable.variable=無法多次將新值賦給不可變變數
inspection.message.cannot.be.declared.unsafe=不能將 `{0}` 宣告為 unsafe
inspection.message.cannot.be.used.in.closures.only.inside.loop.while.blocks=`{0}` 不能在閉包中使用，只能在 `loop` 和 `while` 塊中使用
inspection.message.cannot.be.variadic=`{0}` 不能是可變的
inspection.message.cannot.borrow.immutable.local.variable.as.mutable=無法借用不可變區域變數 `{0}` 作為可變變數
inspection.message.cannot.cast.as.bool=無法轉換為 `bool`
inspection.message.cannot.cast.from.pointer.unknown.kind=無法轉換未知類型的指針
inspection.message.cannot.cast.thin.pointer.to.fat.pointer=無法將瘦指針 `{0}` 轉換為胖指針 `{1}`
inspection.message.cannot.cast.to.pointer.that.may.be.wide=無法將 `{0}` 轉換為可能較寬的指針
inspection.message.cannot.cast.to.pointer.that.wide=無法將 `{0}` 轉換為較寬的指針
inspection.message.cannot.cast.to.pointer.unknown.kind=無法轉換為未知類型的指針
inspection.message.cannot.declare.non.inline.module.inside.block.unless.it.has.path.attribute=不能在塊內宣告非內聯模組，除非它具有路徑特性
inspection.message.cannot.define.inherent.impl.for.dyn.auto.trait=無法為動態自動特徵定義固有 `impl`
inspection.message.cannot.define.inherent.impl.for.type.outside.crate.where.type.defined=無法為其包含 crate 之外的類型定義固有 `impl`
inspection.message.cannot.divide.by=無法將 `{0}` 除以 `{1}`
inspection.message.cannot.have.anonymous.parameters=`{0}` 不能有匿名參數
inspection.message.cannot.have.body=`{0}` 不能有主體
inspection.message.cannot.have.const.qualifier=`{0}` 不能有 `const` 限定符
inspection.message.cannot.have.default.qualifier=`{0}` 不能有 `default` 限定符
inspection.message.cannot.have.extern.abi=`{0}` 不能有 extern ABI
inspection.message.cannot.have.generic.parameters=`{0}` 不能有泛型參數
inspection.message.cannot.have.pub.qualifier=`{0}` 不能有 `pub` 限定符
inspection.message.cannot.have.self.parameter=`{0}` 不能有 `self` 參數
inspection.message.cannot.have.unsafe.qualifier=`{0}` 不能有 `unsafe` 限定符
inspection.message.cannot.have.where.clause=`{0}` 不能有 `where` 子句
inspection.message.cannot.have.where.clause.after.type=`{0}` 在類型後面不能有 `where` 子句
inspection.message.cannot.have.where.clause.before.type=`{0}` 在類型前面不能有 `where` 子句
inspection.message.cannot.implement.both.copy.drop=Both `Copy` and `Drop` cannot be implemented simultaneously
inspection.message.cannot.mod.by=無法將 `{0}` 以 `{1}` 為模
inspection.message.cannot.move=無法移動
inspection.message.cannot.multiply.by=無法將 `{0}` 乘以 `{1}`
inspection.message.cannot.subtract.from=無法從 `{1}` 中減去 `{0}`
inspection.message.cast.to.unsized.type.as=轉換為 unsized 類型\: `{0}` 轉換為 `{1}`
inspection.message.casting.as.invalid=將 `{0}` 轉換為 `{1}` 無效
inspection.message.cfg.predicate.cannot.be.a.literal=謂詞鍵必須是文字
inspection.message.cfg.predicate.is.not.specified=缺少謂詞
inspection.message.cfg.predicate.must.be.identifier=謂詞鍵必須是關鍵字
inspection.message.chained.comparison.operator.require.parentheses=鏈式比較運算符需要圓括號
inspection.message.condition.always=條件始終為 {0}
inspection.message.const=const
inspection.message.const.cannot.refer.to.static=const `{0}` 不能參照 static `{1}`
inspection.message.const.generic.argument.cannot.refer.to.static=const 泛型實參不能參照 static `{0}`
inspection.message.const2=const
inspection.message.constant=常數 `{0}`
inspection.message.constant.function.cannot.refer.to.static=常數函式 `{0}` 不能參照 static `{1}`
inspection.message.consts={0}\:\:{1}\:\:consts\:\:{2}
inspection.message.continue.pointing.to.labeled.block=`Continue` 指向帶標籤的塊
inspection.message.crate.in.paths.can.only.be.used.in.start.position=路徑中的 `crate` 只能在起始位置使用
inspection.message.crate.name.can.only.contain.unicode.alphanumeric.or.underscore.empty.found=crate 名稱只能包含 Unicode 字母數字或 `_` 字元
inspection.message.crate.name.cannot.be.empty.found=crate 名稱不能為空
inspection.message.crate.not.found=找不到 crate `{0}`
inspection.message.cyclic.feature.dependency.feature.depends.on.itself=迴圈功能相依關係\: 功能 `{0}` 依賴於自身
inspection.message.default.cannot.have.pub.qualifier=預設 `{0}` 不能有 `pub` 限定符
inspection.message.default.parameter.values.are.not.supported.in.rust=Rust 不支持預設參數值
inspection.message.defaults.for.const.parameters.are.only.allowed.in.struct.enum.type.or.trait.definitions=const 參數的預設值只允許在結構、枚舉、類型和特徵定義中使用
inspection.message.defaults.for.type.parameters.are.only.allowed.in.struct.enum.type.or.trait.definitions=類型參數的預設值只允許在結構、枚舉、類型和特徵定義中使用
inspection.message.denote.infinite.loops.with.loop=使用 `loop { ... }` 表示無限迴圈
inspection.message.dereference.raw.pointer.requires.unsafe.function.or.block=只允許在 `unsafe` 塊或函式內取消參照原始指針
inspection.message.derive.may.only.be.applied.to.structs.enums.unions=`derive` 只能應用於結構、枚舉和聯合
inspection.message.different.impl.member.order.from.trait=`impl` 成員的順序與特徵不同
inspection.message.direct.implementation.of.to.string=`ToString` 不應直接實作
inspection.message.discriminant.value.already.exists=判別值 `{0}` 已存在
inspection.message.doesn.t.derive.both.partialeq.eq=`{0}` 無法同時派生 `PartialEq` 和 `Eq`
inspection.message.doesn.t.implement.required.by=`{0}` 不實現 `{1}` (`{2}` 需要)
inspection.message.drop.can.be.only.implemented.by.structs.enums=`Drop` can only be implemented for structs and enums
inspection.message.duplicate.definitions.with.name=重複的定義 `{0}`
inspection.message.duplicate.field=重複欄位
inspection.message.duplicate.key=重複的雜湊鍵
inspection.message.duplicate.macro.pattern=重複的巨集模式
inspection.message.duplicated.parameter.name.consider.renaming.it=重複的參數名稱 `{0}`
inspection.message.enum.variant=枚舉變體
inspection.message.enum.variant.expected=應為枚舉變體
inspection.message.enum.variant.s.discriminant.value.cannot.refer.to.static=`{0}` 枚舉變體的判別值不能參照 static `{1}`
inspection.message.enum.with.no.variants.can.t.have.repr.attribute=沒有變體的枚舉不能有 `repr` 特性
inspection.message.expected.cfg.pattern=應為一個 cfg 模式
inspection.message.expected.function.found=應為函式，但實際為 `{0}`
inspection.message.expected.path.to.trait.found.literal=Expected path to a trait but found literal
inspection.message.expected.trait.bound.found.impl.trait.type=應為特徵邊界，但實際為 `impl Trait` 類型
inspection.message.expected.trait.found=應為特徵，但實際為{0} `{1}`
inspection.message.experimental.can.be.added=功能 `{0}` 不穩定，當前未啟用
inspection.message.experimental.not.available=功能 `{0}` 在當前 Rust 工具鏈中不可用
inspection.message.explicit.calls.to.drop.are.forbidden.use.std.mem.drop.instead=禁止顯式呼叫 `drop`。請改用 `std\:\:mem\:\:drop`。
inspection.message.explicit.impls.for.sized.trait.are.not.permitted=不允許為 `Sized` 特徵使用顯式 impl
inspection.message.explicit.impls.for.unsize.trait.are.not.permitted=不允許為 `Unsize` 特徵使用顯式 impl
inspection.message.explicit.lifetimes.given.in.parameter.types.where.they.could.be.elided=參數類型包含可以省略的顯式生命周期
inspection.message.expression.can.be.simplified=表達式可以簡化
inspection.message.expressions.must.be.enclosed.in.braces.to.be.used.as.const.generic.arguments=要將表達式用作 const 泛型實參，請將其括在大括號中
inspection.message.extern=extern
inspection.message.extern.crate.self.requires.as.name=`extern crate self` 需要 `as name`
inspection.message.extra.field.found.in.pattern={0} `{1}` 不包含欄位 `{2}`
inspection.message.extra.fields.found.in.tuple.struct.pattern.expected.found=在元組結構模式中找到了額外欄位\: 應為 {0} 個，但實際為 {1} 個
inspection.message.failed.to.resolve.could.not.find=在 `{1}` 中找不到 `{0}`
inspection.message.failed.to.resolve.use.undeclared.crate.or.module=使用未宣告的 crate 或模組 `{0}`
inspection.message.failed.to.resolve.use.undeclared.type=使用未宣告的類型 `{0}`
inspection.message.feature.has.been.removed=功能 `{0}` 已被移除
inspection.message.feature.may.not.be.used.on.release.channel=`\#\![feature]` 無法在{0}發佈通道上使用
inspection.message.field.already.declared=欄位 `{0}` 已宣告
inspection.message.field.bound.multiple.times.in.pattern=欄位 `{0}` 在模式中被多次綁定
inspection.message.field.struct.private=結構 `{1}` 中的欄位 `{0}` 為 private
inspection.message.file.not.found.for.module=找不到模組 `{0}` 的檔案
inspection.message.file.not.included.in.module.tree.analysis.not.available=缺少模組宣告。這可能會影響智能編輯功能和自動補全。
inspection.message.for.loop.expression.has.unnecessary.parentheses=`for` 迴圈表達式有不必要的圓括號
inspection.message.foreign.items.may.not.have.parameters=外部條目不能有{0}參數
inspection.message.format.call.without.format.parameters=不帶格式參數的 `format\!` 呼叫
inspection.message.formatting.is.supported.only.for.tuples.up.to.12.elements=只能格式化最多包含 12 個元素的元組。
inspection.message.from.trait=`{0}` (來自特徵 `{1}`)
inspection.message.function.returns.instead=函式返回 `()` 而不是 `{0}`
inspection.message.functions.with.start.attribute.must.have=使用 `\#[start]` 特性標記的函式必須具有 {0}
inspection.message.functions.with.start.attribute.must.return.isize=使用 `\#[start]` 特性標記的函式必須返回 `isize`
inspection.message.generic.arguments.must.come.before.first.constraint=泛型實參必須在第一個約束之前指定
inspection.message.generic.default.param.cannot.use.forward.declared.identifiers=Generic parameters with a default value cannot use forward-declared identifiers
inspection.message.generic.parameter.expected=應為泛型參數
inspection.message.has.been.removed=`{0}` 已被移除
inspection.message.has.been.removed2={0} has been removed
inspection.message.has.but.its.trait.declaration.has={0} `{1}` 具有 {2} 個{3}，但其特徵宣告具有 {4} 個{5}
inspection.message.identifier.bound.more.than.once.in.same.pattern=關鍵字 `{0}` 在同一模式中被多次綁定
inspection.message.identifier.bound.more.than.once.in.this.parameter.list=關鍵字 `{0}` 在此參數列表中被多次綁定
inspection.message.impl.trait.not.allowed.in.path.parameters=不允許在路徑參數中使用 `impl Trait`
inspection.message.impl.trait.not.allowed.outside.function.inherent.method.return.types=不允許在函式或固有方法返回值類型之外使用 `impl Trait`
inspection.message.implementing.trait.not.unsafe=實作特徵 `{0}` 是安全的
inspection.message.in.expressions.can.only.be.used.on.left.hand.side.assignment=在表達式中，`_` 只能用在賦值的左側
inspection.message.in.this.pattern.redundant=此模式中的 `{0}\:` 是冗餘的
inspection.message.inclusive.ranges.must.be.bounded.at.end.b.or.b=包含範圍必須有指定的結束邊界(`..\=b` or `a..\=b`)
inspection.message.incorrect.meta.item=Invalid meta item
inspection.message.incorrect.repr.align.attribute.format=`\#[repr(align())]` 特性格式不正確
inspection.message.incorrect.visibility.restriction=可見性限制不正確
inspection.message.inherent.impls.cannot.be.unsafe=固有 impl 不得為 unsafe
inspection.message.invalid.abi.found=無效的 ABI\: {0}
inspection.message.invalid.crate.type.value=`crate_type` 值無效
inspection.message.invalid.dyn.keyword=`dyn` 關鍵字無效
inspection.message.invalid.format.string=格式字串無效
inspection.message.invalid.format.string.expected.if.you.intended.to.print.symbol.you.can.escape.it.using=無效的格式字串\: 應為 `}`。\n如果您打算列印 `{` 符號，請使用轉義序列\: `{{`。
inspection.message.invalid.format.string.unmatched=格式字串無效\: 不符合的 `}`
inspection.message.invalid.json.schema.format=Value format should be `{0}`
inspection.message.invalid.label.name=標籤名稱 `{0}` 無效
inspection.message.invalid.path.self.super.are.allowed.only.at.beginning=無效的路徑\: `self` 和 `super` 只能出現在路徑的開頭
inspection.message.invalid.predicate=謂詞 `{0}` 無效
inspection.message.invalid.reference.to.positional.argument=對位置實參 {0} 的參照無效({1})
inspection.message.invalid.suffix.for.suffix.must.be.one=`{1}` 的後綴 `{0}` 無效。後綴必須為其中之一\: {2}。
inspection.message.invalid.version.requirement=版本要求 `{0}` 無效
inspection.message.invoking.drop.with.copy.type=使用實作 `Copy` 的值呼叫 `std\:\:mem\:\:drop` 不起任何作用
inspection.message.it.not.allowed.to.cast.to.bool=無法轉換為布爾
inspection.message.item.associated.which.doesn.t.match.its.trait=`{0}` 是關聯{1}，與特徵 `{2}` 的定義相矛盾
inspection.message.item.expected=應為條目
inspection.message.let.expressions.are.not.supported.here=此處不能使用 `let` 表達式
inspection.message.let.expressions.in.this.position.are.unstable=此位置的 `let` 表達式不穩定
inspection.message.lifetime.name.declared.twice.in.same.scope=生命周期名稱 `{0}` 在同一作用域內宣告了兩次
inspection.message.lifetime.without.specified.name=未指定名稱的生命周期
inspection.message.lifetimes.cannot.use.keyword.names=生命周期不能使用關鍵字名稱
inspection.message.literal.out.of.range=文字 `{0}` 不適合類型 `{1}`
inspection.message.macro.reference.unexpected=`{1}` 類型的意外元素 `{0}`
inspection.message.main.function.not.allowed.to.have.generic.parameters=`main` 函式不能有泛型參數
inspection.message.main.function.not.found.in.crate=在 crate `{0}` 中找不到 `main` 函式
inspection.message.main.is.async=`{0}` 函式不能為 `async`
inspection.message.malformed.attribute.input=`{0}` 特性輸入格式錯誤
inspection.message.malformed.attribute.input.missing.parentheses=`{0}` 特性輸入格式錯誤\: 缺少圓括號
inspection.message.manual.implementations.are.experimental=`{0}` 的手動實作為實驗性
inspection.message.match.expr.can.be.replaced.with.method.call=match 表達式可被取代為方法呼叫
inspection.message.match.expression.has.unnecessary.parentheses=`match` 表達式具有不必要的圓括號
inspection.message.match.must.be.exhaustive=`match` 表達式並未涵蓋所有可能的情況
inspection.message.may.only.be.used.inside.loop.while.blocks=`{0}` 只能在 `loop` 和 `while` 塊內使用
inspection.message.method=方法
inspection.message.method.has.but.declaration.in.trait.has=方法 `{0}` 具有 {1} 個{2}，但特征 `{3}` 中的宣告具有 {4} 個
inspection.message.method.has.declaration.in.impl.but.not.in.trait=方法 `{0}` 在 `impl` 中具有 `{1}` 宣告，但在特徵中沒有
inspection.message.method.has.declaration.in.trait.but.not.in.impl=方法 `{0}` 在特徵中具有 `{1}` 宣告，但在 `impl` 中沒有
inspection.message.methods.called.usually.take.consider.choosing.less.ambiguous.name=名為 `{0}*{1}` 的方法通常接受{2}。考慮選擇一個更明確的名稱。
inspection.message.mismatched.types=類型不符合
inspection.message.missing.features=缺少功能\: {0}
inspection.message.missing.fields.in.initializer.of=`{2}` 初始設定式中缺少{0, choice, 0\#欄位|1\#欄位}\: {1}
inspection.message.missing.lifetime.specifier=缺少生命周期說明符
inspection.message.missing.type.for.item=缺少 `{0}` 的類型
inspection.message.multiple.attributes=多個 `{0}` 特性
inspection.message.multiple.bounds.can.be.applied.with.plus=可以使用 `+` 套用多個邊界
inspection.message.multiple.cfg.predicates.are.specified=不允許多個謂詞
inspection.message.multiple.default.variants=Multiple defaults declared
inspection.message.multiple.items=多個 `{0}` 條目
inspection.message.multiple.patterns.in.if.let.while.let.are.unstable=`if let` 和 `while let` 中的多個模式不穩定
inspection.message.must.be.declared.prior.to=`{0} {1}` 必須在 `{2} {3}` 之前宣告
inspection.message.must.be.last.in.argument.list.for.variadic.function=`...` 必須為可變函式的最後一個實參
inspection.message.must.have.body=`{0}` 必須具有主體
inspection.message.must.have.value=`{0}` 必須有一個值
inspection.message.mutable=可變
inspection.message.name.already.used.for.generic.parameter.in.this.item.s.generic.parameters=名稱 `{0}` 已在此條目中用作泛型參數
inspection.message.name.defined.multiple.times=`{0}` 被多次定義
inspection.message.named.argument.never.used=命名實參從未使用
inspection.message.named.field.expected=應為命名欄位
inspection.message.negative.implementations.are.not.unsafe=否定實作並非 unsafe
inspection.message.nested.impl.trait.not.allowed=不允許使用嵌套 `impl Trait`
inspection.message.nested.quantification.lifetimes=生命周期的嵌套量化
inspection.message.newer.version.available.for.crate=有較新版本的 crate `{0}` 可用\: {1}
inspection.message.no.arguments.were.given=未提供任何實參
inspection.message.no.default.declared=No default declared
inspection.message.no.implementation.for=沒有 `{0}` 的實作
inspection.message.no.such.field=沒有此類別欄位
inspection.message.no.version.matching.found.for.crate=找不到 crate `{1}` 的與 {0} 符合的版本
inspection.message.non.constant.value.was.used.in.constant.expression=在常數表達式中使用了非常量值
inspection.message.non.primitive.cast.as=非基元轉換\: `{0}` 轉換為 `{1}`
inspection.message.non.string.abi.literal=ABI 文字必須為字串
inspection.message.not.all.trait.items.implemented.missing=未實作所有特徵條目，缺少\: {0}
inspection.message.not.member.trait={0} `{1}` 不是特徵 `{2}` 的成員
inspection.message.only.auto.traits.can.be.used.as.additional.traits.in.trait.object=在特徵物件中，只能將自動特徵新增為其他特徵
inspection.message.only.single.explicit.lifetime.bound.permitted=只允許單個顯式生命周期邊界
inspection.message.only.static.constants.are.allowed.in.extern.blocks=`extern` 塊中只允許使用 static 常數
inspection.message.only.traits.defined.in.current.crate.can.be.implemented.for.arbitrary.types=只有在當前 crate 中定義的特徵才能為任意類型實作
inspection.message.only.u8.can.be.cast.as.char.not=`{0}` 不能轉換為 `char` (只有 `u8` 可以)
inspection.message.parameter.expected=應為參數
inspection.message.parameter.never.used=參數 `{0}` 從未使用
inspection.message.parenthesized.lifetime.bounds.are.not.supported=不支持圓括號中的生命周期邊界
inspection.message.parenthetical.notation.only.stable.when.used.with.fn.family.traits=圓括號表示法僅在與 `fn` 系列特徵一起使用時才穩定
inspection.message.pattern.does.not.correspond.to.its.declaration.expected.found=`{0}` 模式與其宣告不對應\: 應為 {1} 個{2}，但實際為 {3} 個
inspection.message.pattern.does.not.mention=`{0}` 模式未提及{1} {2}
inspection.message.patterns.aren.t.allowed.in.foreign.function.declarations=不允許在外部函式宣告中使用模式
inspection.message.patterns.aren.t.allowed.in.function.pointer.types=不允許在函式指針類型中使用模式
inspection.message.patterns.aren.t.allowed.in.functions.without.bodies=不允許在沒有主體的函式中使用模式
inspection.message.positional.arguments.cannot.follow.named.arguments=位置實參必須位於命名實參之前
inspection.message.precise.format.fn.family.traits.type.parameters.subject.to.change=`fn` 系列特徵中類型參數的精確格式可能會發生變化
inspection.message.predicate.expression.has.unnecessary.parentheses=謂詞表達式有不必要的圓括號
inspection.message.println.macro.invocation.can.be.simplified=`println\!` 巨集呼叫可簡化
inspection.message.private={0} `{1}` 為 private
inspection.message.private.cannot.be.re.exported=`{0}` 為 private，無法重新匯出
inspection.message.proc.macro.crates.can.export.only.functions=`proc-macro` crate 只能匯出具有 `\#[proc_macro]`、`\#[proc_macro_derive]` 或 `\#[proc_macro_attribute]` 特性的函式
inspection.message.provided.when.constant.was.expected=應為常數時提供了{0}
inspection.message.provided.when.lifetime.was.expected=應為生命周期時提供了{0}
inspection.message.provided.when.type.was.expected=應為類型時提供了{0}
inspection.message.range.to.patterns.with.are.not.allowed=不允許使用帶有 `...` 的範圍結尾模式
inspection.message.recursion.in.async.fn.requires.boxing=Recursion in an `async` function requires boxing
inspection.message.redundant=冗餘的 `\:\:`
inspection.message.redundant.else=冗餘的 `else`
inspection.message.repr.inttype.must.be.specified=必須指定 `\#[repr(inttype)]`
inspection.message.requires.unsafe.impl.declaration.due.to.attribute=`\#[{0}]` 特性需要 `unsafe impl` 宣告
inspection.message.reserved.keyword=`{0}`是保留關鍵字
inspection.message.reserved.keyword.in.edition=`{0}` 是 Rust {1} 版中的保留關鍵字
inspection.message.reserved.lifetime.name=`{0}` 是保留的生命周期名稱
inspection.message.rest.expr.without.base.expr=`..` 後需要基本表達式
inspection.message.return.can.be.lifted.out=`return` 關鍵字可從 `{0}` 中提取
inspection.message.return.expression.has.unnecessary.parentheses=`return` 表達式具有不必要的圓括號
inspection.message.return.in.function.whose.return.type.not=在返回值類型不是 `()` 的函式中使用了 `return;`
inspection.message.rust.has.no.incdec.operator=Rust 沒有 `{0}` 運算符
inspection.message.self.import.appears.more.than.once.in.list=`self` import 在列表中多次出現
inspection.message.self.import.can.only.appear.in.import.list.with.non.empty.prefix=在 import 列表中，`self` import 必須具有非空前綴
inspection.message.self.imports.are.only.allowed.within.list=僅允許在 `{ }` 列表中使用 `self` import
inspection.message.self.keyword.was.used.in.static.method=在 static 方法中使用 `self` 關鍵字
inspection.message.self.value.not.available.in.this.context=`self` 值在此上下文中不可用
inspection.message.should.have.body=`{0}` 必須具有主體
inspection.message.should.have.body2=`{0}` must have a body
inspection.message.should.have.case.name.such.as={0} `{1}` 應具有{2}命名法名稱，例如 `{3}`
inspection.message.specifier.must.be.type.usize=`{0}` 說明符必須是 `usize` 類型
inspection.message.start.attribute.can.be.placed.only.on.functions=`\#[start]` 特性只能用於標記函式
inspection.message.statement.expected=應為語句
inspection.message.static.constant=static 常數 `{0}`
inspection.message.static.constants.are.not.allowed.in.impl.blocks=不允許在 `impl` 塊中使用 static 常數
inspection.message.static.constants.are.not.allowed.in.traits=不允許在特徵中使用 static 常數
inspection.message.static.constants.in.extern.blocks.cannot.have.values=`extern` 塊中的 static 常數不得包含值
inspection.message.struct=結構
inspection.message.suffixed.literals.are.not.allowed.in.attributes=不允許在特性中使用後綴文字
inspection.message.suspicious.assignment.did.you.mean.or=可疑的賦值。您指的是 `{0}` 還是 `{1}`?
inspection.message.suspicious.else.if.formatting=可疑的 `else if` 格式設定
inspection.message.suspicious.if.did.you.mean.else.if=可疑的 `if`。您是否指的是 `else if`?
inspection.message.syntax.deprecated.use.for.exclusive.range.or.for.inclusive.range=`...` 語法已被棄用。使用 `..` 表示排除範圍或使用 `..\=` 表示包含範圍
inspection.message.there.are.arguments=有 {0} 個實參
inspection.message.there.argument=有 1 個實參
inspection.message.there.no.argument.named=沒有名為 `{0}` 的實參
inspection.message.this.feature.only.available.in.edition=此功能僅在 Rust {0} 版中可用
inspection.message.this.function.takes.choice.at.least.but.choice.was.were.supplied=此函式需要{0, choice, 0\# 至少|1\#} {1} 個{2}，但提供了 {3} 個{4}{5, choice, 0\#|1\#}
inspection.message.trait.bound.not.satisfied=`{0}\: {1}` 特徵邊界未實作
inspection.message.trait.copy.may.not.be.implemented.for.this.type=Trait `Copy` cannot be implemented for this type
inspection.message.trait.functions.cannot.be.declared.const=特徵函式不允許使用 const 宣告
inspection.message.trait.not.implemented=沒有為 `{1}` 實作特徵 `{0}`
inspection.message.trait.objects.must.include.dyn.keyword=特徵物件必須包含 `dyn` 關鍵字
inspection.message.trait.objects.without.explicit.dyn.are.deprecated=沒有 `dyn` 關鍵字的特徵物件已棄用
inspection.message.trait.requires.unsafe.impl.declaration=特徵 `{0}` 需要 `unsafe impl` 宣告
inspection.message.try.macro.can.be.replaced.with.operator=`try\!` 巨集可被取代為 `?` 運算符
inspection.message.tuple.field.expected=應為元組欄位
inspection.message.tuple.struct=元組結構
inspection.message.type=類型
inspection.message.type.0=類型 `{0}`
inspection.message.type.cannot.be.dereferenced=類型 `{0}` 無法取消參照
inspection.message.type.cant.be.indexed.by=類型 `{0}` 無法由 `{1}` 編制索引
inspection.message.type.mismatch=類型不符合解析 `{0}`
inspection.message.type.parameter.has.more.than.one.relaxed.default.bound.only.one.supported=類型參數有多個寬鬆的預設邊界，僅支援一個
inspection.message.type.parameters.with.default.must.be.trailing=具有預設類型的類型參數必須為尾隨
inspection.message.type.placeholder.not.allowed.within.types.on.item.signatures=條目簽名中不允許使用類型佔位符 `_`
inspection.message.type2=類型
inspection.message.unclosed=未閉合的 {0}
inspection.message.unexpected=意外 `...`
inspection.message.unexpected2=意外 `..\=`
inspection.message.unexpected3=意外 `..`
inspection.message.union.cannot.be.tuple.like=聯合不能類似元組
inspection.message.union.expressions.should.have.exactly.one.field=聯合表達式應有且只有一個欄位
inspection.message.union.patterns.requires.field=聯合模式需要一個欄位
inspection.message.union.patterns.should.have.exactly.one.field=聯合模式應有且只有一個欄位
inspection.message.unknown.format.trait=未知的格式設定特徵 `{0}`
inspection.message.unknown.meta.item=未知元條目 `{0}`
inspection.message.unlabeled.inside.labeled.block=標記的塊內有未標記的 `{0}`
inspection.message.unnecessary.cast=不必要的轉換
inspection.message.unnecessary.qualification=路徑前綴不必要
inspection.message.unnecessary.visibility.qualifier=不必要的可見性限定符
inspection.message.unreachable.code=不可到達的程式碼
inspection.message.unreachable.pattern=不可到達的模式
inspection.message.unrecognized.representation=無法識別的表示 `{0}`
inspection.message.unresolved.associated.item.for.struct=在結構 `{1}` 的當前作用域中找不到關聯條目 `{0}`
inspection.message.unresolved.function.name=在此作用域內找不到函式 `{0}`
inspection.message.unresolved.function.or.associated.item=在結構 `{1}` 的當前作用域中找不到函式或關聯條目 `{0}`
inspection.message.unresolved.import=未解析的匯入\: `{0}`
inspection.message.unresolved.method=在結構 `{1}` 的當前作用域中找不到方法 `{0}`
inspection.message.unresolved.reference=未解析的參照\: `{0}`
inspection.message.unresolved.reference2=未解析的參照
inspection.message.unresolved.struct.variant.or.union=在此作用域內找不到結構、變體或聯合類型 `{0}`
inspection.message.unresolved.trait=在此作用域內找不到特徵 `{0}`
inspection.message.unresolved.type=在此作用域內找不到類型 `{0}`
inspection.message.unresolved.value.name=在此作用域內找不到值 `{0}`
inspection.message.unresolved.variant.or.associated.item=在枚舉 `{0}` 的當前作用域內找不到變體或關聯條目 `{1}`
inspection.message.unsafe.dereference.raw.pointer=取消參照原始指針不安全
inspection.message.unstable=`{0}` 不穩定{1}
inspection.message.unused.attribute=未使用的特性
inspection.message.unused.import=未使用的 import\: `{0}`
inspection.message.unused.mut=未使用的 `mut`
inspection.message.use.moved.value=移動後使用的值
inspection.message.use.possibly.uninitialized.variable=變數可能未初始化
inspection.message.use.static.unsafe.requires.unsafe.function.or.block=僅允許在 `unsafe` 塊或函式內使用 static {0}
inspection.message.use.undeclared.label=未宣告的標籤 `{0}`
inspection.message.use.undeclared.lifetime.name=未宣告的生命周期名稱 `{0}`
inspection.message.use.unreachable.label=不可到達的標籤 `{0}`
inspection.message.use.unsafe.requires.unsafe.function.or.block=僅允許在 `unsafe` 塊或函式內使用 `{0}\!`
inspection.message.use.unsafe.static=使用 unsafe {0} static 條目
inspection.message.value.associated.must.be.specified=必須提供關聯{0} {1}的值
inspection.message.value.was.moved.out.while.it.was.still.borrowed=值在借用時已被移出
inspection.message.variable.never.used=變數 `{0}` 從未使用
inspection.message.visibilities.can.only.be.restricted.to.ancestor.modules=可見性限制僅限於上級模組
inspection.message.with.no.label.in.condition.while.loop=在 `while` 迴圈條件中存在沒有標籤的 `{0}`
inspection.message.with.suffix.invalid=帶後綴的 `{0}` 無效
inspection.message.wrong.meta.list.delimiters=元列表分隔符錯誤
inspection.message.wrong.number.arguments.expected.found={0} 實參數量錯誤\: 應為 {1} 個，但實際為 {2} 個
inspection.message.wrong.number.lifetime.arguments.expected.found=生命周期實參數量錯誤\: 應為 {0} 個，但收到 {1} 個
inspection.message.x.could.be.misinterpreted.as.pre.decrement.but.effectively.no.op=`--x` 可能會被誤解釋為預減，但實際上是無運算
inspection.missing.features.display.name=缺少功能
inspection.new.crate.version.available.display.name=有較新的 crate 版本可用
inspection.rs.approx.constant.display.name=近似常數
inspection.rs.argument.naming.display.name=實參命名約定
inspection.rs.array.out.of.bounds.display.name=陣列超出界限
inspection.rs.assert.equal.display.name=等式斷言可以簡化
inspection.rs.assign.to.immutable.display.name=不可變變數被重新賦值
inspection.rs.assoc.type.naming.display.name=關聯類型命名約定
inspection.rs.async.main.function.display.name=入口點為 async
inspection.rs.attempt.to.call.not.function.display.name=嘗試呼叫非函式
inspection.rs.attr.without.parentheses.display.name=不帶圓括號的特性
inspection.rs.attribute.error=特性錯誤
inspection.rs.bare.trait.objects.display.name=特徵物件中缺少 `dyn`
inspection.rs.borrow.checker.display.name=借用檢查器
inspection.rs.c.string.pointer.display.name=unsafe CString 指針
inspection.rs.cannot.impl.for.dyn.auto.trait=Inherent `impl` for dyn auto trait
inspection.rs.cast.to.bool.display.name=轉換為布林值
inspection.rs.compile.error.macro.display.name=`compile_error\!` 巨集
inspection.rs.compiler.feature.is.unavailable=編譯器功能不可用
inspection.rs.const.naming.display.name=常數命名約定
inspection.rs.const.refer.static.display.name=常數不能參照 static
inspection.rs.constant.condition.if.display.name=`if` 條件為常數
inspection.rs.control.flow.expr.in.while.condition.without.loop=`break` or `continue` with no label in the condition of a `while` loop
inspection.rs.copy.and.drop.impl=Both `Copy` and `Drop` implemented
inspection.rs.crate.name.display.name=crate 名稱無效
inspection.rs.dangling.else.display.name=懸空 `else`
inspection.rs.deprecation.display.name=棄用的元素
inspection.rs.derive.on.unsupported.item=`derive` 只能應用於結構、枚舉和聯合
inspection.rs.detached.file.display.name=分離的檔案
inspection.rs.double.must.use.display.name=冗餘的 `\#[must_use]`
inspection.rs.double.neg.display.name=雙重求反
inspection.rs.drop.copy.type.display.name=`Copy` 類型已刪除
inspection.rs.drop.ref.display.name=參照已刪除
inspection.rs.duplicate.defnition=重複的定義
inspection.rs.duplicated.macro.pattern.name=重複的巨集模式
inspection.rs.duplicated.trait.method.binding.display.name=重複的特徵方法參數名稱
inspection.rs.enum.naming.display.name=枚舉命名約定
inspection.rs.enum.repr.int.is.required=`\#[repr(inttype)]` must be specified for enum
inspection.rs.enum.variant.naming.display.name=枚舉變體命名約定
inspection.rs.equality.trait.members.display.name=Derived trait not implemented
inspection.rs.experimental.checks.display.name=實驗性檢查
inspection.rs.experimental.trait.obligations.display.name=類型不實現特徵(實驗性)
inspection.rs.experimental.type.check.display.name=類型檢查器(實驗性)
inspection.rs.external.linter.display.name=外部 linter
inspection.rs.field.init.shorthand.display.name=非速記欄位初始化
inspection.rs.field.naming.display.name=欄位命名約定
inspection.rs.field.without.type=Missing struct field type
inspection.rs.format.macro.errors=Format macro error
inspection.rs.function.naming.display.name=函式命名約定
inspection.rs.function.parameters.are.sized=Parameter type with unknown size
inspection.rs.generic.default.param.cannot.use.forward=Forward-declared identifier for parameter with default value
inspection.rs.impl.copy.for.wrong.type=Invalid `Copy` implementation
inspection.rs.impl.drop.for.non.adt=Invalid `Drop` implementation
inspection.rs.impl.for.non.adt.error=條目不允許使用固有 `impl` 塊
inspection.rs.incorrect.function.argument.count=實參數量錯誤
inspection.rs.incorrect.type.of.index.expression.display.name=索引表達式的類型錯誤
inspection.rs.incorrectly.placed.inline.attr=`\#[inline]` Attribute can only be applied to a function or closure
inspection.rs.inherent.impl.different.crate=固有 `impl` 在類型所包含的 crate 外部定義
inspection.rs.invalid.brea.continue.usage=Invalid 'break' or 'continue'
inspection.rs.invalid.label.name=標籤名稱無效
inspection.rs.invalid.lifetime.name=Invalid lifetime name
inspection.rs.invalid.macro.call.display.name=無效的巨集呼叫
inspection.rs.invalid.macro.variable.type.display.name=無效的巨集變數類型
inspection.rs.invalid.start.attribute=`\#[start]` 特性無效
inspection.rs.invalid.struct.fields=結構中的無效欄位
inspection.rs.lifetime.naming.display.name=生命周期命名約定
inspection.rs.lift.display.name=`return` 可被提取
inspection.rs.literal.out.of.range.display.name=文字超出範圍
inspection.rs.liveness.display.name=存活性分析
inspection.rs.loop.only.keyword.outside.of.loop=`break` and `continue` can only be used inside `loop` and `while` blocks
inspection.rs.macro.naming.display.name=巨集命名約定
inspection.rs.main.function.not.found.display.name=找不到 main 函式
inspection.rs.method.naming.display.name=方法命名約定
inspection.rs.missing.else.display.name=缺少 `else`
inspection.rs.module.naming.display.name=模組命名約定
inspection.rs.needless.lifetimes.display.name=不必要的生命周期註解
inspection.rs.non.exhaustive.match.display.name=非窮盡匹配
inspection.rs.non.shorthand.field.patterns.display.name=非速記欄位模式
inspection.rs.nonexistent.field.access=Non-existent field access
inspection.rs.path.statements.display.name=無效的路徑語句
inspection.rs.public.items.in.proc.macro.crate.inspection.display.name=proc macro crate 中的 public 條目
inspection.rs.reassign.immutable.display.name=不可變變數被重新賦值
inspection.rs.recursion.in.async.function=No boxing for async recursion
inspection.rs.redundant.else.display.name=冗餘的 `else`
inspection.rs.redundant.semicolons.display.name=冗餘的分號
inspection.rs.reference.is.not.public=Invalid private field/method access
inspection.rs.replace.cast.with.suffix.display.name=轉換可被取代為文字後綴
inspection.rs.return.must.have.value=`return` must have a value
inspection.rs.self.convention.display.name=Self 約定
inspection.rs.simplify.boolean.expression.display.name=布爾表達式可以簡化
inspection.rs.simplify.print.display.name=`println\!` 巨集可以簡化
inspection.rs.sleep.in.async.context=阻塞 `sleep` 函式不能在 `async` 上下文中使用
inspection.rs.sort.impl.trait.members.display.name=`impl` 成員順序與特徵不同
inspection.rs.static.const.naming.display.name=static 常數命名約定
inspection.rs.struct.naming.display.name=結構命名約定
inspection.rs.struct.rest.without.base.expression.name=`..` 後需要基本表達式
inspection.rs.super.trait.is.not.implemented=Supertrait is not implemented
inspection.rs.suspicious.assignment.display.name=可疑的賦值
inspection.rs.test.failed.line.display.name=測試中的失敗行
inspection.rs.thread.rng.gen.can.be.replaced.with.random=`thread_rng().gen()` 可被取代為 `random()`
inspection.rs.trait.implementation.display.name=特徵實作問題
inspection.rs.trait.naming.display.name=特徵命名約定
inspection.rs.trait.obligations.display.name=類型不實現特徵
inspection.rs.traits.defined.in.current.crate=外部特徵實施
inspection.rs.try.macro.display.name=`try\!` 巨集用法
inspection.rs.type.alias.naming.display.name=類型別名命名約定
inspection.rs.type.check.display.name=類型檢查器
inspection.rs.type.mismatch.display.name=類型與特徵的關聯類型不符合。
inspection.rs.type.parameter.naming.display.name=類型參數命名慣例
inspection.rs.type.placeholder.is.forbidden=條目簽名中使用的類型佔位符
inspection.rs.union.expression.fields.count.display.name=聯合表達式欄位計數
inspection.rs.unknown.crate.types.display.name=未知的 crate 類型
inspection.rs.unlabeled.control.flow.expr=Unlabeled `continue` or `break` inside of a labeled block
inspection.rs.unnecessary.cast.display.name=不必要的轉換
inspection.rs.unnecessary.parentheses.inspection.display.name=不必要的圓括號
inspection.rs.unnecessary.qualifications.display.name=不必要的路徑前綴
inspection.rs.unreachable.code.display.name=不可到達的程式碼
inspection.rs.unreachable.patterns.display.name=不可到達的模式
inspection.rs.unresolved.method.display.name=未解析的方法
inspection.rs.unresolved.method.experimental.display.name=未解析的方法(實驗性)
inspection.rs.unresolved.path.display.name=未解析的路徑
inspection.rs.unresolved.path.experimental.display.name=未解析的路徑(實驗性)
inspection.rs.unresolved.reference.display.name=未解析的參照
inspection.rs.unsupported.binary.operator.display.name=不支持的二元運算符
inspection.rs.unused.import.display.name=未使用的 import
inspection.rs.unused.labels.display.name=未使用的標籤
inspection.rs.unused.must.use.display.name=未使用的 `\#[must_use]`
inspection.rs.unused.mut.display.name=未使用的 `mut` 修飾符
inspection.rs.variable.naming.display.name=變數命名約定
inspection.rs.while.true.loop.display.name=`while true` 可被取代為 `loop`
inspection.rs.wrong.assoc.type.arguments.display.name=錯誤的關聯類型實參
inspection.rs.wrong.generic.arguments.number.display.name=錯誤數量的泛型實參
inspection.rs.wrong.generic.arguments.order.display.name=排序錯誤的泛型實參
inspection.rs.wrong.generic.parameters.number.display.name=錯誤數量的類型或 const 參數
inspection.rs.wrong.lifetime.parameters.number.display.name=錯誤數量的生命周期參數
inspection.toml.duplicate.table.header=重複的表標頭
inspection.toml.edition.must.be.in.list=版次必須是 {0} 之一
inspection.toml.invalid.category=軟體套件類別無效
inspection.toml.invalid.package.name=無效的軟體套件名稱
inspection.toml.json.schema=Doesn't conform to schema
inspection.toml.string.literal.expected=應為字串文字
inspection.toml.too.many.categories=crates.io 最多允許 5 個類別
inspection.toml.unclosed.string=未閉合的字串文字
intention.Rust.ToggleFeatureIntention.disable=停用功能 `{0}`
intention.Rust.ToggleFeatureIntention.enable=啟用功能 `{0}`
intention.Rust.ToggleFeatureIntention.family.name=切換功能狀態
intention.family.name.add.default.meta.item=Add \#[default] to first variant
intention.family.name.add.feature.attribute=新增 `\#\![feature]` 特性
intention.family.name.add.fn.main=新增 `fn main()`
intention.family.name.add.import=新增 import
intention.family.name.add.import.for.path.in.pattern=在模式中新增路徑匯入
intention.family.name.add.label=新增標籤
intention.family.name.add.method.call=表達式的呼叫方法
intention.family.name.add.missing.generic.arguments=新增缺少的泛型實參
intention.family.name.add.parentheses=新增圓括號
intention.family.name.add.safe.cast=新增安全轉換
intention.family.name.add.self.to=將 `self` 新增到{0}
intention.family.name.add.to.dependencies=將 crate 新增到相依項
intention.family.name.add.type=新增類型
intention.family.name.apply.suggested.replacement.made.by.external.linter=按照外部 linter 的建議進行取代
intention.family.name.change.function.signature=更改函式簽名
intention.family.name.change.item.visibility=更改條目可見性
intention.family.name.change.name.element=更改元素名稱
intention.family.name.change.repr.attribute=更改 `repr` 特性
intention.family.name.change.return.type=更改返回值類型
intention.family.name.compare.with.zero=與零比較
intention.family.name.convert.not.b.cfg.pattern.to.all.not.not.b=將 `not(a, b)` cfg-pattern 轉換為 `all(not(a), not(b))`
intention.family.name.convert.to.loop=轉換為迴圈
intention.family.name.convert.to.sized.type=轉換為大小類型
intention.family.name.convert.to.type=轉換為類型
intention.family.name.convert.to.unsuffixed.integer=轉換為無後綴整數
intention.family.name.convert.type=轉換宣告類型
intention.family.name.convert.type.local.variable=轉換區域變數類型
intention.family.name.create.enum.variant=建立枚舉變體
intention.family.name.create.function=建立函式
intention.family.name.create.lifetime.parameter=建立生命周期參數
intention.family.name.create.module.file=建立模組檔案
intention.family.name.create.struct=建立結構
intention.family.name.create.tuple.struct=建立元組結構
intention.family.name.demorgan.s.law=德摩根定律
intention.family.name.derive.trait=派生特徵
intention.family.name.do.not.show.again=不再顯示
intention.family.name.enable.features=啟用功能
intention.family.name.extract.inline.module.structure=提取內聯模組結構
intention.family.name.import=匯入
intention.family.name.import.item.from.crate=從外部 crate 匯入條目
intention.family.name.lift.return=提取 `return`
intention.family.name.make.async=設為 async
intention.family.name.make.mutable=設為可變
intention.family.name.make.private=設為私密
intention.family.name.make.public=設為 public
intention.family.name.qualify.path=指定完整路徑
intention.family.name.reload.project=重新載入專案
intention.family.name.remove=移除
intention.family.name.remove.bound=移除邊界
intention.family.name.remove.macro.branch=移除巨集分支
intention.family.name.remove.parameter=移除參數
intention.family.name.remove.pat.field=移除模式欄位
intention.family.name.remove.reference=移除參照
intention.family.name.remove.return.type=移除返回值類型
intention.family.name.remove.self.from=從{0}中移除 `self`
intention.family.name.remove.struct.literal.field=移除結構文字欄位
intention.family.name.remove.unnecessary.cast=移除不必要的轉換
intention.family.name.remove.variable=移除變數
intention.family.name.rename.element=重新命名元素
intention.family.name.rename.label=重新命名標籤
intention.family.name.replace.box.with.box.new=將 `box` 取代為 `Box\:\:new`
intention.family.name.replace.cast.with.literal.suffix=將轉換取代為文字後綴
intention.family.name.replace.fragment.specifier=將 `{0}` 的片段說明符更改為 `{1}`
intention.family.name.replace.str.index.with.chars.index=將 str 索引取代為 char 索引(&S)
intention.family.name.replace.successive.with=將連續的 `_` 取代為 `..`
intention.family.name.replace.with.block.comment=取代為塊註釋
intention.family.name.replace.with.end.line.comment=取代為行註釋
intention.family.name.replace.with.inclusive.range=取代為包含範圍
intention.family.name.replace.with.predefined.constant=取代為預定義常數
intention.family.name.replace.with.thread.local.stable.method.call=取代為執行緒區域穩定方法呼叫
intention.family.name.simplify.boolean.expression=簡化布爾表達式
intention.family.name.specify.return.type=指定返回值
intention.family.name.split.if=拆分 `if`
intention.family.name.substitute.one.text.to.another=將一個文本取代為另一個文本
intention.family.name.suppress.warnings=禁止警告
intention.family.name.unwrap.enum.or.tuple.struct.constructor.from.expression=從表達式中解包枚舉或元組結構建構函式
intention.family.name.update.dependency.version=更新相依項版本
intention.family.name.use.loop=使用 `loop`
intention.family.name.use.shorthand.field.pattern=使用速記欄位模式
intention.name.={0}{1}
intention.name.add=新增 `..`
intention.name.add.as.parameter.to=將 `{0}` 作為 `{1}` 參數新增到{2} `{3}`
intention.name.add.async.recursion.attribute=新增 `\#[async_recursion]` 特性
intention.name.add.braces.to.lambda.expression=向 lambda 表達式新增大括號
intention.name.add.curly.braces=新增大括號
intention.name.add.definition.to.trait=將成員定義新增到特徵
intention.name.add.derive.clause=新增 `\#[derive]` 特性
intention.name.add.derive.to=將 `\#[derive({0})]` 新增到 `{1}`
intention.name.add.dummy.parameter.name=新增虛擬參數名稱
intention.name.add.dyn.keyword.to.trait.object=將 `dyn` 關鍵字新增到特徵物件
intention.name.add.else.branch.to.this.if.statement=新增 `else` 分支
intention.name.add.feature=新增 `{0}` 功能
intention.name.add.field.name=新增欄位名稱
intention.name.add.field.to.struct=將欄位 `{0}` 新增到類型 `{1}`
intention.name.add.format.argument=新增格式實參 `{0}`
intention.name.add.format.string=新增格式字串
intention.name.add.format.string.argument=新增格式字串實參
intention.name.add.impl.before.trait=新增 `impl` 關鍵字
intention.name.add.impl.block=新增 `impl` 塊
intention.name.add.import.for=為 `{0}` 新增 import
intention.name.add.method.call=為 `{1}` 呼叫 `{0}`
intention.name.add.missing=新增缺失的{0}
intention.name.add.missing.associated.types=新增缺少的關聯類型
intention.name.add.missing.fields=新增缺少的欄位
intention.name.add.parentheses.to=將圓括號新增到 `{0}`
intention.name.add.pattern=新增 `_` 模式
intention.name.add.remaining.patterns=新增剩餘的模式
intention.name.add.required.features=為 `{0}` 新增必選功能
intention.name.add.required.features.family.name=新增必選功能
intention.name.add.safe.cast.to=新增到 {0} 的安全轉換
intention.name.add.self=Add `Self\:\:`
intention.name.add.self.to.function=將 `self` 新增到函式定義
intention.name.add.to.dependencies=將 `{0}` 新增到相依項
intention.name.add.to.owned=新增 `.to_owned()`
intention.name.add.tokio.main=新增 `\#[tokio\:\:main]`
intention.name.add.turbofish.operator=新增 turbofish 語法
intention.name.add.type=新增類型 `{0}`
intention.name.add.unsafe.to=將 `unsafe` 新增到{0}
intention.name.append.semicolon=新增分號
intention.name.apply.same.member.order=套用與特徵中相同的成員順序
intention.name.attach.file.to=將檔案附加到{0}
intention.name.b.b=<b>{0}</b>
intention.name.b.b2=<b>{0}</b>
intention.name.block=阻塞
intention.name.change.equals.op.to.eq=將 `\=\=` 更改為 `.eq(...)`
intention.name.change.field.lookup.to.method.call=將欄位存取表達式取代為方法呼叫
intention.name.change.format.parameter.to=將格式參數更改為 `{\:?}`
intention.name.change.iter.to.iter.mut=在 for 迴圈中將 `.iter()` 更改為 `.iter_mut()`
intention.name.change.match.expr.to.method.call=將 match 表達式轉換為方法呼叫
intention.name.change.reference.to.mutable=更改對可變變數的參照
intention.name.change.representation.enum.to.repr=將枚舉 `{0}` 的表示更改為 `\#[repr({1})]`
intention.name.change.return.type.to=將返回值類型{0} {1} 更改為 `{2}`
intention.name.change.to=更改為 `{0}`
intention.name.change.to.else.if=更改為 `else if`
intention.name.change.to1=更改為 `{0}`
intention.name.change.to3=更改為 `{0}`
intention.name.change.toml.literal.to.array=將文字轉換為數組
intention.name.change.try.to=將 `try\!` 更改為 `?`
intention.name.change.type.to=將{1} {2} 中 {0} 的類型更改為 `{3}`
intention.name.change.type.to2=將 {0} 的類型更改為 `{1}`
intention.name.convert.closure.to.function=將閉包轉換為函式
intention.name.convert.function.to.closure=將函式轉換為閉包
intention.name.convert.if.let.statement.to.match=將 `if let` 語句轉換為 `match`
intention.name.convert.impl.trait.to.type.parameter=將 `impl Trait` 轉換為類型參數
intention.name.convert.match.statement.to.if.let=將 `match` 語句轉換為 `if let`
intention.name.convert.to=轉換為 `{0}`
intention.name.convert.to.box=轉換為 `Box`
intention.name.convert.to.by.removing.refs=通過移除參照轉換為 `{0}`
intention.name.convert.to.display.implementation=轉換為 `Display` 實作
intention.name.convert.to.macro=轉換為 `{0}\!`
intention.name.convert.to.method.call=轉換為方法呼叫
intention.name.convert.to.reference=轉換為參照
intention.name.convert.to.struct=轉換為結構
intention.name.convert.to.tuple=轉換為元組
intention.name.convert.to.ufcs=轉換為 UFCS
intention.name.convert.to.using=使用 {1}轉換為 {0}
intention.name.create.associated.function=建立關聯函式 `{0}\:\:{1}`
intention.name.create.associated.function.self=建立關聯函式 `Self\:\:{0}`
intention.name.create.enum.variant=建立枚舉變體 `{0}`
intention.name.create.field=建立欄位
intention.name.create.function=建立函式 `{0}`
intention.name.create.method=建立方法 `{0}`
intention.name.create.module.file=建立模組檔案 `{0}`
intention.name.create.struct=建立結構 `{0}`
intention.name.create.tuple.struct=建立元組結構 `{0}`
intention.name.demorgan.s.law.replace.with=將 `||` 取代為 `&&` (德摩根定律)
intention.name.demorgan.s.law.replace.with2=將 `&&` 取代為 `||` (德摩根定律)
intention.name.derive.copy.trait=派生 Copy 特徵
intention.name.derive.debug.and.replace.display.to.debug=派生 `{0}` 的 `Debug` 並將 `'{}'` 取代為 `'{\:?}'`
intention.name.elide.lifetimes=省略生命周期
intention.name.enclose.expression.in.braces=將表達式括在大括號中
intention.name.escape.keyword=轉義關鍵字
intention.name.escape.reserved.keyword=轉義保留關鍵字
intention.name.expand.dependency.specification=展開相依項規範
intention.name.explain.move.error=Explain
intention.name.external.linter=外部 Linter\: {0}
intention.name.extract.enum.variant=提取枚舉變體
intention.name.extract.inline.module=提取內聯模組
intention.name.fill.missing.arguments=填充缺少的實參
intention.name.fix.visibility.restriction=修正可見性限制
intention.name.flatten.use.statements=平展 `use` 語句
intention.name.flip=翻轉 `{0}`
intention.name.flip.binary.expression=翻轉二元表達式
intention.name.flip.changes.semantics=翻轉 `{0}` (語意將會改變)
intention.name.flip.to=將 `{0}` 翻轉為 `{1}`
intention.name.function=函式
intention.name.generate.documentation.stub=生成文檔存根
intention.name.html.change.signature.to.html=<html> 將簽名更改為 `{0}({1})`</html>
intention.name.impl=impl
intention.name.implement.display.trait.for=為 `{0}` 實作 `Display` 特徵
intention.name.implement.members=實作成員
intention.name.implement.members.hint.text=<html><body><a href\="action">是否實作 {0} 的缺失成員</a>? \\&nbsp;\\&nbsp;<span style\="color\:\#{2}">{1}</span></body></html>
intention.name.implement.missing.supertrait.s=實作缺少的超特徵
intention.name.implement.operator.trait=實作運算符特徵
intention.name.implement.trait=實作特徵
intention.name.implement.trait2=實作 `{0}` 特徵
intention.name.import=匯入
intention.name.import.item.from.crate=從 crate `{1}` 匯入 `{0}`
intention.name.initialize.with.default.value=使用預設值初始化
intention.name.install.tokio.and.add.main=將 `tokio` 新增到相依項，並使用 `\#[tokio\:\:main]` 註解 main 函式
intention.name.introduce.local.variable=引入區域變數
intention.name.invert.if.condition=反轉 `if` 條件
intention.name.join.else.if=加入 `else if`
intention.name.lambda=lambda
intention.name.lift.return.out=從 `{0}` 中提取 `return`
intention.name.make=將 {0} 設為 {1}
intention.name.make.async=將 {0} 設為 async
intention.name.make.mutable=將 `{0}` 設為可變
intention.name.make.private=將 `{0}` 設為 private
intention.name.make.public=將 `{0}` 設為 public
intention.name.merge.with.nested.if.expression=與嵌套的 `if` 表達式合併
intention.name.method=方法
intention.name.method.not.a.field=試圖將方法 {0} 作為類型 `{1}` 的欄位進行存取
intention.name.move.guard.inside.match.arm=將 guard 移至 match arm 內
intention.name.move.to.type.reference=將 `\\&` 移動到類型參照
intention.name.move.type.constraint.to.parameter.list=將類型約束移至參數列表
intention.name.move.type.constraint.to.where.clause=將類型約束移至 `where` 子句
intention.name.nest.use.statements=嵌套 `use` 語句
intention.name.put.arguments.on.one.line=在單行中對齊實參
intention.name.put.arguments.on.separate.lines=在不同的行上排列實參
intention.name.put.fields.on.one.line=在單行中對齊欄位
intention.name.put.fields.on.separate.lines=在不同的行中排列欄位
intention.name.put.parameters.on.one.line=在單行中對齊參數
intention.name.put.parameters.on.separate.lines=在不同的行中排列參數
intention.name.put.variants.on.one.line=在單行中對齊變體
intention.name.put.variants.on.separate.lines=在不同的行中排列變體
intention.name.qualify.path.to=指定 `{0}` 的完整路徑
intention.name.recursively.add.missing.fields=遞迴新增缺少的欄位
intention.name.recursively.replace.with.actual.fields=將 `..` 遞迴取代為實際欄位
intention.name.remove=移除 `{0}`
intention.name.remove.as=移除 `as {0}`
intention.name.remove.bound=移除 `{0}` 邊界
intention.name.remove.braces.from.single.expression=從表達式中移除大括號
intention.name.remove.braces.from.single.expression.statement=從表達式語句中移除大括號
intention.name.remove.curly.braces=移除大括號
intention.name.remove.dbg=移除 `dbg\!`
intention.name.remove.drop.and.keep.expression=移除 `drop` 並保留表達式
intention.name.remove.element.semicolon=分號
intention.name.remove.else=移除 `else`
intention.name.remove.field=移除欄位 `{0}`
intention.name.remove.format.parameter=移除格式實參
intention.name.remove.from=從{1} `{2}` 中移除 `{0}`
intention.name.remove.if.expression=移除 'if' 表達式
intention.name.remove.parameter=移除參數 `{0}`
intention.name.remove.parentheses.from.expression=從表達式中移除圓括號
intention.name.remove.quotes=移除引號
intention.name.remove.redundant.arguments=移除冗餘參數
intention.name.remove.redundant.associated.type=移除冗餘的關聯類型
intention.name.remove.redundant.generic.arguments=移除冗餘的泛型實參
intention.name.remove.suffix=移除後綴
intention.name.remove.unary.operator.add.rev=移除一元運算符 `-` 並新增 `.rev()`
intention.name.remove.unnecessary.argument=移除不必要的實參
intention.name.remove.unnecessary.path.prefix=移除不必要的路徑前綴
intention.name.remove.unreachable.code=移除不可到達的程式碼
intention.name.remove.unreachable.match.arm=移除不可到達的 match arm
intention.name.remove.unreachable.pattern=移除不可到達的模式
intention.name.remove.unused.argument=移除未使用的實參
intention.name.remove.unused.import=移除未使用的 import
intention.name.remove.variable=移除變數 `{0}`
intention.name.remove2=移除 {0}
intention.name.rename.to=重命名為 `{0}`
intention.name.replace.brackets=取代中括號
intention.name.replace.comma.with.plus.sign=將逗號取代為加號
intention.name.replace.deprecated.element.with.suggestion=將棄用的元素取代為建議的元素
intention.name.replace.inc.dec.operator=取代為 `{0}`
intention.name.replace.unwrap.with.match=將 `.unwrap()` 取代為 `match`
intention.name.replace.unwrap.with.try=將 `.unwrap()` 取代為 `try`
intention.name.replace.with=將 `{0}` 取代為 `{1}`
intention.name.replace.with.0.1=取代為 `{0}{1}`
intention.name.replace.with.1=取代為 ''{0}''
intention.name.replace.with.actual.fields=將 `..` 取代為實際欄位
intention.name.replace.with.and.import=取代為 `{0}` 並從 `{1}` 匯入
intention.name.replace.with.parse.call=取代為 `.parse` 呼叫
intention.name.replace.with.std.mem.drop=取代為 `std\:\:mem\:\:drop`
intention.name.replace.with.to.string=取代為 `{0}.to_string()`
intention.name.replace.with2=取代為 `{0}`
intention.name.set.reference.immutable=將參照設為不可變
intention.name.set.reference.mutable=將參照設為可變
intention.name.show.recursive.macro.expansion=顯示遞迴巨集展開
intention.name.show.result.macro.expansion.cargo.expand=顯示展開的巨集(cargo expand)
intention.name.show.single.step.macro.expansion=顯示單步巨集展開
intention.name.simplify.boolean.expression=簡化布爾表達式
intention.name.simplify.dependency.specification=簡化相依項規範
intention.name.specify.type=指定類型
intention.name.specify.type.explicitly=明確地指定類型
intention.name.split.into.if.s=拆分為兩個 if
intention.name.substitute=取代
intention.name.substitute.type.alias=取代類型別名
intention.name.suppress.all.inspections.for.item=禁止條目的所有檢查
intention.name.suppress.for=禁止{1}的 `{0}`
intention.name.suppress.for.item.with.comment=禁止帶有註釋的條目
intention.name.surround.with.unsafe.block=使用 unsafe 塊包圍
intention.name.toggle.ignore.for.tests=切換測試的 ignore
intention.name.un.elide.lifetimes=取消省略生命周期
intention.name.unwrap.from.expression=從表達式中解包 `{0}`
intention.name.unwrap.if.expression=解包 'if' 表達式
intention.name.update.version.to=將版本更新到 {0}
intention.name.use.destructuring.declaration=使用解構宣告
intention.name.use.drop.to.clarify.intent.drop=使用 `drop` 澄清意圖\: `drop({0});`
intention.name.use.initialization.shorthand=使用速記初始設定式
intention.name.use.shorthand.field.pattern=使用速記欄位模式\: `{0}`
intention.name.wrap.in.ok=使用 `Ok()` 包裝
introduce.parameter.to.method=將參數引入方法
invalid.rust.toolchain.0=無效的 Rust 工具鏈\: {0}
invalid.rust.toolchain.02=無效的 Rust 工具鏈\: {0}
invalid.standard.library.0=無效的標準庫\: {0}
irrefutable.let.pattern=不可反駁的 let 模式
iso.8601.rfc.3339.date.time.format.2001.07.08t00.34.60.026490.09.30=(2001-07-08T00\:34\:60.026490+09\:30) ISO 8601 / RFC 3339 日期和時間格式。
item.and.impls=條目和 impl
kind.of.development.hobby=個人、編外或開源專案
kind.of.development.professional=專業軟體開發
label.attribute=特性
label.channel=通道(&H)\:
label.everything=所有內容
label.expression=表達式
label.for.what.kind.development.do.you.primarily.use.rustrover=您主要在什麼情況下使用 RustRover?
label.install.cargo.generate.using.cargo=使用 Cargo 安裝 cargo-generate
label.item=條目
label.methods.only=僅方法
label.module=模組
label.on.block=塊上的標籤
label.rust=Rust
label.rust.files=Rust 檔案
label.statement=語句
label.struct=struct {0}`{`
label.structure=結構
label.trait.name=特徵名稱\:
label.type.alias=類型別名 {0}
let.else=`let-else`
library.file.restore.content.notification.hyperlink=Restore initial content
library.file.restore.content.notification.text=External source files should not be modified
lints=Lint
list.item.attach.to.module=附加到模組
list.item.binary.application=二進制檔案(應用程式)
list.item.don.t.attach.to.module=不附加到模組
list.item.empty.file=空檔案
list.item.function.to.inline=要內聯的函式
list.item.library=庫
list.item.procedural.macro=過程巨集
list.item.to.inline=要內聯的{0}
list.item.type.alias.to.inline=要內聯的類型別名
list.item.webassembly.lib=WebAssembly Lib
literal.newline.n=文字換行符(\\n)
literal.percent.sign=文字百分號
literal.tab.t=文字制表符(\\t)
local.time.zone.name.skips.all.non.whitespace.characters.during.parsing.acst=(ACST)本地時區名稱。在解析過程中跳過所有非空白字元。
locale.s.date.and.time.thu.mar.3.23.05.25.2005=(Thu Mar 3 23\:05\:25 2005)區域設定的日期和時間。
locale.s.date.representation.12.31.99=(12/31/99)區域設定的日期表示。
locale.s.time.representation.23.13.48=(23\:13\:48)區域設定的時間表示。
macro=`巨集`
macro.expansion.error.BuiltinMacroExpansionError.message=無法展開內建巨集
macro.expansion.error.CfgDisabled.message=使用 `\#[cfg()]` 特性有條件地停用巨集呼叫
macro.expansion.error.ConcatArgumentsMustBeLiteral.message=只有文字(如 `"foo"`、`-42` 和 `3.14`)可以傳遞給 `concat\!()`
macro.expansion.error.ConcatArgumentsNotFound.message=`concat\!()` 巨集沒有實參
macro.expansion.error.DeclMacroExpansionError.DefSyntax.message=巨集定義包含語法錯誤
macro.expansion.error.DeclMacroExpansionError.Matching.message=無法將巨集呼叫主體與巨集定義模式符合
macro.expansion.error.DeclMacroExpansionError.TooLargeExpansion.message=巨集展開太大
macro.expansion.error.ExpansionFileNotFound.message=巨集尚未展開
macro.expansion.error.ExpansionNameNotFound.message=找不到展開名稱(內部錯誤)
macro.expansion.error.FileIncludedIntoMultiplePlaces.message=不支持在多個位置包含相同的檔案
macro.expansion.error.IncludingFileNotFound.message=找不到包含的檔案
macro.expansion.error.InconsistentExpansionCacheAndVfs.message=找不到展開檔案，但快取包含有效的展開(內部錯誤)
macro.expansion.error.InconsistentExpansionExpandedFrom.message=`macro.expansion.expandedFrom \!\= macro` (內部錯誤)。巨集呼叫可能位於與另一個模組名稱衝突的模組內部。
macro.expansion.error.MacroCallSyntax.message=巨集呼叫語法中存在錯誤
macro.expansion.error.MacroDefSyntax.message=巨集定義語法中存在錯誤
macro.expansion.error.MacroExpansionEngineIsNotReady.message=巨集展開引擎尚未準備就緒
macro.expansion.error.MacroExpansionIsDisabled.message=巨集展開在專案設定中停用
macro.expansion.error.MacroMatchingError.EndOfInput.message=巨集呼叫實參與定義不符合\: 缺少令牌
macro.expansion.error.MacroMatchingError.ExtraInput.message=巨集呼叫實參與定義不符合\: 沒有規則需要此令牌
macro.expansion.error.MacroMatchingError.FragmentIsNotParsed.message=巨集呼叫實參與定義不符合\: 無法符合元變數 `{0}`
macro.expansion.error.MacroMatchingError.UnmatchedToken.message=巨集呼叫實參與定義不符合\: 令牌與任何規則都不符合，應為 `{0}` 而不是 `{1}`
macro.expansion.error.MemExpAttrMacro.message=舊的巨集展開引擎無法展開特性或派生巨集
macro.expansion.error.MemExpParsingError.message=無法將 `{0}` 解析為 `{1}`
macro.expansion.error.ModDataNotFound.message=找不到包含巨集呼叫的 `mod` 的 ModData (內部錯誤)
macro.expansion.error.NoMacroIndex.message=找不到巨集呼叫的巨集索引(內部錯誤)
macro.expansion.error.NoProcMacroArtifact.message=過程巨集編譯時出錯
macro.expansion.error.OldEngineStd.message=舊的巨集展開引擎無法從 Rust 標準庫展開巨集
macro.expansion.error.ProcMacroExpansionError.CantRunExpander.message=建立 `{0}` 程序時出錯。請參閱日誌，了解更多詳細資訊。
macro.expansion.error.ProcMacroExpansionError.ExecutableNotFound.message=找不到 `{0}` 可執行檔案
macro.expansion.error.ProcMacroExpansionError.IOExceptionThrown.message=與過程巨集展開伺服器通信時引發異常。請參閱日誌，了解更多詳細資訊。
macro.expansion.error.ProcMacroExpansionError.ProcMacroExpansionIsDisabled.message=過程巨集展開未啟用
macro.expansion.error.ProcMacroExpansionError.ProcessAborted.message=過程巨集展開器程序意外退出，程式碼為 {0}
macro.expansion.error.ProcMacroExpansionError.ServerSideError.message=出現過程巨集錯誤\n{0}
macro.expansion.error.ProcMacroExpansionError.Timeout.message=已達到過程巨集展開的超時時間({0} 毫秒)
macro.expansion.error.ProcMacroExpansionError.UnsupportedExpanderVersion.message=無法使用當前 Rust 工具鏈版本({0})展開過程巨集。請嘗試更新 IDE 或將工具鏈降級到之前的版本。
macro.expansion.error.Skipped.message=此過程巨集的展開已跳過
macro.expansion.error.SkippedInsideMacroRulesInjection.message=無法在巨集宣告中展開巨集
macro.expansion.error.TooDeepExpansion.message=已達到遞迴限制
macro.expansion.error.TooLargeExpansion.message=巨集展開太大
macro.expansion.error.UnmatchedProcMacroKind.message=過程巨集 `{0}` 無法作為 `{1}` 呼叫
macro.expansion.error.Unresolved.message=找不到巨集定義
macro.expansion.error.VirtualFileFoundButPsiIsNull.message=找不到 PSI 檔案(內部錯誤)
macro.expansion.error.VirtualFileFoundButPsiIsUnknown.message=未知的 PSI 檔案(內部錯誤)
macro.expansion.error.start=無法展開巨集\: {0}
min.const.generics=min const generics
minute.number.00.59.zero.padded.to.2.digits=(34)分鐘數字(00?59)，在前面填充零，變成 2 位數。
missing.else=缺少 `else`
mod.0=mod {0}
mod.statements.in.non.mod.rs.files=mod.rs 以外的檔案中的模組宣告
monday.1.tuesday.2.sunday.7.iso.8601=(7)星期一 \= 1、星期二 \= 2、…、星期日 \= 7。(ISO 8601)
month.day.year.format.same.as.m.d.y=(07/08/01)月-日-年格式。與 %m/%d/%y 相同。
month.number.01.12.zero.padded.to.2.digits.07=(07)月份數字(01?12)，在前面填充零，變成 2 位數。
name=姓名
name2=名稱\:
naming.conventions=命名約定
no.explicit.stdlib.or.rustup.found=找不到 stdlib 和 rustup
no.lines.covered=未覆蓋任何行
no.mutable.required=不需要 `mutable`
non.exhaustive.match=非窮盡匹配
notification.0.action.is.not.available.for.1.command=“{0}”動作不適用於 `{1}` 指令
notification.action.attach.manually.text=手動附加
notification.action.attach.text=附加 Cargo.toml
notification.action.do.not.show.again.text=不再顯示
notification.action.set.up.toolchain.text=設定工具鏈
notification.can.not.attach.stdlib.sources=在沒有 rustup 的情況下無法自動附加 stdlib 源
notification.content.bad.answer.from.crates.io=crates.io 的響應無效
notification.content.cannot.load.rustc.renderers=無法載入 rustc 呈現器
notification.content.cannot.load.rustc.sources=無法載入 rustc 源
notification.content.cargo.expand=cargo-expand
notification.content.could.not.create.mod=無法建立 `mod {0}`
notification.content.could.not.reach.crates.io=無法存取 crates.io
notification.content.debugger.downloading.failed=無法下載偵錯器
notification.content.debugger.successfully.downloaded=偵錯器下載成功
notification.content.failed.to.find.stdlib.in.sysroot=在 sysroot 中找不到 stdlib
notification.content.failed.to.install.cargo.generate=無法安裝 cargo-generate
notification.content.grcov=grcov
notification.content.incompatible.toml.plugin.version.code.completion.for.cargo.toml.not.available=TOML 延伸模組版本不相容。Cargo.toml 的程式碼補全不可用。
notification.content.low.performance.due.to.rust.external.linter=外部 Rust linter 導致性能降低 {0}{1}\\&nbsp;\\&nbsp;\\&nbsp;\\&nbsp;{2}
notification.content.need.at.least=需要 {0} {1} 或更高版本
notification.content.new.rust.version.available.for.download=Rust {0} 的新版本可供下載
notification.content.new.rust.version.was.installed=Rust {0} 已安裝
notification.content.no.rustup=無法使用 {0}\: 未找到 rustup
notification.content.not.installed=未安裝 {0}
notification.content.please.answer.few.questions.it.will.take.about.minutes=請回答幾個問題。大約需要 2 分鐘。
notification.content.project.not.found=找不到專案
notification.content.rebuilt.defmap.for.all.crates.in.ms=在 {0} 毫秒內為所有 crate 重建了 DefMap
notification.content.respond=回應
notification.content.rust.toolchain.no.longer.supported=Rust <b>{0}</b> 不受支援，使用它可能會導致錯誤。請將工具鏈升級到 <b>{1}</b> 或更高版本。
notification.content.rustup.failed=rustup 失敗\: {0}
notification.content.target.no.rustup=無法使用目標 {0}\: 未找到 rustup
notification.content.target.not.installed=目標 {0} 未安裝
notification.content.using.path.to.cargo=有效 Cargo 路徑\: {0}
notification.content.wasm.pack=wasm-pack
notification.failed.to.load.cargo.changes=建置失敗
notification.failed.to.load.cargo.changes.with.settings=建置失敗\n當您在 Cargo.toml 中鍵入時，Cargo 更改將自動重新載入。<a href\="disable.auto.reload">停用自動重新載入</a>
notification.file.not.belong.to.cargo.project=該檔案不屬於已知的 Cargo 專案
notification.group.rust=Rust
notification.group.rust.updates=Rust 更新
notification.group.rustfmt=Rustfmt
notification.group.toml=TOML
notification.invalid.stdlib.source.path=無效的 Rust 標準庫源路徑\: `{0}`
notification.load.cargo.change.with.settings=當您在 Cargo.toml 中鍵入時，Cargo 更改將自動重新載入。<a href\="disable.auto.reload">停用自動重新載入</a>
notification.navigation.to.implementations=您無法在索引更新期間導覽到實作
notification.no.cargo.projects.found=專案未與 Cargo.toml 檔案關聯
notification.no.toolchain.configured=未組態 Rust 工具鏈
notification.run.tests.as.root.unix=不支持使用 root 權限執行測試
notification.run.tests.as.root.windows=不支持使用管理員權限執行測試
notification.rustfmt.show.details.in.console=在主控台中顯示詳細資訊
notification.successful.cargo.sync.with.settings=建置成功\n當您在 Cargo.toml 中鍵入時，Cargo 更改將自動重新載入。<a href\="disable.auto.reload">停用自動重新載入</a>
notification.title.code.code.not.installed=未安裝 Crate `{0}`
notification.title.debugger=偵錯器
notification.title.potentially.inconsistent.build.test.results=建置/測試結果可能不一致
notification.title.rustfmt=Rustfmt
notification.title.rustfmt.error=Rustfmt 錯誤
notification.title.share.feedback.about.rustrover=分享有關 RustRover 的反饋
off=關閉
offset.from.the.local.time.to.utc.with.seconds.09.30.00=(+09\:30\:00)本地時間與 UTC 的偏移，帶秒。
offset.from.the.local.time.to.utc.with.utc.being.0000=(+0930)本地時間與 UTC 的偏移。
offset.from.the.local.time.to.utc.without.minutes.09=(+09)本地時間與 UTC 的偏移，不帶分鐘。
on=開啟
optimize.imports.fix=最佳化 import
or.patterns.syntax=or 模式語法
parameters=參數\:
parsing.error.expected=應為 `{0}`
parsing.error.expected.got=應為 `;`，實際為 `{0}`
parsing.error.macro.argument.expected.got=應為<巨集實參>，實際為 `{0}`
parsing.only.same.as.z.but.allows.minutes.to.be.missing.or.present=(+09)僅解析\: 與 %z 相同，但允許分鐘數缺失或存在。
popular.crates.import.paste.dialog.always.add=始終新增
popular.crates.import.paste.dialog.cancel=不
popular.crates.import.paste.dialog.explanation=<html>貼上的程式碼包含以下 crate 的匯入。<br/>是否將它們新增到 Cargo.toml?</html>
popular.crates.import.paste.dialog.never.add=從不新增
popular.crates.import.paste.dialog.title=新增 crate
popup.title.choose.module.declaration=選擇模組宣告
popup.title.choose.scope.to.introduce.constant=選擇取代 `{0}` 的新常數的作用域
popup.title.first.level.expansion=`{0}` 的一級展開
popup.title.item.to.import=要匯入的條目
popup.title.macro=`{0}\!` 巨集
popup.title.recursive.expansion=`{0}` 的遞迴展開
popup.title.rename.label=標籤
popup.title.value.used.after.being.moved=Value Used After Being Moved
previous.command.is.still.running.please.wait.or.press.ctrl.c.in.console.to.interrupt=上一個指令仍在執行。請稍候，或在主控台中按 Ctrl+C 以中斷執行。
println.usage=`println\!` 巨集用法
private=不公開
profiler.attach.default.group.title=原生
progress.text.building=正在建置…
progress.text.building1=正在建置…
progress.text.connecting.to.console=正在連線 Rust REPL…
progress.text.getting.rust.stdlib=正在檢索 Rust stdlib
progress.text.getting.toolchain.version=正在檢索工具鏈版本
progress.text.info=資訊\:
progress.text.installing.using.cargo=正在通過 Cargo 安裝…
progress.text.preparing.resolve.data=正在為名稱解析準備資料…
progress.text.save.macro.expansions=正在儲存巨集展開…
progress.text.updating.workspace.info=正在更新工作區資訊
progress.text.waiting.for.current.build.to.finish=正在等待當前建置完成…
progress.title.analyzing.project.with=正在使用 {0} 分析專案
progress.title.build=建置
progress.title.building=正在建置
progress.title.building.cargo.project=正在建置 Cargo 專案
progress.title.checking.if.installed=正在檢查 {0} 是否已安裝
progress.title.checking.if.toolchain.supported=正在檢查工具鏈是否受支援
progress.title.choice.recursive.single.step.expansion.progress=正在進行{0, choice, 0\#遞迴|1\#單步}展開
progress.title.cleaning.outdated.macros=正在移除過時的巨集
progress.title.connecting.to.console=正在連線到 REPL 主控台
progress.title.expanding.rust.macros=正在展開 Rust 巨集
progress.title.generating.cargo.project=正在生成 Cargo 專案
progress.title.getting.environment.variables=正在檢索環境變數
progress.title.getting.installed.distributions=正在檢索已安裝的分發版
progress.title.installing=正在安裝 {0}
progress.title.installing2=正在安裝 {0}
progress.title.loading.cargo.registry.index=正在載入 Cargo 註冊表索引
progress.title.loading.coverage.data=正在載入覆蓋率資料
progress.title.preparing.remote.environment=正在準備遠端環境
progress.title.reformatting.cargo.project.with.rustfmt=正在使用 Rustfmt 重新格式化 Cargo 專案
progress.title.reloading.cargo.projects=正在重新載入 Cargo 專案
progress.title.restarting.console=正在重新啟動 REPL 主控台
public=公開
quick.doc.macro.expansion=巨集展開
radio.inline.all.keep.method=全部內聯並保留方法
radio.inline.all.references.keep=內聯所有參照並保留 `{0}`
radio.inline.all.remove.type.alias=全部內聯並移除類型別名
radio.inline.this.only.keep=僅內聯此條目並保留 `{0}`
radio.inline.this.only.keep.type.alias=僅內聯此條目並保留類型別名
raw.address.of.syntax=raw-address-of 語法
redundant.else=冗餘的 `else`
refactoring.change.signature.error.cfg.disabled.parameters=無法更改簽名\: 該函式具有 cfg 停用的參數
refactoring.change.signature.name=更改簽名
refactoring.change.signature.name.conflict=名稱 `{0}` 與 `{1}` 中的現有條目衝突
refactoring.change.signature.refactor.super.function=方法 `{0}` 實作特徵 `{1}` 的基方法。是否要重構基方法?
refactoring.change.signature.visibility.conflict=重構後，該函式將在 `{0}` 中不可見
resolve.context.promoter.header=目標基礎架構小工具
resolve.context.promoter.message=使用此小工具更改當前目標基礎架構
resolve.contexts.linemarker.tooltip=組態目標架構
resolve.contexts.popup.footer=僅為所選架構解析程式碼
resolve.contexts.popup.header=可用的目標架構
resolve.contexts.popup.tooltip=只有以 ''{0}'' 為目標的原始碼正在被解析。
resolve.contexts.widget.undefined=<選擇架構>
resolve.contexts.widget.undefined.tooltip=選擇目標架構允許 IDE 相應地解析專案原始碼。
resolve.pasted.references.command.name=解析貼上的參照
resolve.pasted.references.indicator.text=正在解析貼上的參照
revert=還原
revert.applied.imports.command.name=移除新增的 Import
run.rustfmt=執行 rustfmt
run.target.build.arguments.comment=在停用<b>在目標上建置</b>選項的情況下，`cargo build` 指令的其他實參
run.target.build.arguments.label=其他建置實參\:
run.target.cargo.executable.path.label=Cargo 可執行檔案\:
run.target.cargo.executable.version.label=Cargo 版本\:
run.target.rustc.executable.path.label=Rustc 可執行檔案\:
run.target.rustc.executable.version.label=Rustc 版本\:
runs.cargo.command=執行 Cargo 指令
runs.wasm.pack.command=執行 wasm-pack 指令
rust=Rust
rust.1.70.0.stable=Rust 1.70.0 穩定版
rust.cargo.toml=Rust/Cargo.toml
rust.checkin.factory.fmt.commit.anyway.question=是否仍要提交?
rust.checkin.factory.fmt.failed.message=無法執行 Rusfmt
rust.checkin.factory.fmt.header.message=Rustfmt 無法格式化 `{0}`
rust.checkin.factory.fmt.rustfmt.not.installed.message=Rustfmt 未安裝
rust.code.vision.implementation.hint={0,choice, 1\#1 個實作|2\#{0,number} 個實作}
rust.code.vision.overrides.hint={0,choice, 1\#1 個覆寫|2\#{0,number} 個覆寫}
rust.code.vision.usage.hint={0,choice, 0\#無用法|1\#1 個用法|2\#{0,number} 個用法}
rust.compiler=Rust 編譯器
rust.consoles=Rust 主控台
rust.debugger.renderers.bundled.item=捆綁呈現器
rust.debugger.renderers.compiler.item=Rust 編譯器的呈現器
rust.debugger.renderers.none.item=沒有呈現器
rust.external.linter=Rust 外部 linter
rust.external.linter.cargo.check.item=Cargo Check
rust.external.linter.clippy.item=Clippy
rust.file=Rust 檔案
rust.module=Rust 模組
rust.repl=Rust REPL
rustc.bootstrap.warning=為了支援 {0}，IDE 使用 {2} 環境變數執行 {1}，這很少會導致建置/測試結果不一致。{3} 您可以通過{4}避免潛在的不一致。
rustfmt.console.toolwindow.display.name=Rustfmt 日誌
rustfmt.promoter.enable.message=預設啟用
rustfmt.promoter.message=<html>{0} 支援使用 Rustfmt 進行整個檔案格式化<br/>{1}</html>
rustup.could.not.amend.shell.profile=<html>無法寫入 rcfile\:<br><code>{0}</code><br><br>請手動將以下行新增到您的 rcfile\:<br><code>. "$HOME/.cargo/env"</code></html>
rustup.could.not.amend.shell.profile.title=無法修正 Shell 組態檔案
rustup.failed.to.install.exit.code=退出程式碼 {0}
rustup.failed.to.install.timed.out=安裝超時
rustup.failed.to.install.title=無法安裝 Rustup
rustup.failed.to.start.installation=無法啟動 Rustup 安裝
rustup.installation.has.been.cancelled.title=Rustup 安裝已取消
rustup.installer.downloading=正在下載 {0}
rustup.installer.running=正在執行 {0}
rustup.installer.vs.question=Rust 需要鏈接器和 Windows API 庫。\n\n您可以通過 Visual Studio Community 安裝程序(對個人、學術用途和開源免費)安裝這些組件。\n\n要繼續嗎?
rustup.installer.vs.question.title=Rust Visual C++ 先決條件
rustup.some.installed.components.might.get.inconsistent.after.cancellation=取消之前安裝的 Rustup 組件的執行可能不一致。
rustup.try.to.install.manually=嘗試從 https\://rustup.rs 手動安裝 Rustup。
same.as.d.but.space.padded.8=( 8)與 %d 相同，但用空格填充。
same.as.h.but.space.padded.same.as.h=( 0)與 %H 相同，但用空格填充。與 %_H 相同。
same.as.i.but.space.padded.same.as.i=(12)與 %I 相同，但用空格填充。與 %_I 相同。
same.as.u.but.uses.the.week.number.in.iso.8601.week.date.01.53=(27)與 %U 相同，但使用 ISO 8601 周日期中的周數字(01?53)。
same.as.u.but.week.1.starts.with.the.first.monday.in.that.year.instead=(27)與 %U 相同，但第 1 周從該年的第一個星期一開始。
same.as.y.but.uses.the.year.number.in.iso.8601.week.date=(01)與 %y 相同，但使用 ISO 8601 周日期中的年份數字。
same.as.y.but.uses.the.year.number.in.iso.8601.week.date.2001=(2001)與 %Y 相同，但使用 ISO 8601 周日期中的年份數字。
same.as.z.but.with.a.colon=(+09\:30)與 %z 相同，但帶有冒號。
second.number.00.60.zero.padded.to.2.digits=(60)秒數字(00?60)，在前面填充零，變成 2 位數。
separator.items.to.move=要移動的條目
separator.members.to.form.trait=形成特徵的成員
settings.rust.add.crates.dependencies.on.paste=在貼上時新增 crate 相依項\:
settings.rust.auto.import.exclude.comment=像在 <code>use</code> 宣告中一樣指定每個路徑。如果要對路徑中包含給定前綴的所有條目停用自動匯入，請將 <code>\:\:*</code> 新增到路徑。排除特徵時，指定僅對特徵方法還是同時對特徵名稱停用自動匯入。請注意，<code>use</code> 宣告會覆蓋這些設定。
settings.rust.auto.import.exclude.label=從自動匯入和補全中排除\:
settings.rust.auto.import.on.completion=補全時匯入作用域外的條目
settings.rust.auto.import.on.paste=貼上時插入 import
settings.rust.auto.import.show.popup=顯示 import 彈出視窗
settings.rust.auto.import.title=Rust
settings.rust.cargo.auto.update.project.label=每當 Cargo.toml 更改時自動更新專案
settings.rust.cargo.compile.all.targets.comment=將 <b>--target-all</b> 選項傳遞至 <b>cargo build</b>/<b>check</b>
settings.rust.cargo.compile.all.targets.label=盡可能編譯所有專案目標
settings.rust.cargo.moved.label=Cargo 設定已移動到“建置、執行、部署 | 建置工具 | Cargo”
settings.rust.cargo.name=Cargo
settings.rust.cargo.offline.mode.comment=將 <b>--offline</b> 選項傳遞至 Cargo 指令以避免網絡請求
settings.rust.cargo.offline.mode.label=脫機模式
settings.rust.cargo.show.first.error.label=當建置失敗時，自動在編輯器中顯示第一個錯誤
settings.rust.code.style.align.return.type=將返回值類型與函式參數對齊
settings.rust.code.style.align.where.clause=將 `where` 子句與函式參數對齊
settings.rust.code.style.align.where.clause.bounds=對齊 `where` 子句邊界
settings.rust.code.style.around.associated.type.bindings=關聯類型綁定周圍
settings.rust.code.style.between.declarations=宣告之間\:
settings.rust.code.style.end.of.line.comments.on.the.same.line=Preserve end of line comments on the same line
settings.rust.code.style.indent.where.clause=縮排 'where' 子句
settings.rust.code.style.match.expressions.in.one.line=在一行中符合表達式
settings.rust.code.style.name=Rust
settings.rust.code.style.punctuation=標點
settings.rust.color.associated.function.call=函式//關聯函式呼叫
settings.rust.color.associated.function.declaration=函式//關聯函式宣告
settings.rust.color.attribute=特性
settings.rust.color.char=文字//字元
settings.rust.color.conditionally.disabled.code=有條件停用的程式碼
settings.rust.color.const.parameter=參數//const 參數
settings.rust.color.constant=變數//常數
settings.rust.color.crate=類型//Crate
settings.rust.color.enum=類型//枚舉
settings.rust.color.enum.variant=類型//枚舉變體
settings.rust.color.field=變數//欄位
settings.rust.color.format.parameter=文字//字串//格式參數
settings.rust.color.format.specifier=文字//字串//格式參數內的格式說明符
settings.rust.color.function.call=函式//函式呼叫
settings.rust.color.function.declaration=函式//函式宣告
settings.rust.color.generated.items=由巨集生成的條目
settings.rust.color.invalid.escape.sequence=文字//字串//轉義序列//無效
settings.rust.color.keyword=關鍵字//關鍵字
settings.rust.color.keyword.unsafe=關鍵字//unsafe
settings.rust.color.lifetime=參數//生命周期
settings.rust.color.macro=函式//巨集
settings.rust.color.method.call=函式//方法呼叫
settings.rust.color.method.declaration=函式//方法宣告
settings.rust.color.module=類型//模組
settings.rust.color.mutable.binding=變數//可變綁定
settings.rust.color.mutable.parameter=參數//可變參數
settings.rust.color.number=文字//數字
settings.rust.color.operation.sign=大括號和運算符//運算符號
settings.rust.color.parameter=參數//參數
settings.rust.color.primitive=類型//基元
settings.rust.color.question.mark=大括號和運算符/? 運算符
settings.rust.color.rustdoc.bold=Rustdoc//粗體文本
settings.rust.color.rustdoc.code=Rustdoc//程式碼
settings.rust.color.rustdoc.comment=Rustdoc//註釋
settings.rust.color.rustdoc.heading=Rustdoc//標題
settings.rust.color.rustdoc.italic=Rustdoc//斜體文本
settings.rust.color.rustdoc.link=Rustdoc //鏈接
settings.rust.color.scheme.title=Rust
settings.rust.color.self.parameter=參數//Self 參數
settings.rust.color.static=變數//static
settings.rust.color.static.mutable=變數//可變 static
settings.rust.color.string=文字//字串//字串
settings.rust.color.struct=類型//結構
settings.rust.color.trait=類型//特徵
settings.rust.color.type.alias=類型//類型別名
settings.rust.color.type.parameter=參數//類型參數
settings.rust.color.union=類型//聯合
settings.rust.color.unsafe.code=unsafe 程式碼
settings.rust.color.valid.escape.sequence=文字//字串//轉義序列//有效
settings.rust.color.variables.default=變數//預設值
settings.rust.completion.suggest.out.of.scope.items=建議作用域外的條目
settings.rust.completion.title=Rust
settings.rust.external.linters.additional.arguments.comment=<b>cargo check</b> / <b>cargo clippy</b> 的其他實參
settings.rust.external.linters.additional.arguments.label=其他實參\:
settings.rust.external.linters.channel.label=通道\:
settings.rust.external.linters.name=外部 Linter
settings.rust.external.linters.on.the.fly.comment=新增基於外部 linter 結果的程式碼醒目提示顯示。可能會影響 IDE 性能。
settings.rust.external.linters.on.the.fly.label=即時執行外部 linter
settings.rust.external.linters.tool.comment=執行其他程式碼分析
settings.rust.external.linters.tool.label=外部工具\:
settings.rust.folding.one.line.methods.checkbox=一行方法
settings.rust.folding.title=Rust
settings.rust.inlay.hints.for=顯示以下項的提示\:
settings.rust.inlay.hints.for.closures=閉包
settings.rust.inlay.hints.for.exclusive.range.expressions=獨佔範圍表達式
settings.rust.inlay.hints.for.exclusive.range.patterns=獨佔範圍模式
settings.rust.inlay.hints.for.iterators=迭代器作為 `impl Iterator<...>`
settings.rust.inlay.hints.for.loop.variables=迴圈變數
settings.rust.inlay.hints.for.obvious.types=明顯類型
settings.rust.inlay.hints.for.same.consecutive.types=相同的連續類型
settings.rust.inlay.hints.for.type.placeholders=類型佔位符
settings.rust.inlay.hints.for.variables=變數
settings.rust.inlay.hints.title.method.chains=方法鏈
settings.rust.inlay.hints.title.types=類型
settings.rust.inlay.hints.title.values=值
settings.rust.inlay.parameter.hints.only.smart=僅智能提示
settings.rust.rustfmt.actions.on.save=在儲存時組態動作…
settings.rust.rustfmt.additional.arguments.comment=<b>rustfmt</b> / <b>cargo fmt</b> 的其他實參
settings.rust.rustfmt.additional.arguments.label=其他實參\:
settings.rust.rustfmt.builtin.formatter.label=使用 Rustfmt 代替內建格式化程序
settings.rust.rustfmt.builtin.formatter.label.comment=Rustfmt 將僅用於格式化整個檔案。對於程式碼段，IDE 將切換到內建格式化程序。
settings.rust.rustfmt.channel.label=通道\:
settings.rust.rustfmt.name=Rustfmt
settings.rust.rustup.install.rustup.dialog.title=安裝 Rustup
settings.rust.rustup.install.rustup.link=安裝 Rustup
settings.rust.toolchain.download.stdlib.dialog.title=正在下載 Rust 標準庫
settings.rust.toolchain.download.stdlib.link=通過 Rustup 下載
settings.rust.toolchain.download.stdlib.progress.text=正在通過 Rustup 安裝…
settings.rust.toolchain.expand.macros.checkbox=展開巨集
settings.rust.toolchain.expand.macros.comment=啟用巨集呼叫的處理。這將允許巨集進行正確的名稱解析和類型推斷
settings.rust.toolchain.inject.rust.in.doc.comments.checkbox=將 Rust 語言注入文檔註釋
settings.rust.toolchain.invalid.toolchain.error.1=無效的工具鏈位置\: 在 {0} 中找不到 Cargo
settings.rust.toolchain.invalid.toolchain.error.2=未指定工具鏈位置
settings.rust.toolchain.location.label=工具鏈位置\:
settings.rust.toolchain.name=Rust
settings.rust.toolchain.not.applicable.version.text=不適用
settings.rust.toolchain.select.standard.library.dialog.title=指定 Rust 標準庫源的位置
settings.rust.toolchain.standard.library.label=標準庫\:
settings.rust.toolchain.version.label=工具鏈版本\:
signature=簽名\:
similar.to.3f.but.without.the.leading.dot.026=(026)類似於 %.3f，但沒有前導點。
similar.to.6f.but.without.the.leading.dot.026490=(026490)類似於 %.6f，但沒有前導點。
similar.to.9f.but.without.the.leading.dot.026490000=(026490000)類似於 %.9f，但沒有前導點。
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.3.026=(.026)類似於 .%f，但為左對齊，長度固定為 3。
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.6.026490=(.026490)類似於 .%f，但為左對齊，長度固定為 6。
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.9.026490000=(.026490000)類似於 .%f，但為左對齊，長度固定為 9。
similar.to.f.but.left.aligned.these.all.consume.the.leading.dot.026490=(.026490)類似於 .%f，但為左對齊。這些均使用前導點。
ssr.unsupported.replace.template=暫不支持取代
ssr.unsupported.search.template=搜尋模板包含不受支援的元素
start.function=`\#[start]` 函式
status.bar.text.rebuilt.defmap.for.in.ms=在 {1} 毫秒內為 `{0}` 重建了 DefMap
struct=結構
structs.deriving.default=派生 Default 的結構
structs.with.a.u8.field=具有 `u8` 欄位的結構
structure.view.show.macro.expanded=顯示巨集展開中的條目
structure.view.sort.visibility=按可見性排序
subslice.patterns=子切片模式
suffixes.on.tuple.index.are.invalid=元組索引不允許後綴
sunday.0.monday.1.saturday.6=(0)星期日 \= 0、星期一 \= 1、…、星期六 \= 6。
super.structs=super 結構
suspicious.assignment=可疑的賦值
system.notification.text.={0} 個{1}和 {2} 個{3}
system.notification.title.canceled={0}已取消
system.notification.title.failed={0}失敗
system.notification.title.finished={0}已完成
tab.title.error.running.console=執行 Rust REPL 時出錯
test=測試
text.conditionally.disabled.code=有條件停用的程式碼
text.use.my.e.mail.location.for.this.purpose=為此目的使用我的電子郵件和位置
the.0.tool.window.was.disabled.1.2=“{0}”工具視窗已停用。{1}{2}
the.fractional.seconds.in.nanoseconds.since.last.whole.second.026490000=(026490000)自上一整秒以來的小數秒(以納秒為單位)。
the.full.proleptic.gregorian.year.zero.padded.to.4.digits.2021=(2001)完整的外推格里年份，用零填充為 4 位數。
the.proleptic.gregorian.year.divided.by.100.zero.padded.to.2.digits.20=(20)外推格里年份除以 100，用零填充為 2 位數。
the.proleptic.gregorian.year.modulo.100.zero.padded.to.2.digits.01=(01)外推格里年份以 100 為模，在前面填充零，變成 2 位數。
to=到\:
too.many.characters.in.0=`{0}` 中的字元過多
toolchain.version.is.unknown.hardcoded.stdlib.structure.will.be.used=無法確定工具鏈版本。將改用硬編碼 stdlib 結構。
tooltip.cannot.cast.enum.with.non.exhaustive.variant.when.it.s.defined.in.another.crate=無法轉換具有非詳盡變體的枚舉，因為它是在另一個 crate 中定義的
tooltip.delimiters.should.be=使用 `(` 和 `)` 作為分隔符
tooltip.does.not.have.constant.size.known.at.compile.time=`{0}` 在編譯時沒有已知的常數大小
tooltip.following.are.possible.correct.uses=潛在的正確使用
tooltip.implements=實作
tooltip.in={0} `{2}` 中的{1}
tooltip.instead.using.suffixed.literal.1u8.0f32.etc.use.unsuffixed.version.etc=將帶後綴的文字(例如 `1u8`、`1.0f32`)取代為無後綴的版本(例如 `1`、`1.0`)
tooltip.must.be.defined.only.once.in.namespace.this=`{0}` can only be defined once in the `{1}` namespace of this {2}
tooltip.must.be.form=必須是以下形式
tooltip.overrides=覆寫
tooltip.project.directory.does.not.exist=專案目錄不存在
tooltip.project.needs.update=專案需要更新
tooltip.project.up.to.date=專案處於最新狀態
tooltip.target={0}目標 `{1}`
tooltip.this.accepted.in.current.edition.rust.but.hard.error.in.rust=此語法在 Rust 2018 版中可以接受，但在 Rust 2021 中無法編譯
tooltip.this.was.previously.accepted.by.compiler.but.being.phased.out.it.will.become.hard.error.in.future.release=此語法在較舊的編譯器版本中可以接受，但在即將推出的版本中將無法編譯.
tooltip.trait.not.implemented.for=沒有為 `{1}` 實作特徵 `{0}`
tooltip.valid.abis=有效的 ABI\: {0}
tooltip.visibility.restriction.with.module.path.should.start.with.in.keyword=使用 `in` 表示模組路徑中的可見性限制
toolwindow.stripe.RustCargo=Cargo
trait=特徵
try.macro.usage=`try\!` 巨集用法
type=類型
type.0=類型\: {0}
type2=類型
unable.to.run.debugger=無法執行偵錯器
unix.timestamp.the.number.of.seconds.since.1970.01.01.00.00.utc.994518299=(994518299) UNIX 時間戳，自 1970-01-01 00\:00 UTC 以來的秒數。
unreachable.patterns=不可到達的模式
unsafe.cstring.pointer=unsafe CString 指針
untrusted.project.notification.execution.error=無法執行任務\: 不受信任的 Cargo 專案
update.status.failed.hardcoded.stdlib=無法確定 stdlib 結構。將改用硬編碼的 stdlib 結構。
visibility=可見性\:
visibility.qualifier=可見性限定符
vs.exit.code.-1073720687=連線失敗
vs.exit.code.-1073741510=Microsoft Visual Studio 安裝程序已終止
vs.exit.code.1001=Visual Studio 安裝程序程序正在執行
vs.exit.code.1003=Visual Studio 正在使用中
vs.exit.code.1602=動作已被取消
vs.exit.code.1618=另一個安裝正在執行
vs.exit.code.1641=動作已成功完成，已啟動重啟
vs.exit.code.3010=動作已成功完成，但安裝需要重啟才能使用
vs.exit.code.5003=引導程序無法下載安裝程序
vs.exit.code.5004=動作已被取消
vs.exit.code.5005=引導程序命令行解析錯誤
vs.exit.code.5007=動作被阻止 - 計算機不符合要求
vs.exit.code.740=需要提升
vs.exit.code.8001=ARM 計算機檢查失敗
vs.exit.code.8002=背景下載預檢查失敗
vs.exit.code.8003=不受支援的可選故障
vs.exit.code.8004=目標目錄失敗
vs.exit.code.8005=驗證源有效負載故障
vs.exit.code.8006=Visual Studio 程序正在執行
vs.exit.code.else=退出程式碼 {0}
vs.failed.to.install.timed.out=超時
vs.failed.to.install.title=無法安裝 Visual Studio
vs.failed.to.start.installation=無法啟動 Visual Studio 安裝
vs.installation.has.been.cancelled.title=Visual Studio 安裝已被取消
vs.installer.downloading=正在下載 Visual Studio 安裝程序
vs.installer.running=正在執行 Visual Studio 安裝程序
vs.installer.title=Visual Studio 安裝程序
vs.installer.waiting=Visual Studio 安裝完成後，Rustup 將繼續
vs.some.installed.components.might.get.inconsistent.after.cancellation=取消後，某些已安裝的 Visual Studio 組件可能會變得不一致。
vs.try.to.install.manually=嘗試從 https\://visualstudio.microsoft.com 手動安裝 Visual Studio。
wasm.pack=wasm-pack
wasm.pack.command.run.configuration=wasm-pack 執行組態
wasm.pack.commands=wasm-pack 指令
week.number.starting.with.sunday.00.53.zero.padded.to.2.digits=(28)從星期日開始的周數字(00?53)，在前面填充零，變成 2 位數。
where.clauses.on.associated.types=關聯類型上的 `where` 子句
while.true.loop=`while true` 迴圈
year.month.day.format.iso.8601.same.as.y.m.d=(2001-07-08)年-月-日格式(ISO 8601)。與 %Y-%m-%d 相同。
yield.syntax=`yield` 語法

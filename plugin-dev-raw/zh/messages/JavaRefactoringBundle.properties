0.already.contains.field.1={0}已包含字段{1}.
0.already.contains.inner.class.named.1={0}已包含名為{1}的內部類.
0.already.has.parameter.named.1.use.this.name.anyway={0}已經有名為 ''{1}'' 的參數。\n\
仍然使用此名稱?
0.contains.call.with.null.argument.for.parameter.1={0} 包含帶有參數 {1} 的 null 實參的調用
0.implements.1={0}實現{1}。
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0}是{1},不能從{2}訪問.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0}方法是層次結構的一部分。您要刪除多個參數嗎？
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0}方法是層級的一部分。要刪除多個類型參數嗎？
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0}是一個接口.方法的實現將被添加到所有直接實現類.繼續進行嗎?
0.is.an.interface.that.has.no.implementing.classes={0}是一個接口.沒有實現類.
0.is.not.a.legal.java.identifier=''{0}''不是合法的java標識符
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0}不可以從{1}訪問。該方法調用中引入參數的值將不正確。
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}在聲明處未初始化。在接口中不允許這樣的字段。
0.is.not.static.it.cannot.be.moved.to.the.interface={0} 不為 static。不能將其移至接口
0.is.used.for.writing.in.1={0}是用來寫在{1}
0.refactoring.is.supported.only.for.final.fields=僅 final 字段支援{0}重構
0.upcasts.an.instance.of.1.to.2={0}向上轉型實例的{1}{2}.
0.uses.1.of.an.instance.of.a.2={0}{1}的使用的一個實例{2}.
0.uses.1.which.needs.class.instance={0}用{1},這需要的類實例.
0.uses.a.package.local.1={0}使用 package-private {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0}使用非 static {1}，後者不作為參數傳遞
0.will.be.inaccessible.from.1={0}將無法從{1}
0.will.become.inaccessible.from.1={0}將變得無法從{1}.
0.will.hide.renamed.1={0}將隱藏更名為{1}
0.will.no.longer.override.1={0}將不再重寫{1}
0.will.no.longer.be.record.component.accessor={0} 將不再是 {1} getter
0.will.no.longer.be.canonical.function Object() { [native code] }=將不再是規範構造函數
0.will.not.be.accessible.from.1.after.inlining={0}不可以從{1}在內聯
0.will.override.renamed.1={0}將覆蓋更名為{1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=Package-local 類 {0} 將不再可以從{1}訪問
accept.signature.change=接受簽名變更
add.object.as.a.parameter.to.constructors.with.name=將對象作為參數添加到具有以下名稱的構造函數(&O):
add.parameters.for.fields=添加字段參數(&F):
add.parameters.for.fields.to.constructors=向構造函數添加字段參數(&F):
all.candidate.variables.have.types.not.in.project=所有候選變量均含有不在項目中的類型
all.candidate.variables.have.unknown.types=所有的候選變量都未知類型
all.invocations.keep.the.method=內聯所有引用並保留方法(&E)
all.references.and.remove.super.class=內聯所有引用並移除類(&A)
all.references.and.remove.the.class=內聯所有引用並移除類(&A)
all.references.and.remove.the.field=內聯所有引用並刪除字段 (&A)
all.references.keep.field=內聯所有引用並保留字段(&E)
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=所有這些目錄將被移動，並且所有對 {0} 的引用將被更改。
analyze.and.replace.usages=分析和替換用法
analyze.module.conflicts=分析模塊衝突…
annotate.field.as.nonnls.checkbox=註釋字段作為 @NonNls (&F)
anonymous.class.text=匿名類
anonymous.to.inner.enum.constant.cannot.refactor.message=枚舉常量無法轉換為內部類
anonymousToInner.class.name.label.text=類名:
anonymousToInner.make.class.static.checkbox.text=將類設為 static(&S)
anonymousToInner.no.inner.class.name=需指定類名
anonymousToInner.parameters.panel.border.title=構造函數的參數
anonymousToInner.refactoring.name=轉換匿名為內部
auto.rename.module.dialog.description=將具有以下名稱的 Java 模塊重命名為:
auto.rename.module.dialog.title=重命名 Java 模塊
auto.rename.module.entity=Java 模塊
boolean.method.result=布爾方法的結果
can.t.restore.context.for.method.extraction=無法為方法提取恢復上下文
cannot.find.or.create.destination.directory=無法找到或創建目標目錄
cannot.introduce.field.in.interface=接口中不允許出現實例字段
cannot.introduce.field.in.record=記錄中不允許出現實例字段
cannot.move=無法移動
cannot.move.inner.class.0.into.itself=不能移動內部類{0}到本身.
cannot.move.package.into.itself=無法將軟件包移動到其自身
caret.position.warning.message=文本光標應置於要重構的字段、變量、方法或方法參數類型上
change.method.signature.action.name=更改方法簽名
change.signature.default.value.missing.warning.message=缺少默認值。方法調用將包含空值，而不是新的參數值。
change.signature.use.any.checkbox=使用任意變量(&U)
changeClassSignature.bad.value=錯誤 {0} 值: ''{1}'' 參數 ''{2}''
changeClassSignature.class.label.text=更改{0}的簽名
changeClassSignature.no.type.parameters=這個類不能有類型參數
changeClassSignature.parameters.panel.border.title=參數
changeClassSignature.refactoring.name=更改類簽名
changeClassSignature.already.contains.type.parameter=''{0}'' 已包含類型參數 ''{1}''
changeClassSignature.Type.parameter.can.not.be.primitive=類型參數不能為基元
changeSignature.bound.value.column=綁定值:
changeSignature.cannot.resolve.return.type=無法解析返回類型''{0}''。\n\
是否繼續?
changeSignature.default.value.column=默認值
changeSignature.exception.caller.chooser=選擇要傳遞新異常的方法
changeSignature.exceptions.panel.border.title=異常
changeSignature.exceptions.wont.propagate=遞歸傳播的異常的更改不會被執行
changeSignature.no.return.type=未指定返回類型
changeSignature.no.type.for.exception=指定一個類型給異常
changeSignature.no.type.for.parameter=指定參數 ''{1}'' 的 {0} 類型
changeSignature.not.throwable.type=錯誤的異常類型''{0}'',應繼承java.lang.Throwable
changeSignature.propagate.exceptions.title=傳播異常(&X)…
changeSignature.vararg.not.last=vararg 參數應當為方法簽名中的最後一個參數
changeSignature.wrong.return.type=錯誤的返回類型:''{0}''
changeSignature.wrong.type.for.exception=異常的錯誤類型:''{0}''
changeSignature.wrong.type.for.parameter=類型錯誤: 參數 ''{1}'' 的 ''{0}''
changeSignature.empty.caller.method.text=此處將顯示高亮顯示被調用方調用的調用方方法文本
changeSignature.empty.callee.method.text=此處將顯示被調用方方法文本
changeSignature.contract.converter.external.annotations=不支持外部註解的自動更新
changeSignature.contract.converter.mutation.contract=註解包含突變協定
changeSignature.contract.converter.definition.error=約定定義出錯: {0}
changeSignature.contract.converter.invalid.clause=約定子句 ''{0}'' 無效
changeSignature.contract.converter.parameter.removed=參數 ''{0}'' 已刪除，但是約定子句 ''{1}'' 依賴於此
changeSignature.contract.converter.invalid.return.reference=返回值中的引用無效: {0}
changeSignature.contract.converter.return.parameter.removed=參數 ''{0}'' 已刪除，但是約定子句 ''{1}'' 將其返回
changeSignature.contract.converter.can.not.update.annotation=@Contract 註解無法自動更新: {0}
changeSignature.contract.converter.inherited.annotation=註解繼承自基方法
changeSignature.use.any.var=使用任意變量。
checking.conflicts=正在檢查衝突…
choose.the.ones.you.want.to.be.deleted=選擇您想要的被刪除.
class.0.already.exists=類{0}已存在
class.0.is.not.accessible.from.target.1=類{0}是不可以從目標{1}
class.0.not.found=找不到類 {0}。
class.description=類{0}
class.does.not.exist.in.the.project=模塊中不存在類。要創建嗎?
class.does.not.have.base.classes.or.interfaces=類{0}沒有基類或接口.
class.does.not.have.implicit.default.function Object() { [native code] }=類{0}沒有隱式的預設構造函數.
class.has.been.successfully.created=已成功創建類{0}.
class.is.abstract={0}為 abstract。
class.is.final.warning.message=類 {0} 為 final
class.is.interface={0}是一個接口.
class.is.never.used=類從未使用
class.name.prompt=類名(&N):
collect.overloads=收集重載…
comments.elements.header=匹配項被發現在註釋、字符串和非標檔案{0}
function Object() { [native code] }.being.refactored.is.used.in.initializer.of.0=正在重構的構造函數在 {0} 的初始值設定項中使用。內部類 {1} 的非 static 工廠無法在此上下文中使用。生成的代碼將不會編譯。
function Object() { [native code] }.description=構造函數{0}
function Object() { [native code] }.with.builder.new.setter.prefix.dialog.message=新的 setter 前綴:
function Object() { [native code] }.with.builder.parameters.to.pass.to.the.builder.title=要傳遞到構建器的參數
function Object() { [native code] }.with.builder.rename.setters.prefix.action.name=重命名 Setter 前綴
convert.anonymous.to.inner.action.name=將匿名轉換成內部…
convert.local.to.field.title=將局部轉換為字段
convert.to.instance.method.title=轉換為實例方法
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=找不到實例方法的目標類: 所有引用的類型均不在項目中。
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=找不到實例方法的目標類: 所有引用的類型均未知。
convertToInstanceMethod.method.is.not.static=無法執行重構\n\
方法 {0} 不為 static
convertToInstanceMethod.no.default.ctor=還包含沒有預設構造函數的類。
convertToInstanceMethod.no.parameters.with.reference.type=不存在具有引用類型的參數。
convert.to.record.title=轉換為記錄類
convert.to.record.weakens.field.visibility={0} 是 {1}。\n\
創建特定 {2} 記錄訪問器將削弱可見性。
convert.to.record.weakens.accessor.visibility={0} 是 {1}。\n\
將其轉換為 {2} 記錄訪問器將削弱可見性。
convert.to.record.weakens.ctor.visibility={0} 是 {1}。\n\
將其轉換為 {2} 記錄規範構造函數將削弱可見性。
copy.class.clone.0.1=克隆{0}{1}
copy.class.copy.0.1=複製{0}{1}
copy.handler.clone.class=克隆類
copy.handler.copy.class=複製類
copy.handler.copy.class.with.dialog=複製類…
copy.handler.copy.classes.with.dialog=複製類…
copy.handler.is.not.available.during.indexing=編制索引期間無法複製類
current.class=當前類
dataflow.to.here.expand.progress=正在展開所有節點…{0}
dataflow.to.here.group.by.leaf.action.description=確定 null 是否可以流入此表達式
dataflow.to.here.group.by.leaf.action.text=按葉表達式空值分組{0, choice, 1#|2# (正在分析)}
dataflow.to.here.variable.dereferenced.tooltip=已取消引用變量
declaration.s.to.be.generified=聲明(s)是泛型{0}
declare.final=聲明 final(&F)
declare.generated.annotations=生成註解(&G)
declare.static.checkbox=聲明 static(&S)
declare.static.pass.fields.checkbox=聲明 static (作為參數傳遞字段)(&S)
declare.var.type=聲明變量類型(&V)
declare.varargs.checkbox=聲明 vararg(&A)
default.visibility.border.title=預設可見性
delete.variable.declaration=刪除變量聲明 (&D)
destination.directory.does.not.correspond.to.any.package=目標目錄不對應於任何軟件包
destination.package=目標軟件包(&P):
different.name.expected=應為不同名稱
directory.0.already.contains.1.named.2=目錄已經包含了{0}{1}命名為"{2}"
directory.0.already.contains.a.file.named.1=目錄{0}已經包含一個檔案命名為"{1}"
do.not.replace=不要替換 (&N)
do.not.show.this.message.in.the.future=以後不再顯示此消息 (&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=您想要使用協變返回類型處理覆蓋方法?
dont.move.to.another.source.folder.option=不移動到另一個源資料夾(&D)
edit.migration.entry.title=編輯類/軟件包遷移規則
element.will.no.longer.be.accessible={0}將不再可以從{1}
encapsulate.fields..encapsulated.fields.visibility.border.title=封裝字段的可見性
encapsulate.fields..package.local.radio=Package local(&C)
encapsulate.fields.accessors.visibility.border.title=訪問器可見性
encapsulate.fields.command.name=封裝字段在{0}
encapsulate.fields.encapsulate.border.title=封裝
encapsulate.fields.existed.accessor.hidden={0} 已經存在，將被生成的訪問器隱藏
encapsulate.fields.existed.accessor.hides.generated={0} 已經存在，將為 {1} 隱藏生成的訪問器
encapsulate.fields.expression.type.is.used=使用結果類型時，無法繼續使用後綴/前綴表達式
encapsulate.fields.field.column.name=字段
encapsulate.fields.fields.to.be.encapsulated=字段封裝
encapsulate.fields.fields.to.encapsulate.border.title=字段來封裝
encapsulate.fields.get.access.checkbox=獲取訪問權限 (&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=那已經是一個方法不同於{0}{1}的getter只返回類型.
encapsulate.fields.no.target=未找到要封裝的內容
encapsulate.fields.nothing.todo.warning.message=類具有要封裝的字段
encapsulate.fields.private.radio=私有(&I)
encapsulate.fields.protected.radio=protected(&T)
encapsulate.fields.refactoring.cannot.be.applied.to.interface=封裝字段重構不能應用到接口
encapsulate.fields.set.access.checkbox=設定訪問權限 (&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=那已經是一個方法{0},{1}有別於setter由返回類型只有.
encapsulate.fields.title=封裝字段
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=使用訪問器即使字段是可訪問的
entity.name.function Object() { [native code] }.parameter=參數
entity.name.inheritor=繼承者
entity.name.test=測試
entity.name.variable=變量
entity.name.accessor=訪問器
enum.description=枚舉 {0}
error.cannot.resolve=無法解析 {0}
error.incorrect.data=不正確的數據
error.not.supported.for.jsp={0}重構不支持JSP
error.not.supported.for.local=局部類不支持 {0} 重構
error.not.supported.for.package.info={0}重構不支持 package-info.java
error.wrong.caret.position.anonymous=文本光標應置於要重構的匿名類內
error.wrong.caret.position.function Object() { [native code] }=文本光標應置於要重構的構造函數內
error.wrong.caret.position.local.or.expression.name=文本光標應置於要重構的局部變量或表達式的名稱處
error.wrong.caret.position.method=文本光標應置於要重構的方法內
error.wrong.name.input=錯誤的名稱:{0}
expand.method.reference.warning=方法用於方法引用。繼續將導致轉換為 lambda 表達式
expression.result=表達式結果
extract.chained.function Object() { [native code] }.checkbox=提取鏈接構造函數 (&C)
extract.delegate.as.enum.checkbox=提取為枚舉
extract.delegate.create.nested.checkbox=創建嵌套類
extract.delegate.generate.accessors.checkbox=生成訪問器
extract.delegate.unable.create.warning.message=無法創建包含給定名稱的類
extract.method.control.flow.analysis.failed=代碼包含語法錯誤。無法執行必要的分析。
extract.method.error.prefix=無法提取方法。
extract.method.error.class.outside.used=局部類在所選塊之外使用。
extract.method.error.class.outside.defined=局部類在所選塊之外定義。
extract.method.error.many.outputs=有多個變量要返回。
extract.method.error.many.exits=有多個出口點。
extract.method.error.many.finals=存在對 final 字段的賦值。
extract.method.error.variable.in.expression=所選表達式內有一個要返回的變量。
extract.method.error.class.not.found=所選塊應當是 java 類的一部分。
extract.method.error.invalid.name=無效方法名稱
extract.method.error.method.conflict=具有相同簽名的方法已存在
extract.method.object.anonymous.make.varargs.option=設為 vararg(&V)
extract.method.object.class.name=類名(&C):
extract.method.object.create.anonymous.class=創建匿名類(&A)
extract.method.object.create.inner.class=創建內部類(&I)
extract.method.object.inner.class.visibility=可見性:
extract.method.object.inner.make.static.option=設為 static(&S)
extract.method.object.inner.make.varargs.option=設為 vararg(&V)
extract.method.object.inner.visibility.package.local=package local(&K)
extract.method.object.inner.visibility.private=private(&V)
extract.method.object.inner.visibility.protected=protected(&O)
extract.method.object.inner.visibility.public=public(&B)
extract.method.object.method.name=方法名稱(&M):
extract.method.object.parameters=參數
extract.method.object.signature.preview=簽名預覽
extract.method.object.suggestion=是否要提取方法對象?
extract.parameters.to.replace.duplicates=提取參數以替換重複項
extract.subclass.command=提取子類
extractSuper.rename.original.class.to=重命名原始類到: (&R)
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=工廠方法名稱:
failed.to.re.run.refactoring=無法重新運行重構
field.0.is.already.defined.in.the.1=字段{0}已經定義在{1}.
field.0.is.never.used=字段{0}從未使用過
field.0.is.not.accessible=字段{0}是不可以從{1}
field.0.will.hide.field.1.of.the.base.class=字段{0}將隱藏基類 {2} 的字段{1}.
field.declaration.radio=字段聲明 (&D)
field.description=字段{0}
field.name=字段名稱 (&F):
fields.to.be.refactored.should.belong.to.the.same.class=重構的字段應該屬於同一個類.
functional.interface.broken=函數表達式要求功能界面準確的一種方法
generate.getter.for.delegated.component=為委派成員生成getter (&G)
generate.module.descriptors.analysing.message=正在分析依賴關係
generate.module.descriptors.build.required.message=無法生成模塊描述符，因為該項目尚未構建
generate.module.descriptors.collecting.message=正在收集依賴關係
generate.module.descriptors.command.title=生成 module-info 描述符
generate.module.descriptors.no.suitable.modules.message=未找到可能包含模塊信息的模塊
generate.module.descriptors.preparing.message=正在準備代碼
generate.module.descriptors.rebuild.message=為了提高依賴關係計算的準確性，需要構建該項目。\n\
在生成模塊信息描述符之前開始構建?
generate.module.descriptors.scanning.message=正在掃描編譯器輸出
generate.module.descriptors.title=生成模塊描述符
generify.title=將原始類型轉換為泛型
getter.and.setter.methods.found.for.the.field.0=Getter和setter方法發現的領域{0}.{1}它們嗎?
getter.method.found.for.the.field.0=Getter方法發現田野{0}.{1}getter嗎?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}沒有發現任何副本
ignore.button=忽略
implicit.last.parameter.warning=隱式最後一個參數不應刪除
infer.class.type.args.warning=無法推斷類類型實參。繼續時，將創建原始 {0}
information.title=信息
initializer.for.variable.cannot.be.a.constant.initializer=變量的 {0} 初始值設定項不能是常量初始值設定項
inline.action.name=內聯
inline.anonymous.conflict.progress=正在搜尋類“{0}”繼承者…
inline.class.elements.header=類內聯
inline.conflicts.progress=檢查是否可以內聯…
inline.constant.field.not.supported.for.enum.constants=枚舉常量不支持 {0}
inline.element.unknown.header=未知元素
inline.field.action.name=內聯字段…
inline.field.command=內聯場{0}
inline.field.elements.header=場內聯
inline.field.field.name.label=字段 {0}
inline.field.field.occurrences=字段 {0} 有 {1} {1, choice, 1#匹配項|2#匹配項}
inline.field.title=內聯領域
inline.field.used.in.javadoc=已內聯字段用於 javadoc
inline.field.used.in.reflection=已內聯字段以反射形式使用
inline.field.initializer.is.not.accessible=字段初始值設定項引用無法在 {1} 中訪問的 {0}
inline.local.unable.try.catch.warning.message=無法在 try/catch 語句外內聯
inline.local.used.as.resource.cannot.refactor.message=變量用作資源引用
inline.local.variable.declared.outside.cannot.refactor.message=變量在代碼塊外聲明
inline.method.calls.not.accessible.in=已內聯方法調用將不會在 {1} 中訪問的 {0}
inline.method.calls.not.accessible.on.qualifier=已內聯方法調用在限定符 {1} 上將無法訪問的 {0}
inline.method.checking.tail.calls.progress=檢查尾調用用法
inline.method.elements.header=方法內聯
inline.method.method.label=方法 {0}
inline.method.method.occurrences=方法 {0} 有 {1} {1, choice, 1#匹配項|2#匹配項}
inline.method.multiline.method.in.ctor.call=內聯不能在構造函數調用中應用於多行方法
inline.method.multiline.method.in.loop.condition=內聯不能在循環條件中應用於多行方法
inline.method.object.action.name=內聯對象
inline.method.object.suggestion.message=要內聯對象和後續調用嗎?
inline.method.qualifier.usage.side.effect=已內聯方法用於方法引用，限定符具有副作用
inline.method.used.in.javadoc=已內聯方法用於 javadoc
inline.method.used.in.reflection=已內聯方法以反射形式使用
inline.parameter.action.name=內聯參數…
inline.parameter.cannot.find.initializer.warning.message=無法為參數找到常量初始值設定項
inline.parameter.confirmation=將參數 ''{0}'' 與初始值設定項 ''{1}'' 內聯?
inline.parameter.error.hierarchy=內聯參數不支持當方法是一個繼承層次結構的一部分
inline.parameter.error.non.project.method=非項目方法不支持內聯
inline.parameter.error.varargs=不支持內聯 vararg 參數
inline.parameter.dependency.unavailable.in.static.method=參數初始值設定項依賴 {0}，其在 static 方法中不可用
inline.parameter.depends.on.caller.parameter=參數初始值設定項依賴調用方參數
inline.parameter.depends.on.non.static=參數初始值設定項依賴其他類的非 static 成員
inline.parameter.depends.on.non.static.class=參數初始值設定項依賴非 static 類，其在 static 方法中不可用
inline.parameter.depends.on.this.inside.static.method=參數初始值設定項依賴於此，其在 static 方法中不可用
inline.parameter.depends.on.unavailable.element.inside.method=參數初始值設定項依賴 {0}，其在方法內部不可用並且無法內聯
inline.parameter.depends.on.unavailable.value=參數初始值設定項依賴方法內部不可用的值
inline.parameter.initializer.depends.on.inaccessible.value=參數初始值設定項依賴方法內部不可用且無法內聯的值
inline.parameter.method.usages.progress=正在搜尋方法用法
inline.parameter.no.usages.warning.message=方法沒有用法
inline.parameter.not.accessible.warning.message=在方法體內無法訪問常量初始值設定項
inline.parameter.refactoring=內聯參數
inline.parameter.replace.with.local.checkbox=替換為局部變量(e)\r (&E)
inline.parameter.write.usages.warning.message=不支持具有寫入用法的內聯參數
inline.pattern.variable.title=內聯模式變量
inline.super.class=內聯超類
inline.super.class.action.name=內聯超類…
inline.super.class.label=類{0}
inline.super.ctor.can.be.replaced=構造函數 {0} 可以替換為 {1} 的任意一個
inline.super.doc.panel.title=已內聯成員的 JavaDoc
inline.super.expr.can.be.replaced={0} 可以替換為 {1} 的任意一個
inline.super.no.anonymous.class=無法內聯到匿名類中。
inline.super.no.ctor=找不到構造函數匹配的 super
inline.super.no.inner.class=無法內聯到內部類中。將 ''{0}'' 移動到上一級別
inline.super.no.substitution=找不到 {0} 的一致替換。應為 ''{1}''，但找到的為 ''{2}''。
inline.super.no.return.in.super.ctor=當 return 語句中斷超級構造函數的執行流時，不支持重構
inline.super.non.project.class.warning.message=無法內聯非項目類
inline.super.static.import.can.be.replaced=靜態導入可以替換為 {0} 的任意一個
inline.super.target.instead.of.super.class=目標類型的實例被傳遞到期望超類的位置。
inline.super.type.element.can.be.replaced={0} 可以替換為 {1} 的任意一個
inline.super.type.params.differ=類型參數在 {0} 中不一致。應為 {1}，但找到的為 {2}
inline.super.unknown.type=類型未知
inline.to.anonymous.border.title=內聯
inline.to.anonymous.command.name=內聯類{0}
inline.to.anonymous.name.label=類{0}
inline.to.anonymous.no.abstract=abstract 類不能被內聯
inline.to.anonymous.no.ctor.calls=因為在主體內部對構造函數的調用，無法內聯類
inline.to.anonymous.no.get.class.calls=getClass() 調用的結果將被更改
inline.to.anonymous.no.method.calls=因為在主體內部對成員的調用，無法內聯類
inline.to.anonymous.no.multiple.interfaces=實現多個接口的類不能被內聯
inline.to.anonymous.no.superclass.and.interface=有超類和實現了接口的類不能被內聯
inline.to.anonymous.refactoring=內聯到匿名類
inline.vars.elements.header=變量以內聯
inlined.method.implements.method.from.0=內聯方法實現方法從{0}
inlined.method.overrides.method.from.0=從{0}內聯方法重寫方法
inlined.method.will.be.transformed.to.single.return.form=內聯方法將轉換為單個返回形式
inner.class.0.is.already.defined.in.class.1=內部類 {0} 已在類 {1} 中定義。\n\
仍然繼續?
inner.class.0.is.not.static=內部類 {0} 不為 static。\n\
僅 static 成員支援{1}重構。
inner.class.exists=名為''{0}''的內部類已經定義在類''{1}''中
inner.class.name=內部類名(&I):
instance.initializer.description=類 {0} 的實例初始值設定項
instances.casted.to.java.lang.object=實例轉換為java.lang.Object
instances.of.0.upcasted.to.1.were.found=實例的{0},{1}向上轉型被發現.如果您繼續下去,他們將被顯示在一個單獨的找到頁籤.
instances.upcasted.to.java.lang.object.found=實例向上轉型到java.lang.Object對象發現
instances.upcasted.to.object=向上轉型實例對象
interface.0.does.not.have.inheritors=接口{0}沒有繼承者.
interface.description=接口 {0}
interface.does.not.have.base.interfaces=接口{0}沒有基本接口.
interface.has.been.successfully.created=已成功創建接口{0}.
introduce.constant.enum.cb=提取為枚舉常量 (&E)
introduce.constant.field.of.type=常量(static final 字段)的類型(&T):
introduce.constant.introduce.to.class=提取到類(完全限定名稱)(&C):
introduce.constant.move.to.another.class.checkbox=移動到另一個類
introduce.constant.used.for.write.cannot.refactor.message=選定的表達式用於寫入
introduce.field.field.of.type=類型的字段: (&T)
introduce.field.static.field.of.type=static 字段的類型(&T):
introduce.functional.variable.pass.fields.checkbox=將字段作為參數傳遞(&F)
introduce.local.variable.to.reassign.title=選擇要重新分配的變量
introduce.parameter.command=正在將參數提取到{0}
introduce.parameter.convert.lambda=轉換為 lambda (&C)
introduce.parameter.duplicates.progress=搜尋方法重複項…
introduce.parameter.elements.header=正在將參數添加到方法
introduce.parameter.object.create.inner.class=創建內部類(&I)
introduce.parameter.object.create.new.class=創建新類(&C)
introduce.parameter.object.escalate.visibility.option=升級可見性(&E)
introduce.parameter.object.existing.class.name=名稱(&N)
introduce.parameter.object.generate.accessors.option=生成訪問器(&G)
introduce.parameter.object.inner.class.name=名稱(&N)
introduce.parameter.object.new.class.name=名稱(&N)
introduce.parameter.object.new.class.package.name=軟件包名稱(&P)
introduce.parameter.object.use.existing.class=使用現有類(&U)
introduce.parameter.super.method.checkbox=重構 super 方法
introduce.parameter.to.method=將參數提取到方法:
introduced.variable.will.conflict.with.0=引入的變量與{0}衝突
introducing.variable.may.break.code.logic=引入變量可能打破代碼邏輯。
invalid.expression.context=無效的表達式上下文.
invalid.package.name=無效的軟件包名稱: {0}
invalid.target.package.name.specified=指定了無效的目標軟件包名稱
invert.boolean.foreach=Foreach 參數初始值設定不能反轉
invert.boolean.wrong.type=該方法的返回類型或類型的變量是重構應該是布爾
invocations.to.be.inlined=調用內聯{0}
is.modified.in.loop.body={0}是修改在循環體.
javadoc.for.abstracts=JavaDoc的摘要
keep.original.signature=保留原始簽名
lambda.to.reference.side.effect.warning.message=方法引用限定符中可能存在副作用。\n\
引入局部變量?
local.variable.description=局部變量{0}
local.will.be.hidden.renamed.description=重命名的字段將隱藏 {0}
locate.caret.inside.a.method=將文本光標定位在成員內
locate.duplicates.action.name=定位重複項
make.0.static=將{0}設為 static
make.method.static.title=將方法設為 static
make.static.command=將 {0} 設為 static
make.static.description.label=將{0} {1}設為 static
make.static.elements.header=要設為 static 的{0}
make.static.method.references.progress=搜尋方法引用
make.static.methods.to.propagate.dialog.title=選擇要傳遞 static 的方法
members.to.form.interface.title=要構成接口的成員
members.to.form.superclass.title=要形成超類的成員
method.0.is.overridden.by.1=方法{0}被{1}重寫。
method.0.will.hide.method.of.the.base.class=方法{0}將隱藏基類{1}的此方法。
method.0.will.implement.method.of.the.base.class=方法{0}將實現基類{1}的一個方法。
method.0.will.override.a.method.of.the.base.class=方法{0}將重寫基類{1}的一個方法。
method.call.would.be.linked.to.0.after.rename=重命名後，方法調用將被鏈接到“{0}”
method.column=方法
method.description=方法{0}
method.does.not.have.a.body=方法{0}沒有方法體。
method.duplicates.found.message=已找到 {0, choice, 1#1 個代碼段|2#{0,number} 個代碼段}
method.has.an.empty.body=方法 {0} 具有空體。
method.is.not.a.function Object() { [native code] }=方法是不是構造函數。
migration.class=類
migration.dialog.ok.button.text=運行
migration.dialog.title=軟件包和類遷移
migration.entry.class=類
migration.entry.new.name=新名稱:
migration.entry.old.name=舊名稱:
migration.entry.package=軟件包
migration.map.description.label=圖描述:
migration.map.name.prompt=地圖的名字:
migration.new.name.column.header=新名字
migration.no.usages.found.in.the.project=沒有在項目找到用法
migration.old.name.column.header=舊名稱
migration.package=軟件包
migration.package.with.subpackages=軟件包和子軟件包
migration.remove.button=移除
migration.title=遷移
migration.type.column.header=類型
move.class=移動類…
move.class.refactoring.cannot.be.applied.to.anonymous.classes=移動類重構不能應用於匿名類
move.class.to.inner.command.name=將 {0, choice, 1#類|2#類} 從 {1} 移動到 {2}
move.class.to.inner.move.to.self.error=不允許移動類到自身
move.class.to.inner.nonstatic.error=不允許將類移動到非 static 內部類
move.classes=移動類…
move.classes.and.packages=移動類和軟件包…
move.classes.command=正在將 {0} 移到軟件包 {1}
move.classes.destination.make.inner=使內部類(
move.classes.destination.package.prompt=到軟件包:
move.classes.destination.to.package=到軟件包(&G)
move.classes.invalid.package.name.warning.message=無效的軟件包名稱
move.classes.or.packages.title=移動
move.classes.or.packages.different.modules.exports.conflict=將 {0} 從模塊 {1} 移動到模塊 {2} 可以隱藏對其的訪問
move.classes.or.packages.new.module.exports.conflict=更改軟件包 {0} 的 export/opens 語句將授予對同一軟件包中其他類型及其成員的訪問權限
move.classes.or.packages.unused.exports.notification.title=在模塊 {0,choice, 1#描述符|2#描述符} 中<br>\n\
發現未使用的 export/open
move.classes.or.packages.unused.exports.action.name=刪除未使用的 exports/opens
move.classes.or.packages.unused.exports.command.name=刪除未使用的 exports/opens
move.enum.constant.cb=如果可能,移動為枚舉常數 (&E)
move.files.regrouping.command.name=正在重新分組…
move.files.to.new.directory.prompt=到目錄:
move.inner.class.action.name=移動內部類…
move.inner.class.command=移動內部類{0}
move.inner.class.to.another.class=移動內部類{0}到另一個類 (&M)
move.inner.class.to.be.moved=類移動
move.inner.class.to.upper.level=移動內部類{0}上水平(
move.inner.class.to.upper.level.action.name=將內部類移動到上一級別…
move.instance.method.delegate.title=移動實例方法…
move.instance.method.elements.header=移動實例方法
move.instance.method.handler.make.method.static=是否要將方法 ''{0}'' 設為 static 並隨後移動?
move.members.action.name=移動成員…
move.method.enter.a.valid.name.for.parameter=請輸入一個有效的參數名稱
move.method.is.not.supported.for.0=移動實例方法不支持{0}
move.method.is.not.supported.for.constructors=移動方法不支持構造函數
move.method.is.not.supported.for.generic.classes=移動方法不支持泛型類
move.method.is.not.supported.for.non.project.methods=非項目方法不支持移動方法
move.method.this.parameter.label=為 ''{0}.this'' 參數選擇一個名稱
move.methods.panel.title=要移至已提取類的方法(&M)
move.methods.used.in.extracted.block.only=移動僅在提取塊中使用的方法
move.nonstatic.class.from.jsp.not.supported=不支持從 JSP 頁面移動非 static 類
move.package.or.directory=移動軟件包或目錄…
move.package.refactoring.cannot.be.applied.to.default.package=“移動軟件包”重構不能用於預設軟件包
move.packages.or.directories=移動軟件包或目錄…
move.single.class.or.package.name.label=移動 {0} {1}
move.specified.classes=移動指定的類
move.specified.classes.to=移動指定的類到:
move.specified.packages=移動指定的軟件包
move.to.inner.duplicate.inner.class=類{0}已包含一個名為{1}的內部類
moving.local.classes.is.not.supported=不支持移動局部類。
no.class.name.specified=未指定類名
no.exact.method.duplicates.were.found=<html><b>未找到確切的方法重複項</b>，但如下所示，變更的方法中有 {0} 個{0,choice, 1#重複項|2#重複項}</html>
no.initializer.present.for.the.field=字段沒有初始值設定項
no.parameter.name.specified=未指定參數名稱
no.usages.can.be.replaced=沒有用途的{0}可以替換用法{1}
occurrences.to.be.migrated=匹配項被遷移的{0}
ok.button=確定
only.fields.variables.of.methods.of.valid.type.can.be.considered=僅可以考慮有效類型的字段、變量、方法參數或方法。
package.description=軟件包 {0}
package.does.not.exist=軟件包 {0} 不存在。\n\
要創建嗎?
package.does.not.exist.preview=軟件包 {0} 不存在。\n\
重構稍後將為您創建該軟件包。
package.name.prompt=軟件包名稱(&G):
parameter.description=參數 {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=參數初始值設定項包含 {0}，但並非對方法的所有調用都位於其類中
parameter.name.prompt=參數名稱(&M) : 
parameter.of.type=類型的參數(&T):
parameter.type.table.column.title=類型
parameter.used.in.method.body.warning={0} 用於方法體
pass.outer.class.instance.as.parameter=將外部類實例作為參數傳遞(&O)
please.enter.a.valid.target.package.name=請輸入一個有效的目標軟件包名稱
press.the.do.migrate.button=按搜尋結果面板\n\
底部的"遷移"按鈕,使用遷移地圖"{0}"\n\
進行遷移
preview.usages.to.be.changed=預覽要改變的用法 (&P)
process.duplicates.change.signature.promt=要替換所有匹配項，需要更改方法簽名。是否繼續?
process.duplicates.title=處理重複項
process.methods.duplicates.title=過程方法複製的{2}({0},{1})
processing.progress.text=正在處理 {0}
project.files.have.been.changed=已更改項目檔案。\n\
要重新運行重構嗎?
push.down.delete.warning.text={0}向下推動成員會導致它們被刪除。要繼續嗎?
push.down.enum.no.constants.warning.text=枚舉 {0} 沒有要內聯到的常量。
push.down.no.inheritors.class.warning.text=類 {0} 沒有繼承者。
push.down.no.inheritors.final.class.warning.text=final 類 {0} 沒有繼承者。
re.run.refactoring=重新運行重構
refactoring.cannot.be.applied.no.sources.attached={0}重構不能應用:無源連接
refactoring.cannot.be.applied.to.abstract.methods={0}重構不能應用於 abstract 方法
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0}重構不能用於內聯非鏈接構造函數
refactoring.cannot.be.applied.to.native.methods={0} 重構不能應用於原生方法
refactoring.cannot.be.applied.to.vararg.constructors={0}重構無法應用於 vararg 構造函數
refactoring.extract.method.dialog.duplicates.count={0,choice, 1#1|2#{0,number}} 個重複的代碼{0,choice, 1#段|2#段}可以替換為提取的方法調用
refactoring.extract.method.dialog.duplicates.pending=正在搜尋重複項…
refactoring.extract.method.dialog.duplicates.progress=正在搜尋重複項
refactoring.extract.method.inner.class.defined=內部類 {0} 已在類 {1} 中定義。
refactoring.extract.method.preview.button.refactor=執行重構(&D)
refactoring.extract.method.preview.button.rerun=重新運行重構(&E)
refactoring.extract.method.preview.failed=無法提取方法
refactoring.extract.method.preview.group.duplicates=重複的代碼段
refactoring.extract.method.preview.group.method=要提取的方法
refactoring.extract.method.preview.group.original=原始代碼段
refactoring.extract.method.preview.preparing=正在準備差異
refactoring.extract.method.preview.updating=正在更新差異
refactoring.extract.method.reference.to.change=待變更引用
refactoring.introduce.variable.enum.in.label.message=無法提取 switch 標籤中的枚舉常量
refactoring.is.not.supported.for.jsp.classes=重構不支持JSP類.
refactoring.is.not.supported.for.local.and.jsp.classes=重構不支持局部和JSP類.
refactoring.is.not.supported.in.the.current.context={0}重構是不支持在當前上下文
references.in.code.to.elements.from.migration.map=在代碼元素的引用從移民地圖"{0}"{1}
references.to.0.to.be.replaced.with.references.to.1=對 ''{0}'' 的引用要替換為對 ''{1}''{2} 的引用
remove.parameter.0.no.longer.used=移除不再使用的參數 ''{0}''
rename.function Object() { [native code] }.parameters.title=重命名構造函數參數
rename.function Object() { [native code] }.parameters.with.the.following.names.to=將具有以下名稱的參數重命名為:
rename.module.already.exists=模塊 ''{0}'' 已經存在於項目中
rename.module.directory.command=將模塊和目錄重命名為 ''{0}''
rename.module.directory.title=重命名模塊和目錄(&A)
rename.overloads=重命名重載 (&O)
rename.overloads.dialog.title=重命名重載
rename.overloads.to.dialog.description=將重載重命名為:
rename.parameter.in.hierarchy.to.dialog.description=將層次結構中的參數重命名為:
rename.parameters.dialog.title=重命名參數
rename.tests=重命名測試 (&E)
rename.tests.title=重命名測試
rename.tests.with.the.following.names.to=重命名測試具有以下名稱:
rename.variables=重命名變量 (&V)
rename.variables.title=重命名變量
rename.accessors=重命名訪問器(&A)
rename.accessors.title=重命名 Getter/Setter
rename.accessors.with.the.following.names.to=重命名具有以下名稱的訪問器:
renamed.class.will.hide.0.in.1=重命名類將隱藏{0}在{1}
renaming.method.will.override.final.0=重命名方法將重寫 final“{0}”
replace.all.fields=替換所有字段 (&R)
replace.all.occurrences.of.expression.0.occurrences=替換所有匹配項({0})(&A)
replace.function Object() { [native code] }.0.with.a.factory.method=將構造函數 {0} 替換為工廠方法
replace.function Object() { [native code] }.builder.create.new=創建新的(&C)
replace.function Object() { [native code] }.builder.use.existing=使用現有項(&U)
replace.function Object() { [native code] }.existing.builder.fqn=構建器類名 (完全限定)(&B)
replace.function Object() { [native code] }.new.builder.class.name=構建器類名(&N)
replace.function Object() { [native code] }.new.builder.package=新構建器的軟件包(&P)
replace.function Object() { [native code] }.with.factory.method=將構造函數替換為工廠方法
replace.function Object() { [native code] }.with.factory.method.title=將構造函數替換為工廠方法
replace.function Object() { [native code] }.with.factory.target.fq.name=在(完全限定名稱):
replace.default.function Object() { [native code] }.of.0.with.a.factory.method=將預設構造函數 {0} 替換為工廠方法
replace.default.function Object() { [native code] }.with.factory.method=將預設構造函數替換為工廠方法
replace.fields.inaccessible.in.usage.context=替換上下文沒有使用的字段 (&I)
replace.fields.used.in.expressions.with.their.getters=替換字段用於表情和他們的getter方法
replace.inheritance.from=替換委派繼承從: (&R)
replace.inheritance.with.delegation.command=使用{0}中的委託替換繼承
replace.inheritance.with.delegation.delegate.members.title=委派成員
replace.inheritance.with.delegation.elements.header=替換繼承與代表團
replace.inheritance.with.delegation.invalid.field=''{0}'' 是委派的無效字段名稱
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' 是委派的無效字段名稱
replace.inheritance.with.delegation.title=用委派替換繼承
replace.instance.qualifiers.with.class.references=替換實例與類引用限定符
replace.method.code.duplicates.title=替換重複代碼
replace.method.duplicates.scope.chooser.message=分析範圍
replace.method.duplicates.scope.chooser.title=指定{0}範圍
replace.this.code.fragment.and.change.signature=方法的簽名將被更改為{0}
replace.this.code.fragment.and.make.method.static=(方法將被設為 static)
replace.this.code.fragment.and.make.method.static.visible=(方法將被設為 static 和{0})
replace.this.code.fragment.and.make.method.visible=(方法將{0})
replace.with.method.call.does.not.work.for.constructors=替換為方法調用不工作為構造函數
replace.write.access.occurrences=替換白名單匹配項 (&L)
replacing.inheritance.with.delegation=替換繼承與代表團
safe.delete.search.for.caller.method.usages.progress=搜尋調用者方法用法…
safe.delete.select.members.to.propagate.dialog.title=選擇要傳播安全刪除的成員
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=選擇要傳播參數刪除的方法
safe.delete.parameter.usage.warning=參數 ''{0}'' 具有無法安全刪除的用法
select.migration.map=選擇遷移映射:
select.source.root.chooser.title=選擇根原始碼
selected.block.contains.invocation.of.another.class.function Object() { [native code] }=選塊包含調用另一個類的構造函數.
selected.block.contains.statement.outside.of.class=所選塊在類外部包含語句
selected.block.should.represent.an.expression=所選塊應代表一個表達式
selected.expression.cannot.be.a.constant.initializer=所選表達式不能是常量初始值設定項
selected.expression.has.void.type=選定的表達式有空隙類型.
selected.expression.introduces.pattern.variable=選定的表達式引入模式變量 ''{0}''
popup.title.choose.class.to.introduce.constant=選擇要引入常量的類
popup.title.choose.class.to.introduce.field=選擇要引入字段的類
setter.method.found.for.the.field.0=Setter方法發現田野{0}.{1}setter嗎?
side.effects.detected.title=已檢測到副作用
source.folder.0.has.package.prefix.1=源資料夾 {0} 具有軟件包前綴 ''{1}''\n\
無法在該資料夾中創建軟件包 ''{2}''。
static.initializer.description=類 {0} 的 static 初始值設定項
superclass.cannot.be.accessed.in.subclass=在子類中將無法訪問的超類
superclass.cannot.be.extracted.from.an.enum=無法從枚舉中提取超類
superclass.cannot.be.extracted.from.a.record=不能從一個記錄中提取超類
synthetic.jsp.class.is.referenced.in.the.method=合成的jsp類是引用的方法
target.0.is.not.accessible.from.1=目標{0}是不可以從{1}
the.field.should.be.declared.in.a.class=應在類中聲明該字段.
there.are.going.to.be.multiple.destination.files.with.the.same.name=有多個目標檔案具有相同的名稱。
there.are.multiple.exit.points.in.the.selected.code.fragment=選定的代碼段有多個出口點。
there.are.multiple.output.values.for.the.selected.code.fragment=選定的代碼段有多個輸出值。
there.are.no.variables.that.have.reference.type=有沒有具有引用類型的變量
there.are.unused.methods.that.override.methods.you.delete=有未使用的方法,覆蓋方法您刪除.
there.is.already.a.0.in.1=已存在一個{0}在{1}中
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=已經有一個{0}。它將衝突與引入的參數衝突
there.is.already.a.0.it.will.conflict.with.the.renamed.1=已經有一個{0}.它將衝突與更名為{1}
there.is.already.type.parameter.in.0.with.name.1=名稱為 {1} 的 {0} 中已存在類型參數
this.method=這種方法
this.reference.only.and.keep.super.class=這個僅供引用並保持內聯的超類(&K)
this.reference.only.and.keep.the.class=內聯這只引用和保持類(&K)
this.reference.only.and.keep.the.field=內聯這只引用和保持字段(&K)
turn.refs.to.super.command=更換用法{0}和{1}
turnRefsToSuper.change.usages.to=更改{0}的使用到: (&C)
turnRefsToSuper.use.superclass.in.instanceof=使用接口/超類在實例 (&U)
type.cook.command=泛化
type.cook.drop.obsolete.casts=刪除廢棄轉換 (&D)
type.cook.elements.header=(年代)generify範圍
type.cook.generify.objects=Generify對象(&O)
type.cook.leave.object.parameterized.types.raw=離開對象參數化類型生(&L)
type.cook.perform.exhaustive.search=執行詳盡的搜尋(&E)
type.cook.preserve.raw.arrays=保存原始數組(&A)
type.cook.produce.wildcard.types=產生通配符類型(&W)
type.cook.ratio.generified={0,choice,-1#不計算|0#{0,number}/{1}}
type.cook.report=項目泛型: {0}, 轉換已移除: {1}
type.migration.action.name=類型遷移
type.migration.choose.scope.title=選擇可能出現變更簽名的範圍
type.migration.conflicts.found=找到的遷移衝突
type.migration.exclude.action.text=排除 (&E)
type.migration.include.action.text=包含 (&I)
type.migration.label=將{0}“{1}”遷移到
type.migration.migrate.button.text=遷移 (&M)
type.migration.no.conflicts.found=未找到遷移衝突
type.migration.no.scope.warning.message=未選擇範圍
type.migration.preview.warning.text=已找到 10 多個要遷移的根。要預覽嗎?
type.migration.reasons.to.migrate=已找到要遷移的原因
type.migration.rerun.button.text=返回類型遷移 (&R)
type.migration.select.suggestion=選擇根以尋找遷移的原因
type.of.the.selected.expression.cannot.be.determined=類型的選定的表達式不能確定.
unable.to.start.type.migration=無法啟動類型遷移
unknown.expression.type=未知的表達式類型.
unused.overriding.methods.title=未使用重寫方法
usages.detected.title=檢測到用法
use.interface.superclass.in.instanceof=使用接口/超類的實例
use.interface.where.possible.title=在可能處使用接口
use.super.references.prompt=在這個階段{0}可以分析用途的{1},換成用法的{2}在可能的情況下.是否要繼續?
use.variable.initializer.to.initialize.parameter=使用變量初始值設定項初始化參數(&I)
variable.0.is.changed.before.last.access=變量 ''{0}'' 在上次訪問變量 ''{1}'' 前已更改。
variable.does.not.have.an.initializer=變量 {0} 沒有初始值設定項。
variable.is.accessed.for.writing=變量''{0}''可寫.
variable.is.never.used.before.modification=修改之前從未使用變量{0}
variable.of.type=類型的變量(&T):
would.you.like.to.replace.default.function Object() { [native code] }.of.0.with.factory.method=要將預設構造函數 {0} 替換為工廠方法嗎?
wrap.return.value.create.inner.class=創建內部類(&I)
wrap.return.value.create.new.class=創建新類(&C)
wrap.return.value.existing.class.name=名稱
wrap.return.value.inner.class.name=名稱(&M)
wrap.return.value.new.class.name=名稱(&N)
wrap.return.value.new.class.package.name=軟件包名稱(&P)
wrap.return.value.use.existing.class=使用現有類(&U)
wrap.return.value.wrapper.field=包裝器字段(&F)

replace.inside.current.lambda=在當前 lambda 內創建變量
replace.as.separate.operation=提取為 ''{0}'' 操作
replace.all.occurrences.changes.semantics=替換所有 {0} 匹配項(將更改語義!)
replace.all.read.and.write=替換讀取和寫入匹配項 (將更改語義!)
replace.all.and.extract=替換所有 {0} 匹配項並提取為 ''{1}'' 操作
replace.lambda.chain.detected=檢測到 lambda 鏈
replace.occurrences.inside.statement=替換{2, choice, 1#|2#外部} ''{1}'' 塊中的 {0} 個匹配項
extract.method.object=提取方法對象
replace.function Object() { [native code] }.with.builder=將構造函數替換為構建器
type.migration.error.hint.title=類型遷移

extract.method.dialog.separator.parameters=參數(&P)
extract.method.conflict.parameter=衝突的參數名: {0}
extract.method.conflict.variable=名為 {0} 的變量已在選定範圍中定義
extract.method.error.annotation.value=無法從註解值提取方法
extract.method.error.local.class.defined.outside=無法提取方法，因為選定代碼段使用在片段之外定義的局部類
extract.method.error.local.class.used.outside=無法提取方法，因為選定代碼段定義在片段之外使用的局部類
extract.method.error.local.class.variable.used.outside=無法提取方法，因為選定代碼段定義在片段之外使用的局部類類型的變量
extract.method.error.make.static=無法設為 static
extract.method.preview.node.invalid.prefix=無效 
suggest.signature.preview.method.call.prefix=方法調用:
suggest.signature.preview.title.before=之前
suggest.signature.preview.after.title=之後
removing.redundant.imports.progress.title=正在移除冗餘導入
introduce.parameter.object.error.class.does.not.exist=''{0}'' 不存在
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' 是無效的限定參數類名稱
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' 是無效的參數類軟件包名稱
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' 是無效的參數類名稱
introduce.parameter.object.error.inner.class.already.exist=名稱為 ''{0}'' 的內部類已存在
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' 是無效的內部類名稱
introduce.parameter.object.error.no.field.associated.found=找不到與 {0} 關聯的字段
introduce.parameter.object.error.existing.class.misses.compatible.function Object() { [native code] }=現有類中沒有兼容的構造函數
introduce.parameter.object.error.created.class.wont.be.accessible=創建的類無法訪問
introduce.parameter.object.error.file.already.exits=檔案已存在: {0}
replace.function Object() { [native code] }.builder.error.identifier.invalid=標識符 ''{0}'' 無效
replace.function Object() { [native code] }.builder.optional.setter.table.title=可選 Setter
replace.function Object() { [native code] }.builder.default.value.table.title=默認值
replace.function Object() { [native code] }.builder.setter.name.table.title=Setter 名稱
replace.function Object() { [native code] }.builder.field.name.table.title=字段名稱
replace.function Object() { [native code] }.builder.parameter.table.title=參數
replace.function Object() { [native code] }.builder.select.builder.class.chooser.title=選擇構建器類
replace.function Object() { [native code] }.builder.error.invalid.builder.qualified.class.name=''{0}'' 是無效的構建器限定類名稱
replace.function Object() { [native code] }.builder.error.invalid.builder.package.name=''{0}'' 是無效的構建器軟件包名稱
replace.function Object() { [native code] }.builder.error.invalid.builder.class.name=''{0}'' 是無效的構建器類名稱
replace.function Object() { [native code] }.builder.error.invalid.setter.name=''{0}'' 不是有效的 setter 名稱
replace.function Object() { [native code] }.builder.error.invalid.field.name=''{0}'' 不是有效的字段名
replace.function Object() { [native code] }.builder.error.no.constructors=當前類沒有要替換為構建器的構造函數。
replace.function Object() { [native code] }.builder.error.caret.position=文本光標應置於構造函數要替換為構建器的類中。
replace.function Object() { [native code] }.builder.error.no.function Object() { [native code] }.chain=找到的構造函數無法縮減為簡單鏈
replace.function Object() { [native code] }.builder.error.class.with.chosen.name.already.exist=具有所選名稱的類已存在。
replace.function Object() { [native code] }.builder.error.selected.class.was.not.found=未找到選定類。
replace.function Object() { [native code] }.factory.error.invalid.factory.method.name=''{0}'' 不是有效的工廠方法名稱
replace.function Object() { [native code] }.factory.error.factory.method.already.exists=工廠方法 {0} 已存在，將用於替代新創建的工廠方法。
java.safe.delete.empty.callee.text=將在此處顯示被調用方文本
java.safe.delete.caller.text=將在此處顯示將被調用方高亮顯示的調用方文本
# {0} = method; {1} = class; {2} = protected/package-private/private
push.up.super.class.signature.conflict=超類中的 {0} 與 {1} 中的方法 {2} 衝突
push.up.abstract.accessibility.in.subclass.conflict={0} 使用無法通過子類訪問的 {1}。
push.up.abstract.accessible.from.the.subclass.conflict=無法將 {0} 設為抽象，因為無法通過子類對其進行訪問。
push.down.unrelated.defaults.conflict={0} 將從 {1} 和 {2} 繼承不相關的默認值
move.member.write.access.in.interface.conflict={0} 具有寫入權限，但會移動至接口
refactor.only.current.method.choice=僅重構當前方法
refactor.base.method.choice=重構基{0, choice, 0#方法|1#方法}
automatic.parameter.renamer.entity.name=參數
automatic.overload.renamer.entity.name=重載
extract.method.checkbox.annotate=註解
extract.method.checkbox.make.static=設為 static
extract.method.checkbox.make.static.and.pass.fields=設為 static 並傳遞字段
extract.method.link.label.more.options=更多選項
dialog.message.field.doesnt.have.initializer=字段 {0} 沒有初始值設定項
dialog.message.replace.duplicates.works.with.constants.only=替換重複項僅適用於常量
dialog.message.caret.should.be.inside.method.or.constant=文本光標應位於方法或常量內部
inline.object.command.name=內聯對象
local.to.field.popup.title.choose.class.to.introduce.constant=選擇要引入常量的類
local.to.field.popup.title.choose.class.to.introduce.field=選擇要引入字段的類
extract.method.gotit.signature.header=更改方法簽名
extract.method.gotit.signature.message=<html><p style=''margin-bottom:3px;''>1. 編輯簽名</p><p style=''margin-bottom:3px;''>2. 更新用法: 點擊間距中的圖標或按 {0}</p><p><font color=gray>要對參數重新排序，請使用 {1} 或 {2}。</font></p></html>
extract.method.gotit.navigation.header=想要更改方法簽名?
extract.method.gotit.navigation.message=轉到方法聲明執行操作: <br/>{0}方法名稱或按 {1}。
introduce.variable.no.matching.occurrences=無匹配項
inline.super.no.inheritors.warning.message=無法內聯沒有繼承者的類
inline.superclass.foreign.language.conflict.message=無法內聯到 {0}
field.0.won.t.be.initialized.already.in.class.initializer=字段 ''{0}'' 不會在類初始值設定項內部初始化
replace.function Object() { [native code] }.with.builder.text=將構造函數替換為構建器
rename.inheritors.with.the.following.names.to.title=將具有以下名稱的繼承者重命名為：
title.rename.variables.with.the.following.names.to=將具有以下名稱的變量重命名為：
dialog.title.analyze.code.fragment.to.extract=分析代碼以提取…
dialog.message.overriding.methods.with.weaken.visibility=是否同時將覆蓋方法的可見性降低到 ''{0}''？
edit.migration.map.title.new=新建遷移映射
edit.migration.map.title.existing=編輯遷移映射
edit.migration.map.ok.button=保存
migration.dialog.alert.name=刪除遷移映射
migration.dialog.alert.text=是否刪除 ''{0}'' 遷移？
migration.dialog.alert.delete=刪除
migration.dialog.link.delete=刪除
migration.dialog.link.duplicate=複製和編輯…
migration.dialog.link.edit=編輯…
migration.dialog.scope.label=範圍:
migration.dialog.scope.whole.project=整個項目
migration.edit.duplicated.migration.name={0} 副本
migration.edit.existing.name=已經存在同名的遷移。
migration.edit.empty.name=遷移名稱不能為空。
migration.edit.empty.table=遷移表不能為空。
migration.edit.copy.existing=複製現有的
0.already.contains.field.1={0} 已包含欄位 {1}
0.already.contains.inner.class.named.1={0} 已包含名為 {1} 的內部類別
0.already.has.parameter.named.1.use.this.name.anyway={0}已經有名為 ''{1}'' 的參數。\n仍然使用此名稱?
0.contains.call.with.null.argument.for.parameter.1={0} 包含帶有參數 {1} 的 null 實參的呼叫
0.implements.1={0}實作{1}。
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} 為 {1}，將無法從 {2} 存取。
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} 是方法層次結構的一部分。是否要刪除多個參數?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} 是方法層次結構的一部分。是否要刪除多個類型參數?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} 是一個接口。\n方法實作將被新增到所有直接實作類別。\n繼續?
0.is.an.interface.that.has.no.implementing.classes={0} 是一個沒有實作類別的接口
0.is.not.a.legal.java.identifier=''{0}''不是合法的java關鍵字
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0}不可以從{1}存取。該方法呼叫中引入參數的值將不正確。
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}在宣告處未初始化。在接口中不允許這樣的欄位。
0.is.not.static.it.cannot.be.moved.to.the.interface={0}不是靜態的.不能將它移至該接口
0.is.not.visible.to.members.of.1={0} 對 {1} 的成員不可見
0.is.used.for.writing.in.1={0}是用來寫在{1}
0.refactoring.is.supported.only.for.final.fields=僅 final 欄位支援{0}重構
0.upcasts.an.instance.of.1.to.2={0} 將 {1} 的實例向上轉換為 {2}。
0.uses.1.of.an.instance.of.a.2={0} 使用 {2} 的一個實例的 {1}
0.uses.1.which.needs.class.instance={0} 使用 {1}，這需要類別實例
0.uses.a.package.local.1={0}使用 package-private {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0}使用非 static {1}，後者不作為參數傳遞
0.will.be.inaccessible.from.1={0}將無法從{1}
0.will.become.inaccessible.from.1={0}將變得無法從 {1} 存取
0.will.hide.renamed.1={0}將隱藏更名為{1}
0.will.no.longer.be.canonical.constructor=將不再是規範建構函式
0.will.no.longer.be.record.component.accessor={0} 將不再是 {1} getter
0.will.no.longer.override.1={0}將不再覆寫{1}
0.will.not.be.accessible.from.1.after.inlining={0}不可以從{1}在內聯
0.will.override.renamed.1={0}將覆蓋更名為{1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=Package-local 類別 {0} 將不再可以從{1}存取
accept.signature.change=接受簽名更改
add.object.as.a.parameter.to.constructors.with.name=將物件作為參數新增到具有以下名稱的建構函式(&O)\:
add.parameters.for.fields=新增欄位參數(&F)\:
add.parameters.for.fields.to.constructors=向建構函式新增欄位參數(&F)\:
all.candidate.variables.have.types.not.in.project=所有候選變數(方法參數和所包含的類別欄位)的類型都不在專案中
all.candidate.variables.have.unknown.types=所有候選變數(方法參數和所包含的類別欄位)都具有未知類型
all.invocations.and.remove.the.method=內聯所有用法並移除方法(&A)
all.invocations.in.project=內聯專案中的所有用法(&A)
all.invocations.keep.the.method=內聯所有用法並保留方法(&E)
all.references.and.remove.super.class=內聯所有參照並移除類別(&A)
all.references.and.remove.the.class=內聯所有參照並移除類別(&A)
all.references.and.remove.the.field=內聯所有參照並移除欄位 (&A)
all.references.keep.field=內聯所有參照並保留欄位(&E)
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=所有這些目錄將被移動，並且所有對 {0} 的參照將被更改。
analyze.and.replace.usages=分析和取代用法
analyze.module.conflicts=分析模組衝突…
annotate.field.as.nonnls.checkbox=註釋欄位作為 @NonNls (&F)
anonymous.class.description=派生自 {0} 的匿名類別
anonymous.class.text=匿名類別
anonymous.to.inner.enum.constant.cannot.refactor.message=枚舉常數無法轉換為內部類別
anonymousToInner.class.name.label.text=類別名\:
anonymousToInner.make.class.static.checkbox.text=將類別設為 static(&S)
anonymousToInner.no.inner.class.name=需指定類別名
anonymousToInner.parameters.panel.border.title=建構函式的參數
anonymousToInner.refactoring.name=轉換匿名為內部
auto.rename.module.dialog.description=將具有以下名稱的 Java 模組重命名為\:
auto.rename.module.dialog.title=重新命名 Java 模組
auto.rename.module.entity=Java 模組
automatic.overload.renamer.entity.name=多載
automatic.parameter.renamer.entity.name=參數
boolean.method.result=布爾方法的結果
can.t.restore.context.for.method.extraction=無法為方法提取還原上下文
cannot.find.or.create.destination.directory=找不到或建立目標目錄
cannot.introduce.field.in.interface=接口中不允許使用非常數欄位
cannot.move=無法移動
cannot.move.inner.class.0.into.itself=不能將內部類別 {0} 移至自身
cannot.move.package.into.itself=無法將軟體套件移至其自身
caret.position.warning.message=文字游標應置於要重構的欄位、變數、方法或方法參數類型上
change.method.signature.action.name=更改方法簽名
change.signature.default.value.missing.warning.message=缺少預設值。方法呼叫將包含空值，而不是新的參數值。
change.signature.use.any.checkbox=使用任意變數(&U)
changeClassSignature.Type.parameter.can.not.be.primitive=類型參數不能為基元
changeClassSignature.already.contains.type.parameter=''{0}'' 已包含類型參數 ''{1}''
changeClassSignature.bad.value=錯誤 {0} 值\: ''{1}'' 參數 ''{2}''
changeClassSignature.class.label.text=更改 <code>{0}</code> 的簽名。
changeClassSignature.no.type.parameters=這個類別不能有類型參數
changeClassSignature.parameters.panel.border.title=參數：
changeClassSignature.refactoring.name=更改類別簽名
changeSignature.bound.value.column=綁定值
changeSignature.cannot.resolve.return.type=無法解析返回值類型''{0}''。\n是否繼續?
changeSignature.contract.converter.can.not.update.annotation=@Contract 註解無法自動更新\: {0}
changeSignature.contract.converter.definition.error=約定定義出錯\: {0}
changeSignature.contract.converter.external.annotations=不支持外部註解的自動更新
changeSignature.contract.converter.inherited.annotation=註解繼承自基方法
changeSignature.contract.converter.invalid.clause=約定子句 ''{0}'' 無效
changeSignature.contract.converter.invalid.return.reference=返回值中的參照無效\: {0}
changeSignature.contract.converter.mutation.contract=註解包含變異協定
changeSignature.contract.converter.parameter.removed=參數 ''{0}'' 已刪除，但是約定子句 ''{1}'' 相依於此
changeSignature.contract.converter.return.parameter.removed=參數 ''{0}'' 已刪除，但是約定子句 ''{1}'' 將其返回
changeSignature.default.value.column=預設值
changeSignature.empty.callee.method.text=此處將顯示被呼叫方方法文本
changeSignature.empty.caller.method.text=此處將顯示醒目提示被呼叫方呼叫的呼叫方方法文本
changeSignature.exception.caller.chooser=選擇要傳遞新異常的方法
changeSignature.exceptions.panel.border.title=異常
changeSignature.exceptions.wont.propagate=遞迴傳播的異常的更改不會被執行
changeSignature.no.return.type=未指定返回值類型
changeSignature.no.type.for.exception=指定一個類型給異常
changeSignature.no.type.for.parameter=指定參數 ''{1}'' 的 {0} 類型
changeSignature.not.throwable.type=錯誤的異常類型 ''{0}''，應擴展 java.lang.Throwable
changeSignature.processing.changes.title=正在處理更改…
changeSignature.propagate.exceptions.title=傳播異常(&X)…
changeSignature.use.any.var=使用任意變數。
changeSignature.validating.title=正在驗證…
changeSignature.vararg.not.last=vararg 參數應當為方法簽名中的最後一個參數
changeSignature.wrong.return.type=錯誤的返回值類型\:''{0}''
changeSignature.wrong.type.for.exception=類型錯誤\: 異常的 ''{0}''
changeSignature.wrong.type.for.parameter=類型錯誤\: 參數 ''{1}'' 的 ''{0}''
checking.conflicts=正在檢查衝突…
class.0.already.exists=類別{0}已存在
class.0.is.not.accessible.from.target.1=類別{0}是不可以從目標{1}
class.0.not.found=找不到類別 {0}。
class.body.description={0} 的類別主體
class.description={1, choice, 0\#|1\#區域}類別 {0}
class.does.not.exist.in.the.project=模組中不存在類別。是否要建立?
class.does.not.have.base.classes.or.interfaces=類別 {0} 沒有基類別或基接口
class.does.not.have.implicit.default.constructor=類別 {0} 沒有隱式預設建構函式
class.has.been.successfully.created=已成功建立類別 {0}。
class.initializer.description={0, choice, 0\#static |1\#實例}初始設定式
class.is.abstract={0}為 abstract。
class.is.anonymous.warning.message=無法執行重構，因為匿名類別不能有子類別
class.is.final.warning.message=無法執行重構，因為該類為 final
class.is.interface={0}是一個接口。
class.is.never.used=類別從未使用
class.name.prompt=類別名(&N)\:
collect.overloads=收集多載…
comments.elements.header=在註釋、字串和非程式碼檔案 {0} 中發現符合項
constructor.being.refactored.is.used.in.initializer.of.0=正在重構的建構函式在 {0} 的初始設定式中使用。內部類別 {1} 的非 static 工廠無法在此上下文中使用。生成的程式碼將不會編譯。
constructor.description=建構函式{0}
constructor.with.builder.new.setter.prefix.dialog.message=新的 setter 前綴\:
constructor.with.builder.parameters.to.pass.to.the.builder.title=要傳遞到建置器的參數
constructor.with.builder.rename.setters.prefix.action.name=重新命名 Setter 前綴
convert.anonymous.or.local.to.inner.fix.name=將匿名類別或區域類別轉換為內部類別
convert.anonymous.to.inner.action.name=將匿名轉換成內部…
convert.anonymous.to.inner.fix.name=將匿名轉換成內部類別
convert.local.to.field.title=將區域轉換為欄位
convert.local.to.inner.action.name=將區域轉換為內部…
convert.local.to.inner.fix.name=將區域類別轉換為內部類別
convert.to.instance.method.title=轉換為實例方法
convert.to.record.accessor.more.accessible={0} 為 {1}。轉換為記錄將使相應的隱式存取器方法{2}。
convert.to.record.ctor.more.accessible={0} 為 {1}。轉換為記錄會將相應的隱式規範記錄建構函式設為 {2}。
convert.to.record.title=轉換為記錄類別
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=找不到實例方法的目標類別\: 找不到參照專案中類別的類型的方法參數。
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=找不到實例方法的目標類別\: 方法參數類型未知。
convertToInstanceMethod.method.is.not.static=方法 {0} 不為 static
convertToInstanceMethod.no.default.ctor=此外，包含類別沒有預設建構函式。
convertToInstanceMethod.no.parameters.with.reference.type=不存在具有參照類型的參數。
copy.class.clone.0.1=克隆{0}{1}
copy.class.copy.0.1=複製{0}{1}
copy.handler.clone.class=克隆類別
copy.handler.copy.class=複製類別
copy.handler.copy.class.with.dialog=複製類別…
copy.handler.copy.classes.with.dialog=複製類別…
current.class=當前類別
dataflow.to.here.expand.progress=正在展開所有節點… {0}
dataflow.to.here.group.by.leaf.action.description=確定 null 是否可以流入此表達式
dataflow.to.here.group.by.leaf.action.text=按葉表達式為 null 性分組{0, choice, 1\#|2\# (正在分析)}
dataflow.to.here.variable.dereferenced.tooltip=已解參照變數
declare.final=宣告 final(&F)
declare.generated.annotations=生成註解(&G)
declare.static.checkbox=宣告 static(&S)
declare.static.pass.fields.checkbox=宣告 static (作為參數傳遞欄位)(&S)
declare.var.type=宣告變數類型(&V)
declare.varargs.checkbox=宣告 vararg(&A)
default.visibility.border.title=缺省可見
delete.variable.declaration=刪除變數宣告 (&D)
destination.directory.does.not.correspond.to.any.package=目標目錄不對應於任何軟體套件
destination.package=目標軟體套件(&P)\:
dialog.message.0.would.hide.which.1.used.by.moved.2={0}將隱藏被移動的{2}使用的{1}。
dialog.message.caret.should.be.inside.method.or.constant=文字游標應位於方法或常數內部
dialog.message.confirmation.to.process.only.implementation=找到 abstract 方法的實作\:<br><br><b>{0}</b><br><br>是否要內聯此實作?
dialog.message.enum.constant.0.won.t.be.compilable.in.1=移動到{1}後{0}將無法編譯。
dialog.message.field.doesnt.have.initializer=欄位 {0} 沒有初始設定式
dialog.message.moving.directories.to=將目錄移至 ''{0}''
dialog.message.non.constant.will.not.be.compilable.in.interface=移動到接口後，非常數{0}將無法編譯。
dialog.message.overriding.methods.with.weaken.visibility=是否還要將覆寫方法的可見性降低到 ''{0}''?
dialog.message.replace.duplicates.works.with.constants.only=取代重複項僅適用於常數
dialog.message.static.class.initializers.are.not.allowed.in.interfaces=接口中不允許使用 static 類別初始設定式。
dialog.title.analyze.code.fragment.to.extract=分析程式碼以提取…
dialog.title.confirm.move=確認移動
dialog.title.move.directory.to.source.root=將目錄移至來源根
dialog.title.resolving.method.implementation=正在解析方法實作
different.name.expected=應為不同名稱
directory.0.already.contains.1.named.2=目錄 {0}\n已經包含一個名為 ''{2}'' 的{1}
directory.0.already.contains.a.file.named.1=目錄 {0}\n已經包含一個名為 ''{1}'' 的檔案
do.not.replace=不要取代 (&N)
do.not.show.this.message.in.the.future=以後不再顯示此訊息 (&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=是否要使用協變返回值類型處理覆寫方法?
edit.migration.entry.title=編輯類別/軟體套件遷移規則
edit.migration.map.ok.button=儲存
edit.migration.map.title.existing=編輯遷移映射
edit.migration.map.title.new=新增遷移映射
element.will.no.longer.be.accessible={0}將不再可以從{1}
encapsulate.fields..encapsulated.fields.visibility.border.title=封裝欄位的可見性
encapsulate.fields..package.local.radio=Package local(&C)
encapsulate.fields.accessors.visibility.border.title=存取器可見性
encapsulate.fields.command.name=封裝欄位在{0}
encapsulate.fields.encapsulate.border.title=封裝
encapsulate.fields.existed.accessor.hidden={0} 已經存在，將被生成的存取器隱藏
encapsulate.fields.existed.accessor.hides.generated={0} 已經存在，將為 {1} 隱藏生成的存取器
encapsulate.fields.expression.type.is.used=使用結果類型時，無法繼續使用後綴/前綴表達式
encapsulate.fields.field.column.name=欄位
encapsulate.fields.fields.to.be.encapsulated=欄位封裝
encapsulate.fields.fields.to.encapsulate.border.title=欄位來封裝
encapsulate.fields.get.access.checkbox=獲取存取權限 (&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=已經存在方法 {0}，它與 getter {1} 僅在返回值類型上不同
encapsulate.fields.no.target=未找到要封裝的內容
encapsulate.fields.nothing.todo.warning.message=類別具有要封裝的欄位
encapsulate.fields.private.radio=私有(&I)
encapsulate.fields.protected.radio=protected(&T)
encapsulate.fields.refactoring.cannot.be.applied.to.interface=封裝欄位重構不能套用到接口
encapsulate.fields.set.access.checkbox=設定存取權限 (&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=已經存在方法 {0}，它與 setter {1} 僅在返回值類型上不同
encapsulate.fields.title=封裝欄位
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=使用存取器即使欄位是可存取的
entity.name.accessor=存取器
entity.name.constructor.parameter=參數
entity.name.inheritor=繼承者
entity.name.test=測試
entity.name.variable=變數
enum.constant.description=枚舉常數{0}
enum.description={1, choice, 0\#|1\#區域}枚舉{0}
error.cannot.resolve=無法解析 {0}
error.incorrect.data=不正確的資料
error.not.supported.for.jsp={0}重構不支持JSP
error.not.supported.for.local=擴展區域類別的類別無法轉換為內部類別
error.not.supported.for.package.info={0}重構不支持 package-info.java
error.wrong.caret.position.anonymous=文字游標應置於要重構的匿名類別或區域內部
error.wrong.caret.position.constructor=文字游標應置於要重構的建構函式內
error.wrong.caret.position.local.or.expression.name=文字游標應置於要重構的區域變數或表達式的名稱處
error.wrong.caret.position.method=文字游標應置於要重構的方法內
error.wrong.name.input=錯誤的名稱\:{0}
expand.method.reference.warning=方法用於一個或多個方法參照。繼續會將這些方法參照轉換為 lambda 表達式。
expression.result=表達式結果
extract.chained.constructor.checkbox=提取鏈接建構函式 (&C)
extract.delegate.as.enum.checkbox=提取為枚舉
extract.delegate.create.nested.checkbox=建立嵌套類別
extract.delegate.generate.accessors.checkbox=生成存取器(&G)
extract.delegate.unable.create.warning.message=無法建立包含給定名稱的類別
extract.method.checkbox.annotate=註解
extract.method.checkbox.make.static=設為 static
extract.method.checkbox.make.static.and.pass.fields=設為 static 並傳遞欄位
extract.method.conflict.parameter=衝突的參數名\: {0}
extract.method.conflict.variable=名為 {0} 的變數已在選定作用域中定義
extract.method.control.flow.analysis.failed=程式碼包含語法錯誤。無法執行必要的分析。
extract.method.dialog.separator.parameters=參數(&P)
extract.method.error.annotation.value=無法從註解值提取方法
extract.method.error.class.not.found=所選塊應當是 java 類別的一部分。
extract.method.error.class.outside.defined=區域類別在所選塊之外定義。
extract.method.error.class.outside.used=區域類別在所選塊之外使用。
extract.method.error.exception=當拋出異常時，其行為會有所不同。
extract.method.error.local.class.defined.outside=無法提取方法，因為選定程式碼段使用在片段之外定義的區域類別
extract.method.error.local.class.used.outside=無法提取方法，因為選定程式碼段定義在片段之外使用的區域類別
extract.method.error.local.class.variable.used.outside=無法提取方法，因為選定程式碼段定義在片段之外使用的區域類別類型的變數
extract.method.error.make.static=無法設為 static
extract.method.error.many.exits=有多個出口點。
extract.method.error.many.finals=存在對 final 欄位的賦值。
extract.method.error.many.outputs=有多個變數要返回。
extract.method.error.method.conflict=具有相同簽名的方法已存在
extract.method.error.prefix=無法提取方法。
extract.method.error.variable.in.expression=所選表達式內有一個要返回的變數。
extract.method.error.wrap.many.outputs=所選程式碼塊中有多個輸出變數。\n如果我們將它們折疊到 {0} 中，即可提取該方法。
extract.method.error.wrap.many.outputs.class=單個物件
extract.method.error.wrap.many.outputs.record=新記錄
extract.method.gotit.navigation.header=想要更改方法簽名?
extract.method.gotit.navigation.message=轉到方法宣告執行動作\: <br/>{0}方法名稱或按 {1}。
extract.method.gotit.signature.header=更改方法簽名
extract.method.gotit.signature.message=<html><p style\=''margin-bottom\:3px;''>1. 編輯簽名</p><p style\=''margin-bottom\:3px;''>2. 更新用法\: 點擊裝訂區域中的圖示或按 {0}</p><p><font color\=gray>要對參數重新排序，請使用 {1} 或 {2}。</font></p></html>
extract.method.link.label.more.options=更多選項
extract.method.object=提取方法物件
extract.method.object.anonymous.make.varargs.option=設為 vararg(&V)
extract.method.object.class.name=類別名(&C)\:
extract.method.object.create.anonymous.class=建立匿名類別(&A)
extract.method.object.create.inner.class=建立內部類別(&I)
extract.method.object.inner.class.visibility=可見性\:
extract.method.object.inner.make.static.option=設為 static(&S)
extract.method.object.inner.make.varargs.option=設為 vararg(&V)
extract.method.object.inner.visibility.package.local=package local(&K)
extract.method.object.inner.visibility.private=private(&V)
extract.method.object.inner.visibility.protected=protected(&O)
extract.method.object.inner.visibility.public=public(&B)
extract.method.object.method.name=方法名稱(&M)\:
extract.method.object.parameters=參數
extract.method.object.signature.preview=簽名預覽
extract.method.object.suggestion=是否要提取方法物件?
extract.method.preview.node.invalid.prefix=無效 
extract.method.progress.replace.duplicates=正在取代重複項
extract.method.progress.search.duplicates=搜尋重複項
extract.parameters.to.replace.duplicates=提取參數以取代重複項
extract.subclass.command=提取子類別
extractSuper.rename.original.class.to=重新命名原始類別到\: (&R)
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=工廠方法名稱\:
failed.to.re.run.refactoring=無法重新執行重構
field.0.is.already.defined.in.the.1=欄位 {0} 已經在 {1} 中定義
field.0.is.never.used=欄位{0}從未使用過
field.0.is.not.accessible=欄位{0}是不可以從{1}
field.0.will.hide.field.1.of.the.base.class=欄位 {0} 將隱藏基{2}的欄位 {1}
field.0.won.t.be.initialized.already.in.class.initializer=欄位 ''{0}'' 不會在類別初始設定式內部初始化
field.declaration.radio=欄位宣告 (&D)
field.description=欄位{0}
field.name=欄位名稱 (&F)\:
fields.to.be.refactored.should.belong.to.the.same.class=重構的欄位應該屬於同一個類別
functional.interface.broken=函式表達式要求功能介面準確的一種方法
generate.getter.for.delegated.component=為委派成員生成getter (&G)
generate.module.descriptors.analysing.message=正在分析相依關係
generate.module.descriptors.build.required.message=無法生成模組檔案描述子，因為該專案尚未建置
generate.module.descriptors.collecting.message=正在收集相依關係
generate.module.descriptors.command.title=生成 module-info 檔案描述子
generate.module.descriptors.io.exceptions.message=讀取模組 {0} 檔案時出現問題
generate.module.descriptors.no.suitable.modules.message=未找到可能包含模組資訊的模組
generate.module.descriptors.preparing.message=正在準備程式碼
generate.module.descriptors.rebuild.message=為了提高相依關係計算的準確性，需要建置該專案。\n在生成模組資訊檔案描述子之前開始建置?
generate.module.descriptors.scanning.message=正在掃描編譯器輸出
generate.module.descriptors.title=生成模組檔案描述子
getter.and.setter.methods.found.for.the.field.0=發現欄位 {0} 的 getter和setter方法。是否將它們一起 {1}?
getter.method.found.for.the.field.0=發現欄位 {0} 的 getter 方法。 是否將 getter 一起{1}?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}沒有發現任何副本
ignore.button=忽略
implicit.last.parameter.warning=隱式最後一個參數不應刪除
infer.class.type.args.warning=無法推斷類別類型實參。繼續時，將建立原始 {0}
information.title=資訊
initializer.for.variable.cannot.be.a.constant.initializer=變數的 {0} 初始設定式不能是常數初始設定式
inline.action.name=內聯
inline.anonymous.conflict.progress=正在搜尋類別“{0}”繼承者…
inline.class.elements.header=類別內聯
inline.conflicts.progress=檢查是否可以內聯…
inline.constant.field.not.supported.for.enum.constants=枚舉常數不支持 {0}
inline.element.unknown.header=未知元素
inline.field.action.name=內聯欄位…
inline.field.command=內聯欄位 {0}
inline.field.elements.header=場內聯
inline.field.field.name.label=內聯欄位 ''{0}''\:
inline.field.field.occurrences=內聯具有 {1} 個{1, choice, 1\#用法|2\#用法}的欄位 ''{0}''\:
inline.field.initializer.is.not.accessible=欄位初始設定式參照無法在 {1} 中存取的 {0}
inline.field.title=內聯領域
inline.field.used.in.javadoc=已內聯欄位用於 javadoc
inline.field.used.in.reflection=已內聯欄位以反射形式使用
inline.local.unable.try.catch.warning.message=無法在 try/catch 語句外內聯
inline.local.used.as.resource.cannot.refactor.message=變數用作資源參照
inline.local.variable.declared.outside.cannot.refactor.message=變數在程式碼塊外宣告
inline.method.calls.not.accessible.in=已內聯方法呼叫將不會在 {1} 中存取的 {0}
inline.method.calls.not.accessible.on.qualifier=已內聯方法呼叫在限定符 {1} 上將無法存取的 {0}
inline.method.checking.tail.calls.progress=檢查尾呼叫用法
inline.method.elements.header=方法內聯
inline.method.method.label=內聯方法 ''{0}''\:
inline.method.method.occurrences=內聯具有 {1} 個{1, choice, 1\#用法|2\#用法}的方法 ''{0}''\:
inline.method.multiline.method.in.ctor.call=內聯不能在建構函式呼叫中應用於多行方法
inline.method.multiline.method.in.loop.condition=內聯不能在迴圈條件中應用於多行方法
inline.method.object.action.name=內聯物件
inline.method.object.suggestion.message=是否要內聯物件和後續呼叫?
inline.method.qualifier.usage.side.effect=已內聯方法用於方法參照，限定符具有副作用
inline.method.used.in.javadoc=已內聯方法用於 javadoc
inline.method.used.in.reflection=已內聯方法以反射形式使用
inline.object.command.name=內聯物件
inline.parameter.action.name=內聯參數…
inline.parameter.cannot.find.initializer.warning.message=無法為參數找到常數初始設定式
inline.parameter.confirmation=將參數 ''{0}'' 與初始設定式 ''{1}'' 內聯?
inline.parameter.dependency.unavailable.in.parameter.method=參數初始設定式相依 {0}，後者在參數的方法中無法存取
inline.parameter.depends.on.caller.parameter=參數初始設定式取決於呼叫方的 {0}
inline.parameter.depends.on.non.static=參數初始設定式依賴於非 static {0}，並且參數的方法內沒有可用實例
inline.parameter.depends.on.non.static.class=參數初始設定式依賴於非 static {0}，後者在參數的方法內部無法存取
inline.parameter.error.hierarchy=內聯參數不支持當方法是一個繼承層次結構的一部分
inline.parameter.error.non.project.method=非專案方法不支持內聯
inline.parameter.error.varargs=不支持內聯 vararg 參數
inline.parameter.initializer.depends.on.inaccessible.value=無法內聯對參數初始設定式的寫入權限
inline.parameter.method.usages.progress=正在搜尋方法用法
inline.parameter.no.usages.warning.message=方法沒有用法
inline.parameter.not.accessible.warning.message=在方法體內無法存取常數初始設定式
inline.parameter.refactoring=內聯參數
inline.parameter.replace.with.local.checkbox=取代為區域變數(e)\r (&E)
inline.parameter.write.usages.warning.message=不支持具有寫入用法的內聯參數
inline.pattern.variable.title=內聯模式變數
inline.popup.highlight=醒目提示顯示 {0} 個衝突的{0, choice, 1\#寫入|2\#寫入}
inline.popup.ignore.conflicts=忽略寫入並繼續
inline.super.class=內聯超類別
inline.super.class.action.name=內聯超類別…
inline.super.class.label=類別{0}
inline.super.ctor.can.be.replaced=建構函式 {0} 可被取代為 {1} 的任意一個
inline.super.doc.panel.title=已內聯成員的 JavaDoc
inline.super.expr.can.be.replaced={0} 可被取代為 {1} 的任意一個
inline.super.no.anonymous.class=無法內聯到匿名類別中。
inline.super.no.ctor=找不到建構函式符合的 super
inline.super.no.inheritors.warning.message=無法內聯沒有繼承者的類別
inline.super.no.inner.class=無法內聯到內部類別中。將 ''{0}'' 移至上一級別
inline.super.no.return.in.super.ctor=當 return 語句中斷超級建構函式的執行流時，不支持重構
inline.super.no.substitution=找不到 {0} 的一致取代。應為 ''{1}''，但找到的為 ''{2}''。
inline.super.non.project.class.warning.message=無法內聯非專案類別
inline.super.static.import.can.be.replaced=static import 可被取代為 {0} 的任意一個
inline.super.target.instead.of.super.class=目標類型的實例被傳遞到期望超類別的位置。
inline.super.type.element.can.be.replaced={0} 可被取代為 {1} 的任意一個
inline.super.type.params.differ=類型參數在 {0} 中不一致。應為 {1}，但找到的為 {2}
inline.super.unknown.type=類型未知
inline.superclass.foreign.language.conflict.message=無法內聯到 {0}
inline.to.anonymous.border.title=內聯
inline.to.anonymous.command.name=內聯類別{0}
inline.to.anonymous.name.label=類別 {0}
inline.to.anonymous.no.abstract=抽象類別不能被內聯
inline.to.anonymous.no.ctor.calls=類別無法內聯，因為它呼叫了自己的建構函式
inline.to.anonymous.no.get.class.calls=getClass() 呼叫的結果將被更改
inline.to.anonymous.no.method.calls=類別無法內聯，因為它在另一個實例上訪問自己的成員
inline.to.anonymous.no.multiple.interfaces=實作多個接口的類別不能被內聯
inline.to.anonymous.no.superclass.and.interface=有超類別和實作了接口的類別不能被內聯
inline.to.anonymous.refactoring=內聯到匿名類別
inline.vars.elements.header=變數以內聯
inline.warning.variables.used.in.initializer.are.updated=不安全的內聯\: 初始設定式中使用的變數已更新
inlined.method.implements.method.from.0=內聯方法實作方法從{0}
inlined.method.overrides.method.from.0=從{0}內聯方法覆寫方法
inlined.method.will.be.transformed.to.single.return.form=內聯方法將轉換為單個返回形式
inner.class.0.is.already.defined.in.class.1=內部類別 {0} 已在類別 {1} 中定義。\n仍然繼續?
inner.class.0.is.not.static=內部類別 {0} 不為 static。\n僅 static 成員支援{1}重構。
inner.class.exists=名為''{0}''的內部類別已經定義在類別''{1}''中
inner.class.name=內部類別名(&I)\:
instance.initializer.description={0} 的實例初始設定式
instances.casted.to.java.lang.object=轉換為 java.lang.Object 的實例
instances.of.0.upcasted.to.1.were.found=發現了 {0} 的實例被向上轉換為 {1}。如果繼續，它們將顯示在單獨的“尋找”頁籤中。
instances.upcasted.to.java.lang.object.found=找到向上轉換為 java.lang.Object 的實例
instances.upcasted.to.object=向上轉型實例物件
interface.0.does.not.have.inheritors=接口 {0} 沒有繼承者
interface.description={1, choice, 0\#|1\#區域}接口 {0}
interface.does.not.have.base.interfaces=接口 {0} 沒有基接口
interface.has.been.successfully.created=已成功建立接口 {0}
introduce.constant.enum.cb=提取為枚舉常數 (&E)
introduce.constant.field.of.type=常數(static final 欄位)的類型(&T)\:
introduce.constant.introduce.to.class=提取到類別(完全限定名稱)(&C)\:
introduce.constant.move.to.another.class.checkbox=移至另一個類別(&M)
introduce.field.field.of.type=類型的欄位\: (&T)
introduce.field.static.field.of.type=static 欄位的類型(&T)\:
introduce.functional.variable.pass.fields.checkbox=將欄位作為參數傳遞(&F)
introduce.local.variable.to.reassign.title=選擇要重新分配的變數
introduce.parameter.command=正在將參數提取到{0}
introduce.parameter.convert.lambda=轉換為 lambda (&C)
introduce.parameter.duplicates.progress=搜尋方法重複項…
introduce.parameter.elements.header=正在將參數新增到方法
introduce.parameter.object.create.inner.class=建立內部類別(&I)
introduce.parameter.object.create.new.class=建立新類別(&C)
introduce.parameter.object.error.class.does.not.exist=''{0}'' 不存在
introduce.parameter.object.error.created.class.wont.be.accessible=建立的類別無法存取
introduce.parameter.object.error.existing.class.misses.compatible.constructor=現有類別中沒有相容的建構函式
introduce.parameter.object.error.file.already.exits=檔案已存在\: {0}
introduce.parameter.object.error.inner.class.already.exist=名稱為 ''{0}'' 的內部類別已存在
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' 是無效的內部類別名
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' 是無效的參數類別名
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' 是無效的參數類別軟體套件名稱
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' 是無效的限定參數類別名
introduce.parameter.object.error.no.field.associated.found=找不到與 {0} 關聯的欄位
introduce.parameter.object.escalate.visibility.option=升級可見性(&E)
introduce.parameter.object.existing.class.name=名稱(&N)
introduce.parameter.object.generate.accessors.option=生成存取器(&G)
introduce.parameter.object.inner.class.name=名稱(&N)
introduce.parameter.object.new.class.name=名稱(&N)
introduce.parameter.object.new.class.package.name=軟體套件名稱(&P)
introduce.parameter.object.use.existing.class=使用現有類別(&U)
introduce.parameter.super.method.checkbox=重構 super 方法(&U)
introduce.variable.message.cannot.extract.in.implicit.class=無法在壓縮原始檔中提取。
introduce.variable.message.cannot.extract.variable.in.interface=無法在接口中提取變數。
introduce.variable.message.change.semantics.warning=提取所選表達式會改變周圍表達式的語意。
introduce.variable.message.expression.refers.to.pattern.variable.declared.outside=所選表達式會參照模式變數 ''{0}''，這將超出作用域。
introduce.variable.no.matching.occurrences=無符合項
introduced.variable.will.conflict.with.0=引入的變數與{0}衝突
introducing.variable.may.break.code.logic=引入變數可能打破程式碼邏輯。
invalid.expression.context=無效的表達式上下文。
invalid.package.name=無效的軟體套件名稱\: {0}
invalid.target.package.name.specified=指定了無效的目標軟體套件名稱
invert.boolean.foreach=Foreach 參數初始值設定不能反轉
invert.boolean.wrong.type=該方法的返回值類型或類型的變數是重構應該是布爾
invocations.to.be.inlined=呼叫內聯{0}
is.modified.in.loop.body={0} 在循環體中被修改
java.safe.delete.caller.text=將在此處顯示將被呼叫方醒目提示的呼叫方文本
java.safe.delete.empty.callee.text=將在此處顯示被呼叫方文本
javadoc.for.abstracts=JavaDoc的摘要
keep.original.signature=保留原始簽名
local.variable.description=區域變數{0}
local.will.be.hidden.renamed.description=重新命名的欄位將隱藏 {0}
localToInner.refactoring.name=將本地類別轉換為內部類別
locate.caret.inside.a.method=將文本光標定位在成員內
locate.duplicates.action.name=定位重複項
make.0.static=將{0}設為 static
make.method.static.title=將方法設為 static
make.static.command=將 {0} 設為 static
make.static.description.label=將{0} {1}設為 static
make.static.elements.header=要設為 static 的{0}
make.static.method.references.progress=搜尋方法參照
make.static.methods.to.propagate.dialog.title=選擇要傳遞 static 的方法
members.to.form.interface.title=要構成接口的成員
members.to.form.superclass.title=要形成超類別的成員
method.0.is.overridden.by.1=方法{0}被{1}覆寫。
method.0.will.hide.method.of.the.base.class=方法將隱藏 super {1} 的 {0}
method.0.will.implement.method.of.the.base.class=方法將實作 super {1} 的 {0}
method.0.will.override.a.method.of.the.base.class=方法將覆寫 super {1} 的 {0}
method.call.would.be.linked.to.0.after.rename=重新命名後將呼叫不同的 {0}
method.column=方法
method.description=方法 {0}
method.does.not.have.a.body=方法{0}沒有方法體。
method.duplicates.found.message=找到 {0, choice, 1\#1 個程式碼段|2\#{0,number} 個程式碼段}
method.has.an.empty.body=方法 {0} 具有空體。
method.is.not.a.constructor=方法是不是建構函式。
method.reference.will.be.converted.to.lambda.expression.warning=方法參照將轉換為 lambda 表達式
method.with.the.same.erasure=具有同樣擦除的方法
migration.class=類別
migration.dialog.alert.delete=刪除
migration.dialog.alert.name=刪除遷移映射
migration.dialog.alert.text=刪除 ''{0}'' 遷移?
migration.dialog.link.delete=刪除
migration.dialog.link.duplicate=複製和編輯…
migration.dialog.link.edit=編輯…
migration.dialog.ok.button.text=執行
migration.dialog.scope.label=作用域\:
migration.dialog.scope.whole.project=整個專案
migration.dialog.title=軟體套件和類別遷移
migration.edit.copy.existing=複製現有
migration.edit.duplicated.migration.name={0} 副本
migration.edit.empty.name=遷移名稱不能為空。
migration.edit.empty.table=遷移表不能為空。
migration.edit.existing.name=已經存在同名的遷移。
migration.entry.class=類別
migration.entry.new.name=新名稱\:
migration.entry.old.name=舊名稱\:
migration.entry.package=軟體套件
migration.map.description.label=映射描述\:
migration.map.name.prompt=地圖的名字\:
migration.new.name.column.header=新名字
migration.no.usages.found.in.the.project=專案中找不到任何用法
migration.old.name.column.header=舊名稱
migration.package=軟體套件
migration.package.with.subpackages=軟體套件和子軟體套件
migration.title=遷移
migration.type.column.header=類型
move.class=移動類別…
move.class.or.package.build.directories=正在建置目錄列表
move.class.refactoring.cannot.be.applied.to.anonymous.classes=移動類別重構不能應用於匿名類別
move.class.to.inner.command.name=將{0, choice, 1\#類別|2\#類別} 從 {1} 移至 {2}
move.class.to.inner.find.target.class.progress=正在尋找目標類別…
move.class.to.inner.move.to.self.error=不允許移動類別到自身
move.class.to.inner.nonstatic.error=不允許將類別移至非 static 內部類別
move.class.to.new.file.or.make.inner.class.preview=將類別 ''{0}'' 移動到您選擇的軟體套件中的新檔案，或將其轉換為現有類別的內部類別。
move.classes=移動類別…
move.classes.and.packages=移動類別和軟體套件…
move.classes.command=正在將 {0} 移到軟體套件 {1}
move.classes.destination.make.inner=使內部類別(&M)
move.classes.destination.package.prompt=到軟體套件\:
move.classes.destination.to.package=到軟體套件(&G)
move.classes.invalid.package.name.warning.message=無效的軟體套件名稱
move.classes.or.packages.different.modules.exports.conflict=將 {0} 從模組 {1} 移至模組 {2} 可以隱藏對其的存取
move.classes.or.packages.new.module.exports.conflict=更改軟體套件 {0} 的 export/opens 語句將授予對同一軟體套件中其他類型及其成員的存取權限
move.classes.or.packages.title=移動
move.classes.or.packages.unused.exports.action.name=刪除未使用的 exports/opens
move.classes.or.packages.unused.exports.command.name=刪除未使用的 exports/opens
move.classes.or.packages.unused.exports.notification.title=在模組 {0,choice, 1\#檔案描述子|2\#檔案描述子} 中<br>\n發現未使用的 export/open
move.enum.constant.cb=如果可能，作為枚舉常數移動(&E)
move.files.regrouping.command.name=正在重新分組…
move.files.to.new.directory.prompt=到目錄\:
move.inner.class.action.name=移動內部類別…
move.inner.class.command=移動內部類別{0}
move.inner.class.to.another.class=移動內部類別{0}到另一個類別 (&M)
move.inner.class.to.be.moved=類別移動
move.inner.class.to.upper.level=將內部類別 {0} 移至上一級
move.inner.class.to.upper.level.action.name=將內部類移至上一級別…
move.inner.class.to.upper.level.or.another.class.preview=將內部類別 ''{0}'' 移動到您選擇的軟體套件的頂層或另一個類別。
move.inner.class.to.upper.level.preview=將內部類別 ''{0}'' 移動到您選擇的軟體套件的頂層。
move.instance.method.delegate.title=移動實例方法…
move.instance.method.elements.header=移動實例方法
move.instance.method.handler.make.method.static=是否要將方法 ''{0}'' 設為 static 並隨後移動?
move.label.text=移動\:
move.member.write.access.in.interface.conflict=向 {0} 寫入，但接口僅允許包含常數。
move.members.action.name=移動成員…
move.method.enter.a.valid.name.for.parameter=請輸入一個有效的參數名稱
move.method.is.not.supported.for.0={0} 不支持移動實例方法
move.method.is.not.supported.for.constructors=建構函式不支持 Move 方法
move.method.is.not.supported.for.generic.classes=泛型類別不支持 Move 方法
move.method.is.not.supported.for.non.project.methods=非專案方法不支持 Move 方法
move.method.this.parameter.label=為 ''{0}.this'' 參數選擇一個名稱
move.methods.panel.title=要移至已提取類別的方法(&M)
move.methods.used.in.extracted.block.only=僅在提取塊中使用的 Move 方法
move.nonstatic.class.from.jsp.not.supported=不支持從 JSP 頁面移動非 static 類別
move.package.or.directory=移動軟體套件或目錄…
move.package.refactoring.cannot.be.applied.to.default.package=“移動軟體套件”重構不能用於預設軟體套件
move.packages.or.directories=移動軟體套件或目錄…
move.single.class.or.package.name.label=移動 {0} {1}
move.specified.classes=移動指定的類別
move.specified.packages=移動指定的軟體套件
move.to.inner.duplicate.inner.class=類別{0}已包含一個名為{1}的內部類別
moving.local.classes.is.not.supported=不支持移動區域類別。
no.class.name.specified=未指定類別名
no.exact.method.duplicates.were.found=<html><b>找到了 {0,choice, 0\#0|1\#1|2\#{0}} 個確切的方法{0,choice, 0\#重複項|1\#重複項|2\#重複項}</b>，但如下所示，被更改的方法中還有 {1} 個{1,choice, 1\#重複項|2\#重複項}</html>
no.initializer.present.for.the.field=欄位沒有初始設定式
no.parameter.name.specified=未指定參數名稱
no.usages.can.be.replaced=沒有用途的{0}可以取代用法{1}
occurrences.to.be.migrated=要遷移的符合項 {0}
ok.button=確定
only.fields.variables.of.methods.of.valid.type.can.be.considered=僅可以考慮有效類型的欄位、變數、方法參數或方法。
package.description=軟體套件 {0}
package.does.not.exist=軟體套件 {0} 不存在。\n是否要建立?
package.does.not.exist.preview=軟體套件 {0} 不存在。\n重構稍後將為您建立該軟體套件。
package.name.prompt=軟體套件名稱(&G)\:
parameter.description=參數 {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=參數初始設定式包含 {0}，但並非對方法的所有呼叫都位於其類別中
parameter.name.prompt=參數名稱(&M)\:
parameter.of.type=類型的參數(&T)\:
parameter.type.table.column.title=類型
parameter.used.in.method.body.warning={0} 用於方法體
pass.outer.class.instance.as.parameter=將外部類別實例作為參數傳遞(&U)
pattern.variable.description=模式變數 {0}
please.enter.a.valid.target.package.name=請輸入一個有效的目標軟體套件名稱
popup.title.choose.class.to.introduce.constant=選擇要引入常數的類別
popup.title.choose.class.to.introduce.field=選擇要引入欄位的類別
press.the.do.migrate.button=按搜尋結果面板底部的“”遷移按鈕，\n使用遷移映射“{0}”進行遷移
preview.usages.to.be.changed=預覽要改變的用法 (&P)
process.duplicates.change.signature.promt=要取代所有符合項，需要更改方法簽名。是否繼續?
process.duplicates.title=處理重複項
process.methods.duplicates.title=過程方法 {2} 重複({0}/{1})
processing.progress.text=正在處理 {0}
progress.title.collect.hierarchy=收集 ''{0}'' 層次結構
project.files.have.been.changed=已更改專案檔案。\n要重新執行重構嗎?
push.down.delete.warning.text={0}向下推動成員會導致它們被刪除。要繼續嗎?
push.down.enum.no.constants.warning.text=枚舉 {0} 沒有要內聯到的常數。
push.down.no.inheritors.class.warning.text=類別 {0} 沒有繼承者。
push.down.no.inheritors.final.class.warning.text=final 類別 {0} 沒有繼承者。
push.down.unrelated.defaults.conflict={0} 將從 {1} 和 {2} 繼承不相關的預設值
push.up.abstract.accessibility.in.subclass.conflict={0} 使用無法通過子類別存取的 {1}。
push.up.abstract.accessible.from.the.subclass.conflict=無法將 {0} 設為抽象，因為無法通過子類別對其進行存取。
push.up.super.class.signature.conflict=超類別中的 {0} 與 {1} 中的方法 {2} 衝突
re.run.refactoring=重新執行重構
record.component.used.in.method.body.warning=記錄組件 ''{0}'' 已使用
record.description={1, choice, 0\#|1\#區域}記錄 {0}
refactor.base.method.choice=重構基{0, choice, 0\#方法|1\#方法}
refactor.only.current.method.choice=僅重構當前方法
refactoring.cannot.be.applied.no.sources.attached=“{0}”重構無法套用\: 未附加任何源
refactoring.cannot.be.applied.to.abstract.methods={0}重構不能應用於 abstract 方法
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0}重構不能用於內聯非鏈接建構函式
refactoring.cannot.be.applied.to.native.methods={0} 重構不能應用於原生方法
refactoring.cannot.be.applied.to.vararg.constructors={0}重構無法應用於 vararg 建構函式
refactoring.extract.method.dialog.duplicates.count={0,choice, 1\#1|2\#{0,number}} 個重複的程式碼{0,choice, 1\#段|2\#段}可被取代為提取的方法呼叫
refactoring.extract.method.dialog.duplicates.pending=正在搜尋重複項…
refactoring.extract.method.dialog.duplicates.progress=正在搜尋重複項
refactoring.extract.method.inner.class.defined=內部類別 {0} 已在類別 {1} 中定義。
refactoring.extract.method.preview.button.refactor=重構(&R)
refactoring.extract.method.preview.button.rerun=重新執行重構(&E)
refactoring.extract.method.preview.failed=無法提取方法
refactoring.extract.method.preview.group.duplicates=重複的程式碼段
refactoring.extract.method.preview.group.method=要提取的方法
refactoring.extract.method.preview.group.original=原始程式碼段
refactoring.extract.method.preview.preparing=正在準備差異
refactoring.extract.method.preview.updating=正在更新差異
refactoring.extract.method.reference.to.change=待更改參照
refactoring.introduce.variable.enum.in.label.message=無法提取 switch 標籤中的枚舉常數
refactoring.is.not.supported.for.jsp.classes=JSP 類別不支持重構
refactoring.is.not.supported.in.the.current.context={0}重構是不支持在當前上下文
references.in.code.to.elements.from.migration.map=在程式碼中參照來自遷移映射“{0}”{1} 的元素
references.to.0.to.be.replaced.with.references.to.1=對 ''{0}'' 的參照要取代為對 ''{1}''{2} 的參照
remove.parameter.0.no.longer.used=移除不再使用的參數 ''{0}''
removing.redundant.imports.progress.title=正在移除冗餘匯入
rename.accessors=重新命名存取器(&A)
rename.accessors.title=重新命名 Getter/Setter
rename.accessors.with.the.following.names.to=將具有以下名稱的存取器重命名為\:
rename.constructor.parameters.title=重新命名建構函式參數
rename.constructor.parameters.with.the.following.names.to=將具有以下名稱的參數重命名為\:
rename.inheritors.with.the.following.names.to.title=將具有以下名稱的繼承者重命名為\:
rename.module.already.exists=模組 ''{0}'' 已經存在於專案中
rename.module.directory.command=將模組和目錄重命名為 ''{0}''
rename.module.directory.title=重新命名模組和目錄(&A)
rename.overloads=重新命名多載 (&O)
rename.overloads.dialog.title=重新命名多載
rename.overloads.to.dialog.description=將重載重命名為\:
rename.parameter.in.hierarchy.to.dialog.description=將層次結構中的參數重命名為\:
rename.parameters.dialog.title=重新命名參數
rename.test.method=重新命名測試方法
rename.test.method.description=將具有以下名稱的測試方法重命名為\:
rename.test.method.entity.name=測試方法
rename.test.method.title=重新命名測試方法
rename.tests=重新命名測試 (&E)
rename.tests.title=重新命名測試
rename.tests.with.the.following.names.to=將具有以下名稱的測試重命名為\:
rename.variables=重新命名變數 (&V)
rename.variables.title=重新命名變數
renamed.class.will.hide.0.in.1=重新命名類別將隱藏{0}在{1}
renaming.method.will.override.final.0=方法將覆寫 super {1} 的 final {0}
replace.all.and.extract=取代所有 {0} 符合項並提取為 ''{1}'' 動作
replace.all.fields=取代所有欄位 (&R)
replace.all.occurrences.changes.semantics=取代所有 {0} 匹配項(將更改語意\!)
replace.all.occurrences.of.expression.0.occurrences=取代所有符合項({0})(&A)
replace.all.read.and.write=取代讀取和寫入符合項 (將更改語意\!)
replace.as.separate.operation=提取為 ''{0}'' 動作
replace.constructor.0.with.a.factory.method=將建構函式 {0} 取代為工廠方法
replace.constructor.builder.create.new=建立新的(&C)
replace.constructor.builder.default.value.table.title=預設值
replace.constructor.builder.error.builder.class.cannot.be.the.same=類別 {0} 不能是其自己的建置器類別。
replace.constructor.builder.error.caret.position=文字游標應置於建構函式要取代為建置器的類別中。
replace.constructor.builder.error.class.with.chosen.name.already.exist=類別 {0} 在軟體套件 {1} 中已存在。
replace.constructor.builder.error.identifier.invalid=關鍵字 ''{0}'' 無效
replace.constructor.builder.error.invalid.builder.class.name=''{0}'' 不是有效的類別名
replace.constructor.builder.error.invalid.builder.package.name=''{0}'' 不是有效的軟體套件名稱
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}'' 不是有效的完全限定類別名
replace.constructor.builder.error.invalid.field.name=''{0}'' 不是有效的欄位名
replace.constructor.builder.error.invalid.setter.name=''{0}'' 不是有效的 setter 名稱
replace.constructor.builder.error.no.constructor.chain={0} 的建構函式不形成簡單鏈。
replace.constructor.builder.error.no.constructors=當前類別沒有要取代為建置器的建構函式。
replace.constructor.builder.error.selected.class.was.not.found=找不到現有的建置器類別 {0}。
replace.constructor.builder.field.name.table.title=欄位名稱
replace.constructor.builder.optional.setter.table.title=可選 Setter
replace.constructor.builder.parameter.table.title=參數
replace.constructor.builder.select.builder.class.chooser.title=選擇建置器類別
replace.constructor.builder.setter.name.table.title=Setter 名稱
replace.constructor.builder.use.existing=使用現有項(&U)
replace.constructor.existing.builder.fqn=建置器類別名 (完全限定)(&B)
replace.constructor.factory.error.factory.method.already.exists=工廠方法 {0} 已存在，將用於替代新建立的工廠方法。
replace.constructor.factory.error.invalid.factory.method.name=''{0}'' 不是有效的工廠方法名稱
replace.constructor.new.builder.class.name=建置器類別名(&N)
replace.constructor.new.builder.package=新建置器的軟體套件(&P)
replace.constructor.with.builder=將建構函式取代為建置器
replace.constructor.with.builder.text=將建構函式取代為建置器
replace.constructor.with.factory.method=將建構函式取代為工廠方法
replace.constructor.with.factory.method.title=將建構函式取代為工廠方法
replace.constructor.with.factory.target.fq.name=在(完全限定名稱)\:
replace.default.constructor.of.0.with.a.factory.method=將預設建構函式 {0} 取代為工廠方法
replace.default.constructor.with.factory.method=將預設建構函式取代為工廠方法
replace.fields.inaccessible.in.usage.context=取代上下文沒有使用的欄位 (&I)
replace.fields.used.in.expressions.with.their.getters=將表達式中使用的欄位取代為其 getter (&U)
replace.inheritance.from=取代委派繼承從(&R)\:
replace.inheritance.with.delegation.command=使用{0}中的委託取代繼承
replace.inheritance.with.delegation.delegate.members.title=委派成員
replace.inheritance.with.delegation.elements.header=取代繼承與代表團
replace.inheritance.with.delegation.invalid.field=''{0}'' 是委派的無效欄位名稱
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' 是委派的無效欄位名稱
replace.inheritance.with.delegation.title=用委派取代繼承
replace.inside.current.lambda=在當前 lambda 內建立變數
replace.instance.qualifiers.with.class.references=將實例限定符取代為類別參照
replace.lambda.chain.detected=檢測到 lambda 鏈
replace.method.code.duplicates.title=取代重複程式碼
replace.method.duplicates.scope.chooser.message=分析作用域
replace.method.duplicates.scope.chooser.title=指定{0}作用域
replace.occurrences.inside.statement=取代{2, choice, 1\#|2\#外部} ''{1}'' 塊中的 {0} 個匹配項
replace.this.code.fragment.and.change.signature=方法的簽名將被更改為{0}
replace.this.code.fragment.and.make.method.static=(方法將被設為 static)
replace.this.code.fragment.and.make.method.static.visible=(方法將被設為 static 和{0})
replace.this.code.fragment.and.make.method.visible=(方法將{0})
replace.with.method.call.does.not.work.for.constructors=取代為方法呼叫不工作為建構函式
replace.write.access.occurrences=取代白名單符合項 (&L)
replacing.inheritance.with.delegation=取代繼承與代表團
safe.delete.parameter.usage.warning={0} 具有無法安全刪除的呼叫端用法。
safe.delete.search.for.caller.method.usages.progress=搜尋呼叫者方法用法…
safe.delete.select.members.to.propagate.dialog.title=選擇要傳播安全刪除的成員
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=選擇要傳播參數刪除的方法
select.source.root.chooser.title=選擇根原始碼
selected.block.contains.invocation.of.another.class.constructor=所選塊包含呼叫另一個類別建構函式
selected.block.contains.statement.outside.of.class=所選塊在類別外部包含語句
selected.block.should.represent.an.expression=所選塊應該表示一個表達式
selected.expression.cannot.be.a.constant.initializer=所選表達式不能是常數初始設定式
selected.expression.cannot.be.extracted=無法提取所選表達式
selected.expression.has.void.type=所選表達式具有類型 'void'
selected.expression.introduces.pattern.variable=選定的表達式引入模式變數 ''{0}''
setter.method.found.for.the.field.0=發現欄位 {0} 的 setter 方法。 是否將 setter 一起{1}?
source.folder.0.has.package.prefix.1=源資料夾 {0} 具有軟體套件前綴 ''{1}''\n無法在該目錄中建立軟體套件 ''{2}''。
static.initializer.description={0} 的 static 初始設定式
suggest.signature.preview.after.title=之後
suggest.signature.preview.method.call.prefix=方法呼叫\:
suggest.signature.preview.title.before=之前
superclass.cannot.be.accessed.in.subclass=在子類別中將無法存取的超類別
superclass.cannot.be.extracted.from.a.record=不能從一個記錄中提取超類別
superclass.cannot.be.extracted.from.an.enum=無法從枚舉中提取超類別
synthetic.jsp.class.is.referenced.in.the.method=合成的jsp類別是參照的方法
target.0.is.not.accessible.from.1=目標{0}是不可以從{1}
template.error.class.already.defined=作用域內已定義名為 ''{0}'' 的類別
template.error.invalid.identifier.name=關鍵字名稱無效
template.error.variable.already.defined=已定義具有此名稱的變數
there.are.going.to.be.multiple.destination.files.with.the.same.name=有多個目標檔案具有相同的名稱。
there.are.multiple.exit.points.in.the.selected.code.fragment=選定的程式碼段有多個出口點。
there.are.multiple.output.values.for.the.selected.code.fragment=選定的程式碼段有多個輸出值。
there.are.no.variables.that.have.reference.type=方法參數或所包含的類別欄位都沒有參照類型
there.are.unused.methods.that.override.methods.you.delete=<html>有未使用的方法會覆寫要刪除的方法。請同時選擇要刪除的未使用的覆寫方法\:</html>
there.is.already.a.0.in.1=已存在一個{0}在{1}中
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=已經有一個{0}。它將衝突與引入的參數衝突
there.is.already.a.0.it.will.conflict.with.the.renamed.1=現有的{0}具有相同的名稱
there.is.already.a.0.it.will.conflict.with.the.renamed.short=變數 ''{0}'' 已存在
there.is.already.type.parameter.in.0.with.name.1=名稱為 {1} 的 {0} 中已存在類型參數
this.invocation.only.and.keep.the.method=僅內聯此用法並保留方法(&K)
this.method=這種方法
this.reference.only.and.keep.super.class=這個僅供參照並保持內聯的超類別(&K)
this.reference.only.and.keep.the.class=內聯這只參照和保持類別(&K)
this.reference.only.and.keep.the.field=僅內聯此用法並保留欄位(&K)
title.rename.variables.with.the.following.names.to=將具有以下名稱的變數重命名為\:
tooltip.cannot.inline.pattern.variable=無法內聯模式變數
turn.refs.to.super.command=將{0}的用法取代為{1}
turnRefsToSuper.change.usages.to=更改{0}的使用到\: (&C)
turnRefsToSuper.use.superclass.in.instanceof=使用接口/超類別在實例 (&U)
type.migration.action.name=類型遷移
type.migration.choose.scope.title=選擇可能出現更改簽名的作用域
type.migration.class.type.argument.label=將類別類型實參 {0} 遷移到
type.migration.conflicts.found=找到的遷移衝突
type.migration.error.hint.title=類型遷移
type.migration.exclude.action.text=排除 (&E)
type.migration.include.action.text=包含(&I)
type.migration.migrate.button.text=遷移 (&M)
type.migration.no.conflicts.found=未找到遷移衝突
type.migration.no.scope.warning.message=未選擇作用域
type.migration.reasons.to.migrate=已找到要遷移的原因
type.migration.rerun.button.text=重新執行類型遷移(&R)
type.migration.return.type.of.method.label=將方法 {1} 的返回值類型 {0} 遷移到
type.migration.select.suggestion=選擇根以尋找遷移的原因
type.migration.type.of.field.label=將欄位 {1} 的類型 {0} 遷移到
type.migration.type.of.parameter.label=將參數 {1} 的類型 {0} 遷移到
type.migration.type.of.pattern.variable.label=將模式變數 {1} 的類型 {0} 遷移到
type.migration.type.of.record.component.label=將記錄組件 {1} 的類型 {0} 遷移到
type.migration.type.of.variable.label=將變數 {1} 的類型 {0} 遷移到
type.of.the.selected.expression.cannot.be.determined=所選表達式的類型不能確定。
unable.to.start.type.migration=無法啟動類型遷移
unknown.expression.type=未知的表達式類型。
unused.overriding.methods.title=未使用覆寫方法
use.interface.where.possible.title=在可能處使用接口
use.super.references.prompt=在這個階段，{0} 可以分析 {1} 的用法，並在可能的情況下將其取代為 {2} 的用法。\n是否要繼續?
use.variable.initializer.to.initialize.parameter=使用變數初始設定式初始化參數(&I)
variable.0.is.changed.before.last.access=變數 ''{0}'' 在上次存取變數 ''{1}'' 前已更改。
variable.does.not.have.an.initializer=變數 {0} 沒有初始設定式。
variable.is.accessed.for.writing=變數 ''{0}'' 被存取以進行寫入
variable.is.never.used.before.modification=修改之前從未使用變數{0}
variable.of.type=類型的變數(&T)\:
variable.type.unknown=變數類型未知
would.you.like.to.replace.default.constructor.of.0.with.factory.method=要將預設建構函式 {0} 取代為工廠方法嗎?
wrap.return.value.create.inner.class=建立內部類別(&I)
wrap.return.value.create.new.class=建立新類別(&C)
wrap.return.value.existing.class.name=名稱
wrap.return.value.inner.class.name=名稱(&M)
wrap.return.value.new.class.name=名稱(&N)
wrap.return.value.new.class.package.name=軟體套件名稱(&P)
wrap.return.value.use.existing.class=使用現有類別(&U)
wrap.return.value.wrapper.field=包裝器欄位(&F)

0.already.contains.a.1={0}已包含{1}
0.already.exists.in.the.target.class={0} 已經存在於目標類別中。
0.has.1.usages.that.are.not.safe.to.delete={0} 有 {1,choice,1\#1 個用法|2\#{1,number} 個用法}不能安全刪除。
0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.method={0} 檢測到此檔案中有 {1} 個程式碼{1,choice,1\#段|2\#段}可被取代為提取方法呼叫。要檢查並取代{1,choice,1\#它|2\#它們}嗎?
0.is.already.defined.in.1=已在 {1} 中定義 {0}
0.is.already.overridden.in.1={0}在{1}中已被覆寫。不會將方法向下推送至該類。
0.is.located.in.a.jar.file={0} 位於唯讀容器中。
0.is.not.a.legal.fq.name=''{0}'' 不是合法的完全限定名稱
0.is.not.an.identifier=<b><code>{0}</code></b> 不是一個要在 <b><code>{1}</code></b> 中使用的正確關鍵字
0.is.read.only={0} 為唯讀條目。
0.refactoring.cannot.be.applied.to.constructors={0}重構無法應用於建構函式
0.referenced.in.1.will.not.be.accessible.from.module.2={0}，在{1}中參照，將無法從模組 {2} 存取
0.referenced.in.1.will.not.be.accessible.from.production.of.module.2={0}，在{1}中參照，將無法從模組 {2} 的生產源中存取
0.referenced.in.1.will.not.be.accessible.in.module.2={0}，在{1}中參照，將無法在模組 {2} 中存取
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1=內聯方法中使用的{0}無法從{1}中的呼叫點存取
0.to.be.renamed.to.1.2={0}將被重命名為{1} {2}
0.to.change.signature={0}以更改簽名
0.uses.1.which.is.not.accessible.from.the.superclass={0}使用{1}，後者無法從超類別存取
0.uses.1.which.is.not.moved.to.the.superclass={0}使用{1}，後者無法移至超類別
0.uses.1.which.is.pushed.down={0}使用{1}，後者已被向下推送
0.which.is.used.in.1.not.accessible.from.call.site.s.in.2=當 {1} 內聯到 {2} 中時，{0} 將無法存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取
ExtractSuperClass.superclass=超類別
action.next.conflict=下一個衝突
action.open.in.find.window=在“尋找”視窗中開啟(&F)
action.previous.conflict=上一個衝突
action.show.conflicts.in.view.text=在檢視中顯示衝突
add.object.as.a.parameter.with.name=將物件作為具有以下名稱的參數新增(&O)\:
advanced.setting.promote.suggested.refactoring.in.editor=在編輯器中顯示建議的重構的提示
all.invocations.and.remove.the.method=內聯所有呼叫並移除方法(&A)
all.invocations.in.project=專案中的所有呼叫(&A)
all.references.and.remove.the.local=內聯所有參照並移除變數(&A)
also.generated=同時生成\:
ask.to.delete.related.file=<html>找到相關檔案\: <code>{0}</code>。<br/>是否同時刪除它?</html>
ask.to.delete.related.files=<html>找到相關檔案\: <br/><code>{0}</code><br/><br/>是否同時刪除它們?</html>
ask.to.move.related.file=<html>找到相關檔案\: <code>{0}</code>。<br/>是否同時移動它?</html>
ask.to.move.related.files=<html>找到相關檔案\: <br/><code>{0}</code><br/><br/>是否同時移動它們?</html>
attempting.to.delete.targets.node.text=試圖刪除
automatic.renamer.entity.name.column={0} 名稱
automatic.renamer.rename.to.column=重命名為
automatic.renaming.dialog.identifier.invalid.error=關鍵字 ''{0}'' 無效
automatic.renaming.dialog.new.name.label=新名稱
automatic.renaming.dialog.rename.selected.title=重新命名選中項
border.title.introduce.parameter.class=參數類別
border.title.introduce.parameters.to.extract=要提取的參數
caller.chooser.callee.method=被呼叫方方法
caller.chooser.caller.method=呼叫方方法
caller.chooser.looking.for.callers=正在尋找呼叫方…
cancel.button=取消(&N)
cannot.create.directory=無法建立目錄
cannot.extract.selected.elements.into.include.file=無法將所選元素提取到 include 檔案中
cannot.make.abstract.method.static=無法將 abstract 方法設為 static
cannot.perform.refactoring=無法執行重構。
change.signature.code.vision.name=更改簽名
change.signature.code.vision.text=更改簽名
change.signature.default.value.chooser.title=需要參數“{0}”的預設值
change.signature.default.value.description=在呼叫此方法時，如果恰好找到了一個正確類型的變數，請使用它。否則請留空。
change.signature.feel.lucky=感到幸運(&L)
change.signature.leave.blank.default.value=留空(&B)
change.signature.use.selected.value=使用所選值(&V)
changeSignature.cannot.resolve.parameter.type=無法解析參數 ''{1}'' 的類型''{0}''。\n是否繼續?
changeSignature.default.value.label=預設值\:
changeSignature.name.prompt=名稱(&N)\:
changeSignature.parameter.caller.chooser=選擇要傳播新參數的方法
changeSignature.parameters.wont.propagate=將不會執行參數更改的遞迴傳播
changeSignature.propagate.parameters.title=傳播參數(&G)…
changeSignature.refactoring.name=更改簽名
changeSignature.return.type.prompt=返回值類型(&T)\:
changing.signature.of.0=更改{0}的簽名
checkbox.introduce.parameter.object.keep.method.as.delegate=使方法保持為委託(&D)
choose.destination.class=選擇目標類別
choose.destination.directory=選擇目標目錄
choose.destination.package=選擇目標軟體套件
class.0.does.not.exist=類別 {0} 不存在。\n是否要建立?
class.0.does.not.have.inheritors=類別 {0} 沒有繼承者。
class.constructors.radio=類別建構函式(&C)
class.does.not.have.base.classes.interfaces.in.current.project={0} 在當前專案中沒有基類別/接口
classes.to.push.down.members.to=要將成員向下推送至{0}的類別
column.name.any.var=任意變數
column.name.default.value=預設值\:
column.name.name=名稱
column.name.type=類型\:
command.name.copy=複製
command.name.move=移動
command.name.rename=重新命名
comments.and.strings=註釋和字串(&C)
comments.elements.header=在註釋、字串和非程式碼檔案中發現符合項 {0}
conflicts.count.label={0} 個衝突
conflicts.detected.title=檢測到衝突
conflicts.tab.name=衝突
constructor.cannot.be.made.static=建構函式不能設為 static
continue.button=繼續(&C)
copy.directories=複製目錄…
copy.directory=複製目錄…
copy.file=複製檔案…
copy.files=複製檔案…
copy.files.and.directories=複製檔案和目錄…
copy.files.clone.directory.0=克隆目錄 {0}
copy.files.clone.file.0=克隆檔案 {0}
copy.files.clone.title=克隆
copy.files.copy.directory.0=複製目錄 {0}
copy.files.copy.file.0=複製檔案 {0}
copy.files.copy.specified.directories.label=複製指定的目錄
copy.files.copy.specified.files.label=複製指定的檔案
copy.files.copy.specified.mixed.label=複製指定的檔案和目錄
copy.files.copy.title=複製
copy.files.new.name.label=新名稱\:
copy.files.to.directory.label=到目錄(&D)\:
copy.handler.clone.files.directories=克隆檔案/目錄
copy.handler.copy.files.directories=複製檔案/目錄
copy.overwrite.button=覆蓋
copy.overwrite.for.all.button=全部覆蓋
copy.skip.button=跳過
copy.skip.for.all.button=全部跳過
copy.update.references=更新參照
create.class.command=建立類別 {0}
create.directory=建立目錄
create.explicit.package.warning=隱式軟體套件 ''{0}'' 將變為顯式
current.method.radio=當前方法(&M)
declare.folded.parameters=折疊參數(&F)
delegation.panel.delegate.via.overloading.method=通過多載方法委託(&L)
delegation.panel.method.calls.label=方法呼叫\:
delegation.panel.modify.radio=修改(&M)
delete.anyway.button=仍然刪除(&D)
delete.title=刪除
detecting.possible.conflicts=正在檢測可能的衝突…
dialog.message.cannot.inline.reference.from.0=無法從 {0} 內聯參照
dialog.message.file.already.exists.in.directory=檔案 ''{0}'' 在目錄 ''{1}'' 中已存在
dialog.message.method.overridden.in.language.that.doesn.t.support.this.refactoring=使用 {1} 重寫了 {0}。此語言不支持“引入參數物件”重構
dialog.message.new.directory.with.ignored.name.warning=正在嘗試建立具有忽略名稱的目錄，結果將不可見
dialog.message.not.supported.source.target.pair.detected=檢測到不受支援的源/目標對
dialog.message.refactoring.not.available.in.current.scope={0} 在當前作用域內不可用
dialog.message.selected.element.used.from.non.project.files=從非專案檔案中使用所選元素。不會重新命名這些用法。仍要繼續?
dialog.title.rename.package.directories=重新命名軟體套件目錄
directories.and.all.references.to.package.will.be.renamed=\n\n您要重新命名哪些目錄?
directory.chooser.hide.non.existing.checkBox.text=僅顯示現有來源根(&H)
directory.description=目錄 {0}
do.you.wish.to.continue=您是否希望繼續?
do.you.wish.to.ignore.them.and.continue=您是否希望忽略它們並繼續?
enter.new.project.name=輸入新項目名稱\:
entity.name.form=形式
error.cannot.be.renamed=此元素無法重新命名
error.in.injected.lang.prefix.suffix=所選{0}位於注入語言文檔的唯讀部分中
error.interface.cannot.be.extracted.from.implicit.class=無法執行重構。\n無法從隱式宣告的類別中提取接口
error.out.of.project.element=所選{0}不位於專案中
error.out.of.project.element.default=所選元素不位於專案中
error.select.class.to.be.refactored=無法執行重構。\n重構應在要重構的類別或成員上呼叫。
error.superclass.cannot.be.extracted.from.implicit.class=無法執行重構。\n無法從隱式宣告的類別中提取超類別
error.title=錯誤
error.wrong.caret.position.class=文字游標應置於要重構的類別內
error.wrong.caret.position.method.or.class.name=文字游標應置於要重構的方法或類別的名稱處
error.wrong.caret.position.method.or.local.name=文字游標應置於要重構的元素的名稱處
error.wrong.caret.position.method.or.variable.name=文字游標應置於要重構的方法或變數的名稱處
error.wrong.caret.position.symbol.to.refactor=文字游標應置於要重構的符號處
error.wrong.caret.position.symbol.to.rename=文字游標應置於要重新命名的符號處
extract.include.file.action.title=提取 Include 檔案…
extract.include.file.title=提取 Include 檔案
extract.interface.command.name=從 {1} 提取接口 {0}
extract.interface.from=從中提取接口\:
extract.interface.title=提取接口
extract.method.progress=提取方法
extract.method.replace.duplicate.command.name=取代重複項
extract.method.title=提取方法
extract.superclass.command.name=從 {1} 提取超類別 {0}
extract.superclass.elements.header=將包含成員的超類別提取至目錄
extract.superclass.from=從中提取超類別\:
extract.superclass.title=提取超類別
extract.to.directory=提取至目錄(&D)\:
extractIncludeFile.name=提取 Include 檔案
extractSuper.extract=提取{0}(&X)
extractSuper.rename.original.class=重新命名原始類別並在可能的情況下使用{0}(&E)
extractSuperInterface.interface=接口
field.0.is.not.static=欄位 {0} 不為 static。\n僅 static 成員支援{1}重構。
field.exists=名稱為 {0} 的欄位\n已存在於類別 ''{1}'' 中。\n是否繼續?
file.already.exist=檔案 {0} 已存在
file.already.exist.title=提取 Include 檔案
file.description=檔案 {0}
generated.code.usage.that.is.not.safe.to.delete=在生成的程式碼中使用了無法安全刪除的 {0}。
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0} 已發現可以使用 include 指令取代的片段。\n是否要審查這些片段?
initialize.in.border.title=初始化位置(&I)
inline.command=內聯{0}
inline.field.border.title=內聯
inline.local.variable.prompt=內聯區域變數 ''{0}''?
inline.method.action.name=內聯方法…
inline.method.border.title=內聯
inline.method.command=正在內聯方法 {0}
inline.method.method.label=方法{0} {1}
inline.method.title=內聯方法
inline.popup.all=所有 {0} 個參照並移除變數
inline.popup.all.keep.name=保留 ''{0}'' 名稱
inline.popup.this.only=僅限此參照
inline.title=內聯
inline.variable.title=內聯變數
inner.classes.cannot.have.static.members=內部類別不能有 static 成員
inplace.change.signature.preview.label=已執行簽名修改\:
inplace.refactoring.abandon.started=放棄已開始的重構
inplace.refactoring.advertisement.text=按 {0} 顯示包含更多選項的對話框
inplace.refactoring.cancel.current=取消當前重構
inplace.refactoring.continue.started=繼續已開始的重構
inplace.refactoring.navigate.to.started=導覽到已開始的重構
inplace.refactoring.press.again.to.complete=再次按 {0} 以執行重構。
inplace.refactoring.tab.advertisement.text=按 {0} 顯示選項彈出視窗
intention.family.name.apply.signature.change=套用簽名更改
interface.member.dependency.required.by.interfaces.list={0,choice,1\#接口|2\#接口} {1} 所需
interface.name.prompt=接口名稱(&I)\:
introduce.constant.title=引入常數
introduce.field.title=引入欄位
introduce.functional.parameter.title=引入函式參數
introduce.functional.variable.title=引入函式變數
introduce.normalize.declaration.command.name=標準化宣告
introduce.parameter.title=引入參數
introduce.selection.error=無法使用所選元素執行重構
introduce.target.chooser.expressions.title=表達式
introduce.variable.title=引入變數
invert.0.1=反轉{0} {1} 及其用法
invert.boolean.elements.header=要反轉的{0}
invert.boolean.name.of.inverted.element=反轉的{0}的名稱(&N)\:
invert.boolean.refs.to.invert=要反轉的參照 {0}
invert.boolean.title=反轉布爾
is.not.supported.in.the.current.context=當前上下文不支持{0}
items.to.be.deleted=要被刪除的條目
javadoc.as.is=保留原樣(&A)
javadoc.copy=複製(&C)
javadoc.move=移動(&M)
keep.abstract.column.header=保持 abstract
label.change.signature.in.all.calls.to.this.method.leave.the.parameter.blank=在對此方法的所有呼叫中，將參數留空
make.abstract=設為 abstract
member.column=成員
member.info.extends.0=擴展{0}
member.info.implements.0=實作{0}
member.is.already.static=成員已經為 static
members.to.be.moved.should.belong.to.the.same.class=要移動的成員應屬於同一類別
members.to.be.pulled.up=要被向上拉取的成員(&B)
members.to.be.pushed.down.panel.title=要被向下推送的成員(&B)
members.to.form.interface=要構成接口的成員(&B)
members.to.form.superclass=要構成超類別的成員(&B)
method.0.is.already.defined.in.the.1=方法 {0} 已在{1}中定義。
method.0.is.not.static=方法 {0} 不為 static。\n僅 static 成員支援{1}重構。
migration.new.button=新…
move.0.title=移動 {0}
move.classes.destination.package.prompt=到軟體套件\:
move.classes.move.to.another.source.folder=移至另一個源資料夾(&F)
move.declarations.group=移動宣告\:
move.directories.elements.header=目錄將被移至 {0}
move.directories.with.dialog=移動目錄…
move.directory=移動目錄…
move.directory.0=移動目錄 {0}
move.file=移動檔案…
move.file.0=移動檔案 {0}
move.files=移動檔案…
move.files.and.directories=移動檔案和目錄…
move.files.elements.header=檔案將被移至 {0}
move.files.group=移動檔案\:
move.files.to.directory.label=到目錄\:
move.handler.is.dumb.during.indexing=在索引編制期間移動檔案不會更新其使用情況。選定的元素不會在非專案檔案中重新命名。是否仍要繼續?
move.inner.to.upper.level.title=將內部類別移至上一級
move.instance.method.command=移動實例方法
move.instance.method.title=移動實例方法
move.members.elements.header=要移動的成員
move.members.members.to.be.moved.border.title=需要移動的成員(僅限 static)(&B)
move.members.move.members.from.label=從以下位置移動成員\:
move.members.title=移動 static 成員
move.members.to.fully.qualified.name.label=到(完全限定名稱)\:
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=當方法是繼承層次結構的一部分時，不支持 Move 方法
move.single.element.elements.header={0} 將被移至 {1}
move.specified.directories=移動指定的目錄
move.specified.elements=移動指定的元素
move.specified.files=移動指定的檔案
move.title=移動
move.to.different.language=目標類別 {2} 具有與{0} {1} 不同的語言
moveInstanceMethod.select.an.instance.parameter=選擇一個實例表達式(&I)\:
moving.directories.command=移動目錄
multiple.directories.correspond.to.package=軟體套件 ''{0}'' 存在於多個目錄中\:
multiple.directories.correspond.to.package.current.marker=已選擇
name.for.extracted.include.file=提取的 include 檔案的名稱(預設副檔名\: {0})(&N)
name.is.not.a.valid.file.name=名稱不是有效的檔名
name.prompt=名稱(&N)
no.button=否(&N)
no.destination.class.specified=未指定目標類別
no.field.name.specified=未指定欄位名稱
no.interface.name.specified=未指定接口名稱
no.members.selected=未選擇任何成員
no.new.name.specified=未指定新名稱
no.selection=無選擇。
no.superclass.name.specified=未指定超類別名
no.target.directory.specified=未指定目標目錄
non.code.usage.that.is.not.safe.to.delete=字串、註釋或非程式碼檔案中使用了無法安全刪除的 {0}。
occurrences.found.in.comments.strings.and.non.java.files=在註釋、字串和非程式碼檔案中找到符合項
occurrences.string=({0,choice,1\#1 個匹配項|2\#{0,number} 個匹配項})
open.copy.in.editor=在編輯器中開啟副本(&O)
open.in.editor.label=在編輯器中開啟(&O)
package.for.new.interface=新接口的軟體套件(&P)\:
package.for.new.superclass=新超類別的軟體套件(&P)\:
package.for.original.class=原始類別的軟體套件(&P)\:
package.for.original.interface=原始接口的軟體套件(&P)\:
package.occurs.in.package.prefixes.of.the.following.source.folders.n=軟體套件 {0} 位於以下源資料夾的軟體套件前綴中\:
parameters.border.title=參數
path.completion.shortcut=使用 {0} 進行路徑補全
please.enter.a.valid.name.for.inverted.element=請為反轉的{0}輸入一個有效的名稱
press.escape.to.remove.the.highlighting=按 Esc 移除醒目提示
preview.button=預覽(&P)
problems.detected.title=檢測到問題
progress.text=正在尋找用法…
progress.title.collect.read.only.files=正在收集唯讀檔案…
progress.title.collecting.references=正在收集參照…
progress.title.collecting.suggested.names=正在收集建議的名稱
progress.title.prepare.additional.searcher=準備額外的搜尋器
progress.title.prepare.to.delete=準備刪除
progress.title.update.added.files=更新新增的檔案
pull.members.up.title=向上拉取成員
pull.up.members.to=將{0}的成員向上拉取至(&U)\:
pullUp.command=從 {0} 向上拉取成員
push.down.javadoc.panel.title=摘要的 JavaDoc
push.down.members.elements.header=從 {0} 向下推送成員
push.down.will.delete.members=向下推送成員將導致它們被刪除? 要建立新的子類別嗎?
push.members.down.title=向下推送成員
push.members.from.0.down.label=從{0}向下推送成員
pushed.members.will.not.be.visible.from.certain.call.sites=推送的成員將無法從特定呼叫點檢視
readonly.occurences.found=在唯讀檔案中找到符合項
refactor.anyway.button=仍然重構(&R)
refactor.button=重構(&R)
refactor.this.title=重構
refactoring.cannot.be.performed=無法執行重構
refactoring.dumb.mode.notification=在索引準備就緒前，重構不可用
refactoring.extract.method.dialog.empty=空
refactoring.extract.method.dialog.method.name=方法名稱\:
refactoring.extract.method.dialog.output.variables=輸出變數
refactoring.extract.method.dialog.parameters=參數
refactoring.extract.method.dialog.signature.preview=簽名預覽
refactoring.extract.method.dialog.title=提取方法
refactoring.extract.method.from.duplicate.code=從重複的程式碼中提取方法
refactoring.extract.method.inplace.options.tooltip=使用 {0} 導覽到選項
refactoring.index.corruption.notifiction=檢測到索引損壞。請重試重構 - 將自動重新建置索引
refactoring.indexing.warning.title=正在編制索引
refactoring.introduce.context.error=無法在此上下文中執行重構
refactoring.introduce.name.error=名稱不正確
refactoring.introduce.name.used.error=此名稱已被使用
refactoring.introduce.parameter.incomplete.call.less.params=呼叫不完整({0})\: 應為 {1} 個參數，但僅找到 {2} 個
refactoring.introduce.parameter.incomplete.call.param.not.found=呼叫不完整({0})\: 應刪除 {1} 參數，但僅找到 {2} 個參數
refactoring.introduce.parameter.interface.chooser.popup.title=選擇適用的函式式接口\: {0} -> {1}
refactoring.introduce.parameter.invalid.name=''{0}'' 是無效的參數名稱
refactoring.introduce.parameter.object.command.name={1}() 的引入參數類別 {0}
refactoring.introduce.parameter.object.method.to.extract.parameters.from.label=要從中提取參數的方法
refactoring.introduce.parameter.object.method.whose.parameters.are.to.wrapped=要包裝其參數的方法
refactoring.introduce.parameter.object.references.to.be.modified=要修改的參照
refactoring.introduce.parameter.object.title=引入參數物件
refactoring.introduce.parameter.popup.title=將參數引入方法
refactoring.introduce.selection.error=無法使用所選元素執行重構
refactoring.introduce.variable.scope.error=名稱與現有變量的名稱衝突
refactoring.introduceVariable=“引入變數”重構
refactoring.is.not.supported.for.recursive.methods=無法套用{0}重構來移除遞迴方法。\n您只能內聯各個方法呼叫。
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流時，不支持{0}重構
refactoring.not.available.indexing=索引編制期間，無法使用重構
refactoring.prepare.progress=準備…
refactoring.preprocess.usages.progress=預處理用法
references.found.in.code=在程式碼中找到參照
references.in.code=程式碼中的參照 {0}
references.in.code.to.0=程式碼中對{0}的參照
references.in.code.to.0.1=程式碼中對{0} {1} 的參照
references.to.be.changed=待更改參照 {0}
related.file=相關檔案
remove.duplicates.command=刪除重複項
rename.0.and.its.usages.preview.text=重新命名 {0} 及其用法
rename.0.and.its.usages.to=將{0}及其用法重命名為\:
rename.bound.forms=重新命名綁定形式(&F)
rename.bound.forms.title=重新命名綁定形式
rename.code.vision.command.name=重新命名程式碼
rename.code.vision.label=重新命名重構
rename.code.vision.text=重新命名用法
rename.command.name.0.1=重新命名\: {0} → ''{1}''
rename.command.name.0.in.place.template=重新命名\: {0}
rename.dialog.new.name.label=新名稱(&N)\:
rename.directories.command.name=重新命名目錄
rename.directory.button.text=僅所選目錄(&S)
rename.directory.command.name=重新命名目錄
rename.directory.title=重新命名目錄(&D)
rename.finding.auto.rename.options.modal.title=正在尋找自動重新命名選項
rename.forms.with.the.following.names.to=將具有以下名稱的形式重命名為\:
rename.implementation.class.to=將實作類別重命名為\:
rename.inheritors=重新命名繼承者(&I)
rename.inheritors.title=重新命名繼承者
rename.module.title=重新命名模組(&M)
rename.not.all.usages.message=<html>已安全跳過以下用法\:<br>{0}</html>
rename.not.all.usages.title=並非所有用法都已重新命名
rename.not.supported=動作不受支援
rename.original.interface.to=將原始接口重命名為\:
rename.package.button.text=所有目錄(&A)
rename.parameters.hierarchy=重新命名層次結構中的參數(&A)
rename.preview.tab.title=重新命名預覽
rename.progress.title.0=正在重新命名\: {0}…
rename.project=重新命名專案
rename.project.action.title=重新命名專案…
rename.project.handler.title=重新命名專案(&P)
rename.related.file.dialog.description=將相關檔案重命名為\:
rename.related.files.option.name=重新命名相關檔案(具有相同的名稱)
rename.source.root.button.text=所選模組中的所有(&M)
rename.string.occurrences.found.title=找到字串符合項
rename.string.select.all.occurrences=重新命名所有符合項
rename.string.select.code.occurrences=重新命名程式碼符合項
rename.target.text.0.1={0} → ''{1}''
rename.title=重新命名
rename.usage.unmodifiable=用法無法更新
renames.project=重新命名專案
renaming.0.1.to.2=將{0} {1} 重命名為{2}
renaming.command.name=重新命名{0}
replace.all.occurences=取代所有符合項({0} 個匹配項)(&A)
replace.all.occurences.checkbox=取代所有符合項(&A)
replace.all.occurrences=取代全部 {0} 個匹配項
replace.all.occurrences.but.write=取代所有符合項但寫入
replace.fragment=取代片段
replace.multiple.occurrences.found=找到多個符合項
replace.this.occurrence.only=僅取代此匹配項
rerun.safe.delete=重新執行安全刪除(&S)
retry.command=重試
safe.delete.command=正在刪除 {0}
safe.delete.comment.occurences.header=在註釋、字串和非程式碼檔案中發現符合項 {0}。將不會更改這些符合項
safe.delete.conflict.title=刪除程式碼中發現的參照可能不安全
safe.delete.not.available.indexing=索引編制期間，無法使用“安全刪除”重構
safe.delete.of.those.0.in.comments.strings.non.code=其中 {0,choice,1\#1 個用法|2\#{0,number} 個用法}位於字串、註釋、非程式碼檔案或生成的程式碼中。
safe.delete.title=安全刪除
search.for.references=搜尋參照(&F)
search.for.references.dumb.mode=搜尋參照(&F) (索引編制期間不可用)
search.for.text.occurrences=搜尋文本符合項(&T)
search.in.comments.and.strings=在註釋和字元中搜尋(&C)
searching.for.duplicates=正在搜尋重複項…
searching.for.overrides=正在搜尋覆寫…
searching.for.variables=正在搜尋變數
select.all.button=全選(&A)
select.refactoring.title=選擇重構
select.target.directory=選擇目標目錄
select.target.directory.description=將在此目錄中建立檔案
selected.block.should.represent.a.set.of.statements.or.an.expression=所選塊應代表一組語句或表達式
selected.block.should.represent.an.expression=所選塊應該代表一個表達式
selection.does.not.form.a.fragment.for.extraction=選區無法構成要提取的片段
setup.method.radio=setUp 方法(&S)
show.more.conflicts.link=顯示更多…
signature.preview.border.title=簽名預覽
source.and.destination.classes.should.be.different=源類別和目標類別應不同
statusBar.noUsages=未找到符合項
statusBar.refactoring.result={0, choice, 1\#1 個匹配項|2\#{0,number} 個匹配項}已更改
suggested.refactoring.change.signature.command.name=更新{0}
suggested.refactoring.change.signature.gutter.icon.tooltip=更新 ''{1}'' 的 {0} 以反映簽名更改… {2}
suggested.refactoring.change.signature.intention.text=更新{0}以反映簽名更改
suggested.refactoring.change.signature.label.text=更新 {0} 以反映簽名更改\:
suggested.refactoring.declaration=宣告
suggested.refactoring.disabled.gutter.icon.tooltip=簽名已更改，但用法無任何更新
suggested.refactoring.group.key=建議的重構
suggested.refactoring.ignore.button.text=忽略
suggested.refactoring.implementations=實作
suggested.refactoring.next.button.text=下一個
suggested.refactoring.overrides=覆寫
suggested.refactoring.parameter.values.label.text=為新參數新增值\:
suggested.refactoring.parameter.values.placeholder=可選值
suggested.refactoring.rename.button.text=重新命名
suggested.refactoring.rename.command.name=重新命名用法
suggested.refactoring.rename.gutter.icon.tooltip=將 ''{0}'' 的用法重命名為 ''{1}''… {2}
suggested.refactoring.rename.intention.text=重新命名 ''{0}'' 的用法
suggested.refactoring.rename.popup.text=將 ''{0}'' 的用法重命名為 ''{1}''
suggested.refactoring.rename.text.occurrences=將 ''{0}'' 重命名為 ''{1}'' 時在註釋和字串中發現符合項。您也想將它們重新命名嗎?
suggested.refactoring.rename.text.occurrences.title=重新命名文本符合項
suggested.refactoring.rename.with.preview.button.text=使用預覽重新命名
suggested.refactoring.update.button.text=更新
suggested.refactoring.usages=用法
suggested.refactoring.use.any.variable.checkbox.hint=如果呼叫位置存在合適類型的單個變數，則會將其用作實參值
suggested.refactoring.use.any.variable.checkbox.text=使用任意變數
superclass.cannot.be.extracted.from.an.interface=無法從接口中提取超類別
superclass.name=超類別名(&S)\:
target.destination.folder=目標目錄(&D)\:
text.identifier.invalid=關鍵字 ''{0}'' 無效
text.occurrences=文本符合項(&T)
text.signature.change.was.detected.highlight.tooltip=檢測到簽名更改
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=文字游標應置於要重構的類別、方法或欄位處
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=文字游標應置於要從中拉取成員的類別內
the.caret.should.be.positioned.inside.a.class.to.push.members.from=文字游標應置於要從中推送成員的類別內
the.file.will.be.copied.to.this.directory=檔案將被複製到此目錄
the.file.will.be.moved.to.this.directory=檔案將被移至此目錄
the.following.problems.were.found=發現以下問題\:
the.language.for.selected.elements.has.no.associated.file.type=所選元素的語言沒有關聯的檔案類型
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter={1} 中已有一個{0}。它將與新參數衝突。
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter={1} 中已有一個{0}。它將與重新命名的參數衝突。
these.package.prefixes.will.be.changed=這些軟體套件前綴將被更改。
this.invocation.only.and.keep.the.method=僅內聯此呼叫並保留方法(&K)
this.member.does.not.seem.to.belong.to.any.class=此成員似乎不屬於任何類別
this.reference.only.and.keep.the.variable=僅內聯此參照並保留變數(&K)
title.rename.parameters.hierarchy=重新命名層次結構中的參數
to.refactor=重構
to.rename=重新命名
unselect.all.button=取消全選(&U)
unsupported.refs.found=在 {0} 個檔案中找到不受支援的參照
usage.that.is.not.safe.to.delete=使用了無法安全刪除的 {0}。
usageView.doAction=重構(&R)
usageView.need.reRun=無法執行重構動作。\n找到用法後代碼有更改。\n請再次執行用法搜尋。
usageView.tabText=重構預覽
usageView.usagesText=用法
usages.detected=檢測到用法
used.by.0=被{0}使用
uses.0=使用{0}
variable.has.no.dominating.definition=找不到要內聯的單一定義
variable.has.no.initializer=變數 {0} 沒有初始設定式。
variable.is.accessed.for.writing.and.used.with.inlined=另一個變數 ''{0}'' 定義與內聯定義結合使用
variable.is.never.used=變數 {0} 從未使用
variable.is.referenced.in.multiple.files=變數 {0} 在多個檔案中參照
view.usages=檢視用法(&V)
visibility.as.is=保留原樣(&A)
visibility.border.title=可見性
visibility.combo.title=可見性(&V)\:
visibility.escalate=升級(&E)
visibility.package.local=Package local(&K)
visibility.private=private(&V)
visibility.protected=protected(&O)
visibility.public=public(&B)
warning.title=警告
what.would.you.like.to.do=您想做什麼?
yes.button=是(&Y)

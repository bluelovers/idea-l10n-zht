language.groovy=Groovy
filetype.groovy.description=Groovy
filetype.dgm.description=Groovy 擴展模組描述符檔案
filetype.dgm.display.name=DGM
filetype.logback.description=Groovy Logback DSL 設定
filetype.logback.display.name=Groovy Logback DSL
filetype.gdsl.description=IntelliJ Groovy DSL 設定
filetype.gdsl.display.name=Groovy DSL
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=操作生成 propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=操作生成 propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() 和 hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=現在操作生成 equals 和 hashCode
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=getter 和 setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=生成 getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=生成 setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=生成 getter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=構造函數
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=生成構造函數
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=生成 toString() 方法
action.ExcludeFromStubGeneration.text=從存根生成中排除
action.ExcludeFromStubGeneration.description=不要在編譯時為該 Groovy 檔案生成 Java 存根
action.DumpGroovyControlFlowAction.text=轉儲 Groovy 控制流
action.ConvertToCompileStatic.text=轉換為 @CompileStatic
action.ConvertToCompileStatic.description=將 Groovy 檔案轉換為 @CompileStatic
action.ConvertGroovyToJava.text=轉換為 Java
action.ConvertGroovyToJava.description=將 Groovy 檔案轉換為 Java
action.Groovy.NewScript.text=Groovy 腳本
action.Groovy.NewScript.description=創建新的 Groovy 腳本
action.Groovy.NewClass.text=Groovy 類
action.Groovy.NewClass.description=創建新的 Groovy 類
action.Groovy.CheckResources.Rebuild.text=重新建置資源 (_R)
action.Groovy.CheckResources.Rebuild.description=為資源根中的所有 Groovy 檔案執行編譯器，以檢查編譯問題
action.Groovy.CheckResources.Make.text=建置資源(_B)
action.Groovy.CheckResources.Make.description=為資源根中所有 Groovy 檔案執行增量編譯器，以檢查編譯問題
group.Groovy.CheckResources.text=Groovy 資源(_O)
group.Groovy.CheckResources.description=為資源根中的 Groovy 檔案執行編譯器，以檢查編譯問題
file.template.group.title.groovy=Groovy
groovy.term.class=類
groovy.term.interface=接口
groovy.term.trait=特徵
groovy.term.enum=枚舉
groovy.term.annotation=註解
groovy.term.method=方法
groovy.term.field=欄位
groovy.term.property=屬性
groovy.term.parameter=參數
groovy.term.variable=局部變數
groovy.term.binding=腳本綁定變數
groovy.term.label=標籤
groovy.term.closure=閉包
groovy.term.expression=表達式
new.class.action.text=Groovy 類
new.class.action.description=創建新的 Groovy 類
new.class.dialog.title=新建 Groovy 類
new.class.list.item.class=類
new.class.list.item.interface=接口
new.class.list.item.trait=特徵
new.class.list.item.enum=枚舉
new.class.list.item.annotation=註解
invalid.qualified.name=這不是有效的 Groovy 限定名稱
new.script.action.text=Groovy 腳本
new.script.action.description=創建新的 Groovy 腳本
new.script.dialog.title=為新的 Groovy 腳本輸入名稱
new.script.list.item.script=Groovy 腳本
new.script.list.item.script.dsl=GroovyDSL 腳本
new.gant.script.dialog.title=新建 Gant 腳本
new.gant.script.dialog.message=為新的 Gant 腳本輸入名稱
debug.option=啟用偵錯堆疊跟踪(&D)
groovy.debug.disable.specific.methods=不單步進入特定的 Groovy 類(&I)
groovy.debug.caption=Groovy
########################################################################################################################
# Parser error messages
########################################################################################################################
identifier.expected=應為關鍵字
identifier.or.block.expected=應為關鍵字或程式碼塊
string.end.expected=應為字串結尾
try.without.catch.finally='try' 沒有 'catch' 或 'finally'
expression.expected=應為表達式
duplicate.modifier=重複的修飾符 ''{0}''
########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=無法解析符號''{0}''
cannot.access=對 ''{0}'' 的存取超出了其存取權限
cannot.reference.non.static=無法從 static 上下文引用非靜態符號 ''{0}''
cannot.return.from.constructor=無法從構造函數返回物件
cannot.return.from.void.method=無法從返回 'void' 的方法返回物件
cannot.return.type=無法從返回 ''{1}'' 的方法返回 ''{0}''
cannot.apply.method.or.closure=''{0}'' 無法應用於 ''{1}''
cannot.apply.method1=''{1}'' 中的 ''{0}'' 無法應用於 ''{2}''
cannot.apply.constructor=''{1}'' 中的構造函數 ''{0}'' 不能應用於 ''{2}''
cannot.apply.default.constructor=無法將預設構造函數應用於類 ''{0}''
cannot.instantiate.abstract.class=無法實例化 abstract 類 ''{0}''
cannot.instantiate.interface=無法實例化接口 ''{0}''
missing.required.named.parameter=缺少必需的命名參數 ''{0}''
loss.of.precision=從 ''{0}'' 到 ''{1}'' 的精度可能會損失
cannot.assign=無法將 ''{0}'' 分配給 ''{1}''
cannot.cast=不能將 ''{0}'' 轉換為 ''{1}''
multiple.assignments.without.list.expr=在靜態類型檢查模式下，不支持右側沒有列表表達式的多個賦值
spread.operator.is.not.available=該展開運算符在進行靜態類型檢查時不能用作實參
replace.with.list.literal=取代為列表文字
replace.with.get.at=取代為索引存取
incorrect.number.of.values=值的數量不正確。應為: {0}，實際為: {1}
invalid.lvalue=要賦予的值無效
duplicate.class=類 ''{0}'' 在 ''{1}'' 中已存在
duplicate.inner.class=重複的類: ''{0}''
script.generated.with.same.name=為腳本程式碼生成了一個合成類 ''{0}''
variable.already.defined=變數 ''{0}'' 已定義
field.already.defined=欄位 ''{0}'' 已定義
create.class.family.name=創建類
create.class.text=創建類 {0}
create.interface.text=創建接口 {0}
create.annotation.text=創建註解 {0}
constructors.are.not.allowed.in.anonymous.class=匿名類中不允許使用構造函數
no.such.property=屬性 ''{0}'' 不存在
change.modifier=將 ''{0}'' 設為{1}
change.modifier.not=將 ''{0}'' 設為非{1}
change.modifier.family.name=更改修飾符
parameter.cast.fix=將第 {0,number,ordinal} 個參數轉換為 {1}
action.convert.lambda.to.closure=將 lambda 轉換為閉包
add.parenthesis.to.lambda.parameter.list=將圓括號添加到參數列表
# suppress inspection "UnusedProperty"
packageLocal.visibility.presentation=預設可見
# suppress inspection "UnusedProperty"
protected.visibility.presentation=protected
# suppress inspection "UnusedProperty"
private.visibility.presentation=private
# suppress inspection "UnusedProperty"
public.visibility.presentation=public
# suppress inspection "UnusedProperty"
abstract.visibility.presentation=abstract
# suppress inspection "UnusedProperty"
static.visibility.presentation=static
# suppress inspection "UnusedProperty"
final.visibility.presentation=final
# suppress inspection "UnusedProperty"
native.visibility.presentation=原生
# suppress inspection "UnusedProperty"
synchronized.visibility.presentation=synchronized
# suppress inspection "UnusedProperty"
strictfp.visibility.presentation=strictfp
# suppress inspection "UnusedProperty"
transient.visibility.presentation=transient
# suppress inspection "UnusedProperty"
volatile.visibility.presentation=volatile
# suppress inspection "UnusedProperty"
def.visibility.presentation=def
intention.family.name.convert.conditional.expression.to.elvis=條件表達式轉換為 Elvis
intention.family.name.replace.with.keyed.access=取代為鍵控存取
intention.family.name.fix.range.class=修正範圍類
intention.family.name.make.return.implicit=設為隱式返回
intention.family.name.simplify=簡化
intention.family.name.remove.unnecessary.continue=移除不必要的 continue
intention.family.name.remove.unnecessary.return=移除不必要的 return
intention.family.name.add.parameter.cast=添加參數轉換
intention.family.name.replace.for.each.operator=取代 'for-each' 運算符
intention.family.name.add.cast=添加轉換
intention.family.name.change.variable.type=更改變數類型
intention.family.name.replace.with.conditional.call=取代為條件調用
intention.family.name.collapse.conditional.expressions=折疊條件表達式
intention.family.name.remove.double.negation=移除雙重求反
intention.family.name.activate.dsl.descriptor=啟用 DSL 描述符
intention.family.name.collapse.if.statement=折疊 'if' 語句
intention.family.name.replace.with.short.circuit.expression=取代為短路表達式
intention.family.name.replace.something.with=將 ''{0}'' 取代為 ''{1}''
intention.family.name.add.attributes.to.annotation=將特性添加到註解
intention.family.name.fix.quotation=修正引用
illegal.combination.of.modifiers=修飾符的組合非法
illegal.combination.of.modifiers.abstract.and.final=修飾符 'abstract' 和 'final' 的組合非法
modifier.volatile.not.allowed.here=此處不允許使用修飾符 'volatile'
modifier.transient.not.allowed.here=此處不允許使用修飾符 'transient'
modifier.0.not.allowed=此處不允許使用修飾符 ''{0}''
interface.cannot.have.modifier.final=接口不能具有修飾符 'final'
script.method.cannot.have.modifier.abstract=腳本方法不能具有修飾符 'abstract'
script.cannot.have.modifier.native=腳本不能具有修飾符 'native'
interface.must.have.no.static.method=接口不得有 static 方法
only.abstract.class.can.have.abstract.method=只有 abstract 類可以具有 abstract 方法
anonymous.class.cannot.have.abstract.method=匿名類不能具有 abstract 方法
illegal.combination.of.modifiers.volatile.and.final=修飾符 'volatile' 和 'final' 的組合非法
variable.cannot.be=變數不能具有修飾符 ''{0}''
remove.modifier=移除 ''{0}''
not.abstract.method.should.have.body=abstract 方法不應有主體
cannot.create.class.error.text=無法創建類 ''{0}'': {1}
cannot.create.class.error.title=無法創建類
no.class.in.file.template=檔案模板中未找到類
Inner.methods.are.not.supported=不支持內部方法
final.class.cannot.be.extended=無法擴展 final 類
# Groovy 1.7 checks
unsupported.inner.class.0=Groovy {0} 中不支持內部類
unsupported.anonymous.class.0=Groovy {0} 中不支持匿名類
# Groovy 1.8 checks
unsupported.diamonds.0=Groovy {0} 中不支持 diamond
unsupported.command.syntax.0=Groovy {0} 中不支持指令表達式語法
unsupported.dollar.slashy.string.0=Groovy {0} 中不支持 $/ 字串
unsupported.multiline.slashy.string.0=Groovy {0} 中不支持多行 / 字串
#Groovy 2.3 checks
unsupported.traits.0=Groovy {0} 中不支持特徵
#Groovy 2.5 checks
duplicating.named.parameter=參數中出現重複的命名參數 ''{0}'': {1}
field.should.be.immutable=欄位 ''{0}'' 應具有不可變的類型，或者應使用 @ImmutableOptions 宣告
immutable.options.property.not.exist=屬性 ''{0}'' 不存在
explicit.includes.and.excludes=應只提供 'includes' 和 'excludes' 之一
require.closure.as.attribute.value=預期閉包為特性值
initializers.are.forbidden.with.defaults=通過在 @TupleConstructor 中禁用 'defaults' 來禁用預設值
super.is.not.allowed.in.pre.with.call.super=在啟用 'callSuper' 的情況下， 不允許在 'pre' 中調用 super
#Groovy 3.0 checks
illegal.default.modifier=修飾符 'default' 僅在接口的方法中有意義
illegal.default.modifier.fix=移除 'default' 修飾符
default.modifier.in.old.versions=修飾符 'default' 適用於 Groovy 3.0 或更高版本
unsupported.do.while.statement=當前版本中不支持 'do while'
unsupported.tuple.declaration.in.for=當前版本不支持 'for' 初始化中的元組宣告
unsupported.multiple.variables.in.for=當前版本不支持 'for' 初始化中的多個變數
unsupported.expression.list.in.for.update=當前版本不支持 'for' 更新中的多個表達式
unsupported.resource.list=當前版本不支持 'try-with-resources'
unsupported.array.initializers=當前版本不支持陣列初始設定式
operator.is.not.supported.in=當前版本不支持運算符 ''{0}''
unsupported.negated.in=當前版本不支持否定 'in'
unsupported.negated.instanceof=當前版本不支持否定 'instanceof'
unsupported.elvis.assignment=當前版本不支持 Elvis 賦值
unsupported.safe.index.access=當前版本不支持安全索引存取
unsupported.lambda=當前版本不支持 lambda
unsupported.type.annotations=當前版本不支持類型註解
unsupported.tuple.application.initializer=當前版本不支持應用程式初始設定式
illegal.single.argument.lambda=lambda 的單實參形式僅可用作賦值表達式的右側部分或方法調用內的實參
method.is.not.implemented=方法 ''{0}'' 未實作
change.implements.and.extends.classes=標準化 extends 和 implements 列表
fix.package.name=修正軟體套件名稱
checkbox.delegate.via.overloading.method=通過多載方法委託
checkbox.ignore.conditional.operators=忽略條件運算符
checkbox.ignore.obscure.operators=忽略模糊運算符
checkbox.ignore.double.checked.locking.on.volatile.fields=忽略對 volatile 欄位的雙重檢查鎖定
checkbox.inspect.anonymous.closures=檢查匿名閉包
checkbox.only.warn.if.loop.empty=僅當迴圈為空時才發出警告
add.dynamic.property=添加動態屬性 ''{0}''
duplicate.element.in.the.map=映射中存在重複的元素 ''{0}''
dynamic.tool.window.id=動態成員
create.field.from.usage.family.name=從用法創建欄位
create.field.from.usage=創建欄位 ''{0}''
create.method.from.usage.family.name=從用法創建方法
create.method.from.usage=創建方法 ''{0}''
create.variable.from.usage.family.name=從用法創建變數
create.variable.from.usage=創建變數 ''{0}''
create.parameter.from.usage.family.name=從用法創建參數
create.parameter.from.usage=創建參數 ''{0}''
add.dynamic.element=添加動態元素
add.dynamic.method=添加動態方法
add.dynamic.method.0=添加動態方法 ''{0}''
dynamic.type=類型
dynamic.name=名稱
dynamic.properties.table.name=方法實參
dynamic.method.return.type=返回類型(&T):
dynamic.method.property.type=屬性類型(&T):
are.you.sure.to.delete.dynamic.property=確定要刪除 ''{0}'' 嗎''?
dynamic.property.deletion=刪除動態屬性
are.you.sure.to.delete.elements=確定要刪除 ''{0}'' 個元素嗎''?
dynamic.element.deletion=動態元素刪除
tuple.cant.be.placed.in.class=不允許對欄位多次賦值
is.not.enclosing.class=''{0}'' 不是封閉類
package.definition.cannot.have.modifiers=軟體套件定義不能具有修飾符
import.statement.cannot.have.modifiers=import 語句不能具有修飾符
undefined.label=未定義標籤 ''{0}''
continue.outside.loop=僅允許在迴圈內部使用 continue 語句
break.outside.loop.or.switch=僅允許在迴圈或 switch 內使用 break 語句
label.already.used=標籤 ''{0}'' 已在使用中
break.outside.loop=僅允許在迴圈內使用具有命名標籤的 break 語句
Constructor=構造函數
Getter=Getter
Setter=Setter
not.allowed.modifier.in.for.in=此處不允許使用修飾符 ''{0}''
property.name.expected=應為屬性名稱
wildcards.are.not.allowed.in.extends.list=super 類型可能未指定萬用字元類型
method.does.not.override.super=方法不覆寫其超類的方法
method.duplicate=具有簽名 {0} 的方法已在類 ''{1}'' 中定義
ambiguous.code.block=不明確的程式碼塊
cyclic.inheritance.involving.0=涉及 ''{0}'' 的迴圈繼承
there.is.no.default.constructor.available.in.class.0=類 ''{0}'' 中沒有可用的預設構造函數
groovy.library.is.not.configured.for.module=沒有為模組 ''{0}'' 設定 Groovy SDK
configure.groovy.library=設定 Groovy SDK…
create.instance.of.built-in.type=內建類型的實例化
incorrect.variable.name=變數名稱不正確
no.interface.expected.here=此處不應為接口
no.class.expected.here=此處不應為類
invoke.completion.second.time.to.show.skipped.methods=第二次調用補全以顯示跳過的方法
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy 檔案已映射到 ''{0}''。\n您可以在“設定 | 檔案類型”中將它們映射到 Groovy
class.is.not.annotation=''{0}'' 不是一個註解
method.call.is.ambiguous=方法調用不明確
operator.call.is.ambiguous=運算符調用不明確
duplicated.named.parameter=已找到重複的命名參數 ''{0}''
no.super.classes.found=未找到超類
no.super.method.found=未找到 super 方法
cannot.assign.string.to.enum.0=無法將字串分配給枚舉 ''{0}''
cannot.find.enum.constant.0.in.enum.1=無法在枚舉 ''{1}'' 中找到枚舉常數 ''{0}''
recursive.constructor.invocation=遞歸構造函數調用
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=當前不支持使用映射項表達式來初始化枚舉
class.definition.is.not.expected.here=不應在此處使用類定義
move.class.0.from.method=將 ''{0}'' 移至正確位置
move.class.from.method.family.name=移至正確位置快速修復
cannot.infer.argument.types=無法推斷實參類型
Equals=等號
default.initializers.are.not.allowed.in.abstract.method=abstract 方法中不允許使用預設初始設定式
groovy.does.not.support.constructor.type.arguments=Groovy 不支持構造函數類型實參
illegal.escape.character.in.string.literal=字串文字中的非法轉義字符
method.with.type.parameters.should.have.return.type=具有類型參數的方法應具有返回類型
primitive.type.parameters.are.not.allowed=類型參數列表中不允許使用基元類型參數
primitive.bound.types.are.not.allowed=不允許使用基元限定類型
ellipsis.type.is.not.allowed.here=此處不允許使用 ellipsis 類型
method.0.is.too.complex.too.analyze=方法 ''{0}'' 過於複雜而無法分析。\n無法推斷局部變數的類型。
closure.is.too.complex.to.analyze=閉包分析起來很複雜。\n無法推斷局部變數的類型。
0.is.deprecated=''{0}'' 已被棄用
wrong.number.of.type.arguments=類型實參的數量錯誤: {0}；要求 {1} 個
type.argument.0.is.not.in.its.bound.should.extend.1=類型參數 ''{0}'' 不在其界限內；應擴展 ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=catch 語句參數類型應當是 Throwable 的子類
exception.0.has.already.been.caught=已捕捉到異常 ''{0}''
unnecessary.type=不必要的異常 ''{0}''。''{1}'' 已宣告
create.enum=創建枚舉 {0}
create.trait=創建特徵 {0}
annotation.field.can.only.be.used.within.a.script.body=註解 @Field 只能在腳本主體內使用
annotation.field.can.only.be.used.within.a.script=註解 @Field 只能在腳本內使用
return.type.is.incompatible={1} 中 {0} 的返回類型與 {3} 中的 {2} 不相容
anonymous.class.derived.from.0=派生自 {0} 的匿名類
throws.clause.is.not.allowed.in.at.interface=@interface 成員中不允許使用 'throws' 子句
at.interface.0.does.not.contain.attribute=@interface ''{0}'' 不包含特性 ''{1}''
duplicate.attribute=重複特性
missed.attributes=缺少特性: {0}
unexpected.attribute.type.0=意外的特性類型: ''{0}''
annotation.field.should.have.type.declaration=註解中的欄位應具有類型宣告
interface.members.are.not.allowed.to.be=接口成員不允許為 {0}
abstract.methods.must.not.have.body=abstract 方法不得有主體
method.has.incorrect.modifier.volatile=方法具有不正確的修飾符 'volatile'
native.methods.cannot.have.body=原生方法不能有主體
top.level.class.may.not.have.private.modifier=頂層類不能具有 'private' 修飾符
top.level.class.may.not.have.protected.modifier=頂層類不能具有 'protected' 修飾符
property.missing=propertyMissing
attribute.name.expected=應為特性名稱
java.style.for.each.statement.requires.a.type.declaration=Java 樣式的 for-each 語句需要類型宣告
super.cannot.be.used.in.static.context='super' 不能在 static 上下文中使用
qualified.0.is.allowed.only.in.nested.or.inner.classes=僅允許在嵌套/內部類中使用限定的 {0}
groovy.file.0=Groovy 檔案 ''{0}''
type.argument.list.is.not.allowed.here=此處不允許使用類型實參列表
initializers.are.not.allowed.in.interface=接口中不允許使用初始設定式
initializer.cannot.have.annotations=初始設定式不能有註解
initializer.cannot.be.0=初始設定式不能為 {0}
constructors.are.not.allowed.in.interface=接口中不允許使用構造函數
type.parameters.are.unexpected=存在意外的類型參數
constructors.cannot.have.return.type=構造函數中不允許使用返回類型元素
constructor.cannot.have.static.modifier=構造函數可能不為 static
annotation.types.may.not.have.extends.clause=註解類型不能具有 'extends' 子句
annotation.types.may.not.have.implements.clause=註解類型不能具有 'implements' 子句
no.implements.clause.allowed.for.interface=接口不能具有 'implements' 子句
enums.may.not.have.extends.clause=枚舉不能具有 'extends' 子句
method.0.cannot.override.method.1.in.2.overridden.method.is.final=方法 ''{0}'' 無法覆寫 ''{2}'' 中的方法 ''{1}''；覆寫的方法為 final
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=方法 ''{0}'' 的存取權限(''{1}'')不能比 ''{3}'' (''{4}'')中的 ''{2}'' 弱
tuple.declaration.should.end.with.def.modifier=元組宣告應以 'def' 修飾符結尾
injection.should.not.contain.line.feeds=GString 注入不得包含換行
collection.literal.contains.named.argument.and.expression.items=集合文字同時包含命名實參和表達式實參
annotation.collector.cannot.have.attributes=使用 @AnnotationCollector 註解的註解類型不能具有特性
annotation.type.cannot.be.inner=註解類型不能是內部類型
named.arguments.are.not.allowed.inside.index.operations=索引操作內不允許使用命名實參
expected.0.to.be.inline.constant=''{0}'' 應是一個內聯常數
cannot.assign.a.value.to.final.field.0=無法將值賦給 final 欄位 ''{0}''
cannot.assign.a.value.to.final.parameter.0=無法將值賦給 final 參數 ''{0}''
variable.0.might.not.have.been.initialized=變數 ''{0}'' 可能尚未初始化
doc.end.expected=應為 '*/'
mixing.private.and.public.protected.methods.of.the.same.name=將具有相同名稱的 private 和 public/protected 方法混合
explicit.constructors.are.not.allowed.in.immutable.class=@Immutable 類不允許使用顯式構造函數
repetitive.method.name.0=重複的方法名稱 ''{0}''
declared.type.0.have.to.extend.script=宣告的類型 ''{0}'' 不擴展 ''groovy.lang.Script'' 類
base.script.annotation.is.allowed.only.inside.scripts=註解 @BaseScript 只能在腳本內使用
delegate.annotation.is.only.for.methods.without.arguments=註解 @Delegate 無法應用於帶有實參的方法
builder.annotation.not.support.super.for.simple.strategy=groovy.transform.builder.SimpleStrategy 不支持註解特性 'includeSuperProperties'
0.expressions.on.trait.fields.properties.are.not.supported.in.traits=特徵中不支持特徵欄位/屬性上的 {0} 個表達式
only.traits.expected.here=此處應僅有特徵
anonymous.classes.cannot.be.created.from.traits=從 Groovy 2.5.2 起可以使用特徵中的匿名類
trait.method.cannot.be.protected=不允許 protected 特徵方法
non.static.classes.not.allowed=特徵中不允許使用非 static 內部類
selfType.class.does.not.inherit=@SelfType: 類 ''{0}'' 不繼承 ''{1}''
illegal.type.void=非法類型: 'void'
illegal.method.name=方法名稱包含非法字符: {0}
indexed.property.is.applicable.to.properties.only=@IndexedProperty 僅適用於屬性
listener.list.field.must.have.a.generic.collection.type=@ListenerList 欄位必須具有泛型集合類型
listener.list.field.with.generic.wildcards.not.supported=不支持包含泛型萬用字元的 @ListenerList 欄位
synchronized.not.allowed.on.abstract.method=抽象方法不允許 @Synchronized
lock.field.0.must.be.static=鎖定欄位 ''{0}'' 必須為 static
lock.field.0.must.not.be.static=鎖定欄位 ''{0}'' 不得為 static
lock.field.0.not.found=未找到鎖定欄位 ''{0}''
select.module.action.text=選擇模組…
select.module.action.description=選擇要使用類路徑的模組
select.module.popup.title=使用模組的類路徑
### Inspection groups ###
inspection.annotations=註解
inspection.assignments=賦值問題
inspection.bugs=可能的錯誤
inspection.confusing=可能引起混淆的程式碼結構
inspection.control.flow=控制流問題
inspection.data.flow=數據流
inspection.error.handling=錯誤處理
inspection.gpath=GPath
inspection.naming=命名慣例
inspection.method.metrics=方法指標
inspection.redundancy=宣告冗餘
inspection.threading=執行緒問題
inspection.validity=有效性問題
inspection.style=樣式
inspection.other=其他
### Inspections ###
inspection.display.name.result.of.assignment.used=使用的賦值的結果
inspection.display.name.assignment.can.be.operator.assignment=賦值可以取代為運算符賦值
inspection.display.name.delegates.to=@DelegatesTo
inspection.display.name.unresolved.access=未解析的引用表達式
inspection.display.name.untyped.access=無類型引用表達式
inspection.display.name.list.set.can.be.keyed.access=對 List.set 的調用可以是鍵控存取
inspection.display.name.list.get.can.be.keyed.access=對 List.get 的調用可以是鍵控存取
inspection.display.name.map.put.can.be.keyed.access=對 Map.put 的調用可以是鍵控存取
inspection.display.name.map.get.can.be.keyed.access=對 Map.get 的調用可以是鍵控存取
inspection.display.name.parameter.naming.convention=方法參數命名慣例
inspection.display.name.constant.naming.convention=常數命名慣例
inspection.display.name.instance.variable.naming.convention=實例變數命名慣例
inspection.display.name.instance.method.naming.convention=實例方法命名慣例
inspection.display.name.static.variable.naming.convention=static 變數命名慣例
inspection.display.name.static.method.naming.convention=static 方法命名慣例
inspection.display.name.local.variable.naming.convention=局部變數命名慣例
inspection.display.name.class.naming.convention=類命名慣例
inspection.display.name.groovydoc.check=未解析的 GroovyDoc 引用
inspection.display.name.constructor.named.arguments=構造函數調用的命名實參
inspection.display.name.result.of.object.allocation.ignored=被忽略的物件分配結果
inspection.display.name.divide.by.zero=除以零
inspection.display.name.infinite.recursion=無限遞歸
inspection.display.name.infinite.loop.statement=無限迴圈語句
inspection.display.name.non.short.circuit.boolean=非短路布爾
inspection.display.name.duplicate.switch.branch=重複 switch case
inspection.display.name.gstring.key=GString 映射鍵
inspection.display.name.octal.integer=八進制整數
inspection.display.name.overly.complex.boolean.expression=過於複雜的布爾表達式
inspection.display.name.clashing.trait.methods=衝突的特徵方法
inspection.display.name.overly.complex.arithmetic.expression=過於複雜的算術表達式
inspection.display.name.double.negation=雙重求反
inspection.display.name.pointless.arithmetic=無意義的算術表達式
inspection.display.name.empty.statement.body=帶空體的語句
inspection.display.name.reassigned.in.closure.local.var=在閉包類或匿名類中重新分配局部變數
inspection.display.name.result.of.increment.or.decrement.used=使用增量或減量的結果
inspection.display.name.negated.if=否定 if 條件表達式
inspection.display.name.in.argument.check=不相容的 'in' 實參類型
inspection.display.name.negated.conditional=否定條件表達式
inspection.display.name.nested.conditional=嵌套條件表達式
inspection.display.name.conditional=三元表達式
inspection.display.name.nested.switch=嵌套 switch 語句
inspection.display.name.multiple.return.points.per.method=具有多個返回點的方法
inspection.display.name.method.with.more.than.three.negations=具有三個以上否定的方法
inspection.display.name.overly.nested.method=過度嵌套的方法
inspection.display.name.overly.long.method=過長的方法
inspection.display.name.overly.complex.method=過於複雜的方法
inspection.display.name.method.parameter.count=參數過多的方法
inspection.display.name.while.loop.spins.on.field=While 迴圈在欄位上自旋
inspection.display.name.unsynchronized.method.overrides.synchronized.method=未同步方法覆寫 synchronized 方法
inspection.display.name.synchronization.on.variable.initialized.with.literal=在使用文字初始化的變數上同步
inspection.display.name.synchronization.on.non.final.field=在非 final 欄位上同步
inspection.display.name.wait.while.not.synchronized=未同步時使用 'wait()'
inspection.display.name.wait.call.not.in.loop='wait()' 不在迴圈中
inspection.display.name.notify.while.not.synchronized=未同步時使用 'notify()' 或 'notifyAll()'
inspection.display.name.system.run.finalizers.on.exit=System.runFinalizersOnExit() 調用
inspection.display.name.thread.stop.suspend.resume=Thread.stop()、Thread.suspend() 或 Thread.resume() 調用
inspection.display.name.nested.synchronized.statement=嵌套 'synchronized' 語句
inspection.display.name.synchronized.method=synchronized 方法
inspection.display.name.synchronization.on.this=在 'this' 上同步
inspection.display.name.empty.sync.block=空 'synchronized' 塊
inspection.display.name.busy.wait=繁忙等待
inspection.display.name.public.field.accessed.in.synchronized.context=在同步上下文中存取非 private 欄位
inspection.display.name.unconditional.wait=無條件的 'wait' 調用
inspection.display.name.double.checked.locking=雙重檢查鎖定
inspection.display.name.access.to.static.field.locked.on.instance=存取實例資料上鎖定的 static 欄位
inspection.display.name.change.to.method=運算符調用可以取代為方法調用
inspection.display.name.change.to.operator=方法調用可以取代為運算符調用
inspection.display.name.unnecessary.alias=不必要的匯入別名
inspection.display.name.unnecessary.semicolon=不必要的分號
inspection.display.name.unnecessary.public.modifier=不必要的 'public'
inspection.display.name.unnecessary.def.modifier=不必要的 'def'
inspection.display.name.java.style.properties.invocation=Java 風格的屬性存取
inspection.display.name.trivial.if=冗餘的 'if' 語句
inspection.display.name.constant.if.statement=常數 if 語句
inspection.display.name.constant.conditional=恒定條件表達式
inspection.display.name.trivial.conditional=冗餘條件表達式
inspection.display.name.return.from.closure.can.be.implicit='return' 語句可以是隱式語句
inspection.display.name.switch.statement.with.no.default=沒有 default case 的 switch 語句
inspection.display.name.final.variable.access=final 變數存取
inspection.display.name.unnecessary.return=不必要的 'return' 語句
inspection.display.name.unnecessary.continue=不必要的 'continue' 語句
inspection.display.name.fallthrough='switch' 語句中的直落
inspection.display.name.if.statement.with.too.many.branches=具有過多分支的 if 語句
inspection.display.name.if.statement.with.identical.branches=具有相同分支的 if 語句
inspection.display.name.conditional.can.be.conditional.call=三元表達式可以取代為安全調用
inspection.display.name.conditional.can.be.elvis=三元表達式可以取代為 elvis 表達式
inspection.display.name.conditional.with.identical.branches=分支相同的三元表達式
inspection.display.name.loop.statement.that.doesnt.loop=不迴圈的迴圈語句
inspection.display.name.unreachable.statement=不可到達的語句
inspection.display.name.continue='continue' 語句
inspection.display.name.break='break' 語句
inspection.display.name.unused.catch.parameter=未使用的 'catch' 參數
inspection.display.name.empty.try.block=空 'try' 塊
inspection.display.name.annotation.references.unknown.identifier=@TupleConstructor 和 @MapConstructor
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate 未解析標籤
inspection.display.name.empty.finally.block=空 'finally' 塊
inspection.display.name.empty.catch.block=空 'catch' 塊
inspection.display.name.throw.from.finally.block='throw' 位於 'finally' 塊內
inspection.display.name.return.from.finally.block='return' 位於 'finally' 塊內
inspection.display.name.method.may.be.static=方法可能為 'static'
inspection.display.name.continue.or.break.from.finally.block='finally' 塊中的 'continue' 或 'break'
inspection.display.name.unchecked.assignment.of.member.of.raw.type=原始類型成員中未經檢查的賦值
inspection.display.name.silly.assignment=不實用的賦值
inspection.display.name.nested.assignment=嵌套賦值
inspection.display.name.assignment.to.method.parameter=賦值給方法參數
inspection.display.name.assignment.to.for.loop.parameter=賦值給 'for' 迴圈參數
inspection.display.name.assignability.check=不相容的類型賦值
inspection.display.name.type.customizer=類型自定義工具檢查
inspection.display.name.unused.declaration=未使用的宣告
inspection.display.name.second.unsafe.call=第二次不安全的調用
inspection.display.name.unused.assignment=未使用的賦值
inspection.display.name.unused.inc.dec=未使用的遞增或遞減
inspection.display.name.unassigned.access=未分配變數
inspection.display.name.no.return=缺少 return 語句
inspection.display.name.clashing.getters=衝突的 getter
inspection.display.name.package.mismatch=軟體套件不符合
inspection.display.name.deprecated.api.usage=棄用的 API 用法
inspection.display.name.unnecessary.qualified.reference=不必要的限定參考
inspection.display.name.pointless.boolean=無意義的布爾表達式
inspection.display.name.access.to.inaccessible.element=不可存取的元素
inspection.display.name.incorrect.range.argument=不正確的範圍實參
inspection.display.name.new.instance.of.singleton=使用 @groovy.lang.Singleton 註解的類的新實例
inspection.display.name.check.labeled.statement=標籤化語句檢查
inspection.display.name.variable.can.be.final=變數可以為 final
inspection.display.name.equals.between.inconvertible.types='equals()' 位於不可轉換類型的物件之間
inspection.display.name.singleton.constructor=@Singleton 構造函數
inspection.display.name.implicit.null.argument=隱式 null 實參
inspection.display.name.string.style.violation=字串樣式違規
inspection.message.access.to.static.field.locked.on.instance.data=存取實例資料中鎖定的 static 欄位 <code>#ref</code> #loc
inspection.message.assignment.replaceable.with.operator.assignment=<code>#ref</code> 可以簡化為 ''{0}'' #loc
inspection.message.assignment.to.for.loop.parameter=賦值給 for 迴圈參數 '#ref' #loc
inspection.message.assignment.to.method.parameter=賦值給方法參數 '#ref' #loc
inspection.message.ref.statement=#ref 語句 #loc
inspection.message.call.to.thread.ref.in.a.loop=在迴圈中調用 <code>Thread.#ref()</code>，可能處於繁忙等待狀態 #loc
inspection.message.conditional.expression.can.be.call=條件表達式可以是調用 #loc
inspection.message.conditional.expression.can.be.elvis=條件表達式可以是 elvis #loc
inspection.message.conditional.expression=條件表達式 #loc
inspection.message.conditional.expression.with.identical.branches=具有相同分支的條件表達式 #loc
inspection.message.ref.can.be.simplified='#ref' 可以簡化 #loc
inspection.message.ref.statement.can.be.simplified=#ref 語句可以簡化 #loc
inspection.message.constant.name.ref.too.short=常數名稱 '#ref' 過短
inspection.message.constant.name.ref.too.long=常數名稱 '#ref' 過長
inspection.message.constant.name.ref.doesnt.match.regex=常數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.ref.inside.finally.block='finally' 塊內的 '#ref' #loc
inspection.message.divide.by.zero=除以零 #loc
inspection.message.double.checked.locking=雙重檢查鎖定 #loc
inspection.message.double.negation.ref=雙重求反 #ref #loc
inspection.message.duplicate.switch.case.ref=重複 switch case '#ref' #loc
inspection.message.empty.ref.block=空 '#ref' 塊 #loc
inspection.message.ref.statement.has.empty.branch='#ref' 語句具有空分支
inspection.message.ref.statement.has.empty.body='#ref' 語句具有空體
inspection.message.fallthrough.in.switch.statement='switch' 語句存在直落 #loc
inspection.message.gstring.used.as.maps.key=GString 用作映射的鍵 #loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=<code>#ref</code> 語句不能在未拋出異常的情況下完成 #loc
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>#ref</code> 無限遞歸，只能以拋出異常完成 #loc
inspection.message.instance.method.name.ref.too.short=實例方法名稱 '#ref' 過短
inspection.message.instance.method.name.ref.too.long=實例方法名稱 '#ref' 過長
inspection.message.instance.method.name.ref.doesnt.match.regex=實例方法名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.instance.variable.name.ref.too.short=實例變數名稱 '#ref' 過短
inspection.message.instance.variable.name.ref.too.long=實例變數名稱 '#ref' 過長
inspection.message.couldnt.find.property.field.with.this.name=找不到使用此名稱的屬性或欄位 #loc
inspection.message.instance.variable.name.ref.doesn.t.match.regex=實例變數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.call.to.ref.can.be.keyed.access=對 '#ref' 的調用可以是鍵控存取 #loc
inspection.message.ref.statement.with.identical.branches=具有相同分支的 '#ref' 語句 #loc
inspection.message.ref.statement.with.too.many.branches=具有過多分支({0})的 ''#ref'' 語句 #loc
inspection.message.local.variable.name.ref.too.short=局部變數名稱 '#ref' 過短
inspection.message.local.variable.name.ref.too.long=局部變數名稱 '#ref' 過長
inspection.message.local.variable.name.ref.doesnt.match.regex=局部變數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.code.ref.code.statement.doesnt.loop=<code>#ref</code> 語句不迴圈 #loc
inspection.message.method.ref.contains.too.many.parameters.0.1=方法 ''#ref'' 包含過多參數({0}>{1})
inspection.message.method.ref.has.too.many.negations=方法 ''#ref'' 包含過多否定({0} > 3)
inspection.message.ref.has.0.return.points=<code>#ref</code> 具有 {0} 個返回點 #loc
inspection.message.negated.conditional.expression=否定的條件表達式 #loc
inspection.message.negated.if.condition.expression=否定的 if 條件表達式 #loc
inspection.message.nested.assignment.expression=嵌套賦值表達式 #loc
inspection.message.nested.conditional.expression=嵌套條件表達式 #loc
inspection.message.nested.ref.statement=嵌套 '#ref' 語句 #loc
inspection.message.non.short.circuit.boolean.expression=非短路布爾表達式 #loc
inspection.message.call.to.ref.outside.synchronized.context=在同步上下文之外調用 '#ref' #loc
inspection.message.octal.integer.ref=八進制整數 #ref #loc
inspection.message.overly.complex.arithmetic.expression=過於複雜的算術表達式 #loc
inspection.message.overly.complex.boolean.expression=過於複雜的布爾表達式 #loc
inspection.message.method.ref.overly.complex.cyclomatic.complexity=方法 ''#ref'' 過於複雜(迴圈復雜度 = {0}>{1})
inspection.message.method.ref.too.long.statement.count=方法 ''#ref'' 過長(語句計數 = {0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=方法 ''#ref'' 過度嵌套(嵌套深度 = {0}>{1})
inspection.message.method.parameter.name.ref.too.short=方法參數名稱 '#ref' 過短
inspection.message.method.parameter.name.ref.too.long=方法參數名稱 '#ref' 過長
inspection.message.method.parameter.name.ref.doesnt.match.regex=方法參數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.non.private.field.accessed.in.synchronized.context=在同步上下文中存取了非 private 欄位 '#ref' #loc
inspection.message.nested.assignment=使用賦值表達式結果 #loc
inspection.message.result.increment.or.decrement.expression.used=使用遞增或遞減結果 #loc
inspection.message.result.of.new.ref.is.ignored=''new #ref{0}'' 的結果被忽略 #loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=閉包結尾存在顯式返回 #loc
inspection.message.silly.assignment=不實用的賦值 #loc
inspection.message.static.method.name.ref.too.short=static 方法名稱 '#ref' 過短
inspection.message.static.method.name.ref.too.long=static 方法名稱 '#ref' 過長
inspection.message.static.method.name.ref.doesnt.match.regex=static 方法名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.static.variable.name.ref.too.short=static 變數名稱 '#ref' 過短
inspection.message.label.name.ref.not.supported.by.0={0} 不支持標籤名稱 ''#ref''
inspection.message.static.variable.name.ref.too.long=static 變數名稱 '#ref' 過長
inspection.message.static.variable.name.ref.doesnt.match.regex=static 變數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.property.0.is.final=屬性 ''{0}'' 為 final #loc
inspection.message.ref.statement.with.no.default.branch=沒有 'default' 分支的 #ref 語句 #loc
inspection.message.synchronization.on.non.final.field.ref=在非 final 欄位 '#ref' 上同步 #loc
inspection.message.synchronization.on.ref=在 '#ref' 上同步 #loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=在由文字初始化的 '#ref' 上同步 #loc
inspection.message.synchronized.method.ref=synchronized 方法 '#ref' #loc
inspection.message.call.to.system.ref=調用 'System.#ref' #loc
inspection.message.call.to.thread.ref=調用 'Thread.#ref' #loc
inspection.message.trivial.conditional.expression=普通條件表達式 #loc
inspection.message.property.0.is.ignored.by.map.constructor=屬性 ''{0}'' 被 @MapConstructor 忽略 #loc
inspection.message.unconditional.call.to.ref=無條件調用 <code>#ref()</code> #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=#ref 不必要，因為是迴圈中的最後一條語句 #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=#ref 不必要，因為它是沒有返回值的方法中的最後一條語句 #loc
inspection.message.unreachable.statement=不可到達的語句 #loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=非同步方法 '#ref' 重寫了一個 synchronized 方法 #loc
inspection.message.cannot.determine.type.ref=無法確定 '#ref' 的類型
inspection.message.call.to.ref.outside.of.loop=在迴圈外部調用 '#ref' #loc
inspection.message.call.to.ref.outside.of.synchronized.context=在同步的上下文外部調用 '#ref' #loc
inspection.message.ref.loop.spins.on.field=<code>#ref</code> 迴圈在欄位上自旋 #loc
inspection.message.package.name.mismatch=軟體套件名稱不符合
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL 描述符檔案已更改，當前未被執行
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=由於處理錯誤，DSL 描述符檔案已被禁用
inspection.message.traits.0.contain.clashing.methods.with.signature.1=特徵 {0} 包含帶簽名 {1} 的衝突方法
inspection.message.unused.catch.parameter.ref=未使用的 catch 參數 '#ref' #loc
inspection.message.package.name.mismatch.actual.0.expected.1=軟體套件名稱不符合。實際: ''{0}''，預期: ''{1}''
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=屬性不可索引。類型必須為數組或列表，但實際為 {0}
inspection.message.type.argument.0.can.not.be.1=實參 ''{0}'' 的類型不能為 ''{1}''
inspection.message.method.called.with.implicit.null.argument=用隱式 null 實參調用方法
inspection.message.plain.string.should.be.double.quoted=普通字串應當使用雙引號引用
inspection.message.plain.string.should.be.single.quoted=普通字串應當使用單引號引用
inspection.message.plain.string.should.be.slashy.quoted=普通字串應當使用 / 引用
inspection.message.plain.string.should.be.dollar.slashy.quoted=普通字串應當使用 $/ 引用
inspection.message.plain.string.should.be.quoted.with.triple.quotes=普通字串應當使用 '''' 引用
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=普通字串應當使用 """ 引用
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=多行字串應當使用 '''' 引用
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=多行字串應當使用 """ 引用
inspection.message.multiline.string.should.be.slashy.quoted=多行字串應當使用 / 引用
inspection.message.multiline.string.should.be.dollar.slashy.quoted=多行字串應當使用 $/ 引用
inspection.message.string.escaping.could.be.minimized=轉義可以最小化
inspection.message.interpolated.string.should.be.double.quoted=內插字串應當使用雙引號引用
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=內插字串應當使用 $/ 引用
inspection.message.interpolated.string.should.be.slashy.quoted=內插字串應當使用 / 引用
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=內插字串應當使用 """ 引用
text.class.0.is.unused=類 {0} 未使用
text.constructor.0.is.unused=構造函數 {0} 未使用
text.method.0.is.unused=方法 {0} 未使用
text.property.0.is.unused=屬性 ''{0}'' 未使用
text.parameter.0.is.unused=參數 {0} 未使用
### Intention groups ###
intention.category.groovy=Groovy
intention.category.conversions=Groovy/表達式轉換
intention.category.closures=Groovy/閉包
intention.category.comments=Groovy/註釋
intention.category.groovy.style=Groovy/Groovy 樣式
intention.category.control.flow=Groovy/控制流
intention.category.groovy.declaration=Groovy/宣告
intention.category.groovy.other=Groovy/其他
configurable.GroovyCompilerConfigurable.display.name=Groovy 編譯器
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=另外，您也可以在 <a href=\"#\">Java 編譯器頁面</a> 中指定 Groovy-Eclipse 編譯器
settings.compiler.select.path.to.groovy.compiler.configscript=選擇 Groovy 編譯器設定腳本的路徑
settings.compiler.path.to.configscript=設定腳本的路徑(&C):
settings.compiler.invoke.dynamic.support=調用動態支援(&D)
settings.compiler.exclude.from.stub.generation=從存根生成中排除:
settings.code.style.label.indent.style=標籤縮排樣式:
settings.code.style.label.indent.size=標籤縮排大小
settings.code.style.indent.statements.after.label=縮排標籤後的語句
settings.code.style.absolute=絕對
settings.code.style.indent.labels=縮排標籤
settings.inlay.parameter.types=參數類型
settings.inlay.inferred.parameter.types=推斷的參數類型
settings.inlay.type.parameter.list=類型參數列表
settings.inlay.show.type.hints.for=顯示類型提示:
intention.name.replace.with.in=將 ':' 取代為 'in'
intention.name.activate.back=重新啟用
intention.name.cast.to.0=轉換為 {0}
intention.name.replace.eq.with.0.eq=將 ''='' 取代為 ''{0}=''
intention.name.cast.operand.to.0=將操作數轉換為 {0}
intention.name.add.required.attributes.to.map.constructor=將必要特性添加到 @MapConstructor
intention.name.convert.to.single.quoted.string=轉換為帶單引號的字串
intention.name.change.quotes.to.triple.single.quotes=將引號更改為 ''''
intention.name.convert.to.double.quoted.string=轉換為帶雙引號的字串
intention.name.change.quotes.to.triple.double.quotes=將引號更改為 """
intention.name.convert.to.slashy.string=轉換為 / 字串
intention.name.convert.to.dollar.slashy.string=轉換為 $/ 字串
intention.family.name.create.field=創建欄位
action.remove.dynamic.member.text=移除
action.remove.dynamic.member.description=移除動態成員
action.collapse.all.text=全部摺疊
action.collapse.all.description=全部摺疊
action.expand.all.text=全部展開
action.expand.all.description=全部展開
dynamic.members.column.name.element=動態元素
dynamic.members.column.name.type=類型
command.name.add.dynamic.member=添加動態成員
popup.content.navigation.to.overriding.classes.unavailable=索引更新時無法導航到覆寫類
overriding.methods.of.0=''{0}'' 的覆寫方法
expression.type.no.expression=找不到表達式
expression.type.unknown=<unknown>
add.class.to.extends.family.name=實作
intention.family.name.rename=重命名
generated.stub.message=此存根為 Groovy 類生成，目的是實作 Groovy-Java 交叉編譯
generated.stub.navigate.link.label=轉到 Groovy 類
generated.stub.exclude.link.label=從存根生成中排除
module.with.groovy=附加了 Groovy 庫的簡單模塊
action.build.restart.text=建置並重啟
action.build.module.restart.description=建置模組 ''{0}'' 並重啟
gdsl.investigate.link.label=點擊此處進行調查
gdsl.error.notification.title=DSL 腳本執行錯誤
dialog.message.gant.not.configured=未設定 Gant
investigate.gdsl.error.intention.name=查看詳細資訊
investigate.gdsl.error.family.name=調查 DSL 描述符處理錯誤
grab.intention.name=Grab 工件
grab.family.name=Grab
grab.progress.title=處理 @Grab 註解
grab.result.title=添加了 {0} 個 Grape 依賴項 {0, choice, 0#jar|1#jar|2#jar}
grab.jar.count=<b>{0}</b>: {1} 個 {1, choice, 0#jar|1#jar|2#jar}
grab.error.ivy.missing.title=缺少 Ivy
grab.error.ivy.missing.message=抱歉，如果沒有 Apache Ivy，IDEA 無法 @Grab 依賴項。請將 Apache Ivy 添加到您的模組依賴項中，然後重新執行這項操作。
grab.error.0.title=無法執行 @Grab: {0}
this.super.completion.advertisement=不使用類限定符，按 {0} 兩次會顯示所有可存取的 static 方法
optimize.imports.progress.title=正在最佳化 Groovy 檔案中的匯入…
groovy.library.label=Groovy 庫
replace.all.occurrences.and.remove.variable.0=取代所有符合項並移除變數 ''{0}''
introduce.variable.declare.final.label=宣告 final(&F)
introduce.variable.replace.all.occurrences=取代所有符合項(&A)
introduce.variable.replace.all.0.occurrences=取代所有符合項({0} 個匹配項)(&A)
introduce.parameter.delegate.via.overload=通過多載方法委託(&L)
introduce.parameter.replace.fields.border.title=將表達式中使用的欄位取代為其 Getter
introduce.parameter.do.not.replace.option.label=不取代(&O)
introduce.parameter.replace.inaccessible.fields.option.label=取代用法上下文中不可存取的欄位(&I)
introduce.parameter.replace.all.fields.option.label=取代所有欄位(&R)
introduce.variable.type.label=類型(&T):
introduce.variable.name.label=名稱(&N):
introduce.parameter.explicit.return.statement.option.label=使用顯式 return 語句(&X)
introduce.parameter.delegating.unavailable.tooltip=閉包上下文中不允許委託
introduce.variable.change.type.advertisement=按 {0} 更改類型
framework.0.home.label={0} 主目錄:
select.framework.0.home.title=選擇 {0} 主目錄
framework.0.sdk.chooser.title={0} SDK
framework.0.sdk.chooser.description=選擇包含 {0} 分發版的目錄
framework.0.sdk.chooser.error.message=指定路徑中的 {0} 分發版似乎已損壞。無法確定版本。
framework.0.sdk.chooser.error.title=無法創建庫
framework.0.library={0} 庫
framework.0.library.version.1=版本 {1} 的 {0} 庫
framework.gant=Gant
script.runner.display.name=Groovy
script.runner.description=Groovy 類或腳本
script.runner.chooser.title=腳本路徑
script.runner.chooser.description=指定腳本路徑
script.runner.module.not.specified.message=未指定模組
script.runner.no.groovy.for.module=沒有為模組 ''{0}'' 設定 Groovy
script.runner.cant.find.script=找不到腳本 ''{0}''
script.runner.unknown.script.type=未知腳本類型 ''{0}''
script.runner.file.is.not.groovy.file=腳本檔案不是 Groovy 檔案
script.runner.class.does.not.exist=類不存在
script.runner.class.cannot.be.executed=類無法執行
dialog.title.refactoring.unavailable.in.current.scope=重構在當前範圍中不可用
parameter.list.owner.chooser.title=將參數引入
extract.closure.command.name=提取閉包
introduce.constant.title=引入常數
undefined.library.version=未定義
method.parameters.count.max.parameters.option=最大參數數量:
method.returns.max.returns.option=return 點限制:
overly.complex.method.complexity.limit.option=方法復雜度限制:
overly.long.method.statements.limit.option=每個方法的最大語句數:
overly.nested.method.nesting.limit.option=最大嵌套深度:
add.method.family=添加方法
change.base.method.label=更改基方法
change.usages.label=更改用法
convert.parameter.to.map.entry.title=將參數轉換為映射條目
live.template.context.declaration=宣告
live.template.context.expression=表達式
live.template.context.statement=語句
find.usages.method.0.of.class.1={1} 的 {0}
change.signature.type.column=類型
change.signature.default.initializer.column=預設初始設定式
static.import.method.fix=static 匯入方法…
static.import.method.0.fix=static 匯入方法 ''{0}''
groovy.consoles.type=Groovy 主控台
getter.kind.gdk.method.0=GDK 方法 {0}
getter.kind.method.0=方法 {0}
getter.kind.getter.0=Getter {0}
parameter.hint.number.of.arguments={0, choice, 0#|1#{0} 個實參|2#{0} 個實參}
surround.with.for=for
surround.with.if=if
surround.with.if.else=if / else
surround.with.if.expr=if (expr)
surround.with.if.else.expr=if (expr) / else
surround.with.parentheses=(expr)
surround.with.closure={ -> ... }.call()
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.finally=try / finally
surround.with.try.catch.finally=try / catch / finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.cast=((Type) expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
surround.with.shouldFail=shouldFail () {...}
code.style.group.list.map.literals=列表和映射文字
code.style.option.align.when.multiple=多行時對齊
code.style.option.wrap.after.dot=在點後換行
code.style.option.align.multiline.named.arguments=對齊多行命名實參
code.style.option.use.flying.geese.braces=使用雁形括號組
code.style.option.import.annotations=匯入註解
code.style.option.simple.lambdas.closures.in.one.line=簡單的 lambda/閉包位於一行中
code.style.option.relational.operators=關係運算符 (<, >, <=, >=, <=>)
code.style.option.unary.operators=一元運算符 (!, -, +, ++, --, *)
code.style.option.in.named.argument.before.colon=在 ':' 之前的命名實參中
code.style.option.in.named.argument.after.colon=在 ':' 之後的命名實參中
code.style.option.list.maps.literals=列表和映射文字
code.style.option.closure.left.brace.in.method.calls=方法調用中有結束左大括號
code.style.option.gstring.injection.braces=GString 注入大括號
code.style.option.tuple.assignment.expression=元組賦值表達式
code.style.option.regexp.expression=正則表達式 (==~, =~)
code.style.option.before.assert.separator=在 'assert' 分隔符前面
code.style.option.after.assert.separator=在 'assert' 分隔符後面
# @Singleton
singleton.constructor.found=@Singleton 類不應有構造函數
singleton.constructor.remove=移除構造函數
singleton.constructor.makeNonStrict=使 @Singleton 非 strict
########################################################################################################################
# Unused imports
########################################################################################################################
unused.import=未使用的 import
optimize.imports=最佳化 import
optimize.all.imports=最佳化未使用的 import 語句
########################################################################################################################
# Create class fix
########################################################################################################################
dialog.create.class.package.chooser.title=選擇目標軟體套件
create.directory.command=創建目錄
destination.package=目標軟體套件:
second.unsafe.call=第二次不安全的調用
call.can.throw.npe=調用鏈可能拋出 NullPointerException
unused.default.parameter.message=未使用預設參數
unused.default.parameter.fix=移除初始設定式
unused.assignment.tooltip=未使用賦值
unused.variable=未使用變數
variable.can.be.final.tooltip=變數 ''{0}'' 可以為 final
parameter.can.be.final.tooltip=參數 ''{0}'' 可以為 final
equals.between.inconvertible.types.tooltip=<code>{0}</code> 位於不可轉換的 ''{1}'' 和 ''{2}'' 類型的物件之間
replace.with.operator.message=''{0}'' 可以取代為運算符
replace.with.operator.fix=將 ''{0}'' 取代為運算符
replace.with.operator.double.negation.option=使用雙重求反(即 !!)
replace.with.operator.compareTo.equality.option=將 'compareTo' 等式取代為等號(即 ==)
replace.with.operator.parentheses=如果需要附加圓括號，則不建議取代為運算符
replace.with.method.message=可以取代為 ''{0}'' 方法調用
replace.with.method.fix=取代為 ''{0}'' 方法
unassigned.access.tooltip=變數 ''{0}'' 可能未被賦值
no.return.message=並非所有執行路徑都返回值
unresolved.type.status=類型 ''{0}'' 未解析
no.type.specified=未指定類型
dynamic.element=動態元素
pointless.boolean.problem.descriptor=冗餘布爾運算 #loc
pointless.arithmetic.error.message=冗餘算術運算 #loc
pointless.boolean.quickfix=簡化
Cannot.perform.undo.operation=無法執行撤消操作
Undo.disable=撤消已禁用
type.doesnt.contain.method=類型 ''{0}'' 不能在範圍內進行迭代，因為它沒有方法 ''{1}''
type.doesnt.implement.comparable=類型 ''{0}'' 未實作 Comparable
add.method=將方法 ''{0}()'' 添加到類 ''{1}''
implement.class=實作 {0}
fix.class=修正類 {0}
rtype.cannot.contain.ltype=''{1}'' 不能包含 ''{0}''
new.instance.of.singleton=使用 @groovy.lang.Singleton 註解的類的新實例
replace.new.expression.with.instance.access=取代為實例存取
getter.0.clashes.with.getter.1=發生衝突: ''{0}'' 和 ''{1}''
unused.0=未使用的 {0}
remove.0=移除 {0}
replace.postfix.0.with.prefix.0=將後綴 {0} 取代為前綴 {0}
replace.0.with.1=將 {0} 取代為二進制 {1}
local.var.0.is.reassigned=局部變數 ''{0}'' 已重新賦值
anonymous.class=匿名類
closure=閉包
other.scope=其他範圍
method.may.be.static=方法可能為 static
method.may.be.static.option.ignore.trait.methods=忽略特徵方法
method.may.be.static.only.private.or.final.option=僅檢查 final 或 private 方法
method.may.be.static.ignore.empty.method.option=忽略空方法
ignore.boolean.expressions=在布爾檢查中忽略未被賦值的變數
highlight.if.groovy.object.methods.overridden=高亮顯示來自覆寫 invokeMethod()、getProperty() 或 setProperty() 的類的引用
highlight.if.missing.methods.declared=高亮顯示來自宣告 missingMethod() 或 missingProperty() 的類的引用
gr.package.inspection.check.scripts=檢查腳本
java.style.property.access=Java 樣式存取器調用
type.customizer.is.not.marked.as.a.resource.file=類型訂製器腳本未被標記為編譯器資源
add.to.resources=添加到資源
add.type.customizer.to.resources=將類型訂製器腳本添加到資源
target.0.does.not.exist=目標 ''{0}'' 不存在
target.annotation.is.unused=@Target 未使用
change.lvalue.type=將變數 ''{0}'' 類型更改為 ''{1}''
replace.qualified.name.with.import=將限定名稱取代為匯入
comments.count.as.content=註釋計為內容
ignore.when.catch.parameter.is.named.ignore.or.ignored=當 catch 參數被命名為 ignore 或 ignored 時忽略
no.applicable.signature.found=未找到適用的簽名
expected.type.0=應為 ''{0}''，但實際為 ''{1}''
declare.explicit.implementations.of.trait=宣告特徵的顯式實作
unnecessary.modifier.description=修飾符 ''{0}'' 不必要
unnecessary.modifier.remove=移除不必要的 ''{0}''
unnecessary.def.explicitly.typed.only=僅在顯式類型宣告中報告
unnecessary.alias.fix=移除不必要的別名
unnecessary.alias.description=別名不必要
unnecessary.semicolon.description=分號不必要
unnecessary.semicolon.fix=移除分號
dynamic.dialog.class.label=類(&C):
dynamic.dialog.type.label=類型(&T):
dynamic.dialog.static.checkbox=static(&S)
find.method.ro.method.usages=正在專案檔案中搜尋封閉方法的用法
find.method.ro.closure.usages=正在專案檔案中搜尋封閉閉包的用法
conversion.method.not.allowed.in.non.groovy.files=不允許重構在非 Groovy 檔案中具有符合項的方法:
conversion.closure.not.allowed.in.non.groovy.files=不允許重構在非 Groovy 檔案中具有符合項的閉包:
wrong.method.first.parameter.type=方法 ''{0}'' 與命名實參一起使用，但它的第一個參數 ''{1}'' 不符合 Map 類型。
wrong.closure.first.parameter.type=閉包 ''{0}'' 與命名實參一起使用，但它的第一個參數 ''{1}'' 不符合 Map 類型。
map.parameter.dialog.create.new.checkbox=為命名實參創建新參數(&C)
map.parameter.dialog.explicit.type.checkbox=顯式指定類型
convert.cannot.itself=重構不適用於映射參數本身
map.param.name=映射參數名稱(&N):
convert.param.to.map.entry=將參數轉換為映射條目
closure.used.as.variable=閉包作為實參傳遞。重構會破壞語意。
do.you.want.to.change.method.return.type=是否要更改 ''{0}'' 方法的返回類型
do.you.want.to.change.variable.type=是否要更改 ''{0}'' 的類型
closure.is.accessed.outside.of.groovy=在 Groovy 外部存取欄位 <b>{0}</b>
write.access.to.closure.variable=欄位 <b>{0}</b> 的寫入存取權限
field.is.used.in.argument.label=在實參標籤中使用欄位 <b>{0}</b>
method.with.signature.already.exists=具有簽名 {0} 的方法已存在
field.already.exists=欄位 <b>{0}</b> 已存在
method.is.used.outside.of.groovy=在 Groovy 外部使用方法
do.you.want.to.change.type.of.parameter.in.method=是否要更改方法 ''{1}'' 中參數 ''{0}'' 的類型
file.exists=檔案 ''{0}'' 在目錄 ''{1}'' 中已存在
move.to.correct.dir.family.name=將檔案移至正確的軟體套件
move.to.correct.dir=移至 ''{0}''
add.return.type=添加返回類型
add.return.type.to.method.declaration=將返回類型添加到方法宣告
infer.method.parameters.types=向參數中添加顯式類型
infer.method.parameters.types.for.method.declaration=為方法宣告中的所有參數添加顯式類型
replace.with.wrapper=取代為 {0}
replace.primitive.type.with.wrapper=將基元類型取代為包裝器
remove.parameter.0=移除參數 ''{0}''
remove.unused.parameter=移除未使用的參數
remove.exception=移除異常
remove.catch.block=移除 catch 塊
try.catch.fix=Try-catch 修正
cannot.create.class=無法創建類
rename.file.to.0=將檔案重命名為 ''{0}''
java.style.properties.invocation.intention.family.name=將 Java 樣式存取器調用更改為 Groovy 樣式屬性引用
java.style.properties.invocation.intention.name=更改為 Groovy 樣式屬性引用
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() 和 hashCode() 已定義
generate.equals.and.hashcode.already.defined.warning=equals() 和 hashCode() 已定義
generate.equals.and.hashcode.already.defined.title=equals() 和 hashCode() 已定義
generate.equals.compare.nested.arrays.comment= //比較嵌套陣列 - 此處 {0} 的值
generate.equals.compare.arrays.comment= //可能不正確 - 使用 Arrays.equals 比較 Object[] 陣列
generate.property.missing.already.defined.warning=propertyMissing() 已定義
generate.property.missing.already.defined.title=propertyMissing() 已定義
generate.method.missing.already.defined.warning=methodMissing() 已定義
generate.method.missing.already.defined.title=methodMissing() 已定義
action.Gant.NewScript.text=Gant 腳本
action.Gant.NewScript.description=創建新的 Gant 腳本
action.Groovy.Console.text=Groovy 主控台
action.Groovy.Console.description=啟動 Groovy 主控台
module.name.0.and.groovy.version.1={0} ({1})
groovy.version.0=Groovy {0}
groovy.version.bundled.0=捆綁的 Groovy {0}
configurable.greclipse.border.title=Groovy-Eclipse 選項
configurable.greclipse.path.label=Groovy-eclipse-batch jar 路徑:
configurable.greclipse.path.chooser.description=選擇版本與您的 Groovy 分發版相符合的 groovy-eclipse-batch-*.jar 的路徑
configurable.greclipse.command.line.params.label=附加命令行參數:
configurable.greclipse.debug.checkbox=生成偵錯資訊
configurable.hotswap.checkbox=為 Groovy 程式碼啟用熱交換代理
configurable.hotswap.checkbox.description=可能在已偵錯的應用程式中導致序列化問題
run.configuration.script.path.label=腳本路徑:
run.configuration.module.chooser.label=模組(&M):
run.configuration.module.classpath.checkbox=向執行程序中添加模組類路徑(&C)
pull.up.wont.be.accessible.from=無法從 {1} 存取 {0}
pull.up.wont.be.accessible.from.the.subclass={0} 使用 {1}，後者無法從子類存取。
pull.up.abstract.wont.be.accessible.from=無法將 {0} 設為 abstract，因為無法通過子類對其進行存取。
settings.inlay.implicit.null.argument=隱式 null 實參
settings.inlay.show.hints.for.implicit.null.argument=顯示有關隱式 null 實參的提示
header.extract.closure=提取閉包
string.sort.default=預設
string.sort.strings.with.escaping=包含轉義的字串
string.sort.strings.with.interpolation=包含內插的字串
string.sort.multiline.string=多行字串
separator.preferable.string.kind=首選種類
separator.domain.of.inspection.usage=用法域
checkbox.inspect.gradle.files=檢查 Gradle 檔案
string.option.do.not.handle.specifically=不做特別處理
string.option.double.quoted.string=帶雙引號的字串
string.option.single.quoted.string=帶單引號的字串
string.option.slashy.string=/ 字串
string.option.triple.quoted.string=帶三引號的字串
string.option.triple.double.quoted.string=帶三個雙引號的字串
string.option.dollar.slashy.string=$/ 字串
gdsl.trusted.project.message=該專案包含 Groovy DSL (GDSL) 腳本，這些腳本可改善在編輯 Groovy 程式碼時的程式碼洞察體驗。GDSL 腳本可能包含潛在的惡意程式碼，這些程式碼將在 IDE 中執行。您是否要執行?
gdsl.trusted.project.answer.trust=是
gdsl.trusted.project.answer.dont.trust=否
label.groovy.library=Groovy 庫
radio.use.version.from.maven=使用 Maven 的版本:
radio.use.jar.file.from.disk=使用磁碟中的 .jar 檔案:
local.variable.types=局部變數類型
settings.inlay.show.variable.type.hints=顯示局部變數類型提示
settings.inlay.put.type.hint.before.identifier=將類型提示放在關鍵字前面

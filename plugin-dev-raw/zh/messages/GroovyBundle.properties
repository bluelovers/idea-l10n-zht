0.expressions.on.trait.fields.properties.are.not.supported.in.traits=特徵中不支持特徵欄位/屬性上的 {0} 個表達式
0.is.deprecated=''{0}'' 已棄用
Cannot.perform.undo.operation=無法執行撤消動作
Constructor=建構函式
Equals=等號
Getter=Getter
Inner.methods.are.not.supported=不支持內部方法
Setter=Setter
Undo.disable=撤消已停用
abstract.methods.must.not.have.body=abstract 方法不得有主體
abstract.visibility.presentation=abstract
action.ConvertGroovyToJava.description=將 Groovy 檔案轉換為 Java
action.ConvertGroovyToJava.text=轉換為 Java
action.ConvertToCompileStatic.description=將 Groovy 檔案轉換為 @CompileStatic
action.ConvertToCompileStatic.text=轉換為 @CompileStatic
action.DumpGroovyControlFlowAction.text=傾印 Groovy 控制流
action.ExcludeFromStubGeneration.description=不要在編譯時為該 Groovy 檔案生成 Java 存根
action.ExcludeFromStubGeneration.text=從存根生成中排除
action.Gant.NewScript.description=建立新的 Gant 腳本
action.Gant.NewScript.text=Gant 腳本
action.Groovy.CheckResources.Make.description=為資源根中所有 Groovy 檔案執行增量編譯器，以檢查編譯問題
action.Groovy.CheckResources.Make.text=建置資源(_B)
action.Groovy.CheckResources.Rebuild.description=為資源根中的所有 Groovy 檔案執行編譯器，以檢查編譯問題
action.Groovy.CheckResources.Rebuild.text=重新建置資源 (_R)
action.Groovy.Console.description=啟動 Groovy 主控台
action.Groovy.Console.text=Groovy 主控台
action.Groovy.NewClass.description=建立新的 Groovy 類別
action.Groovy.NewClass.text=Groovy 類別
action.Groovy.NewScript.description=建立新的 Groovy 腳本
action.Groovy.NewScript.text=Groovy 腳本
action.build.module.restart.description=建置模組 ''{0}'' 並重啟
action.build.restart.text=建置並重啟
action.collapse.all.description=全部摺疊
action.collapse.all.text=全部摺疊
action.convert.lambda.to.closure=將 lambda 轉換為閉包
action.expand.all.description=全部展開
action.expand.all.text=全部展開
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=生成 getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=生成 getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=getter 和 setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=生成 setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=生成建構函式
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=建構函式
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=現在動作生成 equals 和 hashCode
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() 和 hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=動作生成 propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=動作生成 propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=生成 toString() 方法
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.remove.dynamic.member.description=移除動態成員
action.remove.dynamic.member.text=移除
add.class.to.extends.family.name=實作
add.compilestatic=新增 @CompileStatic
add.dynamic.element=新增動態元素
add.dynamic.method=新增動態方法
add.dynamic.method.0=新增動態方法 ''{0}''
add.dynamic.property=新增動態屬性 ''{0}''
add.method=新增方法 ''{0}()'' 到類別 ''{1}''
add.method.family=新增方法
add.modifier.sealed=新增修飾符 'sealed'
add.parenthesis.to.lambda.parameter.list=將圓括號新增到參數列表
add.return.type=新增返回值類型
add.return.type.to.method.declaration=將返回值類型新增到方法宣告
add.to.resources=新增到資源
add.type.customizer.to.resources=將類型訂製器腳本新增到資源
ambiguous.code.block=不明確的程式碼塊
annotation.collector.cannot.have.attributes=使用 @AnnotationCollector 註解的註解類型不能具有特性
annotation.field.can.only.be.used.within.a.script=註解 @Field 只能在腳本內使用
annotation.field.can.only.be.used.within.a.script.body=註解 @Field 只能在腳本主體內使用
annotation.field.should.have.type.declaration=註解中的欄位應具有類型宣告
annotation.type.cannot.be.inner=註解類型不能是內部類型
annotation.types.may.not.have.extends.clause=註解類型不能具有 'extends' 子句
annotation.types.may.not.have.implements.clause=註解類型不能具有 'implements' 子句
anonymous.class=匿名類別
anonymous.class.cannot.have.abstract.method=匿名類別不能具有 abstract 方法
anonymous.class.derived.from.0=派生自 {0} 的匿名類別
anonymous.classes.cannot.be.created.from.traits=從 Groovy 2.5.2 起可以使用特徵中的匿名類別
are.you.sure.to.delete.dynamic.property=確定要刪除 ''{0}'' 嗎''?
are.you.sure.to.delete.elements=確定要刪除 ''{0}'' 個元素嗎''?
at.interface.0.does.not.contain.attribute=@interface ''{0}'' 不包含特性 ''{1}''
attribute.descriptor.abstract.class=抽象類別
attribute.descriptor.annotation.attribute.name=註解特性名稱
attribute.descriptor.annotation.name=註解名稱
attribute.descriptor.annotations=註解
attribute.descriptor.anonymous.class=匿名類別
attribute.descriptor.bad.character=錯誤字元
attribute.descriptor.block.comment=塊註釋
attribute.descriptor.braces=大括號
attribute.descriptor.braces.and.operators=大括號和運算符
attribute.descriptor.brackets=中括號
attribute.descriptor.class=類別
attribute.descriptor.classes.and.interfaces=類別和接口
attribute.descriptor.closure.expression.braces.and.arrow=閉包表達式大括號和箭頭
attribute.descriptor.comments=註釋
attribute.descriptor.constructor.call=建構函式呼叫
attribute.descriptor.constructor.declaration=建構函式宣告
attribute.descriptor.enum=枚舉
attribute.descriptor.fields=欄位
attribute.descriptor.groovydoc=Groovydoc
attribute.descriptor.groovydoc.tag=標記
attribute.descriptor.groovydoc.text=文本
attribute.descriptor.gstring=GString
attribute.descriptor.instance.field=實例欄位
attribute.descriptor.instance.method.call=實例方法呼叫
attribute.descriptor.instance.property.reference=實例屬性參照
attribute.descriptor.interface=接口
attribute.descriptor.invalid.string.escape=無效字串轉義
attribute.descriptor.keyword=關鍵字
attribute.descriptor.label=標籤
attribute.descriptor.lambda.expression.braces.and.arrow=Lambda 表達式大括號和箭頭
attribute.descriptor.line.comment=行註釋
attribute.descriptor.list.map.to.object.conversion=列表/映射到物件轉換
attribute.descriptor.local.variable=區域變數
attribute.descriptor.map.key.named.argument=映射鍵/命名實參
attribute.descriptor.method.declaration=方法宣告
attribute.descriptor.methods=方法
attribute.descriptor.number=數字
attribute.descriptor.operator.sign=運算符
attribute.descriptor.parameter=參數
attribute.descriptor.parentheses=圓括號
attribute.descriptor.reassigned.local.variable=重新賦值的區域變數
attribute.descriptor.reassigned.parameter=重新賦值的參數
attribute.descriptor.references=參照
attribute.descriptor.static.field=static 欄位
attribute.descriptor.static.method.call=static 方法呼叫
attribute.descriptor.static.property.reference=static 屬性參照
attribute.descriptor.string=字串
attribute.descriptor.strings=字串
attribute.descriptor.trait=特徵
attribute.descriptor.type.parameter=類型參數
attribute.descriptor.unresolved.reference=未解析的參照
attribute.descriptor.valid.string.escape=有效字串轉義
attribute.descriptor.variables.and.parameters=變數和參數
attribute.name.expected=應為特性名稱
base.script.annotation.is.allowed.only.inside.scripts=註解 @BaseScript 只能在腳本內使用
break.outside.loop=僅允許在迴圈內使用具有命名標籤的 break 語句
break.outside.loop.or.switch=僅允許在迴圈或冒號樣式的 switch 語句中使用 'break' 語句
builder.annotation.not.support.super.for.simple.strategy=groovy.transform.builder.SimpleStrategy 不支持註解特性 'includeSuperProperties'
call.can.throw.npe=呼叫鏈可能拋出 NullPointerException
call.without.parentheses.are.supported.since.groovy.3=自 Groovy 3.0 起支援在實參列表中不帶圓括號的呼叫
cannot.access=對 ''{0}'' 的存取超出了其存取權限
cannot.apply.constructor=''{1}'' 中的建構函式 ''{0}'' 不能應用於 ''{2}''
cannot.apply.default.constructor=無法將預設建構函式應用於類別 ''{0}''
cannot.apply.method.or.closure=''{0}'' 無法應用於 ''{1}''
cannot.apply.method1=''{1}'' 中的 ''{0}'' 無法應用於 ''{2}''
cannot.assign=無法將 ''{0}'' 分配給 ''{1}''
cannot.assign.a.value.to.final.field.0=無法將值賦給 final 欄位 ''{0}''
cannot.assign.a.value.to.final.parameter.0=無法將值賦給 final 參數 ''{0}''
cannot.assign.string.to.enum.0=無法將字串分配給枚舉 ''{0}''
cannot.cast=不能將 ''{0}'' 轉換為 ''{1}''
cannot.create.class=無法建立類別
cannot.create.class.error.text=無法建立類別 ''{0}'': {1}
cannot.create.class.error.title=無法建立類別
cannot.find.enum.constant.0.in.enum.1=無法在枚舉 ''{1}'' 中找到枚舉常數 ''{0}''
cannot.infer.argument.types=無法推斷實參類型
cannot.instantiate.abstract.class=無法實例化抽象類別 ''{0}''
cannot.instantiate.interface=無法實例化接口 ''{0}''
cannot.reference.non.static=無法從 static 上下文參照非靜態符號 ''{0}''
cannot.resolve=無法解析符號''{0}''
cannot.return.from.constructor=無法從建構函式返回物件
cannot.return.from.void.method=無法從返回 'void' 的方法返回物件
cannot.return.type=無法從返回 ''{1}'' 的方法返回 ''{0}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=catch 語句參數類型應當是 Throwable 的子類別
change.base.method.label=更改基方法
change.implements.and.extends.classes=標準化 extends 和 implements 列表
change.lvalue.type=將變數 ''{0}'' 類型更改為 ''{1}''
change.modifier=將 ''{0}'' 設為{1}
change.modifier.family.name=更改修飾符
change.modifier.not=將 ''{0}'' 設為非{1}
change.signature.default.initializer.column=預設初始設定式
change.signature.type.column=類型
change.usages.label=更改用法
checkbox.delegate.via.overloading.method=通過多載方法委託
checkbox.ignore.conditional.operators=忽略條件運算符
checkbox.ignore.double.checked.locking.on.volatile.fields=忽略對 volatile 欄位的雙重檢查鎖定
checkbox.ignore.obscure.operators=忽略模糊運算符
checkbox.inspect.anonymous.closures=檢查匿名閉包
checkbox.inspect.gradle.files=檢查 Gradle 檔案
checkbox.only.warn.if.loop.empty=僅當迴圈為空時才發出警告
checkbox.report.unmatched.null=報告不符合的 'null'
class.definition.is.not.expected.here=不應在此處使用類別定義
class.is.not.annotation=''{0}'' 不是一個註解
closure=閉包
closure.is.accessed.outside.of.groovy=在 Groovy 外部存取欄位 <b>{0}</b>
closure.is.too.complex.to.analyze=閉包分析起來很複雜。\n無法推斷區域變數的類型。
closure.used.as.variable=閉包作為實參傳遞。重構會破壞語意。
code.style.groovydoc.enable=啟用 GroovyDoc 格式設定
code.style.groovydoc.tab.name=GroovyDoc
code.style.group.list.map.literals=列表和映射文字
code.style.option.after.assert.separator=在 'assert' 分隔符後面
code.style.option.align.multiline.named.arguments=對齊多行命名實參
code.style.option.align.when.multiple=多行時對齊
code.style.option.before.assert.separator=在 'assert' 分隔符前面
code.style.option.before.record.parameter.list=記錄參數列表前
code.style.option.closure.left.brace.in.method.calls=方法呼叫中有結束左大括號
code.style.option.gstring.injection.braces=GString 注入大括號
code.style.option.import.annotations=匯入註解
code.style.option.in.named.argument.after.colon=在 ':' 之後的命名實參中
code.style.option.in.named.argument.before.colon=在 ':' 之前的命名實參中
code.style.option.list.maps.literals=列表和映射文字
code.style.option.regexp.expression=正則表達式 (==~, =~)
code.style.option.relational.operators=關係運算符(<、>、<=、>=、<=>)
code.style.option.simple.lambdas.closures.in.one.line=簡單的 lambda/閉包位於一行中
code.style.option.tuple.assignment.expression=元組賦值表達式
code.style.option.unary.operators=一元運算符 (!、-、+、++、--、*)
code.style.option.use.flying.geese.braces=使用雁形大括號
code.style.option.wrap.after.dot=在點後換行
collection.literal.contains.named.argument.and.expression.items=集合文字同時包含命名實參和表達式實參
command.name.add.dynamic.member=新增動態成員
comments.count.as.content=註釋計為內容
configurable.GantConfigurable.display.name=Gant
configurable.GroovyCompilerConfigurable.display.name=Groovy 編譯器
configurable.greclipse.border.title=Groovy-Eclipse 選項
configurable.greclipse.command.line.params.label=附加命令行參數:
configurable.greclipse.debug.checkbox=生成偵錯資訊
configurable.greclipse.path.chooser.description=選擇版本與您的 Groovy 分發版相符合的 groovy-eclipse-batch-*.jar 的路徑
configurable.greclipse.path.label=Groovy-eclipse-batch jar 路徑:
configurable.hotswap.checkbox=為 Groovy 程式碼啟用熱交換代理
configurable.hotswap.checkbox.description=可能在已偵錯的應用程式中導致序列化問題
configure.groovy.library=組態 Groovy SDK…
constructor.cannot.have.static.modifier=建構函式可能不為 static
constructors.are.not.allowed.in.anonymous.class=匿名類別中不允許使用建構函式
constructors.are.not.allowed.in.interface=接口中不允許使用建構函式
constructors.cannot.have.return.type=建構函式中不允許使用返回值類型元素
continue.outside.loop=僅允許在迴圈內部使用 continue 語句
conversion.closure.not.allowed.in.non.groovy.files=不允許重構在非 Groovy 檔案中具有符合項的閉包:
conversion.method.not.allowed.in.non.groovy.files=不允許重構在非 Groovy 檔案中具有符合項的方法:
convert.cannot.itself=重構不適用於映射參數本身
convert.param.to.map.entry=將參數轉換為映射條目
convert.parameter.to.map.entry.title=將參數轉換為映射條目
create.annotation.text=建立註解 ''{0}''
create.class.family.name=建立類別
create.class.text=建立類別 ''{0}''
create.directory.command=建立目錄
create.enum=建立枚舉 ''{0}''
create.field.from.usage=建立欄位 ''{0}''
create.field.from.usage.family.name=從用法建立欄位
create.instance.of.built-in.type=內建類型的實例化
create.interface.text=建立接口 ''{0}''
create.method.from.usage=建立方法 ''{0}''
create.method.from.usage.family.name=從用法建立方法
create.parameter.from.usage=建立參數 ''{0}''
create.parameter.from.usage.family.name=從用法建立參數
create.record.text=建立記錄 ''{0}''
create.trait=建立特徵 ''{0}''
create.variable.from.usage=建立變數 ''{0}''
create.variable.from.usage.family.name=從用法建立變數
cyclic.inheritance.involving.0=涉及 ''{0}'' 的迴圈繼承
debug.option=啟用偵錯堆疊追蹤(&D)
declare.explicit.implementations.of.trait=宣告特徵的顯式實作
declared.type.0.extends.1.which.is.circular.inheritance=宣告的類型 ''{0}'' 會擴展 ''{1}''，這是一個迴圈繼承
declared.type.0.have.to.extend.script=宣告的類型 ''{0}'' 不擴展 ''groovy.lang.Script'' 類別
def.visibility.presentation=def
default.initializers.are.not.allowed.in.abstract.method=abstract 方法中不允許使用預設初始設定式
default.modifier.in.old.versions=修飾符 'default' 在 Groovy 3.0 或更高版本中可用
delegate.annotation.is.only.for.methods.without.arguments=註解 @Delegate 無法應用於帶有實參的方法
destination.package=目標軟體套件:
dialog.create.class.package.chooser.title=選擇目標軟體套件
dialog.message.gant.not.configured=未組態 Gant
dialog.title.no.jdk.specified.error=未指定 Groovy SDK
dialog.title.no.jdk.specified.prompt=是否要建立未分配 SDK 的專案?
dialog.title.no.jdk.specified.title=未指定 Groovy SDK
dialog.title.refactoring.unavailable.in.current.scope=重構在當前作用域中不可用
dialog.title.select.groovy.sdk=選擇 Groovy SDK
dialog.title.specify.groovy.sdk=指定 Groovy SDK 主目錄
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=您指定了一個不包含 Groovy SDK 的目錄。是否要使用此組態建立專案?
dialog.title.validation.invalid.sdk.specified.error=指定的 Groovy SDK 無效
dialog.title.validation.invalid.sdk.specified.title=指定的 Groovy SDK 無效
dialog.title.validation.path.does.not.contain.groovy.sdk=路徑不包含 Groovy SDK
dialog.title.validation.path.should.not.be.empty=路徑不應為空
do.you.want.to.change.method.return.type=是否要更改 ''{0}'' 方法的返回值類型
do.you.want.to.change.type.of.parameter.in.method=是否要更改方法 ''{1}'' 中參數 ''{0}'' 的類型
do.you.want.to.change.variable.type=是否要更改 ''{0}'' 的類型
doc.end.expected=應為 '*/'
documentation.cannot.infer.type.label=無法推斷類型
documentation.gdk.label=GDK
documentation.inferred.type.label=推斷類型
duplicate.attribute=重複特性
duplicate.class=類別 ''{0}'' 在 ''{1}'' 中已存在
duplicate.element.in.the.map=映射中存在重複的元素 ''{0}''
duplicate.inner.class=重複的類別: ''{0}''
duplicate.modifier=重複的修飾符 ''{0}''
duplicated.named.parameter=已找到重複的命名參數 ''{0}''
duplicating.named.parameter=參數中出現重複的命名參數 ''{0}'': {1}
dynamic.dialog.class.label=類別(&C):
dynamic.dialog.static.checkbox=static(&S)
dynamic.dialog.type.label=類型(&T):
dynamic.element=動態元素
dynamic.element.deletion=動態元素刪除
dynamic.members.column.name.element=動態元素
dynamic.members.column.name.type=類型
dynamic.method.property.type=屬性類型(&T):
dynamic.method.return.type=返回值類型(&T):
dynamic.name=名稱
dynamic.properties.table.name=方法實參
dynamic.property.deletion=刪除動態屬性
dynamic.tool.window.id=動態成員
dynamic.type=類型
ellipsis.type.is.not.allowed.here=此處不允許使用 ellipsis 類型
enums.may.not.have.extends.clause=枚舉不能具有 'extends' 子句
equals.between.inconvertible.types.tooltip=<code>{0}</code> 位於不可轉換的 ''{1}'' 和 ''{2}'' 類型的物件之間
exception.0.has.already.been.caught=已捕捉到異常 ''{0}''
expected.0.to.be.inline.constant=''{0}'' 應是一個內聯常數
expected.type.0=應為 ''{0}''，但實際為 ''{1}''
explicit.constructors.are.not.allowed.in.immutable.class=@Immutable 類別不允許使用顯式建構函式
explicit.includes.and.excludes=應只提供 'includes' 和 'excludes' 之一
expression.expected=應為表達式
expression.type.no.expression=找不到表達式
expression.type.unknown=<unknown>
extract.closure.command.name=提取閉包
field.already.defined=欄位 ''{0}'' 已定義
field.already.exists=欄位 <b>{0}</b> 已存在
field.is.used.in.argument.label=在實參標籤中使用欄位 <b>{0}</b>
field.should.be.immutable=欄位 ''{0}'' 應具有不可變的類型，或者應使用 @ImmutableOptions 宣告
file.exists=檔案 ''{0}'' 在目錄 ''{1}'' 中已存在
file.template.group.title.groovy=Groovy
filetype.dgm.description=Groovy 擴展模組檔案描述子檔案
filetype.dgm.display.name=DGM
filetype.gdsl.description=IntelliJ Groovy DSL 組態
filetype.gdsl.display.name=Groovy DSL
filetype.groovy.description=Groovy
filetype.logback.description=Groovy Logback DSL 組態
filetype.logback.display.name=Groovy Logback DSL
final.class.cannot.be.extended=無法擴展 final 類別
final.visibility.presentation=final
find.method.ro.closure.usages=正在專案檔案中搜尋封閉閉包的用法
find.method.ro.method.usages=正在專案檔案中搜尋封閉方法的用法
find.usages.method.0.of.class.1={1} 的 {0}
fix.class=修正類別 {0}
fix.package.name=修正軟體套件名稱
framework.0.home.label={0} 主目錄:
framework.0.library={0} 庫
framework.0.library.version.1=版本 {1} 的 {0} 庫
framework.0.sdk.chooser.description=選擇包含 {0} 分發版的目錄
framework.0.sdk.chooser.error.message=指定路徑中的 {0} 分發版似乎已損壞。無法確定版本。
framework.0.sdk.chooser.error.title=無法建立庫
framework.0.sdk.chooser.title={0} SDK
framework.gant=Gant
gdsl.error.notification.title=DSL 腳本執行錯誤
gdsl.investigate.link.label=點擊此處進行調查
generate.equals.and.hashcode.already.defined.title=equals() 和 hashCode() 已定義
generate.equals.and.hashcode.already.defined.warning=equals() 和 hashCode() 已定義
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() 和 hashCode() 已定義
generate.equals.compare.arrays.comment= //可能不正確 - 使用 Arrays.equals 比較 Object[] 陣列
generate.equals.compare.nested.arrays.comment= //比較嵌套陣列 - 此處 {0} 的值
generate.method.missing.already.defined.title=methodMissing() 已定義
generate.method.missing.already.defined.warning=methodMissing() 已定義
generate.property.missing.already.defined.title=propertyMissing() 已定義
generate.property.missing.already.defined.warning=propertyMissing() 已定義
generated.stub.exclude.link.label=從存根生成中排除
generated.stub.message=此存根為 Groovy 類別生成，目的是實作 Groovy-Java 交叉編譯
generated.stub.navigate.link.label=轉到 Groovy 類別
getter.0.clashes.with.getter.1=發生衝突: ''{0}'' 和 ''{1}''
getter.kind.gdk.method.0=GDK 方法 {0}
getter.kind.getter.0=Getter {0}
getter.kind.method.0=方法 {0}
ginq.code.style.group.ginq.clauses=GINQ 子句
ginq.code.style.option.indent.having.clauses=縮排 'having' 子句
ginq.code.style.option.indent.on.clauses=縮排 'on' 子句
ginq.code.style.option.space.after.keyword=在關鍵字後加空格
ginq.code.style.option.wrap.having.clauses=包裝 'having' 子句
ginq.code.style.option.wrap.on.clauses=包裝 'on' 子句
ginq.error.message.0.must.be.after.1=''{0}'' 必須在 ''{1}'' 之後
ginq.error.message.0.must.be.before.1=''{0}'' 必須在 ''{1}'' 之前
ginq.error.message.boolean.condition.expected=應為布爾條件
ginq.error.message.container.expected=應為 GINQ、可迭代物件、Stream 或陣列
ginq.error.message.expected.a.boolean.expression=應為布爾表達式
ginq.error.message.expected.alias=應為別名
ginq.error.message.expected.data.source=應為資料來源
ginq.error.message.expected.in.operator=應為 '… in …'
ginq.error.message.expected.one.or.two.arguments.for.limit='limit' 應有一個或兩個實參
ginq.error.message.from.must.be.in.the.start.of.a.query='from' 必須在查詢的開頭
ginq.error.message.groupby.expected.a.list.of.expressions=應為表達式列表
ginq.error.message.on.is.expected.after.join='join'-like 子句之後應為 'on'
ginq.error.message.on.should.not.be.provided.after.crossjoin='on' 不應在 'crossjoin' 之後
ginq.error.message.orderby.expected.a.list.of.ordering.fields=應為排序欄位列表
ginq.error.message.query.should.end.with.select=查詢應以 'select' 結尾
ginq.error.message.query.should.start.from.from=查詢應以 'from' 開頭
ginq.error.message.unrecognized.query=無法識別的查詢
gr.package.inspection.check.scripts=檢查腳本
grab.error.0.title=無法執行 @Grab: {0}
grab.error.ivy.missing.message=抱歉，如果沒有 Apache Ivy，IDEA 無法 @Grab 相依項。請將 Apache Ivy 新增到您的模組相依項中，然後重新執行這項動作。
grab.error.ivy.missing.title=缺少 Ivy
grab.family.name=Grab
grab.intention.name=Grab 工件
grab.jar.count=<b>{0}</b>: {1} 個 {1, choice, 0#jar|1#jar|2#jar}
grab.progress.title=處理 @Grab 註解
grab.result.title=新增了 {0} 個 Grape 相依項 {0, choice, 0#jar|1#jar|2#jar}
groovy.consoles.type=Groovy 主控台
groovy.debug.caption=Groovy
groovy.debug.disable.specific.methods=不步入特定的 Groovy 類別(&I)
groovy.does.not.support.constructor.type.arguments=Groovy 不支持建構函式類型實參
groovy.file.0=Groovy 檔案 ''{0}''
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy 檔案已映射到 ''{0}''。\n您可以在“設定 | 檔案類型”中將它們映射到 Groovy
groovy.library.is.not.configured.for.module=沒有為模組 ''{0}'' 組態 Groovy SDK
groovy.library.label=Groovy 庫
groovy.term.annotation=註解
groovy.term.binding=腳本綁定變數
groovy.term.class=類別
groovy.term.closure=閉包
groovy.term.enum=枚舉
groovy.term.expression=表達式
groovy.term.field=欄位
groovy.term.interface=接口
groovy.term.label=標籤
groovy.term.method=方法
groovy.term.parameter=參數
groovy.term.property=屬性
groovy.term.record=記錄
groovy.term.trait=特徵
groovy.term.type.parameter=類型參數
groovy.term.variable=區域變數
groovy.version.0=Groovy {0}
groovy.version.bundled.0=捆綁的 Groovy {0}
group.Groovy.CheckResources.description=為資源根中的 Groovy 檔案執行編譯器，以檢查編譯問題
group.Groovy.CheckResources.text=Groovy 資源(_O)
header.extract.closure=提取閉包
highlight.if.groovy.object.methods.overridden=醒目提示來自覆蓋 invokeMethod()、getProperty() 或 setProperty() 的類別的參照
highlight.if.missing.methods.declared=醒目提示顯示來自宣告 missingMethod() 或 missingProperty() 的類別的參照
identifier.expected=應為關鍵字
identifier.or.block.expected=應為關鍵字或程式碼塊
ignore.boolean.expressions=在布爾檢查中忽略未被賦值的變數
ignore.when.catch.parameter.is.named.ignore.or.ignored=當 catch 參數被命名為 ignore 或 ignored 時忽略
illegal.combination.of.modifiers=修飾符的組合非法
illegal.combination.of.modifiers.abstract.and.final=修飾符 'abstract' 和 'final' 的組合非法
illegal.combination.of.modifiers.volatile.and.final=修飾符 'volatile' 和 'final' 的組合非法
illegal.default.modifier=修飾符 'default' 僅在接口的方法中有意義
illegal.default.modifier.fix=移除 'default' 修飾符
illegal.escape.character.in.string.literal=字串文字中的非法轉義字元
illegal.method.name=方法名稱包含非法字元: {0}
illegal.nonsealed.modifier.fix=移除 'non-sealed' 修飾符
illegal.sealed.modifier.fix=移除 'sealed' 修飾符
illegal.single.argument.lambda=lambda 的單實參形式僅可用作賦值表達式的右側部分或方法呼叫內的實參
illegal.type.void=非法類型: 'void'
immutable.options.property.not.exist=屬性 ''{0}'' 不存在
implement.class=實作 {0}
import.statement.cannot.have.modifiers=import 語句不能具有修飾符
incorrect.number.of.values=值的數量不正確。應為: {0}，實際為: {1}
incorrect.variable.name=變數名稱不正確
indexed.property.is.applicable.to.properties.only=@IndexedProperty 僅適用於屬性
infer.method.parameters.types=向參數中新增顯式類型
infer.method.parameters.types.for.method.declaration=為方法宣告中的所有參數新增顯式類型
initializer.cannot.be.0=初始設定式不能為 {0}
initializer.cannot.have.annotations=初始設定式不能有註解
initializers.are.forbidden.with.defaults=通過在 @TupleConstructor 中停用 'defaults' 來停用預設值
initializers.are.not.allowed.in.interface=接口中不允許使用初始設定式
injection.should.not.contain.line.feeds=GString 注入不得包含換行
inlay.groovy.implicit.null.argument.hint.description=不向接受一個實參的方法傳遞實參的呼叫，這意味著隱式 null 將作為實參傳遞。
inlay.groovy.parameters.hints.inferred.parameter.types=方法中的推斷參數類型。
inlay.groovy.parameters.hints.type.parameter.list=具有一個或多個推斷類型參數的方法。需要<b>推斷參數類型<b/>提示。
inlay.groovy.variable.type.hints.description=區域變數類型位於未顯式指定的宣告處。
inspection.annotations=註解
inspection.assignments=賦值問題
inspection.bugs=可能的錯誤
inspection.confusing=可能引起混淆的程式碼結構
inspection.control.flow=控制流問題
inspection.data.flow=數據流
inspection.display.name.access.to.inaccessible.element=不可存取的元素
inspection.display.name.access.to.static.field.locked.on.instance=存取實例資料上鎖定的 static 欄位
inspection.display.name.annotation.references.unknown.identifier=@TupleConstructor 和 @MapConstructor
inspection.display.name.assignability.check=不相容的類型賦值
inspection.display.name.assignment.can.be.operator.assignment=賦值可被取代為運算符賦值
inspection.display.name.assignment.to.for.loop.parameter=賦值給 'for' 迴圈參數
inspection.display.name.assignment.to.method.parameter=賦值給方法參數
inspection.display.name.break='break' 語句
inspection.display.name.busy.wait=繁忙等待
inspection.display.name.change.to.method=運算符呼叫可被取代為方法呼叫
inspection.display.name.change.to.operator=方法呼叫可被取代為運算符呼叫
inspection.display.name.check.labeled.statement=標籤化語句檢查
inspection.display.name.clashing.getters=衝突的 getter
inspection.display.name.clashing.trait.methods=衝突的特徵方法
inspection.display.name.class.naming.convention=類別命名約定
inspection.display.name.conditional=三元表達式
inspection.display.name.conditional.can.be.conditional.call=三元表達式可被取代為安全呼叫
inspection.display.name.conditional.can.be.elvis=三元表達式可被取代為 elvis 表達式
inspection.display.name.conditional.with.identical.branches=分支相同的三元表達式
inspection.display.name.constant.conditional=常數條件表達式
inspection.display.name.constant.if.statement=常數 if 語句
inspection.display.name.constant.naming.convention=常數命名約定
inspection.display.name.constructor.named.arguments=建構函式呼叫的命名實參
inspection.display.name.continue='continue' 語句
inspection.display.name.continue.or.break.from.finally.block='finally' 塊中的 'continue' 或 'break'
inspection.display.name.delegates.to=@DelegatesTo
inspection.display.name.deprecated.api.usage=棄用的 API 用法
inspection.display.name.divide.by.zero=除以零
inspection.display.name.double.checked.locking=雙重檢查鎖定
inspection.display.name.double.negation=雙重求反
inspection.display.name.duplicate.switch.branch=重複 switch case
inspection.display.name.empty.catch.block=空 'catch' 塊
inspection.display.name.empty.finally.block=空 'finally' 塊
inspection.display.name.empty.statement.body=帶空體的語句
inspection.display.name.empty.sync.block=空 'synchronized' 塊
inspection.display.name.empty.try.block=空 'try' 塊
inspection.display.name.equals.between.inconvertible.types='equals()' 位於不可轉換類型的物件之間
inspection.display.name.fallthrough='switch' 語句中的直落
inspection.display.name.final.variable.access=final 變數存取
inspection.display.name.groovydoc.check=未解析的 GroovyDoc 參照
inspection.display.name.gstring.key=GString 映射鍵
inspection.display.name.if.statement.with.identical.branches=具有相同分支的 if 語句
inspection.display.name.if.statement.with.too.many.branches=具有過多分支的 if 語句
inspection.display.name.implicit.null.argument=隱式 null 實參
inspection.display.name.in.argument.check=不相容的 'in' 實參類型
inspection.display.name.incorrect.range.argument=不正確的範圍實參
inspection.display.name.infinite.loop.statement=無限迴圈語句
inspection.display.name.infinite.recursion=無限遞迴
inspection.display.name.instance.method.naming.convention=實例方法命名約定
inspection.display.name.instance.variable.naming.convention=實例變數命名約定
inspection.display.name.java.style.properties.invocation=Java 風格的屬性存取
inspection.display.name.list.get.can.be.keyed.access=對 List.get 的呼叫可以是鍵控存取
inspection.display.name.list.set.can.be.keyed.access=對 List.set 的呼叫可以是鍵控存取
inspection.display.name.local.variable.naming.convention=區域變數命名約定
inspection.display.name.loop.statement.that.doesnt.loop=不迴圈的迴圈語句
inspection.display.name.map.get.can.be.keyed.access=對 Map.get 的呼叫可以是鍵控存取
inspection.display.name.map.put.can.be.keyed.access=對 Map.put 的呼叫可以是鍵控存取
inspection.display.name.method.may.be.static=方法可以為 'static'
inspection.display.name.method.parameter.count=參數過多的方法
inspection.display.name.method.with.more.than.three.negations=具有三個以上否定的方法
inspection.display.name.multiple.return.points.per.method=具有多個返回點的方法
inspection.display.name.negated.conditional=否定條件表達式
inspection.display.name.negated.if=否定 if 條件表達式
inspection.display.name.nested.assignment=嵌套賦值
inspection.display.name.nested.conditional=嵌套條件表達式
inspection.display.name.nested.switch=嵌套 switch 語句
inspection.display.name.nested.synchronized.statement=嵌套 'synchronized' 語句
inspection.display.name.new.instance.of.singleton=使用 @groovy.lang.Singleton 註解的類別的新實例
inspection.display.name.no.return=缺少 return 語句
inspection.display.name.non.extending.permitted.subclasses=不可擴展的允許的子類別
inspection.display.name.non.short.circuit.boolean=非短路布爾
inspection.display.name.notify.while.not.synchronized=未同步時使用 'notify()' 或 'notifyAll()'
inspection.display.name.octal.integer=八進制整數
inspection.display.name.overly.complex.arithmetic.expression=過於複雜的算術表達式
inspection.display.name.overly.complex.boolean.expression=過於複雜的布爾表達式
inspection.display.name.overly.complex.method=過於複雜的方法
inspection.display.name.overly.long.method=過長的方法
inspection.display.name.overly.nested.method=過度嵌套的方法
inspection.display.name.package.mismatch=軟體套件不符合
inspection.display.name.parameter.naming.convention=方法參數命名約定
inspection.display.name.pointless.arithmetic=無意義的算術表達式
inspection.display.name.pointless.boolean=無意義的布爾表達式
inspection.display.name.pojo.without.compile.static=無 @CompileStatic 的 @POJO
inspection.display.name.public.field.accessed.in.synchronized.context=在同步上下文中存取的非 private 欄位
inspection.display.name.reassigned.in.closure.local.var=在閉包類別或匿名類別中重新分配區域變數
inspection.display.name.result.of.assignment.used=使用的賦值的結果
inspection.display.name.result.of.increment.or.decrement.used=使用增量或減量的結果
inspection.display.name.result.of.object.allocation.ignored=被忽略的物件分配結果
inspection.display.name.return.from.closure.can.be.implicit='return' 語句可以是隱式語句
inspection.display.name.return.from.finally.block='return' 位於 'finally' 塊內
inspection.display.name.second.unsafe.call=第二次不安全的呼叫
inspection.display.name.silly.assignment=不實用的賦值
inspection.display.name.singleton.constructor=@Singleton 建構函式
inspection.display.name.static.method.naming.convention=static 方法命名約定
inspection.display.name.static.variable.naming.convention=static 變數命名約定
inspection.display.name.string.style.violation=字串樣式違規
inspection.display.name.switch.exhaustiveness.check=switch 表達式的詳盡性檢查
inspection.display.name.switch.statement.with.no.default=沒有 default case 的 switch 語句
inspection.display.name.synchronization.on.non.final.field=在非 final 欄位上同步
inspection.display.name.synchronization.on.this=在 'this' 上同步
inspection.display.name.synchronization.on.variable.initialized.with.literal=在使用文字初始化的變數上同步
inspection.display.name.synchronized.method=synchronized 方法
inspection.display.name.system.run.finalizers.on.exit=System.runFinalizersOnExit() 呼叫
inspection.display.name.thread.stop.suspend.resume=Thread.stop()、Thread.suspend() 或 Thread.resume() 呼叫
inspection.display.name.throw.from.finally.block='throw' 位於 'finally' 塊內
inspection.display.name.trivial.conditional=冗餘條件表達式
inspection.display.name.trivial.if=冗餘的 'if' 語句
inspection.display.name.type.customizer=類型自定義工具檢查
inspection.display.name.unassigned.access=未分配變數
inspection.display.name.unchecked.assignment.of.member.of.raw.type=原始類型成員中的未檢查的賦值
inspection.display.name.unconditional.wait=無條件的 'wait' 呼叫
inspection.display.name.unnecessary.alias=不必要的匯入別名
inspection.display.name.unnecessary.continue=不必要的 'continue' 語句
inspection.display.name.unnecessary.def.modifier=不必要的 'def'
inspection.display.name.unnecessary.final.modifier=不必要的 'final'
inspection.display.name.unnecessary.non.sealed.modifier=不必要的 'non-sealed' 修飾符
inspection.display.name.unnecessary.public.modifier=不必要的 'public'
inspection.display.name.unnecessary.qualified.reference=不必要的限定參考
inspection.display.name.unnecessary.return=不必要的 'return' 語句
inspection.display.name.unnecessary.sealed.modifier=不必要的 'sealed' 修飾符
inspection.display.name.unnecessary.semicolon=不必要的分號
inspection.display.name.unreachable.statement=不可到達的語句
inspection.display.name.unresolved.access=未解析的參照表達式
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate 未解析標籤
inspection.display.name.unsynchronized.method.overrides.synchronized.method=未同步方法覆寫 synchronized 方法
inspection.display.name.untyped.access=無類型參照表達式
inspection.display.name.unused.assignment=未使用的賦值
inspection.display.name.unused.catch.parameter=未使用的 'catch' 參數
inspection.display.name.unused.declaration=未使用的宣告
inspection.display.name.unused.inc.dec=未使用的遞增或遞減
inspection.display.name.variable.can.be.final=變數可以為 final
inspection.display.name.wait.call.not.in.loop='wait()' 不在迴圈中
inspection.display.name.wait.while.not.synchronized=未同步時使用 'wait()'
inspection.display.name.while.loop.spins.on.field=While 迴圈在欄位上自旋
inspection.error.handling=錯誤處理
inspection.gpath=GPath
inspection.message.0.not.allowed.for.record=記錄不允許 ''{0}''
inspection.message.access.to.static.field.locked.on.instance.data=存取實例資料中鎖定的 static 欄位 <code>#ref</code> #loc
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=註解 '@NonSealed' 無法套用到枚舉類別
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=註解 '@Sealed' 無法套用到枚舉類別
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=case 表達式中的箭頭在 Groovy 4.0 或更高版本中可用
inspection.message.assignment.replaceable.with.operator.assignment=<code>#ref</code> 可以簡化為 ''{0}'' #loc
inspection.message.assignment.to.for.loop.parameter=賦值給 for 迴圈參數 '#ref' #loc
inspection.message.assignment.to.method.parameter=賦值給方法參數 '#ref' #loc
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=兩端開放範圍在 Groovy 4.0 或更高版本中可用
inspection.message.call.to.ref.can.be.keyed.access=對 '#ref' 的呼叫可以是鍵控存取 #loc
inspection.message.call.to.ref.outside.of.loop=在迴圈外部呼叫 '#ref' #loc
inspection.message.call.to.ref.outside.of.synchronized.context=在同步的上下文外部呼叫 '#ref' #loc
inspection.message.call.to.ref.outside.synchronized.context=在同步上下文之外呼叫 '#ref' #loc
inspection.message.call.to.system.ref=呼叫 'System.#ref' #loc
inspection.message.call.to.thread.ref=呼叫 'Thread.#ref' #loc
inspection.message.call.to.thread.ref.in.a.loop=在迴圈中呼叫 <code>Thread.#ref()</code>，可能處於繁忙等待狀態 #loc
inspection.message.cannot.determine.type.ref=無法確定 '#ref' 的類型
inspection.message.cannot.resolve.method.call=無法解析方法 'call'
inspection.message.case.or.default.branches.are.expected=應為 'case' 或 'default' 分支
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=類別 ''{0}'' 無密封父級時不能為 non-sealed
inspection.message.class.has.no.explicit.or.implicit.subclasses=類別 ''{0}'' 沒有顯式或隱式允許的子類別
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>#ref</code> 無限遞迴，只能以拋出異常完成 #loc
inspection.message.code.ref.code.statement.doesnt.loop=<code>#ref</code> 語句不迴圈 #loc
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=緊湊建構函式必須具有顯式的可見性修飾符
inspection.message.conditional.expression=條件表達式 #loc
inspection.message.conditional.expression.can.be.call=條件表達式可以是呼叫 #loc
inspection.message.conditional.expression.can.be.elvis=條件表達式可以是 elvis #loc
inspection.message.conditional.expression.with.identical.branches=具有相同分支的條件表達式 #loc
inspection.message.constant.name.ref.doesnt.match.regex=常數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.constant.name.ref.too.long=常數名稱 '#ref' 過長
inspection.message.constant.name.ref.too.short=常數名稱 '#ref' 過短
inspection.message.couldnt.find.property.field.with.this.name=找不到使用此名稱的屬性或欄位 #loc
inspection.message.divide.by.zero=除以零 #loc
inspection.message.double.checked.locking=雙重檢查鎖定 #loc
inspection.message.double.negation.ref=雙重求反 #ref #loc
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL 檔案描述子檔案已更改，當前未被執行
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=由於處理錯誤，DSL 檔案描述子檔案已被停用
inspection.message.duplicate.switch.case.ref=重複 switch case '#ref' #loc
inspection.message.empty.ref.block=空 '#ref' 塊 #loc
inspection.message.fallthrough.in.switch.statement='switch' 語句存在直落 #loc
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=不帶前導零的分數文字在 Groovy 4.0 或更高版本中可用
inspection.message.gstring.used.as.maps.key=GString 用作映射的鍵 #loc
inspection.message.instance.method.name.ref.doesnt.match.regex=實例方法名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.instance.method.name.ref.too.long=實例方法名稱 '#ref' 過長
inspection.message.instance.method.name.ref.too.short=實例方法名稱 '#ref' 過短
inspection.message.instance.variable.name.ref.doesn.t.match.regex=實例變數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.instance.variable.name.ref.too.long=實例變數名稱 '#ref' 過長
inspection.message.instance.variable.name.ref.too.short=實例變數名稱 '#ref' 過短
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=接口 ''{0}'' 無密封父級時不能為 non-sealed
inspection.message.interface.has.no.explicit.or.implicit.implementors=接口 ''{0}'' 沒有顯式或隱式允許的實作者
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=插值字串應當使用 $/ 參照
inspection.message.interpolated.string.should.be.double.quoted=插值字串應當使用雙引號參照
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=插值字串應當使用 """ 參照
inspection.message.interpolated.string.should.be.slashy.quoted=插值字串應當使用 / 參照
inspection.message.invalid.permits.clause.must.be.sealed=無效的 ''permits'' 子句: ''{0}'' 必須為 ''sealed''
inspection.message.invalid.permits.clause.must.directly.extend=無效的 ''permit '' 子句: ''{0}'' 必須直接擴展 ''{1}''
inspection.message.keyword.yield.available.with.groovy.4.or.later=關鍵字 'yield' 在 Groovy 4.0 或更高版本中可用
inspection.message.label.name.ref.not.supported.by.0={0} 不支持標籤名稱 ''#ref''
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=左開右閉範圍在 Groovy 4.0 或更高版本中可用
inspection.message.local.variable.name.ref.doesnt.match.regex=區域變數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.local.variable.name.ref.too.long=區域變數名稱 '#ref' 過長
inspection.message.local.variable.name.ref.too.short=區域變數名稱 '#ref' 過短
inspection.message.method.called.with.implicit.null.argument=用隱式 null 實參呼叫方法
inspection.message.method.parameter.name.ref.doesnt.match.regex=方法參數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.method.parameter.name.ref.too.long=方法參數名稱 '#ref' 過長
inspection.message.method.parameter.name.ref.too.short=方法參數名稱 '#ref' 過短
inspection.message.method.ref.contains.too.many.parameters.0.1=方法 ''#ref'' 包含過多參數({0}>{1})
inspection.message.method.ref.has.too.many.negations=方法 ''#ref'' 包含過多否定({0} > 3)
inspection.message.method.ref.overly.complex.cyclomatic.complexity=方法 ''#ref'' 過於複雜(迴圈復雜度 = {0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=方法 ''#ref'' 過度嵌套(嵌套深度 = {0}>{1})
inspection.message.method.ref.too.long.statement.count=方法 ''#ref'' 過長(語句計數 = {0}>{1})
inspection.message.mixing.arrows.colons.not.allowed=不允許混合使用箭頭和冒號
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=修飾符 'non-sealed' 無法套用到枚舉類別
inspection.message.modifier.nonsealed.available.with.groovy.or.later=修飾符 'non-sealed' 在 Groovy 4.0 或更高版本中可用
inspection.message.modifier.sealed.available.with.groovy.or.later=修飾符 'sealed' 在 Groovy 4.0 或更高版本中可用
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=修飾符 'sealed' 無法套用到枚舉類別
inspection.message.multiline.string.should.be.dollar.slashy.quoted=多行字串應當使用 $/ 參照
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=多行字串應當使用 """ 參照
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=多行字串應當使用 '''' 參照
inspection.message.multiline.string.should.be.slashy.quoted=多行字串應當使用 / 參照
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=case 標籤中的多個表達式在 Groovy 4.0 或更高版本中可用
inspection.message.negated.conditional.expression=否定的條件表達式 #loc
inspection.message.negated.if.condition.expression=否定的 if 條件表達式 #loc
inspection.message.nested.assignment=使用賦值表達式結果 #loc
inspection.message.nested.assignment.expression=嵌套賦值表達式 #loc
inspection.message.nested.conditional.expression=嵌套條件表達式 #loc
inspection.message.nested.ref.statement=嵌套 '#ref' 語句 #loc
inspection.message.non.private.field.accessed.in.synchronized.context=在同步上下文中存取了非 private 欄位 '#ref' #loc
inspection.message.non.short.circuit.boolean.expression=非短路布爾表達式 #loc
inspection.message.not.allowed.in.sealed.hierarchy=密封層次結構中不允許使用 ''{0}''
inspection.message.octal.integer.ref=八進制整數 #ref #loc
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class=僅應將 'final'、'sealed'、'non-sealed'、@Sealed 或 @NonSealed 中的一個套用到類別
inspection.message.overly.complex.arithmetic.expression=過於複雜的算術表達式 #loc
inspection.message.overly.complex.boolean.expression=過於複雜的布爾表達式 #loc
inspection.message.package.name.mismatch=軟體套件名稱不符合
inspection.message.package.name.mismatch.actual.0.expected.1=軟體套件名稱不符合。實際: ''{0}''，預期: ''{1}''
inspection.message.permits.available.with.groovy.4.or.later='permits' 在 Groovy 4.0 或更高版本中可用
inspection.message.plain.string.should.be.dollar.slashy.quoted=普通字串應當使用 $/ 參照
inspection.message.plain.string.should.be.double.quoted=普通字串應當使用雙引號參照
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=普通字串應當使用 """ 參照
inspection.message.plain.string.should.be.quoted.with.triple.quotes=普通字串應當使用 '''' 參照
inspection.message.plain.string.should.be.single.quoted=普通字串應當使用單引號參照
inspection.message.plain.string.should.be.slashy.quoted=普通字串應當使用 / 參照
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO 僅對 @CompileStatic 有效
inspection.message.property.0.is.final=屬性 ''{0}'' 為 final #loc
inspection.message.property.0.is.ignored.by.map.constructor=屬性 ''{0}'' 被 @MapConstructor 忽略 #loc
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=屬性不可索引。類型必須為數組或列表，但實際為 {0}
inspection.message.record.parameter.should.be.immutable=記錄參數 ''{0}'' 應具有不可變類型或使用 @ImmutableOptions 宣告為不可變類型
inspection.message.records.are.available.in.groovy.4.or.later=記錄在 Groovy 4.0.0-beta-2 或更高版本中可用
inspection.message.ref.can.be.simplified='#ref' 可以簡化 #loc
inspection.message.ref.has.0.return.points=<code>#ref</code> 具有 {0} 個返回點 #loc
inspection.message.ref.inside.finally.block='finally' 塊內的 '#ref' #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=#ref 不必要，因為是迴圈中的最後一條語句 #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=#ref 不必要，因為它是沒有返回值的方法中的最後一條語句 #loc
inspection.message.ref.loop.spins.on.field=<code>#ref</code> 迴圈在欄位上自旋 #loc
inspection.message.ref.statement=#ref 語句 #loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=閉包結尾存在顯式返回 #loc
inspection.message.ref.statement.can.be.simplified=#ref 語句可以簡化 #loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=<code>#ref</code> 語句不能在未拋出異常的情況下完成 #loc
inspection.message.ref.statement.has.empty.body='#ref' 語句具有空體
inspection.message.ref.statement.has.empty.branch='#ref' 語句具有空分支
inspection.message.ref.statement.with.identical.branches=具有相同分支的 '#ref' 語句 #loc
inspection.message.ref.statement.with.no.default.branch=沒有 'default' 分支的 #ref 語句 #loc
inspection.message.ref.statement.with.too.many.branches=具有過多分支({0})的 ''#ref'' 語句 #loc
inspection.message.result.increment.or.decrement.expression.used=使用遞增或遞減結果 #loc
inspection.message.result.of.new.ref.is.ignored=''new #ref{0}'' 的結果被忽略 #loc
inspection.message.silly.assignment=不實用的賦值 #loc
inspection.message.static.interface.methods.must.be.qualified.in.groovy.4=從 Groovy 4 開始，'static' 接口方法必須限定
inspection.message.static.method.name.ref.doesnt.match.regex=static 方法名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.static.method.name.ref.too.long=static 方法名稱 '#ref' 過長
inspection.message.static.method.name.ref.too.short=static 方法名稱 '#ref' 過短
inspection.message.static.variable.name.ref.doesnt.match.regex=static 變數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
inspection.message.static.variable.name.ref.too.long=static 變數名稱 '#ref' 過長
inspection.message.static.variable.name.ref.too.short=static 變數名稱 '#ref' 過短
inspection.message.string.escaping.could.be.minimized=轉義可以最小化
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=switch 表達式未涵蓋所有可能的結果
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=切換表達式在 Groovy 4.0 或更高版本中可用
inspection.message.switch.expressions.do.not.support.return=switch 表達式不支持 'return'
inspection.message.synchronization.on.non.final.field.ref=在非 final 欄位 '#ref' 上同步 #loc
inspection.message.synchronization.on.ref=在 '#ref' 上同步 #loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=在使用文字初始化的 '#ref' 上同步 #loc
inspection.message.synchronized.method.ref=synchronized 方法 '#ref' #loc
inspection.message.traits.0.contain.clashing.methods.with.signature.1=特徵 {0} 包含帶簽名 {1} 的衝突方法
inspection.message.trivial.conditional.expression=普通條件表達式 #loc
inspection.message.type.argument.0.can.not.be.1=實參 ''{0}'' 的類型不能為 ''{1}''
inspection.message.unconditional.call.to.ref=無條件呼叫 <code>#ref()</code> #loc
inspection.message.unreachable.statement=不可到達的語句 #loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=非同步方法 '#ref' 重寫了一個 synchronized 方法 #loc
inspection.message.unused.catch.parameter.ref=未使用的 catch 參數 '#ref' #loc
inspection.message.yield.or.throw.expected.in.case.section='yield' 或 'throw' 應出現在 case 部分中
inspection.method.metrics=方法指標
inspection.naming=命名約定
inspection.other=其他
inspection.redundancy=宣告冗餘
inspection.separator.disable.in.file.types=在檔案類型中啟用:
inspection.style=樣式
inspection.threading=執行緒問題
inspection.validity=有效性問題
intention.category.closures=Groovy/閉包
intention.category.comments=Groovy/註釋
intention.category.control.flow=Groovy/控制流
intention.category.conversions=Groovy/表達式轉換
intention.category.groovy=Groovy
intention.category.groovy.declaration=Groovy/宣告
intention.category.groovy.other=Groovy/其他
intention.category.groovy.style=Groovy/Groovy 樣式
intention.family.name.activate.dsl.descriptor=啟用 DSL 檔案描述子
intention.family.name.add.attributes.to.annotation=將特性新增到註解
intention.family.name.add.cast=新增轉換
intention.family.name.add.class.to.clause=將類別新增到子句
intention.family.name.add.missing.case.branches=新增缺少的 case 分支
intention.family.name.add.parameter.cast=新增參數轉換
intention.family.name.change.variable.type=更改變數類型
intention.family.name.collapse.conditional.expressions=摺疊條件表達式
intention.family.name.collapse.if.statement=摺疊 'if' 語句
intention.family.name.convert.conditional.expression.to.elvis=條件表達式轉換為 Elvis
intention.family.name.create.field=建立欄位
intention.family.name.fix.quotation=修正參照
intention.family.name.fix.range.class=修正範圍類別
intention.family.name.make.return.implicit=設為隱式返回
intention.family.name.remove.double.negation=移除雙重求反
intention.family.name.remove.unnecessary.continue=移除不必要的 continue
intention.family.name.remove.unnecessary.return=移除不必要的 return
intention.family.name.rename=重新命名
intention.family.name.replace.for.each.operator=取代 'for-each' 運算符
intention.family.name.replace.keywords=取代元素
intention.family.name.replace.modifiers=取代修飾符
intention.family.name.replace.something.with=將 ''{0}'' 取代為 ''{1}''
intention.family.name.replace.with.conditional.call=取代為條件呼叫
intention.family.name.replace.with.keyed.access=取代為鍵控存取
intention.family.name.replace.with.short.circuit.expression=取代為短路表達式
intention.family.name.simplify=簡化
intention.name.activate.back=重新啟用
intention.name.add.required.attributes.to.map.constructor=將必要特性新增到 '@MapConstructor'
intention.name.add.to.clause=將 ''{0}'' 新增到 ''{2}'' 的 {1} 子句
intention.name.cast.operand.to.0=將動作數轉換為 {0}
intention.name.cast.to.0=轉換為 {0}
intention.name.change.quotes.to.triple.double.quotes=將引號更改為 """
intention.name.change.quotes.to.triple.single.quotes=將引號更改為 ''''
intention.name.convert.to.dollar.slashy.string=轉換為 $/ 字串
intention.name.convert.to.double.quoted.string=轉換為帶雙引號的字串
intention.name.convert.to.single.quoted.string=轉換為帶單引號的字串
intention.name.convert.to.slashy.string=轉換為 / 字串
intention.name.create.abstract.method.in.class=在 ''{1}'' 中建立 abstract 方法 ''{0}''
intention.name.create.constant.field.in.class=在 ''{1}'' 中建立常數欄位 ''{0}''
intention.name.create.enum.constant.0=建立枚舉常數 ''{0}''
intention.name.create.field.in.class=在 ''{1}'' 中建立欄位 ''{0}''
intention.name.create.method.in.class=在 ''{1}'' 中建立方法 ''{0}''
intention.name.insert.case.0=插入 ''case {0}''
intention.name.insert.case.0.case.1=插入 ''case {0}''、''case {1}''
intention.name.insert.default.branch=插入 'default' 分支
intention.name.insert.missing.branches=插入缺少的分支
intention.name.make.compact.constructor.public=將緊湊建構函式設為 'public'
intention.name.remove.wrong.modifiers.for.record=移除記錄的錯誤修飾符
intention.name.replace=將 ''{0}'' 取代為 ''{1}''
intention.name.replace.eq.with.0.eq=將 ''='' 取代為 ''{0}=''
intention.name.replace.with.in=將 ':' 取代為 'in'
intention.name.replace.with.qualified.expression=取代為限定名稱
interface.cannot.have.modifier.final=接口不能具有修飾符 'final'
interface.members.are.not.allowed.to.be=接口成員不允許為 {0}
interface.must.have.no.static.method=接口不得有 static 方法
introduce.constant.title=引入常數
introduce.parameter.delegate.via.overload=通過多載方法委託(&L)
introduce.parameter.delegating.unavailable.tooltip=閉包上下文中不允許委託
introduce.parameter.do.not.replace.option.label=不取代(&O)
introduce.parameter.explicit.return.statement.option.label=使用顯式 return 語句(&X)
introduce.parameter.replace.all.fields.option.label=取代所有欄位(&R)
introduce.parameter.replace.fields.border.title=將表達式中使用的欄位取代為其 Getter
introduce.parameter.replace.inaccessible.fields.option.label=取代用法上下文中不可存取的欄位(&I)
introduce.variable.change.type.advertisement=按 {0} 更改類型
introduce.variable.declare.final.label=宣告 final(&F)
introduce.variable.name.label=名稱(&N):
introduce.variable.replace.all.0.occurrences=取代所有符合項({0} 個匹配項)(&A)
introduce.variable.replace.all.occurrences=取代所有符合項(&A)
introduce.variable.type.label=類型(&T):
invalid.lvalue=要賦予的值無效
invalid.qualified.name=這不是有效的 Groovy 限定名稱
investigate.gdsl.error.family.name=調查 DSL 檔案描述子處理錯誤
investigate.gdsl.error.intention.name=檢視詳細資訊
invoke.completion.second.time.to.show.skipped.methods=第二次呼叫補全以顯示跳過的方法
is.not.enclosing.class=''{0}'' 不是封閉類別
java.style.for.each.statement.requires.a.type.declaration=Java 樣式的 for-each 語句需要類型宣告
java.style.properties.invocation.intention.family.name=將 Java 樣式存取器呼叫更改為 Groovy 樣式屬性參照
java.style.properties.invocation.intention.name=更改為 Groovy 樣式屬性參照
java.style.property.access=Java 樣式存取器呼叫
label.already.used=標籤 ''{0}'' 已在使用中
label.groovy.sdk=Groovy SDK:
language.groovy=Groovy
leave.only.modifier.or.annotation.0=只保留 ''{0}''
listener.list.field.must.have.a.generic.collection.type=@ListenerList 欄位必須具有泛型集合類型
listener.list.field.with.generic.wildcards.not.supported=不支持包含泛型萬用字元的 @ListenerList 欄位
live.template.context.declaration=宣告
live.template.context.expression=表達式
live.template.context.statement=語句
local.var.0.is.reassigned=區域變數 ''{0}'' 已重新賦值
local.variable.types=區域變數類型
lock.field.0.must.be.static=鎖定欄位 ''{0}'' 必須為 static
lock.field.0.must.not.be.static=鎖定欄位 ''{0}'' 不得為 static
lock.field.0.not.found=未找到鎖定欄位 ''{0}''
loss.of.precision=從 ''{0}'' 到 ''{1}'' 的精度可能會損失
map.param.name=映射參數名稱(&N):
map.parameter.dialog.create.new.checkbox=為命名實參建立新參數(&C)
map.parameter.dialog.explicit.type.checkbox=顯式指定類型
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=方法 ''{0}'' 的存取權限(''{1}'')不能比 ''{3}'' (''{4}'')中的 ''{2}'' 弱
method.0.cannot.override.method.1.in.2.overridden.method.is.final=方法 ''{0}'' 無法覆寫 ''{2}'' 中的方法 ''{1}''；覆寫的方法為 final
method.0.is.too.complex.too.analyze=方法 ''{0}'' 過於複雜而無法分析。\n無法推斷區域變數的類型。
method.call.is.ambiguous=方法呼叫不明確
method.does.not.override.super=方法不覆寫其超類別的方法
method.duplicate=具有簽名 {0} 的方法已在類別 ''{1}'' 中定義
method.has.incorrect.modifier.volatile=方法具有不正確的修飾符 'volatile'
method.is.not.implemented=方法 ''{0}'' 未實作
method.is.used.outside.of.groovy=在 Groovy 外部使用方法
method.may.be.static=方法可能為 static
method.may.be.static.ignore.empty.method.option=忽略空方法
method.may.be.static.only.private.or.final.option=僅檢查 final 或 private 方法
method.may.be.static.option.ignore.trait.methods=忽略特徵方法
method.parameters.count.max.parameters.option=最大參數數量:
method.returns.max.returns.option=返回點限制:
method.with.signature.already.exists=具有簽名 {0} 的方法已存在
method.with.type.parameters.should.have.return.type=具有類型參數的方法應具有返回值類型
missed.attributes=缺少特性: {0}
missing.required.named.parameter=缺少必需的命名參數 ''{0}''
mixing.private.and.public.protected.methods.of.the.same.name=將具有相同名稱的 private 和 public/protected 方法混合
modifier.0.not.allowed=此處不允許使用修飾符 ''{0}''
modifier.transient.not.allowed.here=此處不允許使用修飾符 'transient'
modifier.volatile.not.allowed.here=此處不允許使用修飾符 'volatile'
module.name.0.and.groovy.version.1={0} ({1})
module.with.groovy=附加了 Groovy 庫的簡單模塊
move.class.0.from.method=將 ''{0}'' 移至正確位置
move.class.from.method.family.name=“移至正確位置”快速修復
move.to.correct.dir=移至軟體套件 ''{0}''
move.to.correct.dir.family.name=將檔案移至正確的軟體套件
multiple.assignments.without.list.expr=在靜態類型檢查模式下，不支持右側沒有列表表達式的多個賦值
named.arguments.are.not.allowed.inside.index.operations=索引動作內不允許使用命名實參
native.methods.cannot.have.body=原生方法不能有主體
native.visibility.presentation=原生
new.class.action.description=建立新的 Groovy 類別
new.class.action.text=Groovy 類別
new.class.dialog.title=新增 Groovy 類別
new.class.list.item.annotation=註解
new.class.list.item.class=類別
new.class.list.item.enum=枚舉
new.class.list.item.interface=接口
new.class.list.item.record=記錄
new.class.list.item.trait=特徵
new.gant.script.dialog.message=為新的 Gant 腳本輸入名稱
new.gant.script.dialog.title=新增 Gant 腳本
new.instance.of.singleton=使用 @groovy.lang.Singleton 註解的類別的新實例
new.project.wizard.groovy.creating.main.file=正在建立 Groovy 主檔案…
new.project.wizard.groovy.retrieving.has.failed=無法檢索 Groovy 版本
new.script.action.description=建立新的 Groovy 腳本
new.script.action.text=Groovy 腳本
new.script.dialog.title=為新的 Groovy 腳本輸入名稱
new.script.list.item.script=Groovy 腳本
new.script.list.item.script.dsl=GroovyDSL 腳本
newlines.here.are.available.since.groovy.3=自 Groovy 3.0 起可以在實參列表中使用換行符
no.applicable.signature.found=未找到適用的簽名
no.class.expected.here=此處不應為類別
no.class.in.file.template=在檔案模板中找不到類別
no.implements.clause.allowed.for.interface=接口不能具有 'implements' 子句
no.interface.expected.here=此處不應為接口
no.return.message=並非所有執行路徑都返回值
no.such.property=屬性 ''{0}'' 不存在
no.super.classes.found=未找到超類別
no.super.method.found=未找到 super 方法
no.type.specified=未指定類型
non.sealed.visibility.presentation=non-sealed
non.static.classes.not.allowed=特徵中不允許使用非 static 內部類別
not.abstract.method.should.have.body=abstract 方法不應有主體
not.allowed.modifier.in.for.in=此處不允許使用修飾符 ''{0}''
notification.group.grape=Groovy @Grab 註解已處理
notification.group.groovy.dsl=Groovy DSL 錯誤
only.abstract.class.can.have.abstract.method=只有抽象類別可以具有 abstract 方法
only.traits.expected.here=此處應僅有特徵
operator.call.is.ambiguous=運算符呼叫不明確
operator.is.not.supported.in=當前版本不支持運算符 ''{0}''
optimize.all.imports=最佳化未使用的 import 語句
optimize.imports=最佳化 import
optimize.imports.progress.title=正在最佳化 Groovy 檔案中的匯入…
other.scope=其他作用域
overly.complex.method.complexity.limit.option=方法復雜度限制:
overly.long.method.statements.limit.option=每個方法的最大語句數:
overly.nested.method.nesting.limit.option=最大嵌套深度:
overriding.methods.of.0=''{0}'' 的覆寫方法
package.definition.cannot.have.modifiers=軟體套件定義不能具有修飾符
packageLocal.visibility.presentation=預設可見
parameter.can.be.final.tooltip=參數 ''{0}'' 可以為 final
parameter.cast.fix=將第 {0,number,ordinal} 個參數轉換為 {1}
parameter.hint.number.of.arguments={0, choice, 0#|1#{0} 個實參|2#{0} 個實參}
parameter.list.owner.chooser.title=將參數引入
pointless.arithmetic.error.message=冗餘算術運算 #loc
pointless.boolean.problem.descriptor=冗餘布爾運算 #loc
pointless.boolean.quickfix=簡化
popup.content.navigation.to.overriding.classes.unavailable=索引更新時無法導覽到覆寫類別
postfix.template.provider.name=Groovy
primitive.bound.types.are.not.allowed=不允許使用基元限定類型
primitive.type.parameters.are.not.allowed=類型參數列表中不允許使用基元類型參數
private.visibility.presentation=private
property.missing=propertyMissing
property.name.expected=應為屬性名稱
protected.visibility.presentation=protected
public.visibility.presentation=public
pull.up.abstract.wont.be.accessible.from=無法將 {0} 設為 abstract，因為無法通過子類別對其進行存取。
pull.up.wont.be.accessible.from=無法從 {1} 存取 {0}
pull.up.wont.be.accessible.from.the.subclass={0} 使用 {1}，後者無法從子類別存取。
qualified.0.is.allowed.only.in.nested.or.inner.classes=僅允許在嵌套/內部類別中使用限定的 {0}
recursive.constructor.invocation=遞迴建構函式呼叫
remove.0=移除 ''{0}''
remove.catch.block=移除 catch 塊
remove.exception=移除異常
remove.modifier=移除 ''{0}''
remove.parameter.0=刪除參數 ''{0}''
remove.unused.parameter=移除未使用的參數
rename.file.to.0=將檔案重命名為 ''{0}''
repetitive.method.name.0=重複的方法名稱 ''{0}''
replace.0.with.1=將 ''{0}'' 取代為二進制 ''{1}''
replace.all.occurrences.and.remove.variable.0=取代所有符合項並移除變數 ''{0}''
replace.new.expression.with.instance.access=取代為實例存取
replace.postfix.0.with.prefix.0=將後綴 ''{0}'' 取代為前綴 ''{0}''
replace.primitive.type.with.wrapper=將基元類型取代為包裝器
replace.qualified.name.with.import=將限定名稱取代為匯入
replace.with.get.at=取代為索引存取
replace.with.list.literal=取代為列表文字
replace.with.method.fix=取代為 ''{0}'' 方法
replace.with.method.message=可被取代為 ''{0}'' 方法呼叫
replace.with.operator.compareTo.equality.option='compareTo' 等式取代為等號(即 ==)
replace.with.operator.double.negation.option=使用雙重求反(即 !!)
replace.with.operator.fix=''{0}'' 取代為運算符
replace.with.operator.message=''{0}'' 可被取代為運算符
replace.with.operator.parentheses=如果需要附加圓括號，則不建議取代為運算符
replace.with.wrapper=取代為 ''{0}''
require.closure.as.attribute.value=預期閉包為特性值
return.type.is.incompatible={1} 中 {0} 的返回值類型與 {3} 中的 {2} 不相容
rtype.cannot.contain.ltype=''{1}'' 不能包含 ''{0}''
run.configuration.module.chooser.label=模組(&M):
run.configuration.module.classpath.checkbox=向執行程序中新增模組類別路徑(&C)
run.configuration.script.path.label=腳本路徑:
script.cannot.have.modifier.native=腳本不能具有修飾符 'native'
script.generated.with.same.name=為腳本程式碼生成了一個合成類別 ''{0}''
script.method.cannot.have.modifier.abstract=腳本方法不能具有修飾符 'abstract'
script.runner.cant.find.script=找不到腳本 ''{0}''
script.runner.chooser.description=指定腳本路徑
script.runner.chooser.title=腳本路徑
script.runner.class.cannot.be.executed=類別無法執行
script.runner.class.does.not.exist=類別不存在
script.runner.description=Groovy 類別或腳本
script.runner.display.name=Groovy
script.runner.file.is.not.groovy.file=腳本檔案不是 Groovy 檔案
script.runner.module.not.specified.message=未指定模組
script.runner.no.groovy.for.module=沒有為模組 ''{0}'' 組態 Groovy
script.runner.unknown.script.type=未知腳本類型 ''{0}''
sealed.visibility.presentation=sealed
second.unsafe.call=第二次不安全的呼叫
select.framework.0.home.title=選擇 {0} 主目錄
select.module.action.description=選擇要使用類別路徑的模組
select.module.action.text=選擇模組…
select.module.popup.title=使用模組的類別路徑
selfType.class.does.not.inherit=@SelfType: 類別 ''{0}'' 不繼承 ''{1}''
separator.domain.of.inspection.usage=用法域
separator.preferable.string.kind=首選種類
settings.code.style.absolute=絕對
settings.code.style.indent.labels=縮排標籤
settings.code.style.indent.statements.after.label=縮排標籤後的語句
settings.code.style.label.indent.size=標籤縮排大小
settings.code.style.label.indent.style=標籤縮排樣式:
settings.compiler.alternative=另外，您也可以在 <a>Java 編譯器頁面</a> 中指定 Groovy-Eclipse 編譯器
settings.compiler.exclude.from.stub.generation=從存根生成中排除:
settings.compiler.invoke.dynamic.support=呼叫動態支援(&D)
settings.compiler.path.to.configscript=組態腳本的路徑(&C):
settings.compiler.select.path.to.groovy.compiler.configscript=選擇 Groovy 編譯器組態腳本的路徑
settings.inlay.implicit.null.argument=隱式 null 實參
settings.inlay.inferred.parameter.types=推斷的參數類型
settings.inlay.parameter.types=參數類型
settings.inlay.put.type.hint.before.identifier=將類型提示放在關鍵字前面
settings.inlay.show.hints.for.implicit.null.argument=顯示有關隱式 null 實參的提示
settings.inlay.show.type.hints.for=顯示類型提示:
settings.inlay.show.variable.type.hints=顯示區域變數類型提示
settings.inlay.type.parameter.list=類型參數列表
shows.parameter.names.at.function.call.sites=在函式呼叫點顯示參數名稱。
singleton.constructor.found=@Singleton 類別不應有建構函式
singleton.constructor.makeNonStrict=使 @Singleton 非 strict
singleton.constructor.remove=移除建構函式
spread.operator.is.not.available=該展開運算符在進行靜態類型檢查時不能用作實參
static.import.method.0.fix=static 匯入方法 ''{0}''
static.import.method.fix=static 匯入方法…
static.visibility.presentation=static
strictfp.visibility.presentation=strictfp
string.end.expected=應為字串結尾
string.option.do.not.handle.specifically=不做特別處理
string.option.dollar.slashy.string=$/ 字串
string.option.double.quoted.string=帶雙引號的字串
string.option.single.quoted.string=帶單引號的字串
string.option.slashy.string=/ 字串
string.option.triple.double.quoted.string=帶三個雙引號的字串
string.option.triple.quoted.string=帶三引號的字串
string.sort.default=預設
string.sort.multiline.string=多行字串
string.sort.strings.with.escaping=包含轉義的字串
string.sort.strings.with.interpolation=包含插值的字串
super.cannot.be.used.in.static.context='super' 不能在 static 上下文中使用
super.is.not.allowed.in.pre.with.call.super=在啟用 'callSuper' 的情況下， 不允許在 'pre' 中呼叫 super
surround.with.cast=((Type) expr)
surround.with.closure={ -> ... }.call()
surround.with.for=for
surround.with.if=if
surround.with.if.else=if / else
surround.with.if.else.expr=if (expr) / else
surround.with.if.expr=if (expr)
surround.with.parentheses=(expr)
surround.with.shouldFail=shouldFail () {...}
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.catch.finally=try / catch / finally
surround.with.try.finally=try / finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
synchronized.not.allowed.on.abstract.method=抽象方法不允許 @Synchronized
synchronized.visibility.presentation=synchronized
target.0.does.not.exist=目標 ''{0}'' 不存在
target.annotation.is.unused=@Target 未使用
text.class.0.is.unused=類別 {0} 未使用
text.constructor.0.is.unused=建構函式 {0} 未使用
text.method.0.is.unused=方法 {0} 未使用
text.parameter.0.is.unused=參數 {0} 未使用
text.property.0.is.unused=屬性 ''{0}'' 未使用
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=當前不支持使用映射項表達式來初始化枚舉
there.is.no.default.constructor.available.in.class.0=類別 ''{0}'' 中沒有可用的預設建構函式
this.super.completion.advertisement=不使用類別限定符，按 {0} 兩次會顯示所有可存取的 static 方法
throws.clause.is.not.allowed.in.at.interface=@interface 成員中不允許使用 'throws' 子句
top.level.class.may.not.have.private.modifier=頂層類別不能具有 'private' 修飾符
top.level.class.may.not.have.protected.modifier=頂層類別不能具有 'protected' 修飾符
trait.method.cannot.be.protected=不允許 protected 特徵方法
transient.visibility.presentation=transient
try.catch.fix=Try-catch 修正
try.without.catch.finally='try' 沒有 'catch' 或 'finally'
tuple.cant.be.placed.in.class=不允許對欄位多次賦值
tuple.declaration.should.end.with.def.modifier=元組宣告應以 'def' 修飾符結尾
type.argument.0.is.not.in.its.bound.should.extend.1=類型參數 ''{0}'' 不在其界限內；應擴展 ''{1}''
type.argument.list.is.not.allowed.here=此處不允許使用類型實參列表
type.customizer.is.not.marked.as.a.resource.file=類型訂製器腳本未被標記為編譯器資源
type.doesnt.contain.method=類型 ''{0}'' 不能在範圍內進行迭代，因為它沒有方法 ''{1}''
type.doesnt.implement.comparable=類型 ''{0}'' 未實作 Comparable
type.parameters.are.unexpected=存在意外的類型參數
unassigned.access.tooltip=變數 ''{0}'' 可能未被賦值
undefined.label=未定義標籤 ''{0}''
undefined.library.version=未定義
unexpected.attribute.type.0=意外的特性類型: ''{0}''
unnecessary.alias.description=別名不必要
unnecessary.alias.fix=移除不必要的別名
unnecessary.def.explicitly.typed.only=僅在顯式類型宣告中報告
unnecessary.modifier.description=修飾符 ''{0}'' 不必要
unnecessary.modifier.remove=移除不必要的 ''{0}''
unnecessary.semicolon.description=分號不必要
unnecessary.semicolon.fix=移除分號
unnecessary.type=不必要的異常 ''{0}''。''{1}'' 已宣告
unresolved.type.status=類型 ''{0}'' 未解析
unsupported.anonymous.class.0=Groovy {0} 中不支持匿名類別
unsupported.array.initializers=當前版本不支持陣列初始設定式
unsupported.command.syntax.0=Groovy {0} 中不支持指令表達式語法
unsupported.diamonds.0=Groovy {0} 中不支持菱形運算符
unsupported.do.while.statement=當前版本中不支持 'do while'
unsupported.dollar.slashy.string.0=Groovy {0} 中不支持 $/ 字串
unsupported.elvis.assignment=當前版本不支持 Elvis 賦值
unsupported.expression.list.in.for.update=當前版本不支持 'for' 更新中的多個表達式
unsupported.inner.class.0=Groovy {0} 中不支持內部類別
unsupported.lambda=當前版本不支持 lambda
unsupported.multiline.slashy.string.0=Groovy {0} 中不支持多行 / 字串
unsupported.multiple.variables.in.for=當前版本不支持 'for' 初始化中的多個變數
unsupported.negated.in=當前版本不支持否定 'in'
unsupported.negated.instanceof=當前版本不支持否定 'instanceof'
unsupported.resource.list=當前版本不支持 'try-with-resources'
unsupported.safe.index.access=當前版本不支持安全索引存取
unsupported.traits.0=Groovy {0} 中不支持特徵
unsupported.tuple.application.initializer=當前版本不支持應用程式初始設定式
unsupported.tuple.declaration.in.for=當前版本不支持 'for' 初始化中的元組宣告
unsupported.type.annotations=當前版本不支持類型註解
unused.0=未使用的 ''{0}''
unused.assignment.tooltip=未使用賦值
unused.default.parameter.fix=移除初始設定式
unused.default.parameter.message=未使用預設參數
unused.import=未使用的 import
unused.variable=未使用變數
variable.0.might.not.have.been.initialized=變數 ''{0}'' 可能尚未初始化
variable.already.defined=變數 ''{0}'' 已定義
variable.can.be.final.tooltip=變數 ''{0}'' 可以為 final
variable.cannot.be=變數不能具有修飾符 ''{0}''
volatile.visibility.presentation=volatile
wildcards.are.not.allowed.in.extends.list=super 類型可能未指定萬用字元類型
write.access.to.closure.variable=欄位 <b>{0}</b> 的寫入存取權限
wrong.closure.first.parameter.type=閉包 ''{0}'' 與命名實參一起使用，但它的第一個參數 ''{1}'' 不符合 Map 類型。
wrong.method.first.parameter.type=方法 ''{0}'' 與命名實參一起使用，但它的第一個參數 ''{1}'' 不符合 Map 類型。
wrong.number.of.type.arguments=類型實參的數量錯誤: {0}；要求 {1} 個
abstract.class.not.allowed=不允許 abstract 類
access.static.via.instance=通過實例引用訪問 static 成員
action.analyzing.cyclic.dependencies.in.scope={0}的循環依賴
action.create.new.class=創建新的類
action.create.new.class.description=創建新 Java 類
action.create.new.module-info.description=創建新的 module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=創建新的 package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=分析循環依賴
action.description.copy.whole.thread.dump.to.clipboard=將整個線程轉儲複製到剪貼簿
action.description.group.by.scope=按範圍類型分組 (產品, 測試, 庫)
action.description.group.threads.with.identical.stacktraces=組合具有相同堆棧跟踪的線程
action.description.mark.directory.as.a.0.for.generated.files=為生成的檔案將目錄標記為{0}
action.description.mark.directory.as.an.ordinary.0=將目錄標記為普通{0}
action.description.show.only.threads.containing.a.specific.string=僅顯示包含特定字符串的線程
action.group.by.package=軟件包
action.group.by.scope.type=按範圍類型分組
action.implement.method=實現方法
action.implement.methods=實現方法
action.override.method=重寫方法
action.override.methods=重寫方法
action.text.0.on.parameter.1=在形參 ''{1}'' 上{0}
action.text.choose.class.in.0=選擇 {0} 中的類…
action.text.copy.to.clipboard=複製到剪貼簿
action.text.edit.template=編輯模板
action.text.enter.class.name=輸入類名…
action.text.generated.root.0=生成的{0}
action.text.merge.identical.stacktraces=合併相同的堆棧跟踪
action.text.show.methods.to.implement=顯示要實現的方法
action.text.show.quick.list=顯示快速列表
action.text.unmark.generated.0=取消標記生成的{0}
action.GotoSuperClass.text=轉到超類 (_U)
action.GotoSuperClass.MainMenu.text=超類(_U)
action.GotoSuperClass.description=導航到當前類擴展或實現的類的聲明
add.to.permits.list=將 ''{0}'' 添加到密封類 ''{1}'' 的 permits 列表
annotate.intention.chooser.title=選擇要添加的註解
assignment.to.declared.variable.problem.descriptor=變量''{0}''是自我賦值初始化
assignment.to.itself.problem.descriptor=變量''{0}''是分配給自己
assignment.to.itself.quickfix.name=除去自身賦值
bean.property=Bean屬性
boolean.method.is.always.inverted.display.name=布爾方法總是反向的
boolean.method.is.always.inverted.problem.descriptor=布爾方法 '#ref' 總是反轉
button.add.blank=添加空白
button.add.class=添加類…
button.add=添加…
button.add.package=添加軟件包…
button.add.pattern=添加模式…
button.annotations=註解…
button.base.method=基方法(&B)
button.code.patterns=代碼模式…
button.current.method=當前方法(&C)
button.text.settings=設定…
cast.expression=插入轉換表達式
cast.to.0=轉換為''{0}''
change.color.command.text=更改顏色
change.uid.action.name=隨機更改 'serialVersionUID' 初始值設定項
checkbox.after.description=在描述後
checkbox.after.parameter.descriptions=在形參描述後
checkbox.after.return.tag=在return後
checkbox.align.parameter.descriptions=對齊形參說明
checkbox.align.thrown.exception.descriptions=對齊拋出異常說明
checkbox.annotate.local.variables=註解局部變量
checkbox.collapse.annotations=註解
checkbox.collapse.anonymous.classes=匿名類
checkbox.collapse.closures="閉包" (在 Java 8 前，實現一個方法的匿名類)
checkbox.collapse.end.of.line.comments=<html>行尾註釋序列</html>
checkbox.collapse.generic.function Object() { [native code] }.parameters=<html>通用構造函數和方法形參</html>
checkbox.collapse.i18n.messages=<html>I18n字符串</html>
checkbox.collapse.inferred.type=使用推斷類型替換 'var'
checkbox.collapse.inner.classes=內部類
checkbox.collapse.multiline.comments=多行註釋
checkbox.collapse.one.line.methods=<html>一行方法<html>
checkbox.collapse.simple.property.accessors=<html>簡單屬性訪問器</html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.comments.and.javadoc.count.as.content=註釋和 javadoc 計為內容
checkbox.deprecated.members=棄用的成員
checkbox.do.not.indent.top.level.class.members=不縮進頂層類成員
checkbox.do.not.wrap.after.single.annotation=單個註解後不換行
checkbox.do.not.wrap.one.line.comments=一行註釋不分行
checkbox.enable.javadoc.formatting=啟用JavaDoc格式
checkbox.enable.leading.asterisks=啟用前導星號
checkbox.generate.p.on.empty.lines=在空行上生成 "<p>"
checkbox.html.report.inaccessible.symbols=<html>報告無法訪問的符號<br>(javadoc 工具可能無法創建超鏈接)
disable.report.inaccessible.symbols.fix=不報告無法訪問的符號
checkbox.ignore.fields.used.in.multiple.methods=忽略多個方法中使用的字段
checkbox.ignore.simple.setters=忽略簡單的 setter
checkbox.insert.imports.for.inner.classes=插入導入到內部類
checkbox.iterate.unknown.stream.sources.via.stream.iterator=通過 Stream.iterator() 迭代未知的流源
checkbox.keep.empty.lines=保留空行
checkbox.keep.empty.param.tags=保持空 @param 標籤
checkbox.keep.empty.return.tags=保持空 @return 標籤
checkbox.keep.empty.throws.tags=保持空 @throws 標籤
checkbox.keep.invalid.tags=保持無效標籤
checkbox.make.generated.local.variables.final=將生成的局部變量設為 final
checkbox.make.generated.parameters.final=將生成的形參設為 final
checkbox.param.description.on.new.line=形參描述在新行
checkbox.param.indent.on.continuation=縮進連續線
checkbox.prefer.longer.names=提升較長的名稱
checkbox.preserve.line.feeds=保留換行
checkbox.spaces.record.header=記錄標頭
checkbox.spaces.before.colon.in.foreach=在 foreach 中的冒號之前
checkbox.spaces.inside.one.line.enum=在一行枚舉大括號內
checkbox.suggest.conversion.to.map.computeifabsent=建議轉換為 Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=建議轉換為 Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=建議轉換為 Map.merge
checkbox.suggest.conversion.to.map.putifabsent=建議轉換為 Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=建議轉換為 Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=建議替換，即使 lambda 可能有副作用
checkbox.suppress.with.suppresswarnings=使用 @SuppressWarnings 禁止
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=將 'get(k) != null' 視為與 'containsKey(k)' 相同 (可能更改語義)
checkbox.use.fully.qualified.class.names=使用全修飾類名
checkbox.use.single.class.import=使用單個類導入
checkbox.use.throws.rather.than.exception=用 @throws 而不是 @exception
checkbox.warn.if.only.foreach.replacement.is.available=只要 'forEach' 替換可用，就發出警告
checkbox.warn.if.the.loop.is.trivial=循環不重要時發出警告
checkbox.wrap.at.right.margin=在右頁邊距處換行
choose.class=選擇類
chooser.text.choose.where.to.save.0=選擇要保存 ''{0}'' 的位置
chooser.title.select.path.to.save.jar=選擇要保存 Jar 的路徑
class.decorator.or.has.default.function Object() { [native code] }=''{0}'' 應具有預設構造函數或者實現 ''Decorator'' 模式
class.filter.editor.add.dialog.title=新的過濾器
class.filter.editor.choose.class.title=選擇類
class.has.no.default.function Object() { [native code] }=''{0}'' 沒有預設的構造函數
class.is.not.a.subclass=''{0}'' 未分配到 ''{1}''
class.is.not.concrete=''{0}'' 不是一個具體類
class.is.not.public=''{0}'' 不為 public
class.not.found.error.message=未找到類 ''{0}''
code.style.generation.override.method.signature=重寫方法簽名
code.style.generation.repeat.synchronized.modifier=重複 synchronized 修飾符(&S)
code.style.generation.replace.null.check=將 null 檢查替換為 Objects::nonNull 或 Objects::isNull
code.style.generation.use.class.isInstance=如果可能，請使用 Class::isInstance 和 Class::cast
code.style.generation.use.integer.sum=如果可能，請使用 Integer::sum 等
combobox.paste.insert.imports=貼上時插入導入(&I):
command.create.class.from.template=從模板創建類
command.create.new.subdirectory=創建新子目錄
command.name.insert.block.statement=插入塊語句
command.name.updating.package.statement=更新 package 語句
comment.the.class.will.be.created.in.the.package.0=類將在軟件包 ''{0}'' 中創建
completion.class.name.hint.2=再次按{0}可以在搜尋時忽略模塊依賴關係
completion.no.suggestions.of.type=沒有類型為{0}的建議
completion.smart.aslist.hint=再次按{0}尋找{1}的集合(Array)
completion.smart.chain.hint=再次按{0}搜尋方法的調用鏈
completion.smart.hint=按{0}僅顯示適合類型的變量
completion.smart.toar.hint=再次按{0}尋找{1}的集合
completion.smart.type.generate.anonymous.body=生成匿名體
completion.unknown.type=未知類型{0}
configurable.EqualsHashCodeTemplatesPanel.display.name=模板
configurable.GenerateToStringConfigurable.display.name=設定
configurable.TemplatesPanel.display.name=模板
label.new.template.name=新模板名稱:
dialog.title.create.new.template=創建新模板
dialog.title.copy.template=複製模板
configure.annotations.option=配置註解…
convert.compareto.expression.to.equals.call=將 'compareTo()' 表達式轉換為 'equals()' 調用
convert.compareto.expression.to.equals.call.may.change.semantics=將 'compareTo()' 表達式轉換為 'equals()' 調用 (可能更改語義)
copy.abstract.method.intention.name=使用現有實現''{0}''
copy.abstract.method.no.existing.implementations.found=沒有找到現有的實現
copy.abstract.method.popup.title=選擇要複製的實現
copy.abstract.method.title=使用 abstract 方法實現
copy.paste.reference.notification=<html>已添加 {0} 個{0, choice, 1#導入|2#導入}<p><span><a href=''show''>檢查添加的導入…</a></span></html>
cyclic.dependencies.progress.text=正在構建依賴關係圖
cyclic.dependencies.scope.dialog.module.button={0}模塊''{1}'' (&M)
cyclic.dependencies.scope.dialog.project.button={0}整個項目 (&P)
cyclic.dependencies.scope.dialog.title=指定{0}範圍
cyclic.dependencies.scope.include.test.sources.option=包含測試代碼(&T)
cyclic.dependencies.tree.cycle.node.text=循環
cyclic.dependencies.usage.view.initial.text=從左邊樹選擇分析的軟件包
cyclic.dependencies.usage.view.root.node.text=在軟件包 ''{1}'' 中使用軟件包 ''{0}''
dataflow.from.here=流出此處的數據流
dataflow.to.here=流入此處的數據流
deannotate.intention.action.text=取消註解 {0}
deannotate.intention.action.several.text=取消註解…
deannotate.intention.action.family.name=取消註釋
deannotate.intention.chooser.title=選擇要刪除的註解
default.file.template.description=預設檔案模板
default.file.template.display.name=預設檔案模板的使用
default.file.template.edit.template=編輯模板…
default.file.template.replace.with.actual.file.template=替換為實際檔案模板
default.package.presentable.name=<預設>
dependencies.libraries.node.text=庫
dependencies.tree.node.default.package.abbreviation=<預設軟件包>
dialog.create.class.destination.package.label=目標軟件包:
dialog.create.class.label=創建 {0}:
dialog.create.class.name=創建{0}{1}
dialog.create.class.package.chooser.title=選擇目標軟件包
dialog.create.field.from.parameter.already.exists.text=使用現有字段''{0}''？
dialog.create.field.from.parameter.already.exists.use.existing.button=使用現有字段
dialog.create.field.from.parameter.already.exists.title=字段已經存在
dialog.create.field.from.parameter.declare.final.checkbox=聲明 final(&F)
dialog.create.field.from.parameter.field.name.label=名稱:
dialog.create.field.from.parameter.field.type.label=字段的類型:
dialog.create.field.from.parameter.title=創建字段
dialog.edit.template.checkbox.smart.type.completion=類型匹配補全(&O)
dialog.edit.template.checkbox.use.static.import=盡可能使用靜態導入(&I)
dialog.import.on.paste.title=選擇要導入的類
dialog.import.on.paste.title2=選擇要導入的元素
dialog.import.on.paste.title3=選擇要移除的導入
dialog.message.0.update.existing.class={0}。更新現有的類?
dialog.message.create.test.in.the.same.source.root=在相同的源根中創建測試?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=推斷可空性註解需要將項目語言級別設定為 1.5 或更高。
dialog.message.jetbrains.annotations.library.is.missing=缺少 JetBrains 註解庫。\n沒有庫，IntelliJ IDEA 將無法運行分析。要添加嗎?
dialog.message.no.places.found.to.infer.nullable.notnull=未找到要推斷 @Nullable/@NotNull 的位置
dialog.paste.on.import.text=<html>您所貼上的代碼段使用的是不是在新的形勢下,可以通過導入類。<br/>選擇類,您要導入到新檔案。</html>
dialog.paste.on.import.text2=<html>您所貼上的代碼段使用,是不是在新的上下文訪問的導入元件。<br/>選擇元素,您想導入到新檔案。</html>
dialog.paste.on.import.text3=<html>您貼上的代碼段在當前上下文中引入了新的導入。<br/>選擇您想要消除的導入。</html>
dialog.title.choose.0.parameters=選擇 {0} 形參
dialog.title.choose.class=選擇類
dialog.title.configure.annotations=配置註解
dialog.title.configure.code.patterns=配置代碼模式
dialog.title.create.class.in.package=在軟件包中創建類
dialog.title.create.missed.tests=創建缺少的測試
dialog.title.edit.method.contract=編輯方法約定
dialog.title.edit.range=編輯範圍
dialog.title.infer.nullity=推斷可空性
action.description.infer.nullity.annotations=推斷可空性註解
dialog.title.infer.nullity.results=推斷可空性結果
dialog.title.no.test.roots.found=未找到測試根
dialog.title.process.duplicates=處理重複項
dialog.title.super.method.found=發現 super 方法
do.not.import.inner.classes.for=按短名稱排除內部類:
do.not.import.inner.classes.no.classes=未定義內部類
editbox.blanklines.around.initializer=初始值設定項周圍:
editbox.class.count.to.use.import.with.star=將 import 與 '*' 搭配使用的類計數:
editbox.names.count.to.use.static.import.with.star=將靜態 import 與 '*' 搭配使用的名稱計數:
enum.not.allowed=枚舉不被允許
error.attempt.to.generate.function Object() { [native code] }.for.anonymous.class=不能添加構造函數到匿名類
error.hint.no.expression.found=找不到表達式
error.package.already.contains.package-info=''package-info.java'' 的軟件包已經存在“{0}”
error.package.already.contains.package.html=軟件包 ''{0}'' 已經有一個 ''package.html'' 檔案。仍要創建 ''package-info.java''?
error.package.html.found.title=發現“package.html”
error.text.this.is.not.a.valid.java.class.name=這不是有效的 Java 類名
exclude.0.from.completion=從補全中排除 ''{0}''
exclude.accessors=排除訪問器(&E)
exclude.from.completion.group=從自動導入和補全中排除:
exclude.from.imports.no.exclusions=添加類、軟件包或成員
exclude.from.imports.no.exclusions.2=以從自動導入和補全中排除
exclude.table.mask=類、軟件包或成員
exclude.table.scope.column=範圍
export.to.html.generate.hyperlinks.checkbox=生成超鏈接指向類 (&H)
external.annotation.prompt=外部註解提示
external.annotations.external.option=從外部添加 (&E)
external.annotations.in.code.option=添加代碼 (&C)
external.annotations.root.chooser.description=外部註解將被保存在相應的資料夾
external.annotations.root.chooser.title=選擇{0}的外部註解根
external.annotations.suggestion.message=<html><body>如果您的代碼中不需要註解，可以使用外部存儲。<br>要配置外部註解，請指定放置包含註解的檔案的根目錄</body></html>
find.field.accessors.prompt=搜尋字段 ''{0}'' 的訪問器?
find.field.accessors.title=已找到字段訪問器
find.options.include.overloaded.methods.checkbox=重載方法(&V)
find.what.derived.classes.checkbox=派生類 (&D)
find.what.derived.interfaces.checkbox=派生接口 (&D)
find.what.fields.usages.checkbox=字段的用法 (&F)
find.what.implementing.classes.checkbox=實現類 (&I)
find.what.implementing.methods.checkbox=實現方法 (&I)
find.what.implicit.to.string.checkbox=隱式調用(&M)
find.what.methods.usages.checkbox=方法的用法 (&M)
find.what.overriding.methods.checkbox=重寫方法 (&R)
find.what.usages.checkbox=用法 (&U)
find.what.usages.of.classes.and.interfaces=類和接口的用法 (&C)
generate.button.title=生成
generate.function Object() { [native code] }.fields.chooser.title=選擇要通過構造函數初始化的字段
generate.function Object() { [native code] }.super.function Object() { [native code] }.chooser.title=選擇超類構造函數
generate.delegate.target.chooser.title=選擇目標生成的代表
generate.equals.and.hashcode.already.defined.title=生成 'equals()' 和 'hashCode()'
generate.equals.and.hashcode.already.defined.warning=對於類{0},方法''boolean equals(Object)'' 和 ''int hashCode()''已經定義,要繼續刪除它們嗎?
generate.equals.and.hashcode.already.defined.warning.anonymous=對於這個匿名類,方法'boolean equals(Object)' 和 'int hashCode()'已經定義,要繼續刪除它們嗎?
generate.equals.hashcode.accept.sublcasses=接受子類作為 equals() 方法的形參(&S)
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>Object.equals() 不符合接受範圍內<br>子類可能需要生成方法的正確工作<br>在框架中, 它生成的代理子類如Hibernate。</body></html>
generate.equals.hashcode.equals.fields.chooser.title=選擇要包含在 equals() 中的字段(&F)
generate.equals.hashcode.hashcode.fields.chooser.title=選擇要包含在 hashCode() 中的字段(&F)
generate.equals.hashcode.internal.error=內部錯誤
generate.equals.hashcode.non.null.fields.chooser.title=選擇所有非空字段 (&F)
generate.equals.hashcode.template=模板(&T):
generate.equals.hashcode.use.getters=在代碼生成過程中使用 &getters
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode()不支持數組
generate.equals.hashcode.wizard.title=生成 equals() 和 hashCode()
generate.equals.template.title=Equals 模板:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals()不支持嵌套的數組
generate.equals.warning.generated.equals.could.be.incorrect=生成的Object[]的equals()可能不正確
generate.getter.fields.chooser.title=選擇字段生成Getter
generate.getter.setter.title=選擇字段生成Getter和Setter
generate.getter.template=Getter 模板(&G):
generate.hashcode.template.title=HashCode 模板:
generate.record.function Object() { [native code] }.title=生成記錄構造函數
generate.setter.fields.chooser.title=選擇字段生成Setter
generate.setter.template=Setter 模板(&S):
generate.tostring.already.exist.border=當方法已存在時
generate.tostring.available.implicit.variables.label=可用的隱式變量:<br/>{0}
generate.tostring.exclude..transient=排除 transient 字段
generate.tostring.exclude.by.field.name=按名稱排除字段 (reg exp)
generate.tostring.exclude.by.field.type=按類型名稱排除字段 (reg exp)
generate.tostring.exclude.by.name=按名稱排除方法 (reg exp)
generate.tostring.exclude.by.return.type=按返回類型名稱排除方法 (reg exp)
generate.tostring.exclude.constant.fields=排除常量字段
generate.tostring.exclude.enum.fields=排除枚舉字段
generate.tostring.exclude.logger=排除記錄器字段 (Log4j、JDK 日誌記錄、Jakarta Commons 日誌記錄)
generate.tostring.exclude.static.fields=排除 static 字段
generate.tostring.fully.qualified.class.name=在代碼生成中使用完全限定類名 ($classname)
generate.tostring.getters.in.generated.code=在代碼生成中啟用 getter ($methods)
generate.tostring.handle.exception.error.message=執行操作時引發不可恢復的異常 - 請參閱 IDEA 日誌以獲取詳細信息 (堆棧跟踪應位於 idea.log 中):\n{0}
generate.tostring.handle.exception.plugin.warning.message=執行操作時引發 PluginException - 請參閱 IDEA 日誌以獲取詳細信息 (堆棧跟踪應位於 idea.log 中):\n{0}
generate.tostring.handle.exception.velocity.error.message=生成代碼時出現 Velocity 錯誤 - 請參閱 IDEA 日誌以獲取更多詳細信息 (堆棧跟踪應位於 idea.log 中):\n{0}
generate.tostring.insert.border=在哪裡插入?
generate.tostring.method.already.exists.dialog.me=ssage=替換現有的 {0} 方法
generate.tostring.method.already.exists.dialog.title=方法已存在
generate.tostring.move.to.generated.checkbox=將文本光標移動到生成的方法
generate.tostring.settings=設定
generate.tostring.sort.ascending=升序
generate.tostring.sort.checkbox=對元素進行排序
generate.tostring.sort.descending=降序
generate.tostring.sort.super=超類成員優先
generate.tostring.tab.title=function toString() { [native code] }() 生成設定
generate.tostring.template.label=模板:
generate.tostring.title=生成 function toString() { [native code] }()
goto.super.class.chooser.title=選擇超類或接口
group.javadoc.alignment=對齊
group.javadoc.blank.lines=空行
group.javadoc.invalid.tags=無效標籤
group.javadoc.other=其他
gutter.implemented.method=已實現方法
gutter.implementing.method=實現方法
gutter.overridden.method=重寫的方法
gutter.overriding.method=重寫方法
gutter.service=服務
gutter.sibling.inherited.method=同級繼承的方法
highlight.exceptions.thrown.chooser.title=選擇異常類以高亮顯示
highlight.imported.classes.chooser.title=選擇導入高亮的類
highlight.imported.members.chooser.title=選擇導入高亮的成員
highlight.overridden.classes.chooser.title=從...選擇高亮重寫方法的類
icon.preview=圖標預覽
ignore.imports.and.formatting=忽略導入和格式化
illegal.name.validation.info=非法名稱: {0}
import.layout.static.imports.separately=單獨布局靜態導入
import.statically=靜態導入
include.accessors=包含訪問器(&I)
infer.nullity.progress=正在對結果進行後期處理…
insert.override.annotation=插入 @Override 註解(&O)
inspection.1.5.display.name=在配置的語言級別下不可用的 API 用法
inspection.1.5.problem.descriptor=使用API文檔作為 @since {0}
inspection.1.7.problem.descriptor=泛型的使用後,會造成1.6 API編譯問題與JDK{0}
inspection.1.8.problem.descriptor=預設方法不重寫.它會導致JDK編譯問題 {1}
inspection.1.8.problem.single.descriptor=預設的方法 ''{0}'' 不重寫。它會導致JDK編譯問題 {1}
inspection.assert.quickfix=斷言''{0}''
inspection.capturing.cleaner=已傳遞到 Cleaner.register() 的可運行對象捕獲 ''{0}'' 引用
inspection.capturing.cleaner.description=清洗器捕獲對象引用
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=更改變量類型並移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=將 ''{0}'' 的類型更改為 ''{1}'' 並移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.message=可以通過將 ''{0}'' 的類型更改為 ''{1}'' 來移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.name=太弱的變量類型導致不必要的轉換
inspection.charset.object.can.be.used.display.name=可以使用標準 'Charset' 對象
inspection.charset.object.can.be.used.fix.family.name=使用字符集常量
inspection.charset.object.can.be.used.message=可以改用{0}
inspection.collection.factories.fix.family.name=替換集合工廠回調
inspection.collection.factories.fix.name=替換為 ''{0}.{1}()'' 調用
inspection.collection.factories.message=可以替換為 ''{0}.{1}()'' 調用
inspection.collection.factories.option.ignore.non.constant=僅在內容為常量時報告
inspection.collection.factories.option.suggest.ofentries=建議 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=可迭代對象用作 vararg
inspection.collection.used.as.vararg.message=可迭代對象作為 vararg 傳遞: 很可能應為數組
inspection.comparator.result.comparison.display.name=compare 方法的可疑用法
inspection.comparator.result.comparison.fix.family.name=修正比較結果
inspection.comparator.result.comparison.problem.display.name=比較方法的結果與特定常數對比
inspection.conditional.break.in.infinite.loop=將條件移動到循環中
inspection.conditional.break.in.infinite.loop.description=無限循環中存在條件中斷
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=不建議替換為 'do while'
inspection.convert.to.local.quickfix=轉換為當地
inspection.data.flow.display.name=恒定條件和例外
inspection.data.flow.filter.notnull.quickfix=插入'filter(Objects::nonNull)'步驟
inspection.data.flow.nullable.quickfix.option=對可 null 值的方法/字段/形參建議使用 @Nullable 註解
inspection.data.flow.true.asserts.option=不報告條件靜態證明始終為 <code>true</code> 的斷言
inspection.data.flow.ignore.assert.statements=忽略 assert 語句
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=讀取保證為常量的值時發出警告
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=將未註解的成員和形參視為 @Nullable
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=報告使用 null 文字實參用法的非 null 必需形參
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=報告始終返回非 null 值的可 null 方法
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=報告僅在某些代碼路徑上發生的問題
inspection.data.flow.use.computeifpresent.quickfix=將 'compute' 替換為 'computeIfPresent'
inspection.dead.code.option.applet=小程序
inspection.dead.code.option.external=非 Java 檔案中使用的類
inspection.dead.code.option.main=<html><code>void main(String args[])</code> 方法</html>
inspection.dead.code.option.servlet=Servlet
inspection.default.annotation.param=預設註解形參值
inspection.duplicate.branches.in.switch.default.message='switch' 中的分支是預設分支的重複項
inspection.duplicate.branches.in.switch.delete.fix.family.name=刪除冗餘 'switch' 分支
inspection.duplicate.branches.in.switch.delete.fix.name=刪除冗餘 'switch' 分支
inspection.duplicate.branches.in.switch.display.name='switch' 中存在重複分支
inspection.duplicate.branches.in.switch.merge.fix.family.name=合併 'switch' 中的重複分支
inspection.duplicate.branches.in.switch.merge.fix.name=與 ''{0}'' 合併
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=與預設的 'switch' 分支合併
inspection.duplicate.branches.in.switch.message='switch' 中存在重複分支
inspection.duplicate.expressions.complexity.threshold=表達式複雜性閾值
inspection.duplicate.expressions.display.name=同一表達式存在多個匹配項
inspection.duplicate.expressions.introduce.variable.fix.family.name=引入變量
inspection.duplicate.expressions.introduce.variable.fix.name=為 ''{0}'' 引入變量
inspection.duplicate.expressions.message=<code>#ref</code> 的多個匹配項 #loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=替換為表達式的其他可變匹配項
inspection.duplicate.expressions.replace.other.occurrences.fix.name=將 ''{0}'' 替換為 ''{1}'' 的其他匹配項
inspection.duplicate.expressions.reuse.variable.fix.family.name=重用變量
inspection.duplicate.expressions.reuse.variable.fix.name=為 ''{1}'' 重用變量 ''{0}''
inspection.empty.method.delete.quickfix=刪除不必要的方法
inspection.empty.method.problem.descriptor=方法只調用它的 super
inspection.empty.method.problem.descriptor1=空方法重寫空方法
inspection.empty.method.problem.descriptor2=該方法為空
inspection.empty.method.problem.descriptor3=該方法和所有它的derivables是空的
inspection.empty.method.problem.descriptor4=此方法的所有實現都為空
inspection.endless.stream.description=非短路操作消耗無限流
inspection.equals.hashcode.display.name='equals()' 和 'hashCode()' 未配對
inspection.equals.hashcode.generate.equals.quickfix=生成 'equals()'
inspection.equals.hashcode.generate.hashcode.quickfix=生成 'hashCode()'
inspection.excessive.lambda.fix.family.name=常數替換lambda
inspection.excessive.lambda.fix.name=使用沒有lambda的''{0}''方法
inspection.excessive.lambda.message=過度使用 lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=將顯式實參替換為函數
inspection.explicit.argument.can.be.lambda.fix.name=使用包含函數實參的 ''{0}'' 方法
inspection.explicit.argument.can.be.lambda.message=顯式實參可以轉換為 lambda
inspection.explicit.array.filling.description=可以替換為單個 ''Arrays.{0}()'' 方法調用
inspection.explicit.array.filling.fix.family.name=將循環替換為 ''Arrays.{0}()'' 方法調用
inspection.explicit.array.filling.no.suggestion.for.set.all=不建議使用 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=新建數組的冗餘初始化
inspection.explicit.array.filling.suggest.set.all=建議 'Arrays.setAll()'
inspection.export.results.callees=調用鏈
inspection.export.results.implicit.function Object() { [native code] }=隱式構造函數 -
inspection.export.results.overrides.library.methods=重寫庫方法
inspection.export.results.package=軟件包
inspection.export.results.type.references=以下使用這種類型
inspection.field.can.be.local.display.name=可以為本地字段
inspection.field.can.be.local.problem.descriptor=字段可以被轉換為一個局部變量
inspection.field.can.be.local.quickfix.function Object() { [native code] }=將字段轉換為構造函數中的局部變量
inspection.field.can.be.local.quickfix.initializer=將字段轉換為初始值設定項部分中的局部變量
inspection.field.can.be.local.quickfix.one.method=將字段轉換為方法 ''{0}'' 中的局部變量
inspection.fold.expression.fix.family.name=折疊表達式
inspection.fold.expression.into.stream.display.name=表達式可以折疊到流鏈中
inspection.fold.expression.into.stream.fix.name=將表達式折疊到流鏈中
inspection.fold.expression.into.string.display.name=表達式可以折疊到 'String.join' 中
inspection.fold.expression.into.string.fix.name=將表達式折疊到 'String.join' 中
inspection.forward.compatibility.name=前向兼容性
inspection.fuse.stream.operations.display.name=後續步驟可以融合到Stream API鏈中
inspection.fuse.stream.operations.fix.family.name=將更多語句融入 Stream API 鏈
inspection.fuse.stream.operations.fix.name=將 {0} 融合到Stream API 鏈中
inspection.fuse.stream.operations.message=流可能被拓展替換 {0}
inspection.fuse.stream.operations.option.strict.mode=不建議使用 'toList()' 或 'toSet()' 收集器
inspection.handle.signature.change.type.fix.name=將類型更改為 ''{0}''
inspection.handle.signature.field.cannot.resolve=無法解析字段''{0}''
inspection.handle.signature.field.not.static=字段 ''{0}'' 不為 static
inspection.handle.signature.field.static=字段 ''{0}'' 為 static
inspection.handle.signature.field.type=字段''{0}''的類型是''{1}''
inspection.handle.signature.method.abstract=方法 ''{0}'' 在 ''{1}'' 中是 abstract 方法
inspection.handle.signature.method.not.static=方法 ''{0}'' 不為 static
inspection.handle.signature.method.static=方法 ''{0}'' 為 static
inspection.handle.signature.name=MethodHandle/VarHandle 類型不匹配
inspection.handle.signature.not.subclass=調用者類 ''{0}'' 必須是 ''{1}'' 的子類
inspection.handle.signature.use.function Object() { [native code] }.fix.family.name=使用構造函數重載之一
inspection.handle.signature.use.function Object() { [native code] }.fix.name=使用構造函數''{0}''
inspection.handle.signature.use.method.fix.family.name=使用方法重載之一
inspection.handle.signature.use.method.fix.name=使用方法''{0}''
inspection.idempotent.loop.body=冪等循環體
inspection.illegal.character=非法字符
inspection.suspicious.ternary.in.varargs.display.name=vararg 方法調用中的可疑三元運算符
inspection.suspicious.ternary.in.varargs.description=vararg 調用中的三元運算符包含數組和非數組分支
inspection.suspicious.ternary.in.varargs.quickfix=包裝在數組初始值設定項中
inspection.insert.literal.underscores.display.name=不可讀的數字文字
inspection.insert.literal.underscores.family.name=將下划線插入數字文字
inspection.javadoc.dialog.title=編輯附加的JavaDoc標籤
inspection.javadoc.display.name=聲明具有 Javadoc 問題
inspection.javadoc.label.text=附加的 Javadoc 標記:
inspection.javadoc.lint.display.name=Javadoc中的HTML問題(DocLint)
inspection.javadoc.method.problem.missing.param.tag=形參{0}缺少必需的標籤 <code>@param</code>
inspection.javadoc.method.problem.missing.tag.description={0}標籤說明已丟失
inspection.javadoc.option.ignore.deprecated=忽略標記為 @deprecated 的元素
inspection.javadoc.option.ignore.period=忽略期問題
inspection.javadoc.option.ignore.self.ref=忽略指向自己的Javadoc
inspection.javadoc.option.ignore.simple=忽略簡單的屬性訪問器
inspection.javadoc.option.ignore.throws=忽略重複的'throws'標籤
inspection.javadoc.option.tab.title=類
inspection.javadoc.option.tab.title.field=字段
inspection.javadoc.option.tab.title.inner.class=內部類
inspection.javadoc.option.tab.title.method=方法
inspection.javadoc.option.tab.title.module=模塊
inspection.javadoc.option.tab.title.package=軟件包
inspection.javadoc.problem.add.param.tag=為形參''{0}''添加標籤 @param
inspection.javadoc.problem.add.param.tag.family=添加缺少的Javadoc形參標籤
inspection.javadoc.problem.add.tag=添加標籤 @{0}{1}
inspection.javadoc.problem.add.tag.family=添加缺少的 Javadoc 標籤
inspection.javadoc.problem.cannot.resolve=無法解析符號{0}
inspection.javadoc.problem.descriptor=要求Javadoc不在
inspection.javadoc.problem.descriptor1=期在文檔缺失.使用期間由工具生成的Javadoc註釋的概述頁面
inspection.javadoc.problem.disallowed.tag=此處不允許使用標籤{0}
inspection.javadoc.problem.duplicate.param=重複的形參''{0}'' @param 標記
inspection.javadoc.problem.duplicate.tag=重複的 @{0} 標記
inspection.javadoc.problem.duplicate.throws=重複 @throws 或 @exception 標記為異常''{0}''
inspection.javadoc.problem.inaccessible=無法從此處訪問符號 {0}
inspection.javadoc.problem.missing.tag=需要標記{0}是缺失的
inspection.javadoc.problem.missing.tag.description={0}在 @{1} 標記之後丟失
inspection.javadoc.problem.name.expected=應為名稱
inspection.javadoc.problem.pointing.to.itself=Javadoc指向本身
inspection.javadoc.problem.see.tag.expecting.ref=類/方法引用，引用文本或HTML鏈接，預計後 @see tag
inspection.javadoc.problem.wrong.tag=錯誤標籤{0}
inspection.javadoc.ref.display.name=聲明在Javadoc引用中有問題
inspection.javadoc.required.tags.option.title=必需標記
inspection.javadoc.throws.or.exception.option=@throws 或 @exception
inspection.join.declaration.and.assignment.display.name=賦值可與聲明聯接
inspection.join.declaration.and.assignment.fix.family.name=聯接聲明和賦值
inspection.join.declaration.and.assignment.message=賦值可與 ''{0}'' 的聲明聯接
inspection.labeled.switch.rule.redundant.code.block.display.name=標記的 switch 規則具有冗餘代碼塊
inspection.labeled.switch.rule.redundant.code.block.message=標記規則的代碼塊冗餘
inspection.labeled.switch.rule.redundant.code.fix.name=取消標記規則的代碼塊換行
inspection.lambda.to.method.call.fix.family.name=用方法調用替換lambda表達式
inspection.lambda.to.method.call.fix.name=用''{0}''替換lambda表達式
inspection.manual.min.max.calculation.description=可以替換為 ''Math.{0}'' 調用
inspection.manual.min.max.calculation.disable.for.non.integral=禁用 float 和 double
inspection.map.foreach.display.name=可以使用 Map.forEach()
inspection.map.foreach.option.no.loops=不要報告循環
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=匿名s #ref #loc 可以替換為方法引用
inspection.message.can.be.replaced.with.0.function Object() { [native code] }=可以替換為 ''{0}'' 構造函數
inspection.message.can.be.replaced.with.files.readstring=可以替換為 'Files.readString()'
inspection.message.can.be.replaced.with.optional.of.nullable=可以替換為 Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=可以替換為函數樣式的單個表達式
inspection.message.can.be.replaced.with.string.repeat=可以替換為 'String.repeat()'
inspection.message.lambda.parameter.type.is.redundant=Lambda 形參類型冗餘
inspection.message.pseudo.functional.style.code=偽函數樣式代碼
inspection.message.redundant.default.parameter.value.assignment=冗餘的預設形參值賦值
inspection.message.replace.optional.with.if.statements=將 Optional 替換為 if 語句
inspection.no.jdk.error.message=沒有為此項目正確配置 JDK。無法進行檢查。
inspection.no.modules.error.message=此項目不包含模塊。無法進行檢查。
inspection.notnull.field.not.initialized.display.name=@NotNull 字段未初始化
inspection.notnull.field.not.initialized.option.implicit=忽略可以隱式初始化的字段
inspection.notnull.field.not.initialized.option.setup=忽略在 setUp() 方法中初始化的字段
inspection.null.value.for.optional.assigned.ignore.fix.name=將 Optional 與 null 比較時不發出警告
inspection.null.value.for.optional.assigned.message=Optional 值與 null 比較
inspection.null.value.for.optional.context.assignment=分配
inspection.null.value.for.optional.context.declaration=聲明
inspection.null.value.for.optional.context.lambda=lambda表達式
inspection.null.value.for.optional.context.parameter=形參
inspection.null.value.for.optional.context.return=return 語句
inspection.null.value.for.optional.fix.family.name=替換空的可選方法
inspection.null.value.for.optional.message=Null 用於 {0} 中的 ''Optional'' 類型
inspection.null.value.for.optional.option.comparisons=報告 Optional 與 null 的比較
inspection.nullable.problems.display.name=@NotNull/@Nullable 問題
inspection.nullable.problems.ignore.external.notnull=忽略外部 @NotNull(&I)
inspection.nullable.problems.method.overrides.notnull.option=<html>報告重寫 @Nullable 的 @NotNull 形參和<br>重寫 @NotNull 的 @Nullable 方法</html>(&P)
inspection.nullable.problems.method.overrides.option=報告未註解的形參或方法重寫 @NotNull (&A)
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=報告註解字段的非註解 setter 形參或 getter(&S)
inspection.nullable.problems.notnull.overrides.option=報告重寫非註解對象的 @NotNull 形參(&P)
inspection.nullable.problems.notnull.parameters.with.null.literal.option=報告使用 null 文字實參的 @NotNull 形參
inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> 未進行 ''isPresent()'' 檢查
inspection.overflowing.loop.index.inspection.description=循環執行零次或數十億次
inspection.overflowing.loop.index.inspection.name=循環執行零次或數十億次
inspection.overwritten.key.map.message=重複的Map key
inspection.overwritten.key.set.message=重複的 Set 元素
inspection.overwritten.key.array.message=被覆蓋的數組元素
inspection.parameter.can.be.local.display.name=從不讀取作為形參傳遞的值
inspection.parameter.can.be.local.problem.descriptor=形參可以被轉化為一個局部變量
inspection.pseudo.functional.style.add.methods.after.quick.fix=快速修復後:
inspection.pseudo.functional.style.add.methods.before.quick.fix=快速修復前:
inspection.pseudo.functional.style.add.methods.fully.qualified.class.name=完全限定類名:
inspection.pseudo.functional.style.add.methods.method.name=方法名稱:
inspection.pseudo.functional.style.add.methods.stream.api.replacement=Stream API 替換:
inspection.quickfix.assert.family=斷言
inspection.raw.use.of.parameterized.type.problem.descriptor=形參化類 <code>#ref</code> 的原始使用 #loc
raw.variable.type.can.be.generic.family.quickfix=向類型添加泛型形參
raw.variable.type.can.be.generic.quickfix=將 {0} 的類型更改為 {1}
raw.use.of.parameterized.type.ignore.new.objects.option=忽略新對象的構造
raw.use.of.parameterized.type.ignore.type.casts.option=忽略類型轉換
raw.use.of.parameterized.type.ignore.uncompilable.option=忽略類型形參無法編譯的位置
raw.use.of.parameterized.type.ignore.overridden.parameter.option=忽略重寫方法的形參類型
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=在自動快速修復不可用時忽略
inspection.redundant.array.creation.display.name=冗餘數組創建
inspection.redundant.array.creation.for.varargs.call.descriptor=調用 vararg 方法的冗餘數組創建
inspection.redundant.array.creation.quickfix=移除顯式數組創建
inspection.redundant.explicit.close=冗餘 'close()'
inspection.redundant.file.creation.display.name=創建冗餘 'File' 實例
inspection.redundant.file.creation.description=<code>#ref</code> 冗餘 #loc
inspection.redundant.file.creation.quickfix=替換為文件名
inspection.redundant.null.check.always.fail.message=Null 檢查始終失敗: {0} 永不為 null
inspection.redundant.null.check.fix.family.name=移除冗餘 null 檢查
inspection.redundant.null.check.fix.notnull.family.name=移除錯誤的 '!= null'
inspection.redundant.null.check.message=冗餘 null 檢查: {0} 永不為 null
inspection.redundant.operation.on.empty.array.message=數組 <code>#ref</code> 始終為空
inspection.redundant.operation.on.empty.collection.message=集合 <code>#ref</code> 始終為空
inspection.redundant.operation.on.empty.container.display.name=空容器上存在冗餘操作
inspection.redundant.operation.on.empty.map.message=映射 <code>#ref</code> 始終為空
inspection.redundant.record.function Object() { [native code] }.can.be.compact.message=規範構造函數可以轉換為壓縮形式
inspection.redundant.record.function Object() { [native code] }.canonical.message=冗餘規範構造函數
inspection.redundant.record.function Object() { [native code] }.compact.message=冗餘壓縮構造函數
inspection.redundant.record.function Object() { [native code] }.description=冗餘記錄構造函數
inspection.redundant.record.function Object() { [native code] }.fix.family.name=將規範構造函數轉換為壓縮形式
inspection.redundant.record.function Object() { [native code] }.statement.message=壓縮構造函數中存在冗餘字段賦值
inspection.redundant.stream.optional.call.explanation.at.most.one=流最多包含一個元素
inspection.redundant.stream.optional.call.explanation.distinct=鏈中已經存在一個'distinct'的調用
inspection.redundant.stream.optional.call.explanation.distinct.set=收集到集時，元素將保持不重複
inspection.redundant.stream.optional.call.explanation.filter=判定始終為 true
inspection.redundant.stream.optional.call.explanation.map.flatMap=上一個 'map' 調用可以替換 'flatMap' 步驟
inspection.redundant.stream.optional.call.explanation.parallel=後面的''{0}''調用覆蓋了這個調用
inspection.redundant.stream.optional.call.explanation.parallel.single=從單個元素創建的流不會並行化
inspection.redundant.stream.optional.call.explanation.sorted=後面的''{0}''調用使排序無效
inspection.redundant.stream.optional.call.explanation.sorted.twice=之後再對流內容排序
inspection.redundant.stream.optional.call.explanation.unordered=鏈中已經存在一個'unordered'的調用
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=收集到 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=移除冗餘的調用鏈
inspection.redundant.stream.optional.call.fix.name=移除''{0}''調用
inspection.redundant.stream.optional.call.message=冗餘的 ''{0}'' 調用
inspection.redundant.stream.optional.call.message.with.explanation=冗餘 ''{0}'' 調用: {1}
inspection.redundant.stream.optional.call.option.streamboxing=報告Stream.map中無用的裝箱
inspection.reflect.handle.invocation.argument.not.array=實參不是數組類型
inspection.reflect.handle.invocation.argument.not.exact=實參類型應該是 ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=類型 ''{0}'' 的實參不能為 ''null''
inspection.reflect.handle.invocation.receiver.incompatible=回調接收類型不兼容: ''{0}''
inspection.reflect.handle.invocation.receiver.null=調用接收器為 'null'
inspection.reflect.handle.invocation.result.not.assignable=應該被轉換為''{0}''或其超類
inspection.reflect.handle.invocation.result.not.exact=應該被轉換為''{0}''
inspection.reflect.handle.invocation.result.null=返回值總是'null'
inspection.reflect.handle.invocation.result.void=返回類型為'void'
inspection.reflection.invocation.argument.count=應為{0,choice,0#另個實參|1# 1 個實參|1<{0} 個實參}
inspection.reflection.invocation.argument.not.assignable=實參不能分配給 ''{0}''
inspection.reflection.invocation.array.not.assignable=數組項目具有不兼容的類型
inspection.reflection.invocation.item.count={0,choice,0#空數組|1#1個數組項|1<{0}個數組項}是預期的
inspection.reflection.invocation.item.not.assignable=數組項不能分配給''{0}''
inspection.reflection.invocation.name=反射調用實參不匹配
inspection.reflection.member.access.cannot.resolve.function Object() { [native code] }.arguments=無法使用指定的實參類型解析構造函數
inspection.reflection.member.access.cannot.resolve.field=無法解析字段 ''{0}''
inspection.reflection.member.access.cannot.resolve.method=無法解析方法''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=無法使用指定的實參類型解析方法''{0}''
inspection.reflection.member.access.check.exists=檢查該字段/方法是否存在於非 final 類中
inspection.reflection.member.access.check.exists.exclude.label=排除類:
inspection.reflection.member.access.check.exists.exclude.chooser=要排除的類
inspection.reflection.member.access.function Object() { [native code] }.not.public=構造函數不為 public
inspection.reflection.member.access.field.not.in.class=字段''{0}''未在類''{1}''中聲明
inspection.reflection.member.access.field.not.public=字段 ''{0}'' 不為 public
inspection.reflection.member.access.fix.family.name=使用適當的反射方法
inspection.reflection.member.access.method.not.in.class=方法''{0}''未在類''{1}''中聲明
inspection.reflection.member.access.method.not.public=方法 ''{0}'' 不為 public
inspection.reflection.member.access.name=反射訪問不存在/不可見的類成員
inspection.reflection.visibility.name=跨模塊問題的反射訪問
inspection.remove.literal.underscores.display.name=數字文字中的下划線
inspection.remove.literal.underscores.family.name=從數字文字中移除下划線
inspection.replace.methodref.ternary.quickfix=替換為空檢查的lambda
inspection.replace.ternary.quickfix=替換為''{0}!= null嗎?''
inspection.replace.with.bulk.fix.family.name=替換大量方法調用
inspection.replace.with.bulk.fix.name=用大量的''{0}''調用替換迭代
inspection.replace.with.bulk.message=迭代可以替換為大量的 ''{0}'' 調用
inspection.replace.with.bulk.wrap.arrays=使用 Arrays.asList() 包裝數組
inspection.replace.with.enhanced.switch.statement.fix.name=替換為增強的 'switch' 語句
inspection.replace.with.old.style.switch.statement.fix.name=替換為舊式 'switch' 語句
inspection.replace.with.regular.string.literal.fix=替換為正則字符串文字
inspection.replace.with.switch.expression.fix.name=替換為 'switch' 表達式
inspection.replace.with.text.block.fix=替換為文本塊
inspection.replace.with.trivial.lambda.fix.family.name=替換為普通 lambda
inspection.replace.with.trivial.lambda.fix.name=替換為返回 ''{0}'' 的 lambda
inspection.require.non.null=將 null 檢查替換為 Objects/Stream static 調用
inspection.require.non.null.description=Null 檢查可以替換為方法調用
inspection.require.non.null.message=用對象替換條件.{0}
inspection.require.non.null.no.warning.replacement.bigger=替換長度大於原始長度時不發出警告
inspection.return.separated.from.computation.descriptor=返回與 ''{0}'' 的值的計算分離
inspection.return.separated.from.computation.family.quickfix=將'返回'更接近結果的計算
inspection.return.separated.from.computation.name=與結果計算分離的 'return'
inspection.return.separated.from.computation.quickfix=將“return”更接近計算''{0}''的值
inspection.same.parameter.display.name=實際方法形參為相同的常量
inspection.same.parameter.fix.family.name=內聯形參為常量值
inspection.same.parameter.fix.name=內聯形參 ''{0}'' 的值 ''{1}''
inspection.same.parameter.problem.descriptor=實際的形參值 ''{0}'' 永遠是 ''{1}''
inspection.scope.for.title=範圍
inspection.simplifiable.comparator.comparing.message=不必要的 ''{0}()'' 調用
inspection.simplifiable.comparator.display.name=可以簡化 Comparator 方法
inspection.simplifiable.comparator.entry.comparator.message=可以改用 ''{0}''
inspection.simplifiable.comparator.fix.comparing.family.name=移除冗餘調用
inspection.simplifiable.comparator.fix.entry.comparator.family.name=使用預定義的 'Map.Entry' 比較運算符方法
inspection.simplifiable.comparator.fix.remove.name=移除 ''{0}()'' 調用
inspection.simplifiable.comparator.fix.replace.name=移除 ''{0}()'' 調用並使用 ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=簡化將 'max' 替換為 'min' 的比較運算符方法
inspection.simplifiable.comparator.fix.reversed.name=替換為簡化比較運算符的 ''{0}''
inspection.simplifiable.comparator.reversed.message=如果 ''{0}()'' 調用替換為 ''{1}()''，則可以簡化比較運算符方法
inspection.simplify.collector.fix.family.name=簡化級聯器
inspection.simplify.collector.fix.name=使用''Collectors.{0}''收集
inspection.simplify.collector.message=可以使用 ''{0}'' 收集器簡化
inspection.simplify.foreach.display.name=可簡化的 forEach() 調用
inspection.sorted.collection.with.non.comparable.keys.display.name=包含不可比較元素的排序集合
inspection.sorted.collection.with.non.comparable.keys.message=包含不可比較元素的排序集合的構造
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=不報告不可比較的類型形參
inspection.surround.if.family=環繞用if語句
inspection.surround.if.quickfix=環繞用''if({0}!= null)''
inspection.suspicious.list.remove.display.name=循環中的 'List.remove()' 可疑
inspection.switch.expression.backward.expression.migration.inspection.name='switch' 表達式可以替換為舊式 'switch' 語句
inspection.switch.expression.backward.migration.inspection.name=增強的 'switch'
inspection.switch.expression.backward.statement.migration.inspection.name='switch' 語句可以替換為舊式 'switch' 語句
inspection.switch.expression.migration.inspection.name=語句可以替換為增強的 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch 語句可以替換為增強的 'switch'
inspection.switch.expression.migration.warn.only.on.expression=僅在可以轉換為表達式時顯示警告
inspection.switch.labeled.rule.can.be.code.block.display.name=標記的 switch 規則可以具有代碼塊
inspection.switch.labeled.rule.can.be.code.block.expression.message=標記規則的結果表達式可以使用代碼塊包裝
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=使用代碼塊包裝標記規則的結果表達式
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=使用代碼塊包裝標記規則的語句
inspection.switch.labeled.rule.can.be.code.block.statement.message=標記規則的語句可以使用代碼塊包裝
inspection.text.block.backward.migration.message=文本塊可以轉換為正則字符串文字
inspection.text.block.backward.migration.name=文本塊可以替換為正則字符串文字
inspection.text.block.migration.string.message=字符串可以替換為文本塊
inspection.text.block.migration.concatenation.message=串聯可以替換為文本塊
inspection.text.block.migration.name=可以使用文本塊
inspection.text.block.migration.suggest.literal.replacement=應用於單字符串文字
inspection.inconsistent.text.block.indent.name=文本塊中的空格縮進不一致
inspection.inconsistent.text.block.indent.message=文本塊縮進由制表符和空格組成
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=將空格替換為制表符(1 個空格 = 1 個制表符)
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=將空格替換為制表符({0} 個空格 = 1 個制表符)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=將制表符替換為空格(1 個制表符 = 1 個空格)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=將制表符替換為空格(1 個制表符 = {0} 個空格)
inspection.trailing.whitespaces.in.text.block.name=文本塊中有尾隨空格
inspection.trailing.whitespaces.in.text.block.message=文本塊末尾有尾隨空格
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=移除尾隨空格
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=尾隨空格轉義
inspection.undeclared.service.usage.message=服務 ''{0}'' 的使用未在模塊信息中聲明
inspection.undeclared.service.usage.name=服務的使用未在 'module-info' 中聲明
inspection.unused.assignment.option=在可以替換為(i + 1)時報告 ++i
inspection.unused.assignment.option1=在變更後的值後續未使用時報告 i++
inspection.unused.assignment.option2=報告冗餘的初始值設定項
inspection.unused.assignment.problem.descriptor1=變量{0}從未使用
inspection.unused.assignment.problem.descriptor2=變量 {0} 初始值設定項 {1} 冗餘
inspection.unused.assignment.problem.descriptor3=分配給 {1} 的值 {0} 從未使用
inspection.unused.assignment.problem.descriptor4=在{0}更改的值是不會被使用的
inspection.unused.assignment.remove.assignment.quickfix=刪除冗餘分配
inspection.unused.assignment.remove.quickfix=移除冗餘的初始值設定項
inspection.unused.parameter.composer=形參 <code>#ref</code> 未用於任何實現
inspection.unused.parameter.composer1=形參 <code>#ref</code> 不用於此方法或其任何衍生方法
inspection.unused.parameter.delete.quickfix=刪除未使用的形參
inspection.unused.return.value.display.name=方法可以為 void
inspection.unused.return.value.make.void.quickfix=使方法無效
inspection.unused.return.value.problem.descriptor=方法的返回值是從未使用過
inspection.unused.symbol.check.accessors=Getter/Setter
inspection.unused.symbol.check.classes=類:
inspection.unused.symbol.check.fields=字段:
inspection.unused.symbol.check.inner.classes=內部類:
inspection.unused.symbol.check.localvars=局部變量
inspection.unused.symbol.check.methods=方法:
inspection.unused.symbol.check.parameters=形參位置:
inspection.value.based.warnings=基於值的警告
inspection.preview.feature=預覽功能警告
inspection.value.based.warnings.synchronization=嘗試對基於值的類的實例同步
inspection.variable.assigned.to.itself.display.name=變量被賦值給自己
inspection.wrapper.type.may.be.primitive.fix.name=將包裝器類型轉換為基元類型
inspection.wrapper.type.may.be.primitive.name=類型可能是基元
intention.add.explicit.type.arguments.family=添加顯式類型實參
intention.add.on.demand.static.import.family=添加按需靜態導入
intention.add.on.demand.static.import.text=為 ''{0}'' 添加按需靜態導入
intention.add.single.member.import.text=對''{0}''添加導入
intention.add.single.member.static.import.family=添加單成員靜態導入
intention.add.single.member.static.import.text=為 ''{0}'' 添加靜態導入
intention.assign.field.from.parameter.family=分配形參場
intention.assign.field.from.parameter.text=將形參分配給字段 ''{0}''
intention.bind.fields.from.parameters.family=將形參綁定到字段
intention.bind.fields.from.parameters.text=將 {0} 個形參綁定到字段
intention.break.string.on.line.breaks.text=在 '\\n' 上斷開字符串
intention.compose.function.family=將嵌套函數調用替換為組合
intention.compose.function.text=替換嵌套函數調用和替換後的調用
intention.convert.color.representation.family=轉換顏色表示
intention.convert.color.representation.text=轉換為''新顏色{0}''
intention.convert.compact.function Object() { [native code] }.to.canonical=將壓縮構造函數轉換為規範構造函數
intention.convert.to.single.return.name=將正文轉換成單個出口點形式
intention.convert.to.single.return.progress.title=將正文轉換成單個出口點形式
intention.convert.to.single.return.command.text=將主體轉換成單個出口點形式
intention.create.field.from.parameter.family=創建字段形參
intention.create.field.from.parameter.text=為形參 ''{0}'' 創建字段
intention.create.test.dialog.choose.super.class=選擇超類
intention.create.test.dialog.class.name=類名:
intention.create.test.dialog.fix.library=修正
intention.create.test.dialog.generate=生成:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found={0}庫在該模塊中未找到
intention.create.test.dialog.select.methods=為以下對象生成測試方法(&M):
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=顯示繼承的方法(&I)
intention.create.test.dialog.super.class=超類:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=測試庫(&L):
intention.encapsulate.field.text=封裝領域
intention.error.cannot.create.class.message=無法創建類''{0}''
intention.error.cannot.create.class.title=創建類失敗
intention.extract.if.condition.family=提取if條件
intention.extract.if.condition.text=提取if({0})
intention.extract.map.step.family=提取分離映射方法
intention.extract.map.step.text=提取變量''{0}''到''{1}''操作
intention.extract.method.text=提取方法
intention.extract.set.from.comparison.chain.duplicates={0} 在此類中檢測到 {1} 個可以使用新創建的集替換的代碼{1,choice,1#段|2#段}。要替換{1,choice,1#它|2#它們}嗎?
intention.extract.set.from.comparison.chain.family=從比較鏈提取 Set
intention.family.add.javadoc=添加 Javadoc
intention.family.copy.abstract.method.implementation=複製 abstract 方法實現
intention.family.create.a.class.in.package=在軟件包中創建類
intention.family.edit.method.contract=編輯方法約定
intention.family.edit.range=編輯範圍
intention.family.expand.static.import=展開靜態導入
intention.family.fix.bounded.wildcards=修復有界通配符
intention.family.make.external.annotations.explicit=使外部註解為顯式
intention.family.make.inferred.annotations.explicit=使推斷的註解為顯式
intention.family.move.it=移動它
intention.family.put.arguments.on.one.line=將實參放在同一行上
intention.family.put.arguments.on.separate.lines=將實參放在單獨的行上
intention.family.put.parameters.on.one.line=將形參放在同一行上
intention.family.put.parameters.on.separate.lines=將形參放在單獨的行上
intention.family.put.record.components.on.one.line=將記錄組件放在一行
intention.family.put.record.components.on.separate.lines=將記錄組件放在單獨的行中
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=將 Optional.isPresent() 條件替換為函數樣式表達式
intention.family.sort.content=對內容進行排序
intention.family.swap.if.statements=交換 'if' 語句
intention.family.unimplement.interface.class=取消實現接口/類
intention.family.variable.access.from.inner.class=可變的 accessFromInnerClass
intention.implement.abstract.class.default.text=實現 abstract 類
intention.implement.abstract.class.family=實現 abstract 類或接口
intention.implement.abstract.method.command.name=實現方法
intention.implement.abstract.method.error.no.classes.message=沒有發現這類方法可以實現
intention.implement.abstract.method.error.no.classes.title=沒有找到的類
intention.implement.abstract.method.family=實現 abstract 方法
intention.implement.abstract.method.searching.for.descendants.progress=尋找的後代…
intention.implement.abstract.method.text=實現方法 ''{0}''
intention.inline.map.family=內聯流映射方法
intention.inline.map.inline.text=內聯''{0}''的內容進入下一個''{1}''的調用
intention.inline.map.merge.text=合併''{0}''的調用與''{1}''的調用
intention.introduce.variable.text=引入局部變量
intention.invert.if.condition=反轉 'if' 條件
intention.merge.filter.family=合併過濾器
intention.merge.filter.text=合併過濾器鏈
intention.move.field.assignment.to.declaration=移動指派到字段聲明
intention.move.initializer.to.function Object() { [native code] }=將初始值設定項移動到構造函數
intention.move.initializer.to.set.up=將初始值設定項移動到 setUp 方法
intention.override.method.text=重寫方法 ''{0}''
intention.replace.cast.with.var.family=用變量替換轉換
intention.replace.cast.with.var.text=將 ''{0}'' 替換為 ''{1}''
intention.replace.concatenation.with.formatted.output.family=更換連接與格式化輸出
intention.replace.concatenation.with.formatted.output.text=用'java.text.MessageFormat.format()'替換'+'
intention.split.declaration.assignment.text=拆分為聲明和賦值
intention.split.declaration.family=拆分聲明
intention.split.filter.family=拆分過濾器
intention.split.filter.text=拆分為過濾器鏈
intention.split.if.family=分裂如果
intention.split.if.text=拆分為 2 條 'if' 語句
intention.split.switch.branch.with.several.case.values.copy.text=複製 'switch' 分支
intention.split.switch.branch.with.several.case.values.family=將包含多個 case 值的 switch 分支拆分成單獨的 'switch' 分支
intention.split.switch.branch.with.several.case.values.split.text=拆分 'switch' 分支的值
intention.surround.resource.with.ARM.block=使用 try-with-resources 環繞
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=將方法約定添加到 ''{0}''
intention.text.add.range.to.0=將範圍添加到 ''{0}''
intention.text.annotate.externally=在外部註解
intention.text.collapse.repeating.annotations=收起重複註解
intention.text.create.a.class.in.0=在 ''{0}'' 中創建類
intention.text.edit.method.contract.of.0=編輯 ''{0}'' 的方法約定
intention.text.edit.range.of.0=編輯 ''{0}'' 的範圍
intention.text.fix.method.0.parameters.with.bounded.wildcards=修復包含有界通配符的方法 ''{0}'' 形參
intention.text.generate.missed.test.methods=生成缺少的測試方法
intention.text.insert.0.annotation=插入 ''{0}''
intention.text.replace.implements.with.static.import=將實現替換為靜態導入
intention.text.replace.static.import.with.qualified.access.to.0=將靜態導入替換為 {0} 的限定訪問
intention.text.unimplement.0=取消實現{0}
intention.text.implements.list.remove.others=移除其他 ''{0} 引用
intention.unroll.loop.family=展開循環
intention.unwrap.else.branch=解開 'else' 分支
intention.unwrap.else.branch.changes.semantics=解開 'else' 分支(更改語義)
intention.use.single.member.static.import.text=對 ''{0}'' 使用靜態導入
intention.wrap.with.unmodifiable=使用不可修改的集合或映射包裝
intention.wrap.with.unmodifiable.list=使用不可修改的列表包裝
intention.wrap.with.unmodifiable.map=使用不可修改的映射包裝
intention.wrap.with.unmodifiable.set=使用不可修改的集包裝
interface.not.allowed=不允許接口
java.line.markers=Java 行標記
java.preview.features.accept.notification.link=接受
java.preview.features.alert.title=實驗性功能警報
java.preview.features.legal.notice=您必須接受測試版 Java 規範的法律通知條款才能啟用對“{0}”的支援。<br/><br/><b>根據 Java Community Process (JCP) 開發的早期規範草案的實現僅用於測試和評估目的，與 JCP 的任何規範都不兼容。</b>{1}
java.preview.features.notification.title=Java 預覽功能
java.preview.features.warning=較新的 IDE 版本可能會停止對預覽功能的支援。發佈 Java {0} 時，{1} (預覽)語言級別的支援可能會中斷
java.terms.exception=異常
java.terms.instance.initializer=實例初始值設定項
java.terms.of.annotation.type=註解類型{1}的{0}
java.terms.of.anonymous.class=匿名類的{0}
java.terms.of.class=類{1}的{0}
java.terms.of.enum=枚舉{1}的{0}
java.terms.of.interface=接口{1}的{0}
java.terms.static.initializer=static 初始值設定項
java.terms.type.parameter=類型形參
java.terms.variable.of.method={0}/{1}
javadoc.candidates.not.found=<html>找不到方法調用 <b>{0}</b> 的候選者。</html>
javadoc.function Object() { [native code] }.candidates=<html>新的候選 <b>{0}</b>() 是:<br>{1}</html>
javadoc.deprecated=已棄用
javadoc.description.copied.from.class=來自類：
javadoc.description.copied.from.field=來自字段：
javadoc.description.copied.from.interface=來自接口：
javadoc.generate.arguments=其他命令行實參(&O):
javadoc.generate.exited=\njavadoc退出,退出代碼$EXIT_CODE$\n
javadoc.generate.heap.size=最大堆大小(Mb) (&M):
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=在 -sourcepath 中包含 JDK 和庫源
javadoc.generate.link.to.jdk.documentation.option=鏈接到 JDK 文檔 (使用 -link 選項)
javadoc.generate.locale=區域設定(&L):
javadoc.generate.no.classes.in.selected.packages.error=選定的範圍不包含Java類
javadoc.generate.no.jdk=無法生成 JavaDoc - 沒有為項目配置 Java SDK。請在“設定 | 項目結構”中指定 Java SDK。
javadoc.generate.no.javadoc.tool=無法生成 JavaDoc - 在 {0} 或 {1} 上找不到 javadoc 工具。請在“設定 | 項目結構”中指定有效的 Java SDK。
javadoc.generate.open.in.browser=生成文檔並用瀏覽器打開 (&G)
javadoc.generate.options.hierarchy=生成層次結構樹
javadoc.generate.options.index=生成索引
javadoc.generate.options.index.per.letter=每個字母單獨的索引
javadoc.generate.options.navigator=生成導航欄
javadoc.generate.output.directory=輸出目錄 (&D):
javadoc.generate.output.directory.browse=瀏覽輸出目錄
javadoc.generate.sources.progress=尋找資源來生成Javadoc
javadoc.generate.tag.list.deprecated=棄用列表
javadoc.generate.temp.file.error=無法創建臨時檔案
javadoc.generate.temp.file.does.not.exist=臨時檔案不存在或無法打開
javadoc.generate.title=生成JavaDoc
javadoc.method.in.class={0}在類{1}裏邊
javadoc.method.in.interface=接口 {1} 中的 {0}
javadoc.method.overrides=重寫:
javadoc.method.specified.by=指定的:
javadoc.option.automatically.insert.closing.tag.javadoc=在 JavaDoc 中自動插入結束標記
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=請參閱:
javadoc.settings.title=Javadoc
javadoc.since=自:
javadoc.author=作者:
javadoc.version=版本:
javadoc.apiNote=API 說明:
javadoc.implNote=實現<br>說明：
javadoc.implSpec=實現<br>要求：
javadoc.type.parameters=類型形參:
jrt.node.short=[JRT]
label.add.math.max.0.count.to.avoid.possible.semantics.change=添加 Math.max(0, count) 以避免可能的語義變更
label.class.filter.editor.add.dialog.filter.pattern=輸入過濾器模式:
label.contract=約定:
label.enter.fully.qualified.class.name=輸入完全限定類名
label.entry.points=入口點:
label.forbid.api.usages=禁止使用 API:
label.from.inclusive=起始(包含):
label.implementation=實現:
label.implements.method.of_class_or_interface.name=實現{0, choice, 0#接口|1#類} ''{1}'' 的方法。
label.implements.method.of_interfaces=以下類/接口的實現方法:
label.maximal.reported.method.visibility=報告方法最大可見性:
label.method=方法 ''{0}''
label.minimal.reported.method.usage.count=報告方法最小使用計數:
label.mutates=變異:
label.name.prefix=名稱前綴:
label.name.suffix=名稱後綴:
label.naming.field=字段:
label.naming.local.variable=局部變量:
label.naming.parameter=形參:
label.naming.static.field=static 字段:
label.naming.subclass=子類:
label.naming.test.class=測試類:
label.overrides.method.of_class_or_interface.name=重寫{0, choice, 0#接口|1#類} ''{1}'' 的方法。
label.show.import.popup.for=顯示自動導入工具提示:
label.to.inclusive=結束(包含):
label.unused.declaration.reachable.from.tests.option=當入口點位於測試源中時，將被調用方標記為:
line.marker.recursive.call=遞歸調用
line.marker.type.external.annotations=外部註解
line.marker.type.inferred.contract.annotations=推斷約定註解
line.marker.type.inferred.nullability.annotations=推斷可空性註解
listbox.import.package=軟件包
listbox.import.static=static
listbox.import.with.subpackages=包含子軟件包
# suppress inspection "UnusedProperty"
macro.array.variable=arrayVariable()
macro.class.name=類名
macro.classpath.entry=該元素所屬的類路徑中的條目
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=檔案完全合格軟件包
macro.file.package=檔案軟件包
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
# suppress inspection "UnusedProperty"
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=JavaDoc輸出目錄
macro.project.classpath=項目的類路徑
macro.variable.of.type=variableOfType(Type)
methods.to.implement.chooser.title=選擇實現的方法
methods.to.override.chooser.title=選擇要重寫的方法
methods.to.override.implement.chooser.title=選擇覆蓋/實現的方法
module.not.in.requirements=模塊 ''{0}'' 的要求中缺少模塊 ''{1}''
module.package.not.exported=模塊 ''{0}'' 不會將軟件包 ''{1}'' 導入到模塊 ''{2}''
module.package.not.open=模塊 ''{0}'' 不會打開模塊 ''{2} ''的軟件包 ''{1}''
module.type.java.description=Java 模塊用於開發<b>基於 JVM 的</b>桌面和 Web 應用程序，包括使用 <b>Java EE</b> 和其他企業開發框架的應用程序。
module.type.java.name=Java模塊
navigate.to.duplicate.fix=導航到重複位置
no.methods.overriding.0.are.found=沒有重寫方法 {0, choice, 0#|1# ''{1}''|2#這些類} 被發現
no.patterns=沒有類模式配置
node.call.hierarchy.unknown.jsp=未知的jsp
node.hierarchy.java.lang.object=所有類都派生自java.lang.Object
notification.navigation.to.overriding.classes=索引更新時無法導航到重寫類
notification.navigation.to.overriding.methods=索引更新時無法導航到重寫方法
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=已成功將完整線程轉儲複製到剪貼簿
nullable.notnull.annotations.panel.title={0}註解:
nullable.notnull.annotations.runtime.instrumentation.tooltip=為非空註解的方法和形參添加運行時斷言
nullable.notnull.configuration.dialog.title=可空/非空配置
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=導航到 'null' 實參用法
nullable.stuff.inspection.navigate.null.argument.usages.view.name=形參 {0} 的 ''null'' 實參用法
offline.inspections.jdk.not.found=找不到 {0}
offline.inspections.library.urls.were.not.resolved=未解析模塊 ''{2}'' 中庫 ''{1}'' 的根 {0}
offline.inspections.library.was.not.resolved=請配置庫''{0}''用於模塊''{1}''
offline.inspections.no.source.roots=未檢測到模塊 ''{0}'' 的源根
options.java.attribute.descriptor.abstract.class=類和接口//abstract 類
options.java.attribute.descriptor.abstract.method=方法//abstract 方法
options.java.attribute.descriptor.annotation.attribute.name=註解//註解特性名稱
options.java.attribute.descriptor.annotation.name=註解//註解名稱
options.java.attribute.descriptor.anonymous.class=類和接口//匿名類
options.java.attribute.descriptor.class=類和接口//類
options.java.attribute.descriptor.function Object() { [native code] }.call=方法//構造函數調用
options.java.attribute.descriptor.function Object() { [native code] }.declaration=方法//構造函數聲明
options.java.attribute.descriptor.enum=類和接口//枚舉
options.java.attribute.descriptor.implicit.anonymous.parameter=形參//隱式的匿名類形參
options.java.attribute.descriptor.inherited.method=方法//繼承的方法
options.java.attribute.descriptor.instance.field=類字段//實例字段
options.java.attribute.descriptor.instance.final.field=類字段//實例 final 字段
options.java.attribute.descriptor.interface=類和接口//接口
options.java.attribute.descriptor.javadoc.comment=註釋//JavaDoc//文本
options.java.attribute.descriptor.javadoc.markup=註釋//JavaDoc//標記
options.java.attribute.descriptor.javadoc.tag=註釋//JavaDoc//標籤
options.java.attribute.descriptor.javadoc.tag.value=註釋//JavaDoc//標籤值
options.java.attribute.descriptor.lambda.parameter=形參//Lambda 形參
options.java.attribute.descriptor.method.call=方法//方法調用
options.java.attribute.descriptor.method.declaration=方法//方法聲明
options.java.attribute.descriptor.method.imported.call=方法//static 導入方法調用
options.java.attribute.descriptor.reassigned.local.variable=變量//重新分配局部變量
options.java.attribute.descriptor.reassigned.parameter=形參//重新分配形參
options.java.attribute.descriptor.static.field=類字段//static 字段
options.java.attribute.descriptor.static.final.field=類字段//常量(static final 字段)
options.java.attribute.descriptor.static.final.imported.field=類字段//常量 (static final 導入字段)
options.java.attribute.descriptor.static.imported.field=類字段//靜態導入字段
options.java.attribute.descriptor.static.method=方法//static 方法
options.java.attribute.descriptor.type.parameter=形參//類型形參
options.java.attribute.descriptor.public=可見性//Public
options.java.attribute.descriptor.protected=可見性//Protected
options.java.attribute.descriptor.package.private=可見性//Package-private
options.java.attribute.descriptor.private=可見性//Private
options.java.display.name=Java
override.implement.broken.file.template.message=請更正“重寫/實現的方法體”模板
override.implement.broken.file.template.title=檔案模板錯誤
package.dependencies.production.node.text=生產類
package.dependencies.test.node.text=測試類
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=運行時映像(JLink)
packaging.jlink.compression.level=壓縮級別
packaging.jlink.compression.zero.level=不壓縮
packaging.jlink.compression.first.level=字符串共享
packaging.jlink.compression.second.level=Zip
packaging.jlink.verbose.tracing=啟用詳細跟踪
paste.class.command.name=貼上類 ''{0}''
please.report.a.bug=請報告錯誤
popup.title.choose.framework=選擇框架
popup.title.choose.test=選擇測試
popup.title.select.a.jar.file=選擇 JAR 檔案
popup.title.select.qualified.name=選擇限定名稱
postfix.template.language.level.title=最低語言級別:
press.0.to.see.inheritors.of.1=按 {0} 以查看 {1} 的繼承者
press.0.to.see.non.imported.classes=按 {0} 以查看未導入的類
pressing.0.twice.without.a.class.qualifier=不使用類限定符，按 {0} 兩次會顯示所有可訪問的 static 方法
project.problems.hint.text={0} 個相關{0, choice, 0#問題|2#問題}
project.problems.window.title={0} 的相關問題
project.problems.fix.text=顯示相關問題
project.problems.fix.description=發現與 ''{0}'' 相關的問題
project.problems.title=相關問題
progress.creating.class=創建類{0}
progress.title.check.applicability=檢查可用性…
progress.title.download.library.descriptor=下載庫描述符
progress.title.find.references.in.implement.extends.lists=在實現/展開列表中尋找引用…
progress.title.finding.cause=正在尋找原因
progress.title.looking.for.jdk.locations=正在尋找 JDK 位置…
progress.title.looking.for.libraries=正在尋找庫
progress.title.optimize.imports=優化 import…
progress.title.preprocess.usages=預處理用法
progress.title.search.for.overriding.methods=搜尋重寫方法…
progress.title.searching.for.sub.classes=正在搜尋子類
prompt.choose.base.class.of.the.hierarchy=選擇層次結構基類,搜尋
prompt.create.non.existing.package=軟件包 {0} 不存在。\n要創建嗎?
prompt.delete.class=個類
prompt.delete.field=個字段
prompt.delete.interface=個接口
prompt.delete.method=個方法
prompt.delete.package={0,choice,1#軟件包|2#軟件包}
prompt.delete.type.parameter={0,choice,1#類型形參|2#類型形參}
#{1} presents an action verb with preposition: "to refactor" is the default value, RefactorinBundle:to.refactor
prompt.do.you.want.to.action_verb.the.method.from_class=要改為對基{0,choice,1#方法|2#方法}{1}嗎?
psi.search.overriding.progress=搜尋覆蓋方法
quickfix.add.variable.family.name=初始化變量
quickfix.add.variable.text=初始化變量 ''{0}''
quickfix.family.avoid.mutation.using.stream.api=使用 Stream API 避免變異
quickfix.family.change.javadoc.to=更改為…
quickfix.family.find.cause=尋找原因
quickfix.family.remove.javadoc.tag=移除標記
quickfix.family.remove.redundant.parameter=刪除冗餘形參
quickfix.family.remove.redundant.parameter.types=刪除冗餘形參類型
quickfix.family.replace.cast.type=替換轉換類型
quickfix.family.replace.inefficient.stream.count=替換低效的 Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=將 Optional 鏈替換為 if 語句
quickfix.family.replace.stream.api.chain.with.loop=將 Stream API 鏈替換為循環
quickfix.family.replace.with.java.stream.api.pipeline=替換為 Java Stream API 管道
quickfix.family.replace.with.magic.constant=替換為魔術常量
quickfix.family.replace.with.method.reference=替換為方法引用
quickfix.family.replace.with.optional.of.nullable.chain=替換為 Optional.ofNullable() 鏈
quickfix.family.replace.with.stream.api.equivalent=替換為 Stream API 對等項
quickfix.family.simplify.foreach.lambda=簡化 forEach lambda
quickfix.family.simplify.stream.call.chain=簡化流調用鏈
quickfix.family.use.flatmap=使用 'flatMap'
quickfix.family.wrap.with.mutable.collection=使用可變集合包裝
quickfix.name.find.jar.on.web=在 web 上尋找 JAR
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (可能無法在 JDK 11.0.2 之前的版本上運行)
quickfix.text.avoid.mutation.using.stream.api.0.operation=使用 Stream API ''{0}'' 操作避免變異
quickfix.text.remove.javadoc.0=移除 ''@{0}'' 標記
quickfix.text.remove.javadoc.0.1=移除 @{0} {1}
quickfix.text.remove.not.null.annotation=移除非空註解
quickfix.text.replace.0.stream.with.1.2=將 {0}.stream() 替換為 {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=將 ''collect({0}())'' 替換為 ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=將 ''filter().{0}().isPresent()'' 替換為 ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=將 ''stream().{0}()'' 替換為 ''{1}()''{2}
quickfix.text.suffix.may.change.semantics=\ (可能更改語義)
quickfix.text.wrap.0.with.1=用 ''{1}'' 包裝 ''{0}''
quickfix.text.replace.url.with.html=將 URL 替換為 HTML 鏈接
radio.button.higher.than=高於:
radio.button.respecting.to.project.language.level.settings=遵循項目語言級別設定
radio.button.subclass.of.0=''{0}'' 的子類
radio.button.unused.declaration.unused.option=未使用
radio.button.unused.declaration.used.option=已使用
radio.button.with.provider.method=帶有 'provider()' 方法
radio.use.fully.qualified.class.names.in.javadoc=使用Javadoc中完全合格的類名:
radio.use.fully.qualified.class.names.in.javadoc.always=始終
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=如果尚未導入
radio.use.fully.qualified.class.names.in.javadoc.never=切勿使用短名稱添加導入
scope.hierarchy={0}的層次結構
sdk.cannot.create=無法創建 SDK
sdk.java.no.classes=無法在''{0}''中找到JDK classes
section.title.inspection.suspicious.names.ignore.methods=忽略方法:
set.language.level=設定語言級別
set.language.level.to.0=設定語言級別為{0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=註解
settings.inlay.java.builder.like.methods=類似於構建器的方法
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=複雜的表達式: 二進制、函數、數組訪問以及其他
settings.inlay.java.enum.constants=枚舉常量
settings.inlay.java.external.annotations=外部註解
settings.inlay.java.inferred.annotations=推斷註解
settings.inlay.java.inheritors=繼承者
settings.inlay.java.insert.annotation=插入註解
settings.inlay.java.implicit.types=隱式類型
settings.inlay.java.methods.with.same.named.numbered.parameters=包含相同名稱的編號形參的方法
settings.inlay.java.new.expressions='New' 表達式
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=在具有相同類型的多個形參的情況下的非文字
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=具有方法名稱中包含的名稱的形參
settings.inlay.java.show.hints.for=顯示以下項的提示:
settings.inlay.java.show.parameter.hints.for=為以下對象顯示形參提示:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=數組初始值設定項、switch、條件、引用、實例、賦值、調用、限定、類型轉換、類對象訪問表達式。
settings.inlay.java.turn.off.external.annotations=關閉外部註解
settings.inlay.java.turn.off.inferred.annotations=關閉推斷註解
settings.inlay.java.usages=用法
show.import.popup.for.classes=類(&C)
show.import.popup.for.static.methods.and.fields=Static 方法和字段(&S)
exclude.import.wildcard.comment=使用 * 通配符排除指定類或軟件包的所有成員
special.annotations.annotations.list=附加的特殊註解:
special.annotations.list.add.annotation.class=添加註解類
special.annotations.list.annotation.class=註解類
special.annotations.list.annotation.pattern.message=添加註解模式
special.annotations.list.annotation.pattern=添加註解模式
special.annotations.list.remove.pattern=移除
spi.extension.error.message=註冊的擴展應實現{0}
filetype.spi.description=服務提供程序接口
spi.no.provider.error.message=未找到服務提供程序“{0}”
status.bar.overridden.methods.highlighted.message=找到{0}重寫方法  (按{1}再次移除高亮顯示, Esc移除所有高亮)
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=!(表達式實例類型)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=無效的檔案模板,用於catch body
surround.with.try.catch.incorrect.template.title=環繞用try-catch
surround.with.try.catch.template=try / catch
tab.title.entry.points=入口點
tab.title.members.to.report=要報告的成員
table.cell.constructors=構造函數
title.cannot.create.class=無法創建類
title.import.layout=導入布局
title.javadoc=JavaDoc
title.naming=命名
title.naming.final.modifier=final 修飾符
title.naming.functional.expressions=Lambda 體
title.package.not.found=找不到軟件包
title.packages=軟件包
title.packages.to.use.import.with=將 import 與 '*' 搭配使用的軟件包
to.import.a.method.statically.press.0=要靜態導入方法，請按 {0}
unscramble.detect.analyze.threaddump.from.clipboard.item=自動檢測和分析從 IntelliJ IDEA 外部複製到剪貼簿的線程轉儲
unscramble.log.path.label=日誌檔案: (&L)
unscramble.no.unscrambler.item=<未安裝譯碼器>
unscramble.normalize.button=標準化 (&N)
unscramble.stacktrace.caption=將一個堆棧跟踪或完整的線程轉儲放在此處:
unscramble.unscrambled.deadlock.tab=<死鎖>
unscramble.unscrambled.stacktrace.tab=<堆棧跟踪>
unscramble.unscrambled.threaddump.tab=<線程>
unscramble.unscrambler.combobox=譯碼器(&S):
unscramble.use.unscrambler.checkbox=譯碼堆棧跟踪(&U)
unwrap.anonymous=開啟 'anonymous...'
unwrap.array.initializer=解包數組初始值設定項
unwrap.conditional=開啟 'f ? a : b'
unwrap.lambda=取消 'lambda...' 換行
unwrap.synchronized=解開 'synchronized…'
unwrap.switch.expression=解開 'switch' 表達式
unwrap.switch.statement=解開 'switch' 語句
usage.target.exception=異常
usage.target.package.in.directory={0} (在 {1} 中)
use.external.annotations=使用外部註解 (&E)
wrapping.annotation.parameters=註解形參
wrapping.record.components=記錄組件
wrapping.text.blocks=文本塊
wrong.package.statement=錯誤的 package 語句
title.code.vision=Code Vision
highlight.throws.popup.throwing.places=引發 {0} 的位置
highlight.throws.popup.usages={0} 的用法
psi.error.incorrect.class.template.message=不能創建{0} - {1}模板不正確。
presentable.text.anonymous.class=匿名類
presentable.text.code.from.context=來自 {0} 的代碼
presentable.text.code.display=代碼
presentable.text.invalid.element.name=無效
inspection.simplify.for.each.replace=替換為 {0}
inspection.simplify.for.each.extract.intermediate.operations=提取中間操作
inspection.message.can.be.replaced.with.files.writestring=可以替換為 'Files.writeString()'
inspection.notnull.field.not.initialized.message=必須初始化 {0} 字段
highlight.throws.class.name=高亮顯示 Throws {0}
class.patterns.panel.add.class=添加類
multiple.usages.of.static.import.found=已找到靜態導入的多個用法
external.annotations.roots=註解根
inspection.stream.api.migration.can.be.replaced.with.call=可以替換為 ''{0}'' 調用
highlight.suppressed.warnings.choose.inspections=選擇檢查以高亮顯示此項中的已禁止問題
inspection.magic.constants.should.be.one.of.values=應當為以下之一: {0}{1,choice,0#|1#或其組合}
live.template.context.consumer.function=使用者函數
live.template.context.statement=語句
live.template.context.expression=表達式
live.template.context.declaration=聲明
inspection.unused.display.name=未使用的聲明
inspection.empty.method.display.name=空方法
inspection.unused.assignment.display.name=未使用的賦值
inspection.unchecked.warning.display.name=未檢查的警告
inspection.convert.2.streamapi.display.name=可以通過 Stream API 收起循環
inspection.optional.to.if.display.name='Optional' 可以替換為 'if' 語句序列
inspection.stream.to.loop.display.name=Stream API 調用鏈可以替換為循環
inspection.anonymous.2.method.ref.display.name=匿名類型可以替換為方法引用
inspection.convert.2.method.ref.display.name=lambda 可以替換為方法引用
inspection.lambda.can.be.method.call.display.name=lambda 可以替換為方法調用
inspection.functional.expression.can.be.folded.display.name=函數表達式可以折疊
inspection.trivial.functional.expression.usage.display.name=函數表達式的普通用法
inspection.magic.constant.display.name=魔術常量
inspection.static.pseudo.functional.style.method.display.name=使用 static 類的偽函數表達式
inspection.static.pseudo.functional.style.table.label=轉換為 'Stream' API 的靜態方法調用:
inspection.overwritten.key.display.name=被覆蓋的 Map、Set 或數組元素
inspection.collection.add.all.can.be.replaced.with.function Object() { [native code] }.display.name=冗餘的 'Collection.addAll()' 調用
inspection.manual.min.max.calculation.display.name=手動最小值/最大值計算
inspection.explicit.array.filling.display.name=顯式數組填充
inspection.java.8.collection.remove.if.display.name=循環可以替換為 'Collection.removeIf()'
inspection.java.8.map.api.display.name=可簡化的 'Map' 運算
inspection.string.repeat.can.be.used.display.name=可以使用 String.repeat()
inspection.read.write.string.can.be.used.display.name=可以使用 'Files.readString()' 或 'Files.writeString()'
inspection.java.9.collection.factory.display.name=不可變集合創建可以替換為集合工廠調用
inspection.explicit.argument.can.be.lambda.display.name=顯式實參可以是 lambda
inspection.excessive.lambda.usage.display.name=過度使用 lambda
inspection.redundant.stream.optional.call.display.name=Stream 或 Optional 調用鏈中存在冗餘步
inspection.obvious.null.check.display.name=使用明顯非空實參調用 null 檢查方法
inspection.simplify.stream.api.call.chains.display.name=可以簡化 Stream API 調用鏈
inspection.simplify.optional.call.chains.display.name=可以簡化 Optional 調用鏈
inspection.simplify.collector.display.name=可簡化的收集器
inspection.use.bulk.operation.display.name=可以使用批量操作代替迭代
inspection.comparator.combinators.display.name=可以使用 'Comparator' 連結符
inspection.replace.inefficient.stream.count.display.name=以 count() 結尾的低效 Stream API 調用鏈
inspection.redundant.lambda.parameter.type.display.name=冗餘 lambda 形參類型
inspection.wrapper.type.may.be.primitive.display.name=包裝器類型可能是基元
inspection.optional.get.without.is.present.display.name=在不進行 isPresent() 檢查的情況下調用 Optional.get()
inspection.optional.is.present.display.name=非函數樣式 'Optional.isPresent()' 用法
inspection.conditional.can.be.optional.display.name=條件可以替換為 Optional
inspection.optional.assigned.to.null.display.name=Optional 類型的 null 值
inspection.excessive.range.check.display.name=過度範圍檢查
inspection.condition.covered.by.further.condition.display.name=條件由進一步的條件覆蓋
inspection.move.field.assignment.to.initializer.display.name=字段賦值可以移動到初始值設定項中
inspection.frequently.used.inheritor.inspection.display.name=類可以擴展常用的基類
inspection.slow.abstract.set.remove.all.description=調用 'set.removeAll(list)' 可能較為緩慢
inspection.slow.abstract.set.remove.all.fix.family.name=使用 'Set.remove' 而不是 'Set.removeAll'
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=''null'' 篩選器不適用於基元類型 {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''!null'' 篩選器不適用於基元類型 {0}
slice.filter.parse.error.enum.constant.not.found=找不到枚舉常量: {0}
slice.filter.parse.error.incorrect.expression=表達式不正確: {0}
slice.filter.parse.error.incorrect.constant.type=常量類型不正確(要求: {0})
slice.filter.parse.error.expression.must.evaluate.to.constant=表達式必須評估為常量: {0}
slice.filter.parse.error.incorrect.constant.expected.number=常量不正確(應為數字): {0}
action.dfa.from.stacktrace.text=尋找 ''{0}'' 可以是 {1} 的原因
slice.usage.message.assertion.violated=(違反斷言!)
slice.usage.message.in.file.stopped.here=(在 {0} 檔案中 - 在此處停止)
slice.usage.message.tracking.container.contents=(正在跟踪容器 ''{0}{1}'' 內容)
slice.usage.message.location=({0} 內)
intention.name.move.into.if.branches=上移至 'if' 語句分支
intention.name.collapse.into.loop=收起到循環中
intention.family.name.make.sealed=密封類
intention.error.make.sealed.class.is.used.in.functional.expression=類用於函數表達式
intention.make.sealed.class.hint.title=使其密封
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=部分繼承者為匿名或局部
intention.error.make.sealed.class.different.packages=模塊未命名，某些繼承者位於不同的軟件包中
intention.error.make.sealed.class.inheritors.not.in.java.file=有些繼承者不在 Java 檔案中
intention.error.make.sealed.class.different.modules=有些繼承者位於不同模塊中
intention.error.make.sealed.class.interface.has.no.inheritors=接口沒有繼承者
intention.make.sealed.class.task.title.set.inheritors.modifiers=正在設定繼承者修飾符
intention.family.name.move.member.into.class=將成員移至類
inspection.fill.permits.list.no.missing.inheritors=密封類沒有缺失的繼承者
inspection.fill.permits.list.display.name=密封類的 permits 子句中缺失同一檔案子類
inspection.fill.permits.list.fix.name=將缺失的子類添加到 permits 子句
update.external.annotations=更新外部註解
intention.create.switch.statement=創建 switch 語句
sort.threads.by.type=按類型對線程排序
sort.threads.by.name=按名稱對線程排序
inspection.message.record.can.be.converted.to.class=記錄可以轉換為類
intention.family.name.convert.record.to.class=將記錄轉換為類
class.can.be.record.display.name=類可以為記錄
class.can.be.record.quick.fix=轉換為記錄
class.can.be.record.suggest.renaming.accessors=建議重命名 get/is 訪問器
class.can.be.record.conversion.weakens.member=當轉換削弱成員訪問級別時:
class.can.be.record.conversion.strategy.do.not.convert=不向記錄建議轉換
class.can.be.record.conversion.strategy.show.members=在衝突視圖中顯示受影響的成員
class.can.be.record.conversion.strategy.convert.silently=靜默轉換
extracted.class.should.have.unique.name=已提取類應具有唯一名稱。已有一個內部類使用名稱 ''{0}''
invalid.extracted.class.name=''{0}'' 是無效的已提取類名稱
caller.chooser.referenced.code.title=引用代碼
dialog.title.choose.annotation=選擇 {0} 註解
unchecked.warning.inspection.settings.ignore.unchecked.assignment=忽略未檢查的賦值
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=忽略 vararg 形參的未檢查的泛型數組創建
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=忽略作為原始類型成員的未檢查的調用
unchecked.warning.inspection.settings.ignore.unchecked.cast=忽略未檢查的轉換
unchecked.warning.inspection.settings.ignore.unchecked.overriding=忽略未檢查的重寫
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=。原因: ''{0}'' 具有原始類型，因此消除了 {1} 的結果
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=vararg 形參的未檢查的泛型數組創建
type.migration.dialog.message.invalid.type=''{0}'' 是無效類型
type.migration.dialog.message.void.not.applicable='void' 不可用
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=將 Stream API 鏈替換為循環
stream.to.loop.inspection.message.replace.foreach.call.with.loop=將 'forEach' 調用替換為循環
todo.index.not.available=不適用
simplify.stream.inspection.message.can.be.replaced=''{0}'' 可以替換為 ''{1}''
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' 可以替換為 ''{1}'' (可能會改變語義)
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=''filter().{0}().isPresent()'' 鏈可以替換為 ''anyMatch()''
simplify.stream.match.negation.fix.name=將 {0} 替換為 {1}(…)
simplify.stream.collection.creation.fix.name=替換為 ''{0}'' 構造函數
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=顯式使用 Stream 元素
simplify.stream.simple.stream.of.message=不必要的單元素 Stream
simplify.stream.replace.with.element.iteration.fix.message=可以替換為元素迭代
simplify.stream.remove.boolean.identity.fix.name=與上一個 'map' 調用合併
simplify.stream.remove.boolean.identity.fix.message=可以與上一個 'map' 調用合併
simplify.stream.replace.support.with.collection.fix.name=替換為''{0}.of''回調
simplify.stream.replace.support.with.collection.fix.message=可以替換為 ''{0}.{1}'' 調用
simplify.stream.swap.filter.and.map.fix.name=交換 'filter()' 和 'map()'
simplify.stream.swap.filter.and.map.fix.message=可以交換 'filter()' 和 'map()'
simplify.stream.inspection.iterate.take.while.fix.name=替換為三實參 'iterate()'
simplify.stream.inspection.iterate.take.while.fix.message=可以替換為三實參 'iterate()'
side.effects.pattern.message=<html>\n<body>\n{0} 中可能存在副作用<br>\n您可以:\n<br>\n-\\&nbsp;<b>移除</b>變量用法以及所有涉及的表達式，或<br>\n-\\&nbsp;<b>自行將分配到變量的表達式轉換</b>到語句中。<br>\n<div style="padding-left: 0.6cm;">\n  即<br>\n  <table border="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  成為: <br>\n  <table border="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
side.effects.non.fixable.message=<html><body>  表達式 ''{0}'' 中可能存在副作用<br>您可以<b>移除</b>類引用以及涉及的全部表達式</body></html>
side.effects.expression.presentation=表達式 ''{0}''
change.signature.from.usage.short.name=<html> 更改 {0}({1}) 的簽名</html>
default.param.value.warning=具有所選簽名的{0, choice, 0#構造函數|1#方法}已存在
qualify.static.constant.access=限定 static 常量訪問
qualify.static.access.command.name=限定 static 訪問
qualify.static.call.fix.text=限定 static 調用
side.effects.expressions.assigned.to.the.variable=分配到變量 ''{0}'' 的表達式
pull.members.up.fix.name=將成員上移
extract.superclass.command.name=提取超類
extract.interface.command.name=提取接口
choose.super.class.popup.title=選擇超類
intention.name.pull.method.up.and.make.it.abstract.conditionally=將方法 ''{0}'' 拉取到 ''{1}''{2, choice, 0#並將其設為 abstract|1#}
intention.name.extract.method.to.new.interface=將方法 ''{0}'' 提取到新接口
intention.name.pull.method.up.make.it.abstract=向上拉取方法 ''{0}'' 並使其抽象
intention.name.pull.method.up=向上拉取方法 ''{0}''
intention.name.copy.to.final.temp.variable=複製''{0}'' {1, choice, 0#|1#effectively }final 臨時變量
intention.name.make.variable.final=將 {1, choice, 0#''''{0}''''|1#變量} 設為 final
intention.name.transform.variables.into.final.one.element.array=將 {1, choice, 0#''''{0}''''|1#變量} 轉換成 final 單元素數組
type.information.value=值
type.information.not.equal.to=不等於
type.information.range=範圍
type.information.nullability=可 null 性
type.information.constraints=約束
type.information.mutability=可變性
type.information.locality=本地性
type.information.local.object=本地對象
type.information.type=類型
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=從可選鏈中移除冗餘步驟
simplify.optional.chain.inspection.to.x=將可選鏈簡化為 ''{0}''
simplify.optional.chain.inspection.map.or.else.description=可選鏈可以簡化
simplify.optional.chain.inspection.optional.rewrapping.name=解開
simplify.optional.chain.inspection.optional.rewrapping.description=不必要的 Optional 重新包裝
simplify.optional.chain.inspection.or.else.return.fix.name=將 null 檢查替換為 {0}({1})
simplify.optional.chain.inspection.or.else.return.fix.description=null 檢查可被消除
simplify.optional.chain.inspection.or.else.non.null.fix.name=將 null 檢查替換為 ifPresent()
simplify.optional.chain.inspection.or.else.non.null.fix.description=null 檢查可被 'ifPresent' 消除
generate.test.support.method.error.no.template.found.for.framework=沒有找到 {0} 的模板: {1}
generate.test.support.method.error.method.already.exists=方法 {0} 已存在
generate.test.support.method.error.cannot.generate.method=無法生成方法: {0}
base.package.project.wizard.error.x.not.valid.package={0} 不是有效的軟件包名稱
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=如果限定名稱匹配，則將代碼標記為入口點
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=方法模式 ''{0}'' 必須是有效的 java 標識符，僅接受 ''*'' 作為佔位符
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=模式必須是有效的 java 限定名稱，僅接受 '*' 作為佔位符
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=在前綴 ''{0}'' 中不是有效的 java 標識符部分
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=在後綴 ''{0}'' 中不是有效的 java 標識符部分
hide.out.of.cyclic.packages.action.text=隱藏沒有循環依賴的軟件包
hide.out.of.cyclic.packages.action.description=隱藏沒有循環依賴的軟件包
generate.missed.tests.action.error.no.tests.found=找不到測試。
generate.missed.tests.action.failed.to.detect.framework=無法檢測到 {0} 的測試框架
pull.up.accessible.conflict={0} 無法訪問
pull.up.accessible.conflict.1=無法從 {1} 訪問 {0}
pull.up.concrete.inherit.abstract.method.conflict=具體的 ''{0}'' 將繼承一個新的抽象方法
pull.up.members.usage.view.description.code.references.node=將成員向上拉取到“{0}”的類
pull.up.members.usage.view.description.processed.elements.node=從類 {0} 上移成員
refactoring.method.reference.to.lambda.conflict=方法引用將轉換為 lambda
introduce.variable.change.semantics.warning=提取所選表達式將改變整個表達式的語義。
introduce.variable.change.type.adv=按 {0} 更改類型
introduce.variable.reassign.adv=按 {0} 重新分配現有變量
introduce.functional.variable.accessibility.conflict=變量 {0} 不是有效的 final 變量，無法在函數表達式中訪問
introduce.functional.variable.interface.chooser.title=選擇適用的函數接口: {0} -> {1}
introduce.functional.variable.nothing.found.message=找不到適用的函數接口
introduce.parameter.object.no.accessor.conflict.message=字段 ''{1}'' 需要 {0, choice, 0#Getter|1#Setter}
push.down.anonymous.conflict=無法將實現推送到匿名類
push.down.static.nonstatic.conflict=static {0} 無法推送到非 static {1}
push.down.missed.implementation.conflict=非抽象 {0} 將錯過 {1} 的實現
push.down.super.method.call.changed.conflict=super 方法調用將解析為另一種方法
move.classes.invalid.destination.package.name.message=''{0}'' 是無效的目標軟件包名稱
move.classes.destination.class.not.found.message=未找到目標類
move.class.import.from.default.package.conflict=無法從預設軟件包訪問 {0}
destination.combo.test.root.not.expected.conflict=應為源根，但選擇了測試根
destination.combo.source.root.not.expected.conflict=應為測試根，但選擇了源根
leave.in.same.source.root.item=留在同一源根中
move.inner.select.target.package.title=選擇目標軟件包
move.member.enum.conflict=枚舉類型不適用於當前上下文
move.member.final.initializer.conflict=移動後，final 變量初始值設定項將不可用。
rename.package.invalid.name.error=不是有效的軟件包名稱
rename.package.ignored.name.warning=正在嘗試創建具有忽略名稱的軟件包，結果將不可見
rename.package.class.already.exist.conflict=具有限定名稱 ''{0}''  的類已存在
rename.package.command.name=重命名軟件包
class.filter.editor.table.model.column.name.pattern=模式
class.filter.editor.table.model.column.name.isActive=活躍
create.class.mapping.dialog.title=選擇 {0} 類
import.layout.panel.up.button=上
import.layout.panel.down.button=下
import.layout.panel.blank.line.entry=<空行>
import.layout.panel.all.other.imports=所有其他導入
edit.contract.dialog.hint=<html>請指定約定文本<p>示例: <code>_, null -> false</code><br><small>請參閱意圖操作描述了解詳細信息</small></html>
edit.range.dialog.message=<html>請指定值範圍<p>如果不受限制，將 'from' 或 'to' 留空</html>
edit.range.error.invalid.value=無效值
edit.range.value.should.be.less.than=不應小於 {0}
edit.range.value.should.be.bigger.than=不應大於 {0}
edit.range.should.not.be.less.than.from=不應小於 'from'
generate.function Object() { [native code] }.already.exists=構造函數已存在
generate.equals.no.fields.for.generation=找不到要包含在 equals/hashCode 中的字段
generate.getter.and.setter.error.setters.for.read.only.not.generated=未生成唯讀字段的 setter
generate.getter.and.setter.error.no.fields=找不到要為之生成 getter/setter 的字段
generate.getter.and.setter.error.no.fields.without.getters.and.setters=找不到沒有 getter/setter 的字段
generate.getter.error.no.fields=找不到要為之生成 getter 的字段
generate.getter.error.no.fields.without.getters=找不到沒有 getter 的字段
generate.getter.setter.header.visibility.hint.=根據“檔案 | 設定 | 編輯器 | 代碼樣式 | Java | 代碼生成“應用可見性
generate.members.nothing.to.insert=未找到要插入的內容
generate.setters.no.fields=找不到要為之生成 setter 的字段
generate.setters.no.fields.without.setters=找不到沒有 setter 的字段
implement.abstract.method.potential.implementations.with.weaker.access=找到具有較弱訪問權限的潛在實現: {0}
implement.method.no.methods.to.implement=找不到要實現的方法
action.sort.by.percent.classes.which.overrides.method.text=按重寫方法的類百分比排序
action.sort.by.percent.classes.which.overrides.method.description=按重寫方法的類百分比排序
override.methods.error.no.methods=找不到要重寫的方法
base.package.parameter.wizard.label=基礎軟件包(&P):
type.migration.multi.root.toolwindow.title=遷移 {0} 的類型
type.migration.single.root.toolwindow.title=將 {0} 的類型從 ''{1}'' 遷移到 ''{2}''
type.migration.processed.elements.header=類型遷移的根
type.migration.cannon.convert.tooltip=無法將類型 <b>{0}</b> 的表達式{3, choice, 0#|1# 從 '<'b'>'{1}'<'/b'>' 轉換為 '<'b'>'{2}'<'/b'>'}<br>
type.migration.replaced.notification=替換為 {0}
type.migration.cannot.convert.tooltip=無法將表達式的類型從 {0} 轉換為 {1}
type.migration.getter.rename.suggestion.text=由於返回類型已遷移到 ''{2}''，getter 名稱是否從 ''{0}'' 遷移到 ''{1}''?
type.migration.getter.rename.suggestion.never.migrate.method.names=從不遷移方法名稱
type.migration.getter.rename.suggestion.always.migrate.method.names=始終遷移方法名稱
hint.text.press.to.go.through.inlined.occurrences=按 {0} 遍歷 {1} 個已內聯匹配項
hint.text.occurrences.were.inlined={0} 個匹配項已內聯
action.expand.static.import.text=展開靜態導入
class.cannot.be.inlined.because.a.call.to.its.function Object() { [native code] }.is.unresolved=無法內聯類，因為其構造函數的調用未解析
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=無法內聯類，因為其用作 'this' 限定符
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=無法內聯類，因為其用於 'throws' 子句
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=無法內聯類，因為其用於 'catch' 子句
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=無法內聯類，因為其具有自身類文字的用法
class.cannot.be.inlined.because.it.has.static.initializers=無法內聯類，因為其具有 static 初始值設定項
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=無法內聯類，因為其具有未從自身超類繼承的字段的用法
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=無法內聯類，因為其具有帶非常量初始值設定項的 static 字段
class.cannot.be.inlined.because.it.has.static.non.final.fields=無法內聯類，因為其具有 static 非 final 字段
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=無法內聯類，因為其具有自身內部類的用法
class.cannot.be.inlined.because.it.has.static.inner.classes=無法內聯類，因為其具有 static 內部類
class.cannot.be.inlined.because.it.has.static.methods=無法內聯類，因為其具有 static 方法
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=無法內聯類，因為其方法的部分用法並非繼承自其超類或接口
class.cannot.be.inlined.because.its.function Object() { [native code] }.contains.return.statements=無法內聯類，因為其構造函數包含 'return' 語句
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=無法內聯類，因為無法解析其實現的一個接口
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=無法內聯類，因為無法解析其超類
library.classes.cannot.be.inlined=庫類無法內聯
enums.cannot.be.inlined=枚舉無法內聯
interfaces.cannot.be.inlined=接口無法內聯
annotation.types.cannot.be.inlined=註解類型無法內聯
type.parameters.cannot.be.inlined=類型形參無法內聯
postfix.template.editor.choose.class.title=選擇類
null.check.surrounder.description=if (expr != null) {…}
push.method.down.command.name=向下推動方法…
replace.implements.with.static.import.field.usages.progress=尋找常量字段用法…
show.siblings.choose.super.class.title=選擇超類或接口
show.siblings.find.usages.method.title=super 方法
show.siblings.find.usages.class.title=超類/接口
switch.stmt.template.description=switch (expr) {…}
wrap.return.value.created.class.not.accessible.conflict=創建的類將無法在調用位置訪問
wrap.return.value.existing.class.does.not.have.getter.conflict=現有類沒有所選字段的 getter
wrap.return.value.existing.class.does.not.have.appropriate.function Object() { [native code] }.conflict=現有類沒有適當的構造函數
wrap.return.value.anonymous.class.presentation=匿名 {0}
empty.title=空
separator.annotations.to.copy=要複製的註解
action.go.to.implementation.text=轉到實現
action.go.to.subclass.text=轉到子類
action.go.to.overriding.methods.text=轉到重寫方法
action.go.to.super.method.text=轉到 super 方法
tooltip.recursive.call=遞歸調用
label.compact.function Object() { [native code] }=壓縮構造函數
label.canonical.function Object() { [native code] }=規範構造函數
edit.contract.dialog.checkbox.pure.method=方法為純方法(沒有副作用)
separator.mark.as.entry.point.if.annotated.by=如果已註解，則標記為入口點:
separator.mark.field.as.implicitly.written.if.annotated.by=如果已註解，則將字段標記為隱式寫入:
rename.super.methods.chooser.popup.title={0} 具有 super 方法
rename.super.base.chooser.popup.title={0} {1, choice, 0#實現|1#重寫} {2} 的方法
add.methods.dialog.or=\ 或
command.name.delegate.detected.change=委託
encapsulate.fields.dialog.javadoc.title=Javadoc
find.jar.hint.text.no.libraries.found.for.fqn=未找到 ''{0}'' 的庫
dependant.sdk.unsatisfied.dependency.message=需要先配置 Java SDK
javadoc.gen.error.modules.without.module.info=IDEA 無法生成 Javadoc，因為模塊 {0} 不含 module-info.java 檔案
javadoc.gen.error.module.source.path.is.not.evaluated=IDEA 無法生成 Javadoc，因為無法評估 module-source-path
generate.members.implement.command=實現
code.style.settings.angle.spacing.brackets=尖括號
code.style.settings.spacing.after.closing.angle.bracket=右尖括號之後
code.style.settings.spacing.around.type.bounds=類型界限周圍
non.code.annotations.explanation.external.and.inferred=外部<br/>和<i>推斷</i><br/>註解
non.code.annotations.explanation.external.and.inferred.available=外部和<i>推斷</i>註解可用。
non.code.annotations.explanation.external=外部<br/>註解
non.code.annotations.explanation.external.available=外部註解可用。
non.code.annotations.explanation.inferred=<i>推斷</i><br/>註解
non.code.annotations.explanation.inferred.available=<i>推斷</i>註解可用。
non.code.annotations.explanation.full.signature=完整簽名:
type.migration.command.name=TypeMigration
dfa.constraint.not.null=非 null
dfa.constraint.0.not.null={0}(非 null)
dfa.constraint.null.or.0=null 或 {0}
label.class.pattern.syntax.explanation=將此方法留空以表示構造函數\n任何 * 將匹配限定名稱中的一個或多個字符(包括點)
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0#模塊|2#模塊}{1}{0, choice, 0#不|2#不}引用具有 IntelliJ IDEA 可空性註解的 ''{2}'' 庫。是否要立即添加{0, choice, 0#依賴項|2#依賴項}?
tab.title.slices.grouped.by.nullness=\ (按可空性分組)
exclude.0.from.auto.import=從自動導入中排除 ''{0}''
column.name.method.entry.point=方法
column.name.class.entry.point=類
column.name.with.subclasses.entry.point=包含子類
code.vision.implementations.hint={0, choice, 1#1 個實現|2#{0,number} 個實現}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
code.vision.overrides.hint={0, choice, 1#1 個重寫|2#{0,number} 個重寫}
hint.text.tostring.method.could.not.be.created.from.template=無法從模板 ''{0}'' 創建 ''function toString() { [native code] }()'' 方法
hint.text.tostring.template.invalid=function toString() { [native code] }() 模板 ''{0}'' 無效
command.name.generate.tostring=生成 function toString() { [native code] }()
column.name.ignore.suppressions=忽略禁止
ignored.suppressions=已忽略禁止:
hint.text.removed.imports=已移除 {0} 個{1, choice, 0#導入|1#導入}
hint.text.added.imports=，已添加 {0} 個{1, choice, 0#導入|1#導入}
hint.text.rearranged.imports=已重新排列導入
enum.constant.ordinal=枚舉常量序數: 
tab.title.infer.nullity.preview=推斷可空性預覽
inspection.message.full.description=完整描述
popup.title.debug.recent.tests=調試最近的測試
list.item.suite=[套件] {0}
list.item.configuration=[配置] {0}
no.jre.description=<無 JRE>
popup.content.tests.were.not.found.in.module.use.instead=改用{0, choice, 0#模塊 {1} |1# \n{2} 之一\n}
postfix.template.provider.name=Java
postfix.template.condition.void.name=void
postfix.template.condition.non.void.name=非 void
postfix.template.condition.boolean.name=布爾
postfix.template.condition.number.name=數字
postfix.template.condition.not.primitive.type.name=非基元類型
postfix.template.condition.array.name=數組
inspection.redundant.unmodifiable.call.display.name=''{0}'' 包裝器的冗餘用法
inspection.redundant.unmodifiable.call.description=不可修改的集合包裝器的冗餘用法
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=解開實參
completion.override.implement.methods=重寫/實現方法…
lambda.tree.node.presentation=Lambda
inspection.meaningless.record.annotation.description=無意義的記錄註解
inspection.meaningless.record.annotation.message.method.and.parameter=註解不起任何作用: 它的目標是 METHOD 和 PARAMETER，但顯式聲明了訪問器和規範構造函數
inspection.meaningless.record.annotation.message.method=註解不起任何作用: 它的目標是 METHOD，但顯式聲明了相應的訪問器
inspection.meaningless.record.annotation.message.parameter=註解不起任何作用: 它的目標是 PARAMETER，但顯式聲明了規範構造函數
header.method.to.be.converted=要轉換的方法
accessible.name.change.modifier=更改修飾符
usages.telescope={0,choice, 0#0 個用法|1#1 個用法|2#{0,number} 個用法}
press.to.navigate=按 {0} 導航
label.jvm.method.name=JVM 方法名稱
link.configure.classes.excluded.from.completion=配置從補全中排除的類
inspection.preview.feature.0.is.preview.api.message={0} 是預覽 API，可能會在將來的版本中移除
progress.title.detect.overridden.methods=檢查重寫方法
intention.name.iterate.over=迭代 {0}
advanced.settings.group.compiler=編譯器
advanced.setting.compiler.automake.allow.when.app.running=即使開發的應用程序當前正在運行，也允許自動 make 啟動
advanced.setting.compiler.automake.allow.when.app.running.description=自動啟動 make 最終可能會刪除該應用程序所需的一些類。

dialog.title.check.functional.interface.candidates=檢查功能接口候選項…
scheduled.thread.pool.executor.with.zero.core.threads.display.name=帶零個核心線程的 'ScheduledThreadPoolExecutor'
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' 不應具有零個核心線程
popup.content.tests.were.not.found.in.module=在模塊 ''{0}'' 中找不到測試。
popup.content.tests.were.not.found.in.module.search.in.dependencies=改為在模塊依賴項中搜尋
find.options.include.accessors.checkbox=搜尋訪問器(&A)
find.options.include.accessors.base.checkbox=搜尋訪問器的基方法(&E)
find.options.include.accessors.base.checkbox.comment=預設使用頂層層次結構方法作為尋找用法目標
find.options.search.overriding.methods.checkbox=在重寫方法中搜尋(&O)
find.what.search.for.base.methods.checkbox=搜尋基方法用法(&E)
find.what.search.for.base.methods.checkbox.comment=預設使用頂層層次結構方法作為尋找用法目標
popup.title.select.target.code.block=選擇目標代碼塊
target.code.block.presentable.text=包含塊
conflict.message.method.will.override.method.base.class=重命名的 {0} 將重寫基 {1} 的方法
intention.category.annotations=Java/註解
intention.category.comments=Java/註釋
intention.category.concurrency=Java/並發
intention.category.conditional.operator=Java/條件
intention.category.control.flow=Java/控制流
intention.category.declaration=Java/聲明
intention.category.i18n=Java/國際化
intention.category.imports=Java/導入
intention.category.junit=Java/JUnit
intention.category.other=Java/其他
intention.category.refactorings=Java/重構
intention.category.streams=Java/流
intention.category.strings=Java/字符串
intention.category.try.statements=Java/Try 語句
intention.category.code.style=Java/代碼樣式
intention.category.expressions=Java/表達式
progress.title.looking.for.jdk=正在尋找 JDK…
intention.category.collections=Java/集合
dialog.title.check.configuration=檢查配置…
dialog.message.template.not.found=找不到模板
dialog.message.template.not.applicable=模板不適用
dialog.message.class.not.found=找不到模板類 ''{0}''
notification.content.was.set.up=已為項目設定了 JDK ''{0}''
notification.content.change.jdk=更改 JDK
nullable.notnull.annotation.used.label=用於生成代碼的註解:
button.to.another.directory=移至另一個目錄 (&D)
button.to.another.source.root=移至另一個源根(&S)
where.do.you.want.to.move.directory.prompt=您要將 ''{0}'' 移至何處？
loading.additional.annotations=正在加載其他註解…
tooltip.anonymous=匿名
tooltip.has.several.functional.implementations=有多個函數實現
tooltip.implements.method=實現方法
tooltip.in=位置
tooltip.is.functionally.implemented.in=函數實現位置:
tooltip.is.implemented.by=實現對象:
tooltip.is.implemented.by.several.subclasses=由多個子類實現
tooltip.is.implemented.in=在以下位置實現:
tooltip.is.implemented.in.several.subclasses=在多個子類中實現
tooltip.is.overridden.by.several.subclasses=被多個子類重寫
tooltip.is.overridden.in=在以下位置被重寫:
tooltip.is.overridden.in.several.subclasses=在多個子類中被重寫
tooltip.is.subclassed.by=被以下對象子類化
tooltip.overrides.method=重寫方法
tooltip.via.subclass=通過子類
label.ignore.complicated.fix=當內聯形參初始值設定項不成功時忽略
tooltip.implements.method.in=在以下位置實現方法:
tooltip.overrides.method.in=在以下位置重寫方法:
progress.title.calculate.applicable.types=計算適用類型…
completion.inner.scope.tail.text=（來自 {0} 塊）
completion.inner.scope=內部
javadoc.documentation.url.checked=已檢查以下文檔 {0, choice, 1#URL|2#URL}：
javadoc.edit.api.docs.paths=編輯 API 文檔路徑
javadoc.generate.defined.in=定義位置
inspection.unused.symbol.check.parameters.excluding.hierarchy=排除層次結構
tooltip.reassigned.local.variable=重新分配的局部變量
tooltip.reassigned.parameter=重新指定的形參
intention.family.name.edit.color.settings=編輯重新分配的變量的顏色設定
intention.name.edit.color.settings=編輯 ''{0}'' 顏色設定
javadoc.generate.options.separator=生成選項
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=移除冗餘的可選鏈
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=可選鏈可被消除
inspection.optional.get.without.is.present.method.reference.message=<code>#ref</code> 未進行 'isPresent()' 檢查
inlay.parameters.java.method.name.contains.parameter.name=從方法名中清除預期實參時接受單個實參的方法，如訪問器方法。
inlay.parameters.java.multiple.params.same.type=對具有同一類型的多個非文字實參的方法的調用。
inlay.parameters.java.build.like.method=返回方法本身操作的類的實例的方法，例如，StringBuilder 鏈中的調用或 Java 8 Stream API 中的中間操作。
inlay.parameters.java.simple.sequentially.numbered=接受多個形參的方法，這些形參的名稱由一個字母後跟一個數字組成。
inlay.parameters.java.enums=使用參數化構造函數的枚舉常量聲明。
inlay.parameters.java.new.expr=對參數化構造函數的調用。
inlay.parameters.java.clear.expression.type=使用複雜表達式作為實參的方法調用，例如，三元運算符或 Java 13 switch 語句。
add.to.permits.list.family.name=將類添加到許可列表
raw.variable.type.can.be.generic.cast.quickfix=將轉換類型更改為 {0}
raw.variable.type.can.be.generic.cast.quickfix.family=參數化轉換類型
inlay.MethodChainsInlayProvider.description=調用鏈中的方法返回類型.
inlay.JavaLens.usages=項目中類或方法的使用次數。點擊提示可導航到用法。
inlay.JavaLens.inheritors=類或接口具有的後代數量。點擊提示可導航到從此類或接口繼承的代碼。
inlay.RelatedProblems.description=項目中與類或成員簽名相關的問題數。例如：缺少形參，錯誤的返回類型等。<br><br>對於同一檔案內的問題，提示不會出現。
intention.family.name.move.class.to.test.root=將類移至測試根
intention.name.move.class.to.test.root=將 ''{0}'' 移至測試根
inlay.annotation.hints.inferred.annotations=IntelliJ IDEA 通過掃描庫和項目代碼生成的註解。這些註解可以幫助您理解代碼約定，並提高靜態分析的能力。註解包括：<br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href='https://www.jetbrains.com/help/idea/inferring-nullity.html#inferred-annotations'>文檔</a>
inlay.annotation.hints.external.annotations=存儲在原始碼之外的註解。<br>當您需要註解時，這些註解會很有用，但不能將其添加到原始碼（例如，在使用庫代碼時）。<br><br><a href='https://www.jetbrains.com/help/idea/external-annotations.html'>文檔</a>
title.related.problems.inlay.hints=相關問題
title.code.vision.inlay.hints=Code Vision
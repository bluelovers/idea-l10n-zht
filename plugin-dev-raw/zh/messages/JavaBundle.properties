abstract.class.not.allowed=不允許 abstract 類
access.static.via.instance=通過實例引用存取 static 成員
action.analyzing.cyclic.dependencies.in.scope={0}的迴圈依賴
action.create.new.class=創建新的類
action.create.new.class.description=創建新 Java 類
action.create.new.module-info.description=創建新的 module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=創建新的 package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=分析迴圈依賴
action.description.copy.whole.thread.dump.to.clipboard=將整個執行緒轉儲複製到剪貼簿
action.description.group.by.scope=按範圍類型分組 (產品, 測試, 庫)
action.description.group.threads.with.identical.stacktraces=組合具有相同堆疊跟踪的執行緒
action.description.mark.directory.as.a.0.for.generated.files=為生成的檔案將目錄標記為{0}
action.description.mark.directory.as.an.ordinary.0=將目錄標記為普通{0}
action.description.show.only.threads.containing.a.specific.string=僅顯示包含特定字串的執行緒
action.group.by.package=軟體套件
action.group.by.scope.type=按範圍類型分組
action.implement.method=實作方法
action.implement.methods=實作方法
action.override.method=覆寫方法
action.override.methods=覆寫方法
action.text.0.on.parameter.1=在參數 ''{1}'' 上{0}
action.text.choose.class.in.0=選擇 {0} 中的類…
action.text.copy.to.clipboard=複製到剪貼簿
action.text.edit.template=編輯模板
action.text.enter.class.name=輸入類名…
action.text.generated.root.0=生成的{0}
action.text.merge.identical.stacktraces=合併相同的堆疊跟踪
action.text.show.methods.to.implement=顯示要實作的方法
action.text.show.quick.list=顯示快速列表
action.text.unmark.generated.0=取消標記生成的{0}
action.GotoSuperClass.text=轉到超類 (_U)
action.GotoSuperClass.MainMenu.text=超類(_U)
action.GotoSuperClass.description=導航到當前類擴展或實作的類的宣告
add.to.permits.list=將 ''{0}'' 添加到密封類 ''{1}'' 的 permits 列表
annotate.intention.chooser.title=選擇要添加的註解
assignment.to.declared.variable.problem.descriptor=變數''{0}''是自我賦值初始化
assignment.to.itself.problem.descriptor=變數''{0}''是分配給自己
assignment.to.itself.quickfix.name=移除自我賦值
bean.property=Bean屬性
boolean.method.is.always.inverted.display.name=布爾方法總是反向的
boolean.method.is.always.inverted.problem.descriptor=布爾方法 '#ref' 總是反轉
button.add.blank=添加空白
button.add.class=添加類...
button.add=添加…
button.add.package=添加軟體套件…
button.add.pattern=添加模式...
button.annotations=註解...
button.base.method=基方法(&B)
button.code.patterns=程式碼模式…
button.current.method=當前方法(&C)
button.text.settings=設定…
cast.expression=插入轉換表達式
cast.to.0=轉換為''{0}''
change.color.command.text=更改顏色
change.uid.action.name=隨機更改 'serialVersionUID' 初始設定式
checkbox.after.description=在描述後
checkbox.after.parameter.descriptions=在參數描述後
checkbox.after.return.tag=在return後
checkbox.align.parameter.descriptions=對齊參數說明
checkbox.align.thrown.exception.descriptions=對齊拋出異常說明
checkbox.annotate.local.variables=註解局部變數
checkbox.collapse.annotations=註解
checkbox.collapse.anonymous.classes=匿名類
checkbox.collapse.closures="閉包" (在 Java 8 前，實作一個方法的匿名類)
checkbox.collapse.end.of.line.comments=<html>行尾註釋序列</html>
checkbox.collapse.generic.constructor.parameters=<html>通用構造函數和方法參數</html>
checkbox.collapse.i18n.messages=<html>I18n字串</html>
checkbox.collapse.inferred.type=使用推斷類型取代 'var'
checkbox.collapse.inner.classes=內部類
checkbox.collapse.multiline.comments=多行註釋
checkbox.collapse.one.line.methods=<html>一行方法<html>
checkbox.collapse.simple.property.accessors=<html>簡單屬性存取器</html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.comments.and.javadoc.count.as.content=註釋和 javadoc 計為內容
checkbox.deprecated.members=棄用的成員
checkbox.do.not.indent.top.level.class.members=不縮排頂層類成員
checkbox.do.not.wrap.after.single.annotation=單個註解後不換行
checkbox.do.not.wrap.one.line.comments=一行註釋不分行
checkbox.enable.javadoc.formatting=啟用JavaDoc格式
checkbox.enable.leading.asterisks=啟用前導星號
checkbox.generate.p.on.empty.lines=在空行中生成 "<p>"
checkbox.html.report.inaccessible.symbols=<html>報告無法存取的符號<br>(javadoc 工具可能無法創建超鏈接)
disable.report.inaccessible.symbols.fix=不報告無法存取的符號
checkbox.ignore.fields.used.in.multiple.methods=忽略多個方法中使用的欄位
checkbox.ignore.simple.setters=忽略簡單的 setter
checkbox.insert.imports.for.inner.classes=插入匯入到內部類
checkbox.iterate.unknown.stream.sources.via.stream.iterator=通過 Stream.iterator() 迭代未知的流源
checkbox.keep.empty.lines=保留空行
checkbox.keep.empty.param.tags=保持空 @param 標籤
checkbox.keep.empty.return.tags=保持空 @return 標籤
checkbox.keep.empty.throws.tags=保持空 @throws 標籤
checkbox.keep.invalid.tags=保持無效標籤
checkbox.make.generated.local.variables.final=將生成的局部變數設為 final
checkbox.make.generated.parameters.final=將生成的參數設為 final
checkbox.param.description.on.new.line=參數描述在新行
checkbox.param.indent.on.continuation=縮排連續線
checkbox.prefer.longer.names=提升較長的名稱
checkbox.preserve.line.feeds=保留換行
checkbox.spaces.record.header=記錄標頭
checkbox.spaces.before.colon.in.foreach=在 foreach 中的冒號之前
checkbox.spaces.inside.one.line.enum=在一行枚舉大括號內
checkbox.suggest.conversion.to.map.computeifabsent=建議轉換為 Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=建議轉換為 Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=建議轉換為 Map.merge
checkbox.suggest.conversion.to.map.putifabsent=建議轉換為 Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=建議轉換為 Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=建議取代，即使 lambda 可能有副作用
checkbox.suppress.with.suppresswarnings=使用 @SuppressWarnings 禁止
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=將 'get(k) != null' 視為與 'containsKey(k)' 相同 (可能更改語意)
checkbox.use.fully.qualified.class.names=使用完全限定類名
checkbox.use.single.class.import=使用單個類匯入
checkbox.use.throws.rather.than.exception=用 @throws 而不是 @exception
checkbox.warn.if.only.foreach.replacement.is.available=只要 'forEach' 取代可用，就發出警告
checkbox.warn.if.the.loop.is.trivial=迴圈不重要時發出警告
checkbox.wrap.at.right.margin=在右頁邊距處換行
choose.class=選擇類
chooser.text.choose.where.to.save.0=選擇要儲存 ''{0}'' 的位置
chooser.title.select.path.to.save.jar=選擇要儲存 Jar 的路徑
class.decorator.or.has.default.constructor=''{0}'' 應具有預設構造函數或者實作 ''Decorator'' 模式
class.filter.editor.add.dialog.title=新的過濾器
class.filter.editor.choose.class.title=選擇類
class.has.no.default.constructor=''{0}'' 沒有預設的構造函數
class.is.not.a.subclass=''{0}'' 未分配到 ''{1}''
class.is.not.concrete=''{0}'' 不是一個具體類
class.is.not.public=''{0}'' 不為 public
class.not.found.error.message=未找到類 ''{0}''
code.style.generation.override.method.signature=覆寫方法簽名
code.style.generation.repeat.synchronized.modifier=重複 synchronized 修飾符(&S)
code.style.generation.replace.null.check=將 null 檢查取代為 Objects::nonNull 或 Objects::isNull
code.style.generation.use.class.isInstance=如果可能，請使用 Class::isInstance 和 Class::cast
code.style.generation.use.integer.sum=如果可能，請使用 Integer::sum 等
combobox.paste.insert.imports=貼上時插入匯入(&I):
command.create.class.from.template=從模板創建類
command.create.new.subdirectory=創建新子目錄
command.name.insert.block.statement=插入塊語句
command.name.updating.package.statement=更新 package 語句
comment.the.class.will.be.created.in.the.package.0=類將在軟體套件 ''{0}'' 中創建
completion.class.name.hint.2=再次按{0}可以在搜尋時忽略模組依賴關係
completion.no.suggestions.of.type=沒有類型為{0}的建議
completion.smart.aslist.hint=再次按{0}尋找{1}的集合(Array)
completion.smart.chain.hint=再次按{0}搜尋方法的調用鏈
completion.smart.hint=按{0}僅顯示適合類型的變數
completion.smart.toar.hint=再次按{0}尋找{1}的集合
completion.smart.type.generate.anonymous.body=生成匿名體
completion.unknown.type=未知類型{0}
configurable.EqualsHashCodeTemplatesPanel.display.name=模板
configurable.GenerateToStringConfigurable.display.name=設定
configurable.TemplatesPanel.display.name=模板
label.new.template.name=新模板名稱:
dialog.title.create.new.template=創建新模板
dialog.title.copy.template=複製模板
configure.annotations.option=設定註解…
convert.compareto.expression.to.equals.call=將 'compareTo()' 表達式轉換為 'equals()' 調用
convert.compareto.expression.to.equals.call.may.change.semantics=將 'compareTo()' 表達式轉換為 'equals()' 調用 (可能更改語意)
copy.abstract.method.intention.name=使用現有實作''{0}''
copy.abstract.method.no.existing.implementations.found=沒有找到現有的實作
copy.abstract.method.popup.title=選擇要複製的實作
copy.abstract.method.title=使用 abstract 方法實作
copy.paste.reference.notification=<html>已添加 {0} 個{0, choice, 1#匯入|2#匯入}<p><span><a href=''show''>檢查添加的匯入…</a></span></html>
cyclic.dependencies.progress.text=正在建置依賴關係圖
cyclic.dependencies.scope.dialog.module.button={0}模組''{1}'' (&M)
cyclic.dependencies.scope.dialog.project.button={0}整個專案 (&P)
cyclic.dependencies.scope.dialog.title=指定{0}範圍
cyclic.dependencies.scope.include.test.sources.option=包含測試程式碼(&T)
cyclic.dependencies.tree.cycle.node.text=迴圈
cyclic.dependencies.usage.view.initial.text=從左邊樹選擇分析的軟體套件
cyclic.dependencies.usage.view.root.node.text=在軟體套件 ''{1}'' 中使用軟體套件 ''{0}''
dataflow.from.here=流出此處的數據流
dataflow.to.here=流入此處的數據流
deannotate.intention.action.text=取消註解 {0}
deannotate.intention.action.several.text=取消註解…
deannotate.intention.action.family.name=取消註釋
deannotate.intention.chooser.title=選擇要刪除的註解
default.file.template.description=預設檔案模板
default.file.template.display.name=預設檔案模板的使用
default.file.template.edit.template=編輯模板...
default.file.template.replace.with.actual.file.template=取代為實際檔案模板
default.package.presentable.name=<預設>
dependencies.libraries.node.text=庫
dependencies.tree.node.default.package.abbreviation=<預設軟體套件>
dialog.create.class.destination.package.label=目標軟體套件:
dialog.create.class.label=創建 {0}:
dialog.create.class.name=創建{0}{1}
dialog.create.class.package.chooser.title=選擇目標軟體套件
dialog.create.field.from.parameter.already.exists.text=使用現有欄位''{0}''？
dialog.create.field.from.parameter.already.exists.use.existing.button=使用現有欄位
dialog.create.field.from.parameter.already.exists.title=欄位已經存在
dialog.create.field.from.parameter.declare.final.checkbox=宣告 final(&F)
dialog.create.field.from.parameter.field.name.label=名稱:
dialog.create.field.from.parameter.field.type.label=欄位的類型:
dialog.create.field.from.parameter.title=創建欄位
dialog.edit.template.checkbox.smart.type.completion=類型符合補全(&O)
dialog.edit.template.checkbox.use.static.import=盡可能使用靜態匯入(&I)
dialog.import.on.paste.title=選擇要匯入的類
dialog.import.on.paste.title2=選擇要匯入的元素
dialog.import.on.paste.title3=選擇要移除的匯入
dialog.message.0.update.existing.class={0}。更新現有的類?
dialog.message.create.test.in.the.same.source.root=在相同的源根中創建測試?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=推斷可空性註解需要將專案語言級別設定為 1.5 或更高。
dialog.message.jetbrains.annotations.library.is.missing=缺少 JetBrains 註解庫。\n沒有庫，IntelliJ IDEA 將無法執行分析。要添加嗎?
dialog.message.no.places.found.to.infer.nullable.notnull=未找到要推斷 @Nullable/@NotNull 的位置
dialog.paste.on.import.text=<html>您所貼上的程式碼段使用的是不是在新的形勢下,可以通過匯入類。<br/>選擇類,您要匯入到新檔案。</html>
dialog.paste.on.import.text2=<html>您所貼上的程式碼段使用,是不是在新的上下文存取的匯入元件。<br/>選擇元素,您想匯入到新檔案。</html>
dialog.paste.on.import.text3=<html>您貼上的程式碼段在當前上下文中引入了新的匯入。<br/>選擇您想要消除的匯入。</html>
dialog.title.choose.0.parameters=選擇 {0} 參數
dialog.title.choose.class=選擇類
dialog.title.configure.annotations=設定註解
dialog.title.configure.code.patterns=設定程式碼模式
dialog.title.create.class.in.package=在軟體套件中創建類
dialog.title.create.missed.tests=創建缺少的測試
dialog.title.edit.method.contract=編輯方法約定
dialog.title.edit.range=編輯範圍
dialog.title.infer.nullity=推斷可空性
action.description.infer.nullity.annotations=推斷可空性註解
dialog.title.infer.nullity.results=推斷可空性結果
dialog.title.no.test.roots.found=未找到測試根
dialog.title.process.duplicates=處理重複項
dialog.title.super.method.found=發現 super 方法
do.not.import.inner.classes.for=按短名稱排除內部類:
do.not.import.inner.classes.no.classes=未定義內部類
editbox.blanklines.around.initializer=初始設定式周圍:
editbox.class.count.to.use.import.with.star=將 import 與 '*' 搭配使用的類計數:
editbox.names.count.to.use.static.import.with.star=將靜態 import 與 '*' 搭配使用的名稱計數:
enum.not.allowed=枚舉不被允許
error.attempt.to.generate.constructor.for.anonymous.class=不能添加構造函數到匿名類
error.hint.no.expression.found=找不到表達式
error.package.already.contains.package-info=''package-info.java'' 的軟體套件已經存在“{0}”
error.package.already.contains.package.html=軟體套件 ''{0}'' 已經有一個 ''package.html'' 檔案。仍要創建 ''package-info.java''?
error.package.html.found.title=發現“package.html”
error.text.this.is.not.a.valid.java.class.name=這不是有效的 Java 類名
exclude.0.from.completion=從補全中排除 ''{0}''
exclude.accessors=排除存取器(&E)
exclude.from.completion.group=從自動匯入和補全中排除:
exclude.from.imports.no.exclusions=添加類、軟體套件或成員
exclude.from.imports.no.exclusions.2=以從自動匯入和補全中排除
exclude.table.mask=類、軟體套件或成員
exclude.table.scope.column=範圍
export.to.html.generate.hyperlinks.checkbox=生成超鏈接指向類 (&H)
external.annotation.prompt=外部註解提示
external.annotations.external.option=從外部添加(&E)
external.annotations.in.code.option=添加程式碼(&C)
external.annotations.root.chooser.description=外部註解將被儲存在相應的資料夾
external.annotations.root.chooser.title=選擇{0}的外部註解根
external.annotations.suggestion.message=<html><body>如果您的程式碼中不需要註解，可以使用外部存儲。<br>要設定外部註解，請指定放置包含註解的檔案的根目錄</body></html>
find.field.accessors.prompt=搜尋欄位 ''{0}'' 的存取器?
find.field.accessors.title=已找到欄位存取器
find.options.include.overloaded.methods.checkbox=多載方法(&V)
find.what.derived.classes.checkbox=派生類(&D)
find.what.derived.interfaces.checkbox=派生接口(&D)
find.what.fields.usages.checkbox=欄位的用法(&F)
find.what.implementing.classes.checkbox=實作類(&I)
find.what.implementing.methods.checkbox=實作方法(&I)
find.what.implicit.to.string.checkbox=隱式調用(&M)
find.what.methods.usages.checkbox=方法的用法 (&M)
find.what.overriding.methods.checkbox=覆寫方法(&R)
find.what.usages.checkbox=用法 (&U)
find.what.usages.of.classes.and.interfaces=類和接口的用法 (&C)
generate.button.title=生成
generate.constructor.fields.chooser.title=選擇要通過構造函數初始化的欄位
generate.constructor.super.constructor.chooser.title=選擇超類構造函數
generate.delegate.target.chooser.title=選擇目標生成的代表
generate.equals.and.hashcode.already.defined.title=生成 'equals()' 和 'hashCode()'
generate.equals.and.hashcode.already.defined.warning=對於類{0},方法''boolean equals(Object)'' 和 ''int hashCode()''已經定義,要繼續刪除它們嗎?
generate.equals.and.hashcode.already.defined.warning.anonymous=對於這個匿名類,方法'boolean equals(Object)' 和 'int hashCode()'已經定義,要繼續刪除它們嗎?
generate.equals.hashcode.accept.sublcasses=接受子類作為 equals() 方法的參數(&S)
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>通常不符合 Object.equals() 接受範圍<br>但要使生成的方法在框架中正確工作，可能會需要接受子類<br>在框架中, 會生成像Hibernate這樣的代理子類。</body></html>
generate.equals.hashcode.equals.fields.chooser.title=選擇要包含在 equals() 中的欄位(&F)
generate.equals.hashcode.hashcode.fields.chooser.title=選擇要包含在 hashCode() 中的欄位(&F)
generate.equals.hashcode.internal.error=內部錯誤
generate.equals.hashcode.non.null.fields.chooser.title=選擇所有非空欄位 (&F)
generate.equals.hashcode.template=模板(&T):
generate.equals.hashcode.use.getters=在程式碼生成過程中使用 &getters
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode()不支持陣列
generate.equals.hashcode.wizard.title=生成 equals() 和 hashCode()
generate.equals.template.title=Equals 模板:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals()不支持嵌套的陣列
generate.equals.warning.generated.equals.could.be.incorrect=生成的Object[]的equals()可能不正確
generate.getter.fields.chooser.title=選擇要生成 Getter 的欄位
generate.getter.setter.title=選擇要生成 Getter 和 Setter 的欄位
generate.getter.template=Getter 模板(&G):
generate.hashcode.template.title=HashCode 模板:
generate.record.constructor.title=生成記錄構造函數
generate.setter.fields.chooser.title=選擇要生成 Setter 的欄位
generate.setter.template=Setter 模板(&S):
generate.tostring.already.exist.border=當方法已存在時
generate.tostring.available.implicit.variables.label=可用的隱式變數:<br/>{0}
generate.tostring.exclude..transient=排除 transient 欄位
generate.tostring.exclude.by.field.name=按名稱排除欄位 (reg exp)
generate.tostring.exclude.by.field.type=按類型名稱排除欄位 (reg exp)
generate.tostring.exclude.by.name=按名稱排除方法 (reg exp)
generate.tostring.exclude.by.return.type=按返回類型名稱排除方法 (reg exp)
generate.tostring.exclude.constant.fields=排除常數欄位
generate.tostring.exclude.enum.fields=排除枚舉欄位
generate.tostring.exclude.logger=排除記錄器欄位 (Log4j、JDK 日誌記錄、Jakarta Commons 日誌記錄)
generate.tostring.exclude.static.fields=排除 static 欄位
generate.tostring.fully.qualified.class.name=在程式碼生成中使用完全限定類名 ($classname)
generate.tostring.getters.in.generated.code=在程式碼生成中啟用 getter ($methods)
generate.tostring.handle.exception.error.message=執行操作時引發不可恢復的異常 - 請參閱 IDEA 日誌以獲取詳細資訊 (堆疊跟踪應位於 idea.log 中):\n{0}
generate.tostring.handle.exception.plugin.warning.message=執行操作時引發 PluginException - 請參閱 IDEA 日誌以獲取詳細資訊 (堆疊跟踪應位於 idea.log 中):\n{0}
generate.tostring.handle.exception.velocity.error.message=生成程式碼時出現 Velocity 錯誤 - 請參閱 IDEA 日誌以獲取更多詳細資訊 (堆疊跟踪應位於 idea.log 中):\n{0}
generate.tostring.insert.border=在哪裡插入?
generate.tostring.method.already.exists.dialog.me=ssage=取代現有的 {0} 方法
generate.tostring.method.already.exists.dialog.title=方法已存在
generate.tostring.move.to.generated.checkbox=將文字游標移動到生成的方法
generate.tostring.settings=設定
generate.tostring.sort.ascending=升序
generate.tostring.sort.checkbox=對元素進行排序
generate.tostring.sort.descending=降序
generate.tostring.sort.super=超類成員優先
generate.tostring.tab.title=toString() 生成設定
generate.tostring.template.label=模板(&T):
generate.tostring.title=生成 toString()
goto.super.class.chooser.title=選擇超類或接口
group.javadoc.alignment=對齊
group.javadoc.blank.lines=空行
group.javadoc.invalid.tags=無效標籤
group.javadoc.other=其他
gutter.implemented.method=已實作方法
gutter.implementing.method=實作方法
gutter.overridden.method=覆寫的方法
gutter.overriding.method=覆寫方法
gutter.service=服務
gutter.sibling.inherited.method=同級繼承的方法
highlight.exceptions.thrown.chooser.title=選擇異常類以高亮顯示
highlight.imported.classes.chooser.title=選擇匯入高亮的類
highlight.imported.members.chooser.title=選擇匯入高亮的成員
highlight.overridden.classes.chooser.title=從...選擇高亮覆寫方法的類
icon.preview=圖標預覽
ignore.imports.and.formatting=忽略匯入和格式設定
illegal.name.validation.info=非法名稱: {0}
import.layout.static.imports.separately=單獨布局靜態匯入
import.statically=靜態匯入
include.accessors=包含存取器(&I)
infer.nullity.progress=正在對結果進行後期處理…
insert.override.annotation=插入 @Override 註解(&O)
inspection.assert.quickfix=斷言''{0}''
inspection.capturing.cleaner=已傳遞到 Cleaner.register() 的可執行物件捕獲 ''{0}'' 引用
inspection.capturing.cleaner.description=清理器捕獲物件引用
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=更改變數類型並移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=將 ''{0}'' 的類型更改為 ''{1}'' 並移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.message=可以通過將 ''{0}'' 的類型更改為 ''{1}'' 來移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.name=太弱的變數類型導致不必要的轉換
inspection.charset.object.can.be.used.display.name=可以使用標準 'Charset' 物件
inspection.charset.object.can.be.used.fix.family.name=使用字符集常數
inspection.charset.object.can.be.used.message=可以改用{0}
inspection.collection.factories.fix.family.name=取代集合工廠回調
inspection.collection.factories.fix.name=取代為 ''{0}.{1}()'' 調用
inspection.collection.factories.message=可被取代為 ''{0}.{1}()'' 調用
inspection.collection.factories.option.ignore.non.constant=僅在內容為常數時報告
inspection.collection.factories.option.suggest.ofentries=建議 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=可迭代物件用作 vararg
inspection.collection.used.as.vararg.message=可迭代物件作為 vararg 傳遞: 很可能應為陣列
inspection.comparator.result.comparison.display.name=compare 方法的可疑用法
inspection.comparator.result.comparison.fix.family.name=修正比較結果
inspection.comparator.result.comparison.problem.display.name=比較方法的結果與特定常數對比
inspection.conditional.break.in.infinite.loop=將條件移動到迴圈中
inspection.conditional.break.in.infinite.loop.description=無限迴圈中存在條件中斷
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=不建議取代為 'do while'
inspection.convert.to.local.quickfix=轉換為當地
inspection.data.flow.display.name=恒定條件和例外
inspection.data.flow.filter.notnull.quickfix=插入'filter(Objects::nonNull)'步驟
inspection.data.flow.nullable.quickfix.option=對可 null 值的方法/欄位/參數建議使用 @Nullable 註解
inspection.data.flow.true.asserts.option=不報告條件靜態證明始終為 <code>true</code> 的斷言
inspection.data.flow.ignore.assert.statements=忽略 assert 語句
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=讀取保證為常數的值時發出警告
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=將未註解的成員和參數視為 @Nullable
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=報告使用 null 文字實參用法的非 null 必需參數
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=報告始終返回非 null 值的可 null 方法
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=報告僅在某些程式碼路徑上發生的問題
inspection.data.flow.use.computeifpresent.quickfix=將 'compute' 取代為 'computeIfPresent'
inspection.dead.code.option.applet=小程序
inspection.dead.code.option.external=非 Java 檔案中使用的類
inspection.dead.code.option.main=<html><code>void main(String args[])</code> 方法</html>
inspection.dead.code.option.servlet=Servlet
inspection.default.annotation.param=預設註解參數值
inspection.duplicate.branches.in.switch.default.message='switch' 中的分支是預設分支的重複項
inspection.duplicate.branches.in.switch.delete.fix.family.name=刪除冗餘 'switch' 分支
inspection.duplicate.branches.in.switch.delete.fix.name=刪除冗餘 'switch' 分支
inspection.duplicate.branches.in.switch.display.name='switch' 中存在重複分支
inspection.duplicate.branches.in.switch.merge.fix.family.name=合併 'switch' 中的重複分支
inspection.duplicate.branches.in.switch.merge.fix.name=與 ''{0}'' 合併
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=與預設的 'switch' 分支合併
inspection.duplicate.branches.in.switch.message='switch' 中存在重複分支
inspection.duplicate.expressions.complexity.threshold=表達式複雜性閾值
inspection.duplicate.expressions.display.name=同一表達式存在多個符合項
inspection.duplicate.expressions.introduce.variable.fix.family.name=引入變數
inspection.duplicate.expressions.introduce.variable.fix.name=為 ''{0}'' 引入變數
inspection.duplicate.expressions.message=<code>#ref</code> 的多個匹配項 #loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=取代為表達式的其他可變符合項
inspection.duplicate.expressions.replace.other.occurrences.fix.name=將 ''{0}'' 取代為 ''{1}'' 的其他符合項
inspection.duplicate.expressions.reuse.variable.fix.family.name=重用變數
inspection.duplicate.expressions.reuse.variable.fix.name=為 ''{1}'' 重用變數 ''{0}''
inspection.empty.method.delete.quickfix=刪除不必要的方法
inspection.empty.method.problem.descriptor=方法只調用它的 super
inspection.empty.method.problem.descriptor1=空方法覆寫空方法
inspection.empty.method.problem.descriptor2=該方法為空
inspection.empty.method.problem.descriptor3=該方法和所有它的derivables是空的
inspection.empty.method.problem.descriptor4=此方法的所有實作都為空
inspection.endless.stream.description=非短路操作消耗無限流
inspection.equals.hashcode.display.name='equals()' 和 'hashCode()' 未配對
inspection.equals.hashcode.generate.equals.quickfix=生成 'equals()'
inspection.equals.hashcode.generate.hashcode.quickfix=生成 'hashCode()'
inspection.excessive.lambda.fix.family.name=常數取代lambda
inspection.excessive.lambda.fix.name=使用沒有lambda的''{0}''方法
inspection.excessive.lambda.message=過度使用 lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=將顯式實參取代為函數
inspection.explicit.argument.can.be.lambda.fix.name=使用包含函數實參的 ''{0}'' 方法
inspection.explicit.argument.can.be.lambda.message=顯式實參可以轉換為 lambda
inspection.explicit.array.filling.description=可被取代為單個 ''Arrays.{0}()'' 方法調用
inspection.explicit.array.filling.fix.family.name=將迴圈取代為 ''Arrays.{0}()'' 方法調用
inspection.explicit.array.filling.no.suggestion.for.set.all=不建議使用 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=新建陣列的冗餘初始化
inspection.explicit.array.filling.suggest.set.all=建議 'Arrays.setAll()'
inspection.export.results.callees=調用鏈
inspection.export.results.implicit.constructor=隱式構造函數 -
inspection.export.results.overrides.library.methods=覆寫庫方法
inspection.export.results.package=軟體套件
inspection.export.results.type.references=以下使用這種類型
inspection.field.can.be.local.display.name=可以為本地欄位
inspection.field.can.be.local.problem.descriptor=欄位可以被轉換為一個局部變數
inspection.field.can.be.local.quickfix.constructor=將欄位轉換為構造函數中的局部變數
inspection.field.can.be.local.quickfix.initializer=將欄位轉換為初始設定式部分中的局部變數
inspection.field.can.be.local.quickfix.one.method=將欄位轉換為方法 ''{0}'' 中的局部變數
inspection.fold.expression.fix.family.name=折疊表達式
inspection.fold.expression.into.stream.display.name=表達式可以折疊到流鏈中
inspection.fold.expression.into.stream.fix.name=將表達式折疊到流鏈中
inspection.fold.expression.into.string.display.name=表達式可以折疊到 'String.join' 中
inspection.fold.expression.into.string.fix.name=將表達式折疊到 'String.join' 中
inspection.forward.compatibility.name=前向相容性
inspection.fuse.stream.operations.display.name=後續步驟可以融合到Stream API鏈中
inspection.fuse.stream.operations.fix.family.name=將更多語句融入 Stream API 鏈
inspection.fuse.stream.operations.fix.name=將 {0} 融合到Stream API 鏈中
inspection.fuse.stream.operations.message=流可能被拓展取代 {0}
inspection.fuse.stream.operations.option.strict.mode=不建議使用 'toList()' 或 'toSet()' 收集器
inspection.handle.signature.change.type.fix.name=將類型更改為 ''{0}''
inspection.handle.signature.field.cannot.resolve=無法解析欄位''{0}''
inspection.handle.signature.field.not.static=欄位 ''{0}'' 不為 static
inspection.handle.signature.field.static=欄位 ''{0}'' 為 static
inspection.handle.signature.field.type=欄位''{0}''的類型是''{1}''
inspection.handle.signature.method.abstract=方法 ''{0}'' 在 ''{1}'' 中是 abstract 方法
inspection.handle.signature.method.not.static=方法 ''{0}'' 不為 static
inspection.handle.signature.method.static=方法 ''{0}'' 為 static
inspection.handle.signature.name=MethodHandle/VarHandle 類型不符合
inspection.handle.signature.not.subclass=調用者類 ''{0}'' 必須是 ''{1}'' 的子類
inspection.handle.signature.use.constructor.fix.family.name=使用構造函數多載之一
inspection.handle.signature.use.constructor.fix.name=使用構造函數''{0}''
inspection.handle.signature.use.method.fix.family.name=使用方法多載之一
inspection.handle.signature.use.method.fix.name=使用方法''{0}''
inspection.idempotent.loop.body=冪等迴圈體
inspection.illegal.character=非法字符
inspection.suspicious.ternary.in.varargs.display.name=vararg 方法調用中的可疑三元運算符
inspection.suspicious.ternary.in.varargs.description=vararg 調用中的三元運算符包含陣列和非陣列分支
inspection.suspicious.ternary.in.varargs.quickfix=包裝在陣列初始設定式中
inspection.insert.literal.underscores.display.name=不可讀的數字文字
inspection.insert.literal.underscores.family.name=將下劃線插入數字文字
inspection.javadoc.label.text=附加 Javadoc 標記:
inspection.javadoc.lint.display.name=Javadoc中的HTML問題(DocLint)
inspection.javadoc.method.problem.missing.param.tag=參數{0}缺少必需的標籤 <code>@param</code>
inspection.javadoc.method.problem.missing.tag.description={0}標籤說明已丟失
inspection.javadoc.option.ignore.deprecated=忽略標記為 @deprecated 的元素
inspection.javadoc.option.ignore.period=忽略期問題
inspection.javadoc.option.ignore.self.ref=忽略指向自己的Javadoc
inspection.javadoc.option.ignore.simple=忽略簡單的屬性存取器
inspection.javadoc.option.ignore.throws=忽略重複的'throws'標籤
inspection.javadoc.option.tab.title=類
inspection.javadoc.option.tab.title.field=欄位
inspection.javadoc.option.tab.title.inner.class=內部類
inspection.javadoc.option.tab.title.method=方法
inspection.javadoc.option.tab.title.module=模組
inspection.javadoc.option.tab.title.package=軟體套件
inspection.javadoc.problem.add.param.tag=為參數''{0}''添加標籤 @param
inspection.javadoc.problem.add.param.tag.family=添加缺少的Javadoc參數標籤
inspection.javadoc.problem.add.tag=添加標籤 @{0}{1}
inspection.javadoc.problem.add.tag.family=添加缺少的 Javadoc 標籤
inspection.javadoc.problem.cannot.resolve=無法解析符號{0}
inspection.javadoc.problem.descriptor=要求Javadoc不在
inspection.javadoc.problem.descriptor1=期在文檔缺失.使用期間由工具生成的Javadoc註釋的概述頁面
inspection.javadoc.problem.disallowed.tag=此處不允許使用標籤{0}
inspection.javadoc.problem.duplicate.param=重複的參數''{0}'' @param 標記
inspection.javadoc.problem.duplicate.tag=重複的 @{0} 標記
inspection.javadoc.problem.duplicate.throws=重複 @throws 或 @exception 標記為異常''{0}''
inspection.javadoc.problem.inaccessible=無法從此處存取符號 {0}
inspection.javadoc.problem.missing.tag=需要標記{0}是缺失的
inspection.javadoc.problem.missing.tag.description={0}在 @{1} 標記之後丟失
inspection.javadoc.problem.name.expected=應為名稱
inspection.javadoc.problem.pointing.to.itself=Javadoc指向本身
inspection.javadoc.problem.see.tag.expecting.ref=類/方法引用，引用文本或HTML鏈接，預計後 @see tag
inspection.javadoc.problem.wrong.tag=錯誤標籤{0}
inspection.javadoc.ref.display.name=宣告在Javadoc引用中有問題
inspection.javadoc.throws.or.exception.option=@throws 或 @exception
inspection.join.declaration.and.assignment.display.name=賦值可與宣告聯接
inspection.join.declaration.and.assignment.fix.family.name=聯接宣告和賦值
inspection.join.declaration.and.assignment.message=賦值可與 ''{0}'' 的宣告聯接
inspection.labeled.switch.rule.redundant.code.block.display.name=標記的 switch 規則具有冗餘程式碼塊
inspection.labeled.switch.rule.redundant.code.block.message=標記規則的程式碼塊冗餘
inspection.labeled.switch.rule.redundant.code.fix.name=取消標記規則的程式碼塊換行
inspection.lambda.to.method.call.fix.family.name=用方法調用取代lambda表達式
inspection.lambda.to.method.call.fix.name=用''{0}''取代lambda表達式
inspection.manual.min.max.calculation.description=可被取代為 ''Math.{0}()'' 調用
inspection.manual.min.max.calculation.disable.for.non.integral=禁用 float 和 double
inspection.map.foreach.display.name=可以使用 Map.forEach()
inspection.map.foreach.option.no.loops=不要報告迴圈
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=匿名s #ref #loc 可被取代為方法引用
inspection.message.can.be.replaced.with.0.constructor=可被取代為 ''{0}'' 構造函數
inspection.message.can.be.replaced.with.files.readstring=可被取代為 'Files.readString()'
inspection.message.can.be.replaced.with.optional.of.nullable=可被取代為 Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=可被取代為函數樣式的單個表達式
inspection.message.can.be.replaced.with.string.repeat=可被取代為 'String.repeat()'
inspection.message.lambda.parameter.type.is.redundant=Lambda 參數類型冗餘
inspection.message.pseudo.functional.style.code=偽函數樣式程式碼
inspection.message.redundant.default.parameter.value.assignment=冗餘的預設參數值賦值
inspection.message.replace.optional.with.if.statements=將 Optional 取代為 if 語句
inspection.no.jdk.error.message=沒有為此專案正確設定 JDK。無法進行檢查。
inspection.no.modules.error.message=此專案不包含模組。無法進行檢查。
inspection.notnull.field.not.initialized.display.name=@NotNull 欄位未初始化
inspection.notnull.field.not.initialized.option.implicit=忽略可以隱式初始化的欄位
inspection.notnull.field.not.initialized.option.setup=忽略在 setUp() 方法中初始化的欄位
inspection.null.value.for.optional.assigned.ignore.fix.name=將 Optional 與 null 比較時不發出警告
inspection.null.value.for.optional.assigned.message=Optional 值與 null 比較
inspection.null.value.for.optional.context.assignment=分配
inspection.null.value.for.optional.context.declaration=宣告
inspection.null.value.for.optional.context.lambda=lambda表達式
inspection.null.value.for.optional.context.parameter=參數
inspection.null.value.for.optional.context.return=return 語句
inspection.null.value.for.optional.fix.family.name=取代空的可選方法
inspection.null.value.for.optional.message=Null 用於 {0} 中的 ''Optional'' 類型
inspection.null.value.for.optional.option.comparisons=報告 Optional 與 null 的比較
inspection.nullable.problems.display.name=@NotNull/@Nullable 問題
inspection.nullable.problems.ignore.external.notnull=忽略外部 @NotNull(&I)
inspection.nullable.problems.method.overrides.notnull.option=<html>報告覆寫 @Nullable 的 @NotNull 參數和<br>覆寫 @NotNull 的 @Nullable 方法</html>(&P)
inspection.nullable.problems.method.overrides.option=報告未註解的參數或方法覆寫 @NotNull (&A)
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=報告註解欄位的非註解 setter 參數或 getter(&S)
inspection.nullable.problems.notnull.overrides.option=報告覆寫非註解物件的 @NotNull 參數(&P)
inspection.nullable.problems.notnull.parameters.with.null.literal.option=報告使用 null 文字實參的 @NotNull 參數
inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> 未進行 ''isPresent()'' 檢查
inspection.overflowing.loop.index.inspection.description=迴圈執行零次或無限次
inspection.overflowing.loop.index.inspection.name=迴圈執行零次或無限次
inspection.overwritten.key.map.message=重複的Map key
inspection.overwritten.key.set.message=重複的 Set 元素
inspection.overwritten.key.array.message=被覆蓋的陣列元素
inspection.parameter.can.be.local.display.name=從不讀取作為參數傳遞的值
inspection.parameter.can.be.local.problem.descriptor=參數可以被轉化為一個局部變數
inspection.pseudo.functional.style.add.methods.after.quick.fix=快速修復後:
inspection.pseudo.functional.style.add.methods.before.quick.fix=快速修復前:
inspection.pseudo.functional.style.add.methods.fully.qualified.class.name=完全限定類名:
inspection.pseudo.functional.style.add.methods.method.name=方法名稱:
inspection.pseudo.functional.style.add.methods.stream.api.replacement=Stream API 取代:
inspection.quickfix.assert.family=斷言
inspection.raw.use.of.parameterized.type.problem.descriptor=參數化類 <code>#ref</code> 的原始使用 #loc
raw.variable.type.can.be.generic.family.quickfix=向類型添加泛型參數
raw.variable.type.can.be.generic.quickfix=將 {0} 的類型更改為 {1}
raw.use.of.parameterized.type.ignore.new.objects.option=忽略新物件的構造
raw.use.of.parameterized.type.ignore.type.casts.option=忽略類型轉換
raw.use.of.parameterized.type.ignore.uncompilable.option=忽略類型參數無法編譯的位置
raw.use.of.parameterized.type.ignore.overridden.parameter.option=忽略覆寫方法的參數類型
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=在自動快速修復不可用時忽略
inspection.redundant.array.creation.display.name=冗餘陣列創建
inspection.redundant.array.creation.for.varargs.call.descriptor=調用 vararg 方法的冗餘陣列創建
inspection.redundant.array.creation.quickfix=移除顯式陣列創建
inspection.redundant.explicit.close=冗餘 'close()'
inspection.redundant.file.creation.display.name=創建冗餘 'File' 實例
inspection.redundant.file.creation.description=<code>#ref</code> 冗餘 #loc
inspection.redundant.file.creation.quickfix=取代為文件名
inspection.redundant.null.check.always.fail.message=Null 檢查始終失敗: {0} 永不為 null
inspection.redundant.null.check.fix.family.name=移除冗餘 null 檢查
inspection.redundant.null.check.fix.notnull.family.name=移除錯誤的 '!= null'
inspection.redundant.null.check.message=冗餘 null 檢查: {0} 永不為 null
inspection.redundant.operation.on.empty.array.message=陣列 <code>#ref</code> 始終為空
inspection.redundant.operation.on.empty.collection.message=集合 <code>#ref</code> 始終為空
inspection.redundant.operation.on.empty.container.display.name=空容器上存在冗餘操作
inspection.redundant.operation.on.empty.map.message=映射 <code>#ref</code> 始終為空
inspection.redundant.record.constructor.can.be.compact.message=規範構造函數可以轉換為壓縮形式
inspection.redundant.record.constructor.canonical.message=冗餘規範構造函數
inspection.redundant.record.constructor.compact.message=冗餘壓縮構造函數
inspection.redundant.record.constructor.description=冗餘記錄構造函數
inspection.redundant.record.constructor.fix.family.name=將規範構造函數轉換為壓縮形式
inspection.redundant.record.constructor.statement.message=壓縮構造函數中存在冗餘欄位賦值
inspection.redundant.stream.optional.call.explanation.at.most.one=流最多包含一個元素
inspection.redundant.stream.optional.call.explanation.distinct=鏈中存在先前的 'distinct()' 調用
inspection.redundant.stream.optional.call.explanation.distinct.set=收集到集時，元素將保持不重複
inspection.redundant.stream.optional.call.explanation.filter=判定始終為 'true'
inspection.redundant.stream.optional.call.explanation.map.flatMap=上一個 'map()' 調用可以取代 'flatMap()' 步驟
inspection.redundant.stream.optional.call.explanation.parallel=存在會覆寫此調用的後續 ''{0}()'' 調用
inspection.redundant.stream.optional.call.explanation.parallel.single=從單個元素創建的流不會並行化
inspection.redundant.stream.optional.call.explanation.sorted=後續的 ''{0}()'' 調用不依賴於排序順序
inspection.redundant.stream.optional.call.explanation.sorted.twice=鏈中存在後續的 'sorted()' 調用
inspection.redundant.stream.optional.call.explanation.unordered=鏈中存在先前的 'unordered()' 調用
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=收集到 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=移除冗餘的調用鏈
inspection.redundant.stream.optional.call.fix.name=移除 ''{0}()'' 調用
inspection.redundant.stream.optional.call.message=冗餘的 ''{0}()'' 調用
inspection.redundant.stream.optional.call.message.with.explanation=冗餘的 ''{0}()'' 調用: {1}
inspection.redundant.stream.optional.call.option.streamboxing=報告Stream.map中無用的裝箱()
inspection.reflect.handle.invocation.argument.not.array=實參不是陣列類型
inspection.reflect.handle.invocation.argument.not.exact=實參類型應該是 ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=類型 ''{0}'' 的實參不能為 ''null''
inspection.reflect.handle.invocation.receiver.incompatible=回調接收類型不相容: ''{0}''
inspection.reflect.handle.invocation.receiver.null=調用接收器為 'null'
inspection.reflect.handle.invocation.result.not.assignable=應該被轉換為''{0}''或其超類
inspection.reflect.handle.invocation.result.not.exact=應該被轉換為''{0}''
inspection.reflect.handle.invocation.result.null=返回值總是'null'
inspection.reflect.handle.invocation.result.void=返回類型為'void'
inspection.reflection.invocation.argument.count=應為{0,choice,0#另個實參|1# 1 個實參|1<{0} 個實參}
inspection.reflection.invocation.argument.not.assignable=實參不能分配給 ''{0}''
inspection.reflection.invocation.array.not.assignable=陣列專案具有不相容的類型
inspection.reflection.invocation.item.count={0,choice,0#空陣列|1#1個陣列項|1<{0}個數組項}是預期的
inspection.reflection.invocation.item.not.assignable=陣列項不能分配給''{0}''
inspection.reflection.invocation.name=反射調用實參不符合
inspection.reflection.member.access.cannot.resolve.constructor.arguments=無法使用指定的實參類型解析構造函數
inspection.reflection.member.access.cannot.resolve.field=無法解析欄位 ''{0}''
inspection.reflection.member.access.cannot.resolve.method=無法解析方法''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=無法使用指定的實參類型解析方法''{0}''
inspection.reflection.member.access.check.exists=檢查該欄位/方法是否存在於非 final 類中
inspection.reflection.member.access.check.exists.exclude.label=排除類:
inspection.reflection.member.access.check.exists.exclude.chooser=要排除的類
inspection.reflection.member.access.constructor.not.public=構造函數不為 public
inspection.reflection.member.access.field.not.in.class=欄位''{0}''未在類''{1}''中宣告
inspection.reflection.member.access.field.not.public=欄位 ''{0}'' 不為 public
inspection.reflection.member.access.fix.family.name=使用適當的反射方法
inspection.reflection.member.access.method.not.in.class=方法''{0}''未在類''{1}''中宣告
inspection.reflection.member.access.method.not.public=方法 ''{0}'' 不為 public
inspection.reflection.member.access.name=反射存取不存在/不可見的類成員
inspection.reflection.visibility.name=跨模組問題的反射存取
inspection.remove.literal.underscores.display.name=數字文字中的下劃線
inspection.remove.literal.underscores.family.name=從數字文字中移除下劃線
inspection.replace.methodref.ternary.quickfix=取代為空檢查的lambda
inspection.replace.ternary.quickfix=取代為''{0}!= null嗎?''
inspection.replace.with.bulk.fix.family.name=取代大量方法調用
inspection.replace.with.bulk.fix.name=用批量 ''{0}()'' 調用取代迭代
inspection.replace.with.bulk.message=迭代可被取代為批量 ''{0}()'' 調用
inspection.replace.with.bulk.wrap.arrays=使用 'Arrays.asList()' 包裝陣列
inspection.replace.with.enhanced.switch.statement.fix.name=取代為增強的 'switch' 語句
inspection.replace.with.old.style.switch.statement.fix.name=取代為舊式 'switch' 語句
inspection.replace.with.regular.string.literal.fix=取代為正則字串文字
inspection.replace.with.switch.expression.fix.name=取代為 'switch' 表達式
inspection.replace.with.text.block.fix=取代為文本塊
inspection.replace.with.trivial.lambda.fix.family.name=取代為普通 lambda
inspection.replace.with.trivial.lambda.fix.name=取代為返回 ''{0}'' 的 lambda
inspection.require.non.null=將 null 檢查取代為 Objects/Stream static 調用
inspection.require.non.null.description=Null 檢查可被取代為方法調用
inspection.require.non.null.message=用對象取代條件.{0}
inspection.require.non.null.no.warning.replacement.bigger=取代長度大於原始長度時不發出警告
inspection.return.separated.from.computation.descriptor=返回與 ''{0}'' 的值的計算分離
inspection.return.separated.from.computation.family.quickfix=將'返回'更接近結果的計算
inspection.return.separated.from.computation.name=與結果計算分離的 'return'
inspection.return.separated.from.computation.quickfix=將“return”更接近計算''{0}''的值
inspection.same.parameter.display.name=方法參數始終是相同的值
inspection.same.parameter.fix.family.name=內聯參數為常量值
inspection.same.parameter.fix.name=內聯參數 ''{0}'' 的值 ''{1}''
inspection.same.parameter.problem.descriptor=參數 <code>#ref</code> 的實際值始終為 ''{0}''
inspection.simplifiable.comparator.comparing.message=不必要的 ''{0}()'' 調用
inspection.simplifiable.comparator.display.name=可以簡化 Comparator 方法
inspection.simplifiable.comparator.entry.comparator.message=可以改用 ''{0}''
inspection.simplifiable.comparator.fix.comparing.family.name=移除冗餘調用
inspection.simplifiable.comparator.fix.entry.comparator.family.name=使用預定義的 'Map.Entry' 比較運算符方法
inspection.simplifiable.comparator.fix.remove.name=移除 ''{0}()'' 調用
inspection.simplifiable.comparator.fix.replace.name=移除 ''{0}()'' 調用並使用 ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=簡化將 'max' 取代為 'min' 的比較運算符方法
inspection.simplifiable.comparator.fix.reversed.name=取代為簡化比較運算符的 ''{0}''
inspection.simplifiable.comparator.reversed.message=如果 ''{0}()'' 調用取代為 ''{1}()''，則可以簡化比較運算符方法
inspection.simplify.collector.fix.family.name=簡化級聯器
inspection.simplify.collector.fix.name=使用''Collectors.{0}''收集
inspection.simplify.collector.message=可以使用 ''{0}'' 收集器簡化
inspection.simplify.foreach.display.name=可簡化的 forEach() 調用
inspection.sorted.collection.with.non.comparable.keys.display.name=包含不可比較元素的排序集合
inspection.sorted.collection.with.non.comparable.keys.message=包含不可比較元素的排序集合的構造
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=不報告不可比較的類型參數
inspection.surround.if.family=環繞用if語句
inspection.surround.if.quickfix=環繞用''if({0}!= null)''
inspection.suspicious.list.remove.display.name=迴圈中的 'List.remove()' 可疑
inspection.switch.expression.backward.expression.migration.inspection.name='switch' 表達式可被取代為舊式 'switch' 語句
inspection.switch.expression.backward.migration.inspection.name=增強的 'switch'
inspection.switch.expression.backward.statement.migration.inspection.name='switch' 語句可被取代為舊式 'switch' 語句
inspection.switch.expression.migration.inspection.name=語句可被取代為增強的 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch 語句可被取代為增強的 'switch'
inspection.switch.expression.migration.warn.only.on.expression=僅在可以轉換為表達式時顯示警告
inspection.switch.labeled.rule.can.be.code.block.display.name=標記的 switch 規則可以具有程式碼塊
inspection.switch.labeled.rule.can.be.code.block.expression.message=標記規則的結果表達式可以使用程式碼塊包裝
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=使用程式碼塊包裝標記規則的結果表達式
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=使用程式碼塊包裝標記規則的語句
inspection.switch.labeled.rule.can.be.code.block.statement.message=標記規則的語句可以使用程式碼塊包裝
inspection.text.block.backward.migration.message=文本塊可以轉換為正則字串文字
inspection.text.block.backward.migration.name=文本塊可被取代為正則字串文字
inspection.text.block.migration.string.message=字串可被取代為文本塊
inspection.text.block.migration.concatenation.message=串聯可被取代為文本塊
inspection.text.block.migration.name=可以使用文本塊
inspection.text.block.migration.suggest.literal.replacement=應用於單字串文字
inspection.inconsistent.text.block.indent.name=文本塊中的空格縮排不一致
inspection.inconsistent.text.block.indent.message=文本塊縮排由制表符和空格組成
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=將空格取代為制表符(1 個空格 = 1 個制表符)
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=將空格取代為制表符({0} 個空格 = 1 個制表符)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=將制表符取代為空格(1 個制表符 = 1 個空格)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=將制表符取代為空格(1 個制表符 = {0} 個空格)
inspection.trailing.whitespaces.in.text.block.name=文本塊中有尾隨空格
inspection.trailing.whitespaces.in.text.block.message=文本塊內有尾隨空格
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=移除尾隨空格
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=尾隨空格轉義
inspection.undeclared.service.usage.message=服務 ''{0}'' 的使用未在模組資訊中宣告
inspection.undeclared.service.usage.name=服務的使用未在 'module-info' 中宣告
inspection.unused.assignment.option=在可被取代為(i + 1)時報告 ++i
inspection.unused.assignment.option1=在變更後的值後續未使用時報告 i++
inspection.unused.assignment.option2=報告冗餘的初始設定式
inspection.unused.assignment.problem.descriptor1=Variable <code>#ref</code> #loc is never used
inspection.unused.assignment.problem.descriptor2=Variable <code>{0}</code> initializer <code>#ref</code> #loc is redundant
inspection.unused.assignment.problem.descriptor3=The value <code>{0}</code> assigned to <code>#ref</code> #loc is never used
inspection.unused.assignment.problem.descriptor4=The value changed at <code>#ref</code> #loc is never used
inspection.unused.assignment.remove.assignment.quickfix=刪除冗餘分配
inspection.unused.assignment.remove.quickfix=移除冗餘的初始設定式
inspection.unused.parameter.composer=參數 <code>#ref</code> 未用於任何實作
inspection.unused.parameter.composer1=參數 <code>#ref</code> 未在此方法中使用，也未在其覆寫方法中使用
inspection.unused.parameter.delete.quickfix=安全刪除未使用的參數 ''{0}''
inspection.unused.return.value.display.name=方法可以為 'void'
inspection.unused.return.value.make.void.quickfix=使方法無效
inspection.unused.return.value.problem.descriptor=方法的返回值從未使用過
inspection.unused.symbol.check.accessors=Getter/Setter
inspection.unused.symbol.check.classes=類:
inspection.unused.symbol.check.fields=欄位:
inspection.unused.symbol.check.inner.classes=內部類:
inspection.unused.symbol.check.localvars=局部變數
inspection.unused.symbol.check.methods=方法:
inspection.unused.symbol.check.parameters=參數位置:
inspection.value.based.warnings=基於值的警告
inspection.preview.feature=預覽功能警告
inspection.value.based.warnings.synchronization=嘗試對基於值的類的實例同步
inspection.variable.assigned.to.itself.display.name=變數被賦值給自己
inspection.wrapper.type.may.be.primitive.fix.name=將包裝器類型轉換為基元類型
inspection.wrapper.type.may.be.primitive.name=類型可能是基元
intention.add.explicit.type.arguments.family=添加顯式類型實參
intention.add.on.demand.static.import.family=添加按需靜態匯入
intention.add.on.demand.static.import.text=為 ''{0}'' 添加按需靜態匯入
intention.add.single.member.import.text=為 ''{0}'' 添加 import
intention.add.single.member.static.import.family=添加單成員靜態匯入
intention.add.single.member.static.import.text=為 ''{0}'' 添加靜態匯入
intention.assign.field.from.parameter.family=分配參數場
intention.assign.field.from.parameter.text=將參數分配給欄位 ''{0}''
intention.bind.fields.from.parameters.family=將參數綁定到欄位
intention.bind.fields.from.parameters.text=將 {0} 個參數綁定到欄位
intention.break.string.on.line.breaks.text=在 '\\n' 上斷開字串
intention.compose.function.family=將嵌套函數調用取代為組合
intention.compose.function.text=取代嵌套函數調用和取代後的調用
intention.convert.color.representation.family=轉換顏色表示
intention.convert.color.representation.text=轉換為''新顏色{0}''
intention.convert.compact.constructor.to.canonical=將壓縮構造函數轉換為規範構造函數
intention.convert.to.single.return.name=將正文轉換成單個出口點形式
intention.convert.to.single.return.progress.title=將正文轉換成單個出口點形式
intention.convert.to.single.return.command.text=將主體轉換成單個出口點形式
intention.create.field.from.parameter.family=創建欄位參數
intention.create.field.from.parameter.text=為參數 ''{0}'' 創建欄位
intention.create.test.dialog.choose.super.class=選擇超類
intention.create.test.dialog.class.name=類名:
intention.create.test.dialog.fix.library=修正
intention.create.test.dialog.generate=生成:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found={0}庫在該模組中未找到
intention.create.test.dialog.select.methods=為以下物件生成測試方法(&M):
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=顯示繼承的方法(&I)
intention.create.test.dialog.super.class=超類:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=測試庫(&L):
intention.encapsulate.field.text=封裝領域
intention.error.cannot.create.class.message=無法創建類''{0}''
intention.error.cannot.create.class.title=創建類失敗
intention.extract.if.condition.family=提取if條件
intention.extract.if.condition.text=提取if({0})
intention.extract.map.step.family=提取分離映射方法
intention.extract.map.step.text=提取變數''{0}''到''{1}''操作
intention.extract.method.text=提取方法
intention.extract.set.from.comparison.chain.duplicates={0} 在此類中檢測到 {1} 個可以使用新創建的集取代的程式碼{1,choice,1#段|2#段}。要取代{1,choice,1#它|2#它們}嗎?
intention.extract.set.from.comparison.chain.family=從比較鏈提取 Set
intention.family.add.javadoc=添加 Javadoc
intention.family.copy.abstract.method.implementation=複製 abstract 方法實作
intention.family.create.a.class.in.package=在軟體套件中創建類
intention.family.edit.method.contract=編輯方法約定
intention.family.edit.range=編輯範圍
intention.family.expand.static.import=展開靜態匯入
intention.family.fix.bounded.wildcards=修復有界萬用字元
intention.family.make.external.annotations.explicit=使外部註解為顯式
intention.family.make.inferred.annotations.explicit=使推斷的註解為顯式
intention.family.move.it=移動它
intention.family.put.arguments.on.one.line=將實參放在同一行中
intention.family.put.arguments.on.separate.lines=將實參放在單獨的行中
intention.family.put.parameters.on.one.line=將參數放在同一行中
intention.family.put.parameters.on.separate.lines=將參數放在單獨的行中
intention.family.put.record.components.on.one.line=將記錄組件放在一行
intention.family.put.record.components.on.separate.lines=將記錄組件放在單獨的行中
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=將 Optional.isPresent() 條件取代為函數樣式表達式
intention.family.sort.content=對內容進行排序
intention.family.swap.if.statements=交換 'if' 語句
intention.family.unimplement.interface.class=取消實作接口/類
intention.family.variable.access.from.inner.class=可變的 accessFromInnerClass
intention.implement.abstract.class.default.text=實作 abstract 類
intention.implement.abstract.class.family=實作 abstract 類或接口
intention.implement.abstract.method.command.name=實作方法
intention.implement.abstract.method.error.no.classes.message=沒有發現這類方法可以實作
intention.implement.abstract.method.error.no.classes.title=沒有找到的類
intention.implement.abstract.method.family=實作 abstract 方法
intention.implement.abstract.method.searching.for.descendants.progress=正在搜尋後代…
intention.implement.abstract.method.text=實作方法 ''{0}''
intention.inline.map.family=內聯流映射方法
intention.inline.map.inline.text=將 ''{0}()'' 主體內聯到下一個 ''{1}()'' 調用中
intention.inline.map.merge.text=合併 ''{0}()'' 調用和 ''{1}()'' 調用
intention.introduce.variable.text=引入局部變數
intention.invert.if.condition=反轉 'if' 條件
intention.merge.filter.family=合併過濾器
intention.merge.filter.text=合併過濾器鏈
intention.move.field.assignment.to.declaration=移動指派到欄位宣告
intention.move.initializer.to.constructor=將初始設定式移動到構造函數
intention.move.initializer.to.set.up=將初始設定式移動到 setUp 方法
intention.override.method.text=覆寫方法 ''{0}''
intention.replace.cast.with.var.family=用變數取代轉換
intention.replace.cast.with.var.text=將 ''{0}'' 取代為 ''{1}''
intention.replace.concatenation.with.formatted.output.family=更換連接與格式化輸出
intention.replace.concatenation.with.formatted.output.text=用'java.text.MessageFormat.format()'取代'+'
intention.split.declaration.assignment.text=拆分為宣告和賦值
intention.split.declaration.family=拆分宣告
intention.split.filter.family=拆分過濾器
intention.split.filter.text=拆分為過濾器鏈
intention.split.if.family=分裂如果
intention.split.if.text=拆分為 2 條 'if' 語句
intention.split.switch.branch.with.several.case.values.copy.text=複製 'switch' 分支
intention.split.switch.branch.with.several.case.values.family=將包含多個 case 值的 switch 分支拆分成單獨的 'switch' 分支
intention.split.switch.branch.with.several.case.values.split.text=拆分 'switch' 分支的值
intention.surround.resource.with.ARM.block=使用 try-with-resources 環繞
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=將方法約定添加到 ''{0}''
intention.text.add.range.to.0=將範圍添加到 ''{0}''
intention.text.annotate.externally=在外部註解
intention.text.collapse.repeating.annotations=摺疊重複註解
intention.text.create.a.class.in.0=在 ''{0}'' 中創建類
intention.text.edit.method.contract.of.0=編輯 ''{0}'' 的方法約定
intention.text.edit.range.of.0=編輯 ''{0}'' 的範圍
intention.text.fix.method.0.parameters.with.bounded.wildcards=修復包含有界萬用字元的方法 ''{0}'' 參數
intention.text.generate.missed.test.methods=生成缺少的測試方法
intention.text.insert.0.annotation=插入 ''{0}''
intention.text.replace.implements.with.static.import=將實作取代為靜態匯入
intention.text.replace.static.import.with.qualified.access.to.0=將靜態匯入取代為 {0} 的限定存取
intention.text.unimplement.0=取消實作{0}
intention.text.implements.list.remove.others=移除其他 ''{0} 引用
intention.unroll.loop.family=展開迴圈
intention.unwrap.else.branch=解開 'else' 分支
intention.unwrap.else.branch.changes.semantics=解開 'else' 分支(更改語意)
intention.use.single.member.static.import.text=對 ''{0}'' 使用靜態匯入
intention.wrap.with.unmodifiable=使用不可修改的集合或映射包裝
intention.wrap.with.unmodifiable.list=使用不可修改的列表包裝
intention.wrap.with.unmodifiable.map=使用不可修改的映射包裝
intention.wrap.with.unmodifiable.set=使用不可修改的集包裝
interface.not.allowed=不允許接口
java.line.markers=Java 行標記
java.preview.features.accept.notification.link=接受
java.preview.features.alert.title=實驗性功能警報
java.preview.features.legal.notice=您必須接受測試版 Java 規範的法律通知條款才能啟用對“{0}”的支援。<br/><br/><b>根據 Java Community Process (JCP) 開發的早期規範草案的實作僅用於測試和評估目的，與 JCP 的任何規範都不相容。</b>{1}
java.preview.features.notification.title=Java 預覽功能
java.preview.features.warning=較新的 IDE 版本可能會停止對預覽功能的支援。發佈 Java {0} 時，{1} (預覽)語言級別的支援可能會中斷
java.terms.exception=異常
java.terms.instance.initializer=實例初始設定式
java.terms.of.annotation.type=註解類型{1}的{0}
java.terms.of.anonymous.class=匿名類的{0}
java.terms.of.class=類 {1} 的 {0}
java.terms.of.enum=枚舉 {1} 的 {0}
java.terms.of.interface=接口 {1} 的 {0}
java.terms.static.initializer=static 初始設定式
java.terms.type.parameter=類型參數
java.terms.variable.of.method={0}/{1}
javadoc.candidates.not.found=<html>找不到方法調用 <b>{0}</b> 的候選者。</html>
javadoc.constructor.candidates=<html>新的候選 <b>{0}</b>() 是:<br>{1}</html>
javadoc.deprecated=已棄用
javadoc.description.copied.from.class=來自類:
javadoc.description.copied.from.field=來自欄位:
javadoc.description.copied.from.interface=來自接口:
javadoc.generate.arguments=命令行實參:
javadoc.generate.exited=\njavadoc退出,退出程式碼$EXIT_CODE$\n
javadoc.generate.heap.size=最大堆大小(&M):
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=在 -sourcepath 中包含 JDK 和庫源
javadoc.generate.link.to.jdk.documentation.option=鏈接到 JDK 文檔 (使用 -link 選項)
javadoc.generate.locale=區域設定(&L):
javadoc.generate.no.classes.in.selected.packages.error=選定的範圍不包含Java類
javadoc.generate.no.jdk=無法生成 JavaDoc - 沒有為專案設定 Java SDK。請在“設定 | 專案結構”中指定 Java SDK。
javadoc.generate.no.javadoc.tool=無法生成 JavaDoc - 在 {0} 或 {1} 上找不到 javadoc 工具。請在“設定 | 專案結構”中指定有效的 Java SDK。
javadoc.generate.open.in.browser=生成文檔並用瀏覽器開啟 (&G)
javadoc.generate.options.hierarchy=生成層次結構樹
javadoc.generate.options.index=生成索引
javadoc.generate.options.index.per.letter=每個字母單獨的索引
javadoc.generate.options.navigator=生成導航欄
javadoc.generate.output.directory=輸出目錄 (&D):
javadoc.generate.output.directory.browse=瀏覽輸出目錄
javadoc.generate.sources.progress=尋找資源來生成Javadoc
javadoc.generate.tag.list.deprecated=棄用列表
javadoc.generate.temp.file.error=無法創建臨時檔案
javadoc.generate.temp.file.does.not.exist=臨時檔案不存在或無法開啟
javadoc.generate.title=生成JavaDoc
javadoc.method.in.class={0}在類{1}裏邊
javadoc.method.in.interface=接口 {1} 中的 {0}
javadoc.method.overrides=覆寫:
javadoc.method.specified.by=指定的:
javadoc.option.automatically.insert.closing.tag.javadoc=在 JavaDoc 中自動插入結束標記
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=請參閱:
javadoc.settings.title=Javadoc
javadoc.since=自:
javadoc.author=作者:
javadoc.version=版本:
javadoc.apiNote=API 說明:
javadoc.implNote=實作<br>說明:
javadoc.implSpec=實作<br>要求:
javadoc.type.parameters=類型參數:
jrt.node.short=[JRT]
label.add.math.max.0.count.to.avoid.possible.semantics.change=添加 Math.max(0, count) 以避免可能的語意變更
label.class.filter.editor.add.dialog.filter.pattern=輸入過濾器模式:
label.contract=&約定:
label.enter.fully.qualified.class.name=輸入完全限定類名
label.entry.points=入口點:
label.forbid.api.usages=禁止使用 API:
label.from.inclusive=&起始 (包含):
label.implementation=實作:
label.implements.method.of_class_or_interface.name=實作{0, choice, 0#接口|1#類} ''{1}'' 的方法。
label.implements.method.of_interfaces=以下類/接口的實作方法:
label.maximal.reported.method.visibility=報告方法最大可見性:
label.method=方法 ''{0}''
label.minimal.reported.method.usage.count=報告方法最小使用計數:
label.mutates=&變異:
label.name.prefix=名稱前綴:
label.name.suffix=名稱後綴:
label.naming.field=欄位:
label.naming.local.variable=局部變數:
label.naming.parameter=參數:
label.naming.static.field=static 欄位:
label.naming.subclass=子類:
label.naming.test.class=測試類:
label.overrides.method.of_class_or_interface.name=覆寫{0, choice, 0#接口|1#類} ''{1}'' 的方法。
label.show.import.popup.for=顯示自動匯入工具提示:
label.to.inclusive=&結束(包含):
label.unused.declaration.reachable.from.tests.option=當入口點位於測試源中時，將被調用方標記為:
line.marker.recursive.call=遞歸調用
line.marker.type.external.annotations=外部註解
line.marker.type.inferred.contract.annotations=推斷約定註解
line.marker.type.inferred.nullability.annotations=推斷可空性註解
listbox.import.package=軟體套件
listbox.import.static=static
listbox.import.with.subpackages=以及子軟體套件
# suppress inspection "UnusedProperty"
macro.array.variable=arrayVariable()
macro.class.name=類名
macro.classpath.entry=該元素所屬的類路徑中的條目
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=檔案完全合格軟體套件
macro.file.package=檔案軟體套件
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
# suppress inspection "UnusedProperty"
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=JavaDoc輸出目錄
macro.project.classpath=專案的類路徑
macro.variable.of.type=variableOfType(Type)
methods.to.implement.chooser.title=選擇要實作的方法
methods.to.override.chooser.title=選擇要覆寫的方法
methods.to.override.implement.chooser.title=選擇覆蓋/實作的方法
module.not.in.requirements=模組 ''{0}'' 的要求中缺少模組 ''{1}''
module.package.not.exported=模組 ''{0}'' 不會將軟體套件 ''{1}'' 匯入到模組 ''{2}''
module.package.not.open=模組 ''{0}'' 不會開啟模組 ''{2} ''的軟體套件 ''{1}''
module.type.java.description=Java 模組用於開發<b>基於 JVM 的</b>桌面和 Web 套用程序，包括使用 <b>Java EE</b> 和其他企業開發框架的應用程式。
module.type.java.name=Java模組
navigate.to.duplicate.fix=導航到重複位置
no.methods.overriding.0.are.found=沒有覆寫方法 {0, choice, 0#|1# ''{1}''|2#這些類} 被發現
no.patterns=沒有類模式設定
node.call.hierarchy.unknown.jsp=未知的jsp
node.hierarchy.java.lang.object=所有類都派生自java.lang.Object
notification.navigation.to.overriding.classes=索引更新時無法導航到覆寫類
notification.navigation.to.overriding.methods=索引更新時無法導航到覆寫方法
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=已成功將完整執行緒轉儲複製到剪貼簿
nullable.notnull.annotations.panel.title={0}註解:
nullable.notnull.annotations.runtime.instrumentation.tooltip=為非空註解的方法和參數添加執行時斷言
nullable.notnull.configuration.dialog.title=可空/非空設定
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=導航到 'null' 實參用法
nullable.stuff.inspection.navigate.null.argument.usages.view.name=參數 {0} 的 ''null'' 實參用法
offline.inspections.jdk.not.found=找不到 {0}
offline.inspections.library.urls.were.not.resolved=未解析模組 ''{2}'' 中庫 ''{1}'' 的根 {0}
offline.inspections.library.was.not.resolved=請設定庫''{0}''用於模組''{1}''
offline.inspections.no.source.roots=未檢測到模組 ''{0}'' 的源根
options.java.attribute.descriptor.abstract.class=類和接口//抽象類
options.java.attribute.descriptor.abstract.method=方法//abstract 方法
options.java.attribute.descriptor.annotation.attribute.name=註解//註解特性名稱
options.java.attribute.descriptor.annotation.name=註解//註解名稱
options.java.attribute.descriptor.anonymous.class=類和接口//匿名類
options.java.attribute.descriptor.class=類和接口//類
options.java.attribute.descriptor.constructor.call=方法//構造函數調用
options.java.attribute.descriptor.constructor.declaration=方法//構造函數宣告
options.java.attribute.descriptor.enum=類和接口//枚舉
options.java.attribute.descriptor.implicit.anonymous.parameter=參數//隱式的匿名類參數
options.java.attribute.descriptor.inherited.method=方法//繼承的方法
options.java.attribute.descriptor.instance.field=類欄位//實例欄位
options.java.attribute.descriptor.instance.final.field=類欄位//實例化final欄位
options.java.attribute.descriptor.interface=類和接口//接口
options.java.attribute.descriptor.javadoc.comment=註釋//JavaDoc//文本
options.java.attribute.descriptor.javadoc.markup=註釋//JavaDoc//標記
options.java.attribute.descriptor.javadoc.tag=註釋//JavaDoc//標籤
options.java.attribute.descriptor.javadoc.tag.value=註釋//JavaDoc//標籤值
options.java.attribute.descriptor.lambda.parameter=參數//Lambda 參數
options.java.attribute.descriptor.method.call=方法//方法調用
options.java.attribute.descriptor.method.declaration=方法//方法宣告
options.java.attribute.descriptor.method.imported.call=方法//static 匯入方法調用
options.java.attribute.descriptor.reassigned.local.variable=變數//重新分配局部變數
options.java.attribute.descriptor.reassigned.parameter=參數//重新分配參數
options.java.attribute.descriptor.static.field=類欄位//靜態欄位
options.java.attribute.descriptor.static.final.field=類欄位//常數(static final 欄位)
options.java.attribute.descriptor.static.final.imported.field=類欄位//常數 (static final 匯入欄位)
options.java.attribute.descriptor.static.imported.field=類欄位//靜態匯入欄位
options.java.attribute.descriptor.static.method=方法//靜態方法
options.java.attribute.descriptor.type.parameter=參數//類型參數
options.java.attribute.descriptor.public=可見性//Public
options.java.attribute.descriptor.protected=可見性//Protected
options.java.attribute.descriptor.package.private=可見性//Package-private
options.java.attribute.descriptor.private=可見性//Private
options.java.display.name=Java
override.implement.broken.file.template.message=請更正“覆寫/實作的方法體”模板
override.implement.broken.file.template.title=檔案模板錯誤
package.dependencies.production.node.text=生產類
package.dependencies.test.node.text=測試類
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=執行時映像(JLink)
packaging.jlink.compression.level=壓縮級別
packaging.jlink.compression.zero.level=不壓縮
packaging.jlink.compression.first.level=字串共享
packaging.jlink.compression.second.level=Zip
packaging.jlink.verbose.tracing=啟用詳細跟踪
paste.class.command.name=貼上類 ''{0}''
please.report.a.bug=請報告錯誤
popup.title.choose.framework=選擇框架
popup.title.choose.test=選擇測試
popup.title.select.a.jar.file=選擇 JAR 檔案
popup.title.select.qualified.name=選擇限定名稱
postfix.template.language.level.title=最低語言級別:
press.0.to.see.inheritors.of.1=按 {0} 以查看 {1} 的繼承者
press.0.to.see.non.imported.classes=按 {0} 以查看未匯入的類
pressing.0.twice.without.a.class.qualifier=不使用類限定符，按 {0} 兩次會顯示所有可存取的 static 方法
project.problems.hint.text={0} 個相關{0, choice, 0#問題|2#問題}
project.problems.window.title={0} 的相關問題
project.problems.fix.text=顯示相關問題
project.problems.fix.description=發現與 ''{0}'' 相關的問題
project.problems.title=相關問題
progress.creating.class=創建類{0}
progress.title.check.applicability=檢查適用性…
progress.title.download.library.descriptor=下載庫描述符
progress.title.find.references.in.implement.extends.lists=在實作/展開列表中尋找引用…
progress.title.finding.cause=正在尋找原因
progress.title.looking.for.jdk.locations=正在尋找 JDK 位置…
progress.title.looking.for.libraries=正在尋找庫
progress.title.optimize.imports=最佳化 import…
progress.title.preprocess.usages=預處理用法
progress.title.search.for.overriding.methods=搜尋覆寫方法…
progress.title.searching.for.sub.classes=正在搜尋子類
prompt.choose.base.class.of.the.hierarchy=選擇層次結構基類,搜尋
prompt.create.non.existing.package=軟體套件 {0} 不存在。\n要創建嗎?
prompt.delete.class=個類
prompt.delete.field=個欄位
prompt.delete.interface=個接口
prompt.delete.method=個方法
prompt.delete.package={0,choice,1#軟體套件|2#軟體套件}
prompt.delete.type.parameter={0,choice,1#類型參數|2#類型參數}
#{1} presents an action verb with preposition: "to refactor" is the default value, RefactorinBundle:to.refactor
prompt.do.you.want.to.action_verb.the.method.from_class=要改為對基{0,choice,1#方法|2#方法}{1}嗎?
psi.search.overriding.progress=搜尋覆蓋方法
quickfix.add.variable.family.name=初始化變數
quickfix.add.variable.text=初始化變數 ''{0}''
quickfix.family.avoid.mutation.using.stream.api=使用 Stream API 避免變異
quickfix.family.change.javadoc.to=更改為…
quickfix.family.find.cause=尋找原因
quickfix.family.remove.javadoc.tag=移除標記
quickfix.family.remove.redundant.parameter=刪除冗餘參數
quickfix.family.remove.redundant.parameter.types=刪除冗餘參數類型
quickfix.family.replace.cast.type=取代轉換類型
quickfix.family.replace.inefficient.stream.count=取代低效的 Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=將 Optional 鏈取代為 if 語句
quickfix.family.replace.stream.api.chain.with.loop=將 Stream API 鏈取代為迴圈
quickfix.family.replace.with.java.stream.api.pipeline=取代為 Java Stream API 管道
quickfix.family.replace.with.magic.constant=取代為魔術常數
quickfix.family.replace.with.method.reference=取代為方法引用
quickfix.family.replace.with.optional.of.nullable.chain=取代為 Optional.ofNullable() 鏈
quickfix.family.replace.with.stream.api.equivalent=取代為 Stream API 對等項
quickfix.family.simplify.foreach.lambda=簡化 forEach lambda
quickfix.family.simplify.stream.call.chain=簡化流調用鏈
quickfix.family.use.flatmap=使用 'flatMap'
quickfix.family.wrap.with.mutable.collection=使用可變集合包裝
quickfix.name.find.jar.on.web=在 web 上尋找 JAR
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (可能無法在 JDK 11.0.2 之前的版本上執行)
quickfix.text.avoid.mutation.using.stream.api.0.operation=使用 Stream API ''{0}'' 操作避免變異
quickfix.text.remove.javadoc.0=移除 ''@{0}'' 標記
quickfix.text.remove.javadoc.0.1=移除 @{0} {1}
quickfix.text.remove.not.null.annotation=移除非空註解
quickfix.text.replace.0.stream.with.1.2=將 {0}.stream() 取代為 {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=將 ''collect({0}())'' 取代為 ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=將 ''filter().{0}().isPresent()'' 取代為 ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=將 ''stream().{0}()'' 取代為 ''{1}()''{2}
quickfix.text.suffix.may.change.semantics=\ (可能更改語意)
quickfix.text.wrap.0.with.1=用 ''{1}'' 包裝 ''{0}''
quickfix.text.replace.url.with.html=將 URL 取代為 HTML 鏈接
radio.button.higher.than=高於:
radio.button.respecting.to.project.language.level.settings=遵循專案語言級別設定
radio.button.subclass.of.0=''{0}'' 的子類
radio.button.unused.declaration.unused.option=未使用
radio.button.unused.declaration.used.option=已使用
radio.button.with.provider.method=帶有 'provider()' 方法
radio.use.fully.qualified.class.names.in.javadoc=在 JavaDoc 中使用完全限定類名:
radio.use.fully.qualified.class.names.in.javadoc.always=始終
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=如果尚未匯入
radio.use.fully.qualified.class.names.in.javadoc.never=切勿使用短名稱和添加匯入
scope.hierarchy={0}的層次結構
sdk.cannot.create=無法創建 SDK
sdk.java.no.classes=無法在''{0}''中找到JDK classes
section.title.inspection.suspicious.names.ignore.methods=忽略方法:
set.language.level=設定語言級別
set.language.level.to.0=設定語言級別為{0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=註解
settings.inlay.java.builder.like.methods=類似於建置器的方法
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=複雜表達式作為實參
settings.inlay.java.enum.constants=枚舉常數
settings.inlay.java.external.annotations=外部註解
settings.inlay.java.inferred.annotations=推斷註解
settings.inlay.java.inheritors=繼承者
settings.inlay.java.insert.annotation=插入註解
settings.inlay.java.implicit.types=隱式類型
settings.inlay.java.methods.with.same.named.numbered.parameters=包含相同名稱的編號參數的方法
settings.inlay.java.new.expressions='New' 表達式
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=在具有相同類型的多個參數的情況下的非文字
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=具有方法名稱中包含的名稱的參數
settings.inlay.java.show.hints.for=顯示以下項的提示:
settings.inlay.java.show.parameter.hints.for=為以下物件顯示參數提示:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=陣列初始設定式、switch、條件、引用、實例、賦值、調用、限定、類型轉換、類物件存取表達式。
settings.inlay.java.turn.off.external.annotations=關閉外部註解
settings.inlay.java.turn.off.inferred.annotations=關閉推斷註解
settings.inlay.java.usages=用法
show.import.popup.for.classes=類(&C)
show.import.popup.for.static.methods.and.fields=Static 方法和欄位(&S)
exclude.import.wildcard.comment=使用 * 萬用字元排除指定類或軟體套件的所有成員
special.annotations.annotations.list=附加特殊註解:
special.annotations.list.add.annotation.class=添加註解類
special.annotations.list.annotation.class=註解類
special.annotations.list.annotation.pattern.message=添加註解模式
special.annotations.list.annotation.pattern=添加註解模式
special.annotations.list.remove.pattern=移除
spi.extension.error.message=註冊的擴展應實作{0}
filetype.spi.description=服務提供程序接口
spi.no.provider.error.message=未找到服務提供程序“{0}”
status.bar.overridden.methods.highlighted.message=找到{0}覆寫方法  (按{1}再次移除高亮顯示, Esc移除所有高亮)
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=!(表達式實例類型)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=無效的檔案模板,用於catch body
surround.with.try.catch.incorrect.template.title=環繞用try-catch
surround.with.try.catch.template=try / catch
tab.title.entry.points=入口點
tab.title.members.to.report=要報告的成員
table.cell.constructors=構造函數
title.cannot.create.class=無法創建類
title.import.layout=匯入布局
title.javadoc=JavaDoc
title.naming=命名
title.naming.final.modifier=final 修飾符
title.naming.functional.expressions=Lambda 體
title.package.not.found=找不到軟體套件
title.packages=軟體套件
title.packages.to.use.import.with=將 import 與 '*' 搭配使用的軟體套件
to.import.a.method.statically.press.0=要靜態匯入方法，請按 {0}
unscramble.detect.analyze.threaddump.from.clipboard.item=自動檢測和分析從 IntelliJ IDEA 外部複製到剪貼簿的執行緒轉儲
unscramble.log.path.label=日誌檔案: (&L)
unscramble.no.unscrambler.item=<未安裝譯碼器>
unscramble.normalize.button=標準化 (&N)
unscramble.stacktrace.caption=將一個堆疊跟踪或完整的執行緒轉儲放在此處:
unscramble.unscrambled.deadlock.tab=<死鎖>
unscramble.unscrambled.stacktrace.tab=<堆疊跟踪>
unscramble.unscrambled.threaddump.tab=<執行緒>
unscramble.unscrambler.combobox=譯碼器(&S):
unscramble.use.unscrambler.checkbox=譯碼堆疊跟踪(&U)
unwrap.anonymous=開啟 'anonymous...'
unwrap.array.initializer=解包陣列初始設定式
unwrap.conditional=開啟 'f ? a : b'
unwrap.lambda=取消 'lambda...' 換行
unwrap.synchronized=解開 'synchronized…'
unwrap.switch.expression=解開 'switch' 表達式
unwrap.switch.statement=解開 'switch' 語句
usage.target.exception=異常
usage.target.package.in.directory={0} (在 {1} 中)
use.external.annotations=使用外部註解 (&E)
wrapping.annotation.parameters=註解參數
wrapping.record.components=記錄組件
wrapping.text.blocks=文本塊
wrong.package.statement=錯誤的 package 語句
title.code.vision=Code Vision
highlight.throws.popup.throwing.places=引發 {0} 的位置
highlight.throws.popup.usages={0} 的用法
psi.error.incorrect.class.template.message=無法創建{0} - {1}模板不正確。
presentable.text.anonymous.class=匿名類
presentable.text.code.from.context=來自 {0} 的程式碼
presentable.text.code.display=程式碼
presentable.text.invalid.element.name=無效
inspection.simplify.for.each.replace=取代為 {0}
inspection.simplify.for.each.extract.intermediate.operations=提取中間操作
inspection.message.can.be.replaced.with.files.writestring=可被取代為 'Files.writeString()'
inspection.notnull.field.not.initialized.message=必須初始化 {0} 欄位
highlight.throws.class.name=高亮顯示 Throws {0}
class.patterns.panel.add.class=添加類
multiple.usages.of.static.import.found=已找到靜態匯入的多個用法
external.annotations.roots=註解根
inspection.stream.api.migration.can.be.replaced.with.call=可被取代為 ''{0}'' 調用
highlight.suppressed.warnings.choose.inspections=選擇檢查以高亮顯示此項中的已禁止問題
inspection.magic.constants.should.be.one.of.values=應當為以下之一: {0}{1,choice,0#|1#或其組合}
live.template.context.consumer.function=使用者函數
live.template.context.statement=語句
live.template.context.expression=表達式
live.template.context.declaration=宣告
inspection.unused.display.name=未使用的宣告
inspection.empty.method.display.name=空方法
inspection.unused.assignment.display.name=未使用的賦值
inspection.unchecked.warning.display.name=未檢查的警告
inspection.convert.2.streamapi.display.name=可以通過 Stream API 摺疊迴圈
inspection.optional.to.if.display.name='Optional' 可被取代為 'if' 語句序列
inspection.stream.to.loop.display.name=Stream API 調用鏈可被取代為迴圈
inspection.anonymous.2.method.ref.display.name=匿名類型可被取代為方法引用
inspection.convert.2.method.ref.display.name=lambda 可被取代為方法引用
inspection.lambda.can.be.method.call.display.name=lambda 可被取代為方法調用
inspection.functional.expression.can.be.folded.display.name=函數表達式可以折疊
inspection.trivial.functional.expression.usage.display.name=函數表達式的普通用法
inspection.magic.constant.display.name=魔術常數
inspection.static.pseudo.functional.style.method.display.name=使用 static 類的偽函數表達式
inspection.static.pseudo.functional.style.table.label=轉換為 'Stream' API 的 static 方法調用:
inspection.overwritten.key.display.name=被覆蓋的 Map、Set 或陣列元素
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=冗餘的 'Collection.addAll()' 調用
inspection.manual.min.max.calculation.display.name=手動最小值/最大值計算
inspection.explicit.array.filling.display.name=顯式陣列填充
inspection.java.8.collection.remove.if.display.name=迴圈可被取代為 'Collection.removeIf()'
inspection.java.8.map.api.display.name=可簡化的 'Map' 運算
inspection.string.repeat.can.be.used.display.name=可以使用 String.repeat()
inspection.read.write.string.can.be.used.display.name=可以使用 'Files.readString()' 或 'Files.writeString()'
inspection.java.9.collection.factory.display.name=不可變集合創建可被取代為集合工廠調用
inspection.explicit.argument.can.be.lambda.display.name=顯式實參可以是 lambda
inspection.excessive.lambda.usage.display.name=過度使用 lambda
inspection.redundant.stream.optional.call.display.name='Stream' 或 'Optional' 調用鏈中存在冗餘步驟
inspection.obvious.null.check.display.name=使用明顯非空實參調用 null 檢查方法
inspection.simplify.stream.api.call.chains.display.name=可以簡化 Stream API 調用鏈
inspection.simplify.optional.call.chains.display.name=可以簡化 Optional 調用鏈
inspection.simplify.collector.display.name=可簡化的收集器
inspection.use.bulk.operation.display.name=可以使用批量操作代替迭代
inspection.comparator.combinators.display.name=可以使用 'Comparator' 連結符
inspection.replace.inefficient.stream.count.display.name=以 count() 結尾的低效 Stream API 調用鏈
inspection.redundant.lambda.parameter.type.display.name=冗餘 lambda 參數類型
inspection.wrapper.type.may.be.primitive.display.name=包裝器類型可能是基元
inspection.optional.get.without.is.present.display.name=在不進行 isPresent() 檢查的情況下調用 Optional.get()
inspection.optional.is.present.display.name=非函數樣式 'Optional.isPresent()' 用法
inspection.conditional.can.be.optional.display.name=條件可被取代為 Optional
inspection.optional.assigned.to.null.display.name=Optional 類型的 null 值
inspection.excessive.range.check.display.name=過度範圍檢查
inspection.condition.covered.by.further.condition.display.name=條件由進一步的條件覆蓋
inspection.move.field.assignment.to.initializer.display.name=欄位賦值可以移動到初始設定式中
inspection.frequently.used.inheritor.inspection.display.name=類可以擴展常用的基類
inspection.slow.abstract.set.remove.all.description=調用 'set.removeAll(list)' 可能較為緩慢
inspection.slow.abstract.set.remove.all.fix.family.name=使用 'Set.remove' 而不是 'Set.removeAll'
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=''null'' 篩選器不適用於基元類型 {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''!null'' 篩選器不適用於基元類型 {0}
slice.filter.parse.error.enum.constant.not.found=找不到枚舉常數: {0}
slice.filter.parse.error.incorrect.expression=表達式不正確: {0}
slice.filter.parse.error.incorrect.constant.type=常數類型不正確(要求: {0})
slice.filter.parse.error.expression.must.evaluate.to.constant=表達式必須評估為常數: {0}
slice.filter.parse.error.incorrect.constant.expected.number=常數不正確(應為數字): {0}
action.dfa.from.stacktrace.text=尋找 ''{0}'' 可以是 {1} 的原因
slice.usage.message.assertion.violated=(違反斷言!)
slice.usage.message.in.file.stopped.here=(在 {0} 檔案中 - 在此處停止)
slice.usage.message.tracking.container.contents=(正在跟踪容器 ''{0}{1}'' 內容)
slice.usage.message.location=({0} 中)
intention.name.move.into.if.branches=上移至 'if' 語句分支
intention.name.collapse.into.loop=摺疊到迴圈中
intention.family.name.make.sealed=密封類
intention.error.make.sealed.class.is.used.in.functional.expression=類用於函數表達式
intention.make.sealed.class.hint.title=使其密封
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=部分繼承者為匿名或局部
intention.error.make.sealed.class.different.packages=模組未命名，某些繼承者位於不同的軟體套件中
intention.error.make.sealed.class.inheritors.not.in.java.file=有些繼承者不在 Java 檔案中
intention.error.make.sealed.class.different.modules=有些繼承者位於不同模組中
intention.error.make.sealed.class.interface.has.no.inheritors=接口沒有繼承者
intention.make.sealed.class.task.title.set.inheritors.modifiers=正在設定繼承者修飾符
intention.family.name.move.member.into.class=將成員移至類
inspection.fill.permits.list.no.missing.inheritors=密封類沒有缺失的繼承者
inspection.fill.permits.list.display.name=密封類的 permits 子句中缺失同一檔案子類
inspection.fill.permits.list.fix.name=將缺失的子類添加到 permits 子句
update.external.annotations=更新外部註解
intention.create.switch.statement=創建 switch 語句
sort.threads.by.type=按類型對執行緒排序
sort.threads.by.name=按名稱對執行緒排序
inspection.message.record.can.be.converted.to.class=記錄可以轉換為類
intention.family.name.convert.record.to.class=將記錄轉換為類
class.can.be.record.display.name=類可以為記錄
class.can.be.record.quick.fix=轉換為記錄
class.can.be.record.suggest.renaming.accessors=建議重命名 get/is 存取器
class.can.be.record.conversion.strategy.do.not.convert=不建議轉換
class.can.be.record.conversion.strategy.show.members=在衝突檢視中顯示受影響的成員
class.can.be.record.conversion.strategy.convert.silently=無提示轉換
extracted.class.should.have.unique.name=已提取類應具有唯一名稱。已有一個內部類使用名稱 ''{0}''
invalid.extracted.class.name=''{0}'' 是無效的已提取類名
caller.chooser.referenced.code.title=引用程式碼
dialog.title.choose.annotation=選擇 {0} 註解
unchecked.warning.inspection.settings.ignore.unchecked.assignment=忽略未檢查的賦值
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=忽略 vararg 參數的未檢查的泛型陣列創建
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=忽略作為原始類型成員的未檢查的調用
unchecked.warning.inspection.settings.ignore.unchecked.cast=忽略未檢查的轉換
unchecked.warning.inspection.settings.ignore.unchecked.overriding=忽略未檢查的覆寫
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=。原因: ''{0}'' 具有原始類型，因此消除了 {1} 的結果
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=vararg 參數的未檢查的泛型陣列創建
type.migration.dialog.message.invalid.type=''{0}'' 是無效類型
type.migration.dialog.message.void.not.applicable='void' 不可用
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=將 Stream API 鏈取代為迴圈
stream.to.loop.inspection.message.replace.foreach.call.with.loop=將 'forEach()' 調用取代為迴圈
todo.index.not.available=不適用
simplify.stream.inspection.message.can.be.replaced=''{0}'' 可被取代為 ''{1}''
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' 可被取代為 ''{1}'' (可能會改變語意)
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=''filter().{0}().isPresent()'' 鏈可被取代為 ''anyMatch()''
simplify.stream.match.negation.fix.name=將 {0} 取代為 {1}(…)
simplify.stream.collection.creation.fix.name=取代為 ''{0}'' 構造函數
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=顯式使用 Stream 元素
simplify.stream.simple.stream.of.message=不必要的單元素 Stream
simplify.stream.replace.with.element.iteration.fix.message=可被取代為元素迭代
simplify.stream.remove.boolean.identity.fix.name=與上一個 'map()' 調用合併
simplify.stream.remove.boolean.identity.fix.message=可以與上一個 'map()' 調用合併
simplify.stream.replace.support.with.collection.fix.name=取代為 ''{0}.{1}()'' 調用
simplify.stream.replace.support.with.collection.fix.message=可被取代為 ''{0}.{1}()'' 調用
simplify.stream.swap.filter.and.map.fix.name=交換 'filter()' 和 'map()'
simplify.stream.swap.filter.and.map.fix.message=可以交換 'filter()' 和 'map()'
simplify.stream.inspection.iterate.take.while.fix.name=取代為三實參 'iterate()'
simplify.stream.inspection.iterate.take.while.fix.message=可被取代為三實參 'iterate()'
side.effects.pattern.message=<html>\n<body>\n{0} 中可能存在副作用<br>\n您可以:\n<br>\n-\\&nbsp;<b>移除</b>變數用法以及所有涉及的表達式，或<br>\n-\\&nbsp;<b>自行將分配到變數的表達式轉換</b>到語句中。<br>\n<div style="padding-left: 0.6cm;">\n  即<br>\n  <table border="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  成為: <br>\n  <table border="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
side.effects.non.fixable.message=<html><body>  表達式 ''{0}'' 中可能存在副作用<br>您可以<b>移除</b>類引用以及涉及的全部表達式</body></html>
side.effects.expression.presentation=表達式 ''{0}''
change.signature.from.usage.short.name=<html> 更改 {0}({1}) 的簽名</html>
default.param.value.warning=具有所選簽名的{0, choice, 0#構造函數|1#方法}已存在
qualify.static.constant.access=限定 static 常數存取
qualify.static.access.command.name=限定 static 存取
qualify.static.call.fix.text=限定 static 調用
side.effects.expressions.assigned.to.the.variable=分配到變數 ''{0}'' 的表達式
pull.members.up.fix.name=將成員上移
extract.superclass.command.name=提取超類
extract.interface.command.name=提取接口
choose.super.class.popup.title=選擇超類
intention.name.pull.method.up.and.make.it.abstract.conditionally=將方法 ''{0}'' 拉取到 ''{1}''{2, choice, 0#並將其設為 abstract|1#}
intention.name.extract.method.to.new.interface=將方法 ''{0}'' 提取到新接口
intention.name.pull.method.up.make.it.abstract=向上拉取方法 ''{0}'' 並使其抽象
intention.name.pull.method.up=向上拉取方法 ''{0}''
intention.name.copy.to.final.temp.variable=複製''{0}'' {1, choice, 0#|1#effectively }final 臨時變數
intention.name.make.variable.final=將 {1, choice, 0#''''{0}''''|1#變數} 設為 final
intention.name.transform.variables.into.final.one.element.array=將 {1, choice, 0#''''{0}''''|1#變數} 轉換成 final 單元素數組
type.information.value=值
type.information.not.equal.to=不等於
type.information.range=範圍
type.information.nullability=可 null 性
type.information.constraints=約束
type.information.mutability=可變性
type.information.locality=本地性
type.information.local.object=本地物件
type.information.type=類型
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=從可選鏈中移除冗餘步驟
simplify.optional.chain.inspection.to.x=將可選鏈簡化為 ''{0}''
simplify.optional.chain.inspection.map.or.else.description=Optional 鏈可以簡化
simplify.optional.chain.inspection.optional.rewrapping.name=解開
simplify.optional.chain.inspection.optional.rewrapping.description=不必要的 Optional 重新包裝
simplify.optional.chain.inspection.or.else.return.fix.name=將 null 檢查取代為 {0}({1})
simplify.optional.chain.inspection.or.else.return.fix.description=null 檢查可被消除
simplify.optional.chain.inspection.or.else.non.null.fix.name=將 null 檢查取代為 ifPresent()
simplify.optional.chain.inspection.or.else.non.null.fix.description=null 檢查可被 'ifPresent' 消除
generate.test.support.method.error.no.template.found.for.framework=沒有找到 {0} 的模板: {1}
generate.test.support.method.error.method.already.exists=方法 {0} 已存在
generate.test.support.method.error.cannot.generate.method=無法生成方法: {0}
base.package.project.wizard.error.x.not.valid.package={0} 不是有效的軟體套件名稱
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=如果限定名稱符合，則將程式碼標記為入口點
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=方法模式 ''{0}'' 必須是有效的 java 關鍵字，僅接受 ''*'' 作為佔位符
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=模式必須是有效的 java 限定名稱，僅接受 '*' 作為佔位符
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=在前綴 ''{0}'' 中不是有效的 java 關鍵字部分
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=在後綴 ''{0}'' 中不是有效的 java 關鍵字部分
hide.out.of.cyclic.packages.action.text=隱藏沒有迴圈依賴的軟體套件
hide.out.of.cyclic.packages.action.description=隱藏沒有迴圈依賴的軟體套件
generate.missed.tests.action.error.no.tests.found=找不到測試。
generate.missed.tests.action.failed.to.detect.framework=無法檢測到 {0} 的測試框架
pull.up.accessible.conflict={0} 無法存取
pull.up.accessible.conflict.1=無法從 {1} 存取 {0}
pull.up.concrete.inherit.abstract.method.conflict=具體的 ''{0}'' 將繼承一個新的抽象方法
pull.up.members.usage.view.description.code.references.node=將成員向上拉取到“{0}”的類
pull.up.members.usage.view.description.processed.elements.node=從類 {0} 上移成員
refactoring.method.reference.to.lambda.conflict=方法引用將轉換為 lambda
introduce.variable.change.semantics.warning=提取所選表達式將改變整個表達式的語意。
introduce.variable.change.type.adv=按 {0} 更改類型
introduce.variable.reassign.adv=按 {0} 重新分配現有變數
introduce.functional.variable.accessibility.conflict=變數 {0} 不是有效的 final 變數，無法在函數表達式中存取
introduce.functional.variable.interface.chooser.title=選擇適用的函數接口: {0} -> {1}
introduce.functional.variable.nothing.found.message=找不到適用的函數接口
introduce.parameter.object.no.accessor.conflict.message=欄位 ''{1}'' 需要 {0, choice, 0#Getter|1#Setter}
push.down.anonymous.conflict=無法將實作推送到匿名類
push.down.static.nonstatic.conflict=static {0} 無法推送到非 static {1}
push.down.missed.implementation.conflict=非抽象 {0} 將錯過 {1} 的實作
push.down.super.method.call.changed.conflict=super 方法調用將解析為另一種方法
move.classes.invalid.destination.package.name.message=''{0}'' 是無效的目標軟體套件名稱
move.classes.destination.class.not.found.message=未找到目標類
move.class.import.from.default.package.conflict=無法從預設軟體套件存取 {0}
destination.combo.test.root.not.expected.conflict=應為源根，但選擇了測試根
destination.combo.source.root.not.expected.conflict=應為測試根，但選擇了源根
leave.in.same.source.root.item=留在同一源根中
move.inner.select.target.package.title=選擇目標軟體套件
move.member.enum.conflict=枚舉類型不適用於當前上下文
move.member.final.initializer.conflict=移動後，final 變數初始設定式將不可用。
rename.package.invalid.name.error=不是有效的軟體套件名稱
rename.package.ignored.name.warning=正在嘗試創建具有忽略名稱的軟體套件，結果將不可見
rename.package.class.already.exist.conflict=具有限定名稱 ''{0}''  的類已存在
rename.package.command.name=重命名軟體套件
class.filter.editor.table.model.column.name.pattern=模式
class.filter.editor.table.model.column.name.isActive=活躍
create.class.mapping.dialog.title=選擇 {0} 類
import.layout.panel.up.button=上
import.layout.panel.down.button=下
import.layout.panel.blank.line.entry=<空行>
import.layout.panel.all.other.imports=所有其他匯入
edit.contract.dialog.hint=<html>請指定約定文本<p>範例: <code>_, null -> false</code><br><small>請參閱意圖操作描述了解詳細資訊</small></html>
edit.range.dialog.message=<html>請指定值範圍<p>如果不受限制，將 'from' 或 'to' 留空</html>
edit.range.error.invalid.value=無效值
edit.range.value.should.be.less.than=不應小於 {0}
edit.range.value.should.be.bigger.than=不應大於 {0}
edit.range.should.not.be.less.than.from=不應小於 'from'
generate.constructor.already.exists=構造函數已存在
generate.equals.no.fields.for.generation=找不到要包含在 equals/hashCode 中的欄位
generate.getter.and.setter.error.setters.for.read.only.not.generated=未生成唯讀欄位的 setter
generate.getter.and.setter.error.no.fields=找不到要為之生成 getter/setter 的欄位
generate.getter.and.setter.error.no.fields.without.getters.and.setters=找不到沒有 getter/setter 的欄位
generate.getter.error.no.fields=找不到要為之生成 getter 的欄位
generate.getter.error.no.fields.without.getters=找不到沒有 getter 的欄位
generate.getter.setter.header.visibility.hint.=根據“檔案 | 設定 | 編輯器 | 程式碼樣式 | Java | 程式碼生成“套用可見性
generate.members.nothing.to.insert=未找到要插入的內容
generate.setters.no.fields=找不到要為之生成 setter 的欄位
generate.setters.no.fields.without.setters=找不到沒有 setter 的欄位
implement.abstract.method.potential.implementations.with.weaker.access=找到具有較弱存取權限的潛在實作: {0}
implement.method.no.methods.to.implement=找不到要實作的方法
action.sort.by.percent.classes.which.overrides.method.text=按覆寫方法的類百分比排序
action.sort.by.percent.classes.which.overrides.method.description=按覆寫方法的類百分比排序
override.methods.error.no.methods=找不到要覆寫的方法
base.package.parameter.wizard.label=基礎軟體套件(&P):
type.migration.multi.root.toolwindow.title=遷移 {0} 的類型
type.migration.single.root.toolwindow.title=將 {0} 的類型從 ''{1}'' 遷移到 ''{2}''
type.migration.processed.elements.header=類型遷移的根
type.migration.cannon.convert.tooltip=無法將類型 <b>{0}</b> 的表達式{3, choice, 0#|1# 從 '<'b'>'{1}'<'/b'>' 轉換為 '<'b'>'{2}'<'/b'>'}<br>
type.migration.replaced.notification=取代為 {0}
type.migration.cannot.convert.tooltip=無法將表達式的類型從 {0} 轉換為 {1}
type.migration.getter.rename.suggestion.text=由於返回類型已遷移到 ''{2}''，getter 名稱是否從 ''{0}'' 遷移到 ''{1}''?
type.migration.getter.rename.suggestion.never.migrate.method.names=從不遷移方法名稱
type.migration.getter.rename.suggestion.always.migrate.method.names=始終遷移方法名稱
hint.text.press.to.go.through.inlined.occurrences=按 {0} 遍歷 {1} 個已內聯符合項
hint.text.occurrences.were.inlined={0} 個符合項已內聯
action.expand.static.import.text=展開靜態匯入
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=無法內聯類，因為其構造函數的調用未解析
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=無法內聯類，因為其用作 'this' 限定符
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=無法內聯類，因為其用於 'throws' 子句
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=無法內聯類，因為其用於 'catch' 子句
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=無法內聯類，因為其具有自身類文字的用法
class.cannot.be.inlined.because.it.has.static.initializers=無法內聯類，因為其具有 static 初始設定式
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=無法內聯類，因為其具有未從自身超類繼承的欄位的用法
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=無法內聯類，因為其具有帶非常數初始設定式的 static 欄位
class.cannot.be.inlined.because.it.has.static.non.final.fields=無法內聯類，因為其具有 static 非 final 欄位
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=無法內聯類，因為其具有自身內部類的用法
class.cannot.be.inlined.because.it.has.static.inner.classes=無法內聯類，因為其具有 static 內部類
class.cannot.be.inlined.because.it.has.static.methods=無法內聯類，因為其具有 static 方法
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=無法內聯類，因為其方法的部分用法並非繼承自其超類或接口
class.cannot.be.inlined.because.its.constructor.contains.return.statements=無法內聯類，因為其構造函數包含 'return' 語句
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=無法內聯類，因為無法解析其實作的一個接口
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=無法內聯類，因為無法解析其超類
library.classes.cannot.be.inlined=庫類無法內聯
enums.cannot.be.inlined=枚舉無法內聯
interfaces.cannot.be.inlined=接口無法內聯
annotation.types.cannot.be.inlined=註解類型無法內聯
type.parameters.cannot.be.inlined=類型參數無法內聯
postfix.template.editor.choose.class.title=選擇類
null.check.surrounder.description=if (expr != null) {…}
push.method.down.command.name=向下推送方法…
replace.implements.with.static.import.field.usages.progress=尋找常數欄位用法…
show.siblings.choose.super.class.title=選擇超類或接口
show.siblings.find.usages.method.title=super 方法
show.siblings.find.usages.class.title=超類/接口
switch.stmt.template.description=switch (expr) {…}
wrap.return.value.created.class.not.accessible.conflict=創建的類將無法在調用位置存取
wrap.return.value.existing.class.does.not.have.getter.conflict=現有類沒有所選欄位的 getter
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=現有類沒有適當的構造函數
wrap.return.value.anonymous.class.presentation=匿名 {0}
empty.title=空
separator.annotations.to.copy=要複製的註解
action.go.to.implementation.text=轉到實作
action.go.to.subclass.text=轉到子類
action.go.to.overriding.methods.text=轉到覆寫方法
action.go.to.super.method.text=轉到 super 方法
tooltip.recursive.call=遞歸調用
label.compact.constructor=壓縮構造函數
label.canonical.constructor=規範構造函數
edit.contract.dialog.checkbox.pure.method=方法為純方法(沒有副作用) (&P)
separator.mark.as.entry.point.if.annotated.by=如果已註解，則標記為入口點:
separator.mark.field.as.implicitly.written.if.annotated.by=如果已註解，則將欄位標記為隱式寫入:
rename.super.methods.chooser.popup.title={0} 具有 super 方法
rename.super.base.chooser.popup.title={0} {1, choice, 0#實作|1#覆寫} {2} 的方法
add.methods.dialog.or=\ 或
command.name.delegate.detected.change=委託
encapsulate.fields.dialog.javadoc.title=Javadoc
find.jar.hint.text.no.libraries.found.for.fqn=未找到 ''{0}'' 的庫
dependant.sdk.unsatisfied.dependency.message=需要先設定 Java SDK
javadoc.gen.error.modules.without.module.info=IDEA 無法生成 Javadoc，因為模組 {0} 不含 module-info.java 檔案
javadoc.gen.error.module.source.path.is.not.evaluated=IDEA 無法生成 Javadoc，因為無法評估 module-source-path
generate.members.implement.command=實作
code.style.settings.angle.spacing.brackets=尖括號
code.style.settings.spacing.after.closing.angle.bracket=右尖括號之後
code.style.settings.spacing.around.type.bounds=類型界限周圍
non.code.annotations.explanation.external.and.inferred.available=外部和<i>推斷</i>註解可用。
non.code.annotations.explanation.external.available=外部註解可用。
non.code.annotations.explanation.inferred.available=<i>推斷</i>註解可用。
non.code.annotations.explanation.full.signature=完整簽名:
type.migration.command.name=TypeMigration
dfa.constraint.not.null=非 null
dfa.constraint.0.not.null={0}(非 null)
dfa.constraint.null.or.0=null 或 {0}
label.class.pattern.syntax.explanation=將此方法留空以表示構造函數\n任何 * 將符合限定名稱中的一個或多個字符(包括點)
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0#模組|2#模組}{1}{0, choice, 0#不|2#不}引用具有 IntelliJ IDEA 可空性註解的 ''{2}'' 庫。是否要立即添加{0, choice, 0#依賴項|2#依賴項}?
tab.title.slices.grouped.by.nullness=\ (按可空性分組)
exclude.0.from.auto.import=從自動匯入中排除 ''{0}''
column.name.method.entry.point=方法
column.name.class.entry.point=類
column.name.with.subclasses.entry.point=包含子類
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number} 個實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number} 個覆寫}
hint.text.tostring.method.could.not.be.created.from.template=無法從模板 ''{0}'' 創建 ''toString()'' 方法
hint.text.tostring.template.invalid=toString() 模板 ''{0}'' 無效
command.name.generate.tostring=生成 toString()
column.name.ignore.suppressions=忽略禁止
ignored.suppressions=已忽略禁止:
hint.text.removed.imports=已移除 {0} 個{1, choice, 0#匯入|1#匯入}
hint.text.added.imports=，已添加 {0} 個{1, choice, 0#匯入|1#匯入}
hint.text.rearranged.imports=已重新排列匯入
enum.constant.ordinal=枚舉常數序數: 
tab.title.infer.nullity.preview=推斷可空性預覽
inspection.message.full.description=完整描述
popup.title.debug.recent.tests=偵錯最近的測試
list.item.suite=[套件] {0}
list.item.configuration=[設定] {0}
no.jre.description=<無 JRE>
popup.content.tests.were.not.found.in.module.use.instead=改用{0, choice, 0#模組 {1} |1# \n{2} 之一\n}
postfix.template.provider.name=Java
postfix.template.condition.void.name=void
postfix.template.condition.non.void.name=非 void
postfix.template.condition.boolean.name=布爾
postfix.template.condition.number.name=數字
postfix.template.condition.not.primitive.type.name=非基元類型
postfix.template.condition.array.name=陣列
inspection.redundant.unmodifiable.call.display.name=''{0}'' 包裝器的冗餘用法
inspection.redundant.unmodifiable.call.description=不可修改的集合包裝器的冗餘用法
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=解開實參
completion.override.implement.methods=覆寫/實作方法…
lambda.tree.node.presentation=Lambda
inspection.meaningless.record.annotation.description=無意義的記錄註解
inspection.meaningless.record.annotation.message.method.and.parameter=註解不起任何作用: 它的目標是 METHOD 和 PARAMETER，但顯式宣告了存取器和規範構造函數
inspection.meaningless.record.annotation.message.method=註解不起任何作用: 它的目標是 METHOD，但顯式宣告了相應的存取器
inspection.meaningless.record.annotation.message.parameter=註解不起任何作用: 它的目標是 PARAMETER，但顯式宣告了規範構造函數
header.method.to.be.converted=要轉換的方法
accessible.name.change.modifier=更改修飾符
usages.telescope={0,choice, 0#0 個用法|1#1 個用法|2#{0,number} 個用法}
press.to.navigate=按 {0} 導航
label.jvm.method.name=JVM 方法名稱
link.configure.classes.excluded.from.completion=設定從補全中排除的類
inspection.preview.feature.0.is.preview.api.message={0} 是預覽 API，可能會在將來的版本中移除
progress.title.detect.overridden.methods=檢查覆寫方法
intention.name.iterate.over=迭代 {0}
advanced.settings.group.compiler=編譯器
advanced.setting.compiler.automake.allow.when.app.running=即使開發的應用程式當前正在執行，也允許自動 make 啟動
advanced.setting.compiler.automake.allow.when.app.running.description=自動啟動 make 最終可能會刪除該套用程序所需的一些類。

dialog.title.check.functional.interface.candidates=檢查功能接口候選項…
scheduled.thread.pool.executor.with.zero.core.threads.display.name=帶零個核心執行緒的 'ScheduledThreadPoolExecutor'
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' 不應具有零個核心執行緒
popup.content.tests.were.not.found.in.module=在模組 ''{0}'' 中找不到測試。
popup.content.tests.were.not.found.in.module.search.in.dependencies=改為在模組依賴項中搜尋
find.options.include.accessors.checkbox=搜尋存取器(&A)
find.options.include.accessors.base.checkbox=搜尋存取器的基方法(&E)
find.options.include.accessors.base.checkbox.comment=預設使用頂層層次結構方法作為尋找用法目標
find.options.search.overriding.methods.checkbox=在覆寫方法中搜尋(&O)
find.what.search.for.base.methods.checkbox=搜尋基方法用法(&E)
find.what.search.for.base.methods.checkbox.comment=預設使用頂層層次結構方法作為尋找用法目標
popup.title.select.target.code.block=選擇目標程式碼塊
target.code.block.presentable.text=包含塊
conflict.message.method.will.override.method.base.class=重命名的 {0} 將覆寫基 {1} 的方法
progress.title.looking.for.jdk=正在尋找 JDK…
intention.category.collections=Java/集合
intention.category.conditional.operator=Java/條件運算符
intention.category.i18n=Java/I18N
dialog.title.check.configuration=檢查設定…
dialog.message.template.not.found=找不到模板
dialog.message.template.not.applicable=模板不適用
dialog.message.class.not.found=找不到模板類 ''{0}''
notification.content.was.set.up=已為專案設定了 JDK ''{0}''
notification.content.change.jdk=更改 JDK
nullable.notnull.annotation.used.label=用於生成程式碼的註解:
button.to.another.directory=到目錄(&D)
button.to.another.source.root=到源根(&S)
where.do.you.want.to.move.directory.prompt={0}\n\n要將目錄移動到另一個源根還是另一個目錄?
loading.additional.annotations=正在載入其他註解…
tooltip.anonymous=匿名
tooltip.has.several.functional.implementations=有多個函數實作
tooltip.implements.method=實作方法
tooltip.in=位置
tooltip.is.functionally.implemented.in=函數實作位置:
tooltip.is.implemented.by=實作物件:
tooltip.is.implemented.by.several.subclasses=由多個子類實作
tooltip.is.implemented.in=在以下位置實作:
tooltip.is.implemented.in.several.subclasses=在多個子類中實作
tooltip.is.overridden.by.several.subclasses=被多個子類覆寫
tooltip.is.overridden.in=在以下位置被覆寫:
tooltip.is.overridden.in.several.subclasses=在多個子類中被覆寫
tooltip.is.subclassed.by=被以下物件子類化
tooltip.overrides.method=覆寫方法
tooltip.via.subclass=通過子類
label.ignore.complicated.fix=當內聯參數初始設定式不成功時忽略
tooltip.implements.method.in=在以下位置實作方法:
tooltip.overrides.method.in=在以下位置覆寫方法:
progress.title.calculate.applicable.types=計算適用類型…
completion.inner.scope.tail.text=(來自 {0} 塊)
completion.inner.scope=內部
javadoc.documentation.url.checked=已檢查以下文檔 {0, choice, 1#URL|2#URL}:
javadoc.edit.api.docs.paths=編輯 API 文檔路徑
inspection.unused.symbol.check.parameters.excluding.hierarchy=排除層次結構
tooltip.reassigned.local.variable=重新分配的局部變數
tooltip.reassigned.parameter=重新指定的參數
javadoc.generate.options.separator=JavaDoc 選項
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=移除冗餘的 Optional 鏈
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=Optional 鏈可被消除
inspection.optional.get.without.is.present.method.reference.message=<code>#ref</code> 未進行 'isPresent()' 檢查
inlay.parameters.java.method.name.contains.parameter.name=從方法名中清除預期實參時接受單個實參的方法，如存取器方法。
inlay.parameters.java.multiple.params.same.type=對具有同一類型的多個非文字實參的方法的調用。
inlay.parameters.java.build.like.method=返回方法本身操作的類的實例的方法，例如，StringBuilder 鏈中的調用或 Java 8 Stream API 中的中間操作。
inlay.parameters.java.simple.sequentially.numbered=接受多個參數的方法，這些參數的名稱由一個字母後跟一個數字組成。
inlay.parameters.java.enums=使用參數化構造函數的枚舉常數宣告。
inlay.parameters.java.new.expr=對參數化構造函數的調用。
inlay.parameters.java.clear.expression.type=使用複雜表達式作為實參的方法調用，例如，三元運算符或 Java 13 switch 語句。
add.to.permits.list.family.name=將類添加到 permits 列表
raw.variable.type.can.be.generic.cast.quickfix=將轉換類型更改為 {0}
raw.variable.type.can.be.generic.cast.quickfix.family=參數化轉換類型
inlay.MethodChainsInlayProvider.description=調用鏈中的方法返回類型。
intention.family.name.move.class.to.test.root=將類移至測試根
intention.name.move.class.to.test.root=將 ''{0}'' 移至測試根
inlay.annotation.hints.inferred.annotations=IntelliJ IDEA 通過掃描庫和專案程式碼生成的註解。這些註解可以幫助您理解程式碼協定，並提高靜態分析的能力。註解包括: <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href='https://www.jetbrains.com/help/idea/inferring-nullity.html#inferred-annotations'>文檔</a>
inlay.annotation.hints.external.annotations=存儲在原始碼外部的註解。<br>當您需要註解時，這些註解會很有用，但不能將其添加到原始碼(例如，在使用庫程式碼時)。<br><br><a href='https://www.jetbrains.com/help/idea/external-annotations.html'>文檔</a>
title.related.problems.inlay.hints=相關問題
title.code.vision.inlay.hints=Code Vision
javadoc.generate.scope.row=可見性級別:
javadoc.generate.ok=生成
javadoc.generate.validation.error=指定輸出目錄。
megabytes.unit=MB
java.platform.module.system.name=Java 平台模組系統
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name=取代為 'String.valueOf()'
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=Optional 鏈可被取代為 'String.valueOf()'
dialog.title.move.directory=移動目錄
progress.title.checking.if.class.exists=檢查目標類 ''{0}'' 是否存在
wrapping.multi.catch.types=多 catch 中的類型
align.types.in.multi.catch=在多 catch 中對齊類型
quickfix.find.cause.description=嘗試高亮顯示導致此警告的程式碼元素，並解釋它們的確切作用。
completion.generate.via.wizard=(通過嚮導生成)
inspection.slow.list.contains.all.description=對 'list.containsAll(collection)' 的調用可能具有較差性能
inspection.slow.list.contains.all.fix.family.name=包裝在 'HashSet' 構造函數中
inspection.slow.list.contains.all.fix.name=將 ''{0}'' 包裝在 ''HashSet'' 構造函數中
checkbox.spaces.around.annotation.eq=在註解值對的周圍環繞 '='
live.template.context.else='else' 位置
inspection.javadoc.problem.snippet.tag.is.not.available='@snippet' 標記在此語言級別不可用
checkbox.don.t.warn.in.case.of.multiline.lambda=如果 'List.replaceAll()' 的參數為多行 lambda，則不發出警告
inspection.java.8.list.replace.all.display.name=迴圈可以取代為 'List.replaceAll()'
notification.group.jdk.resolve.problems=無法解析 JDK
notification.group.jshell=發生了JShell 問題
notification.group.repository=JAR 檔案已與儲存庫同步
notification.group.source.searcher=找不到 JAR 檔案的源
notification.group.language.level=預覽 Java 語言級別需要接受授權
notification.group.preview.features=預覽 Java 語言級別可能會中斷
notification.group.redundant.exports=可以移除冗餘的匯出/開啟
notification.group.setup.sdk=JDK 已設定
external.annotations.problem.title=無法讀取外部註解
external.annotations.problem.parse.error=檔案: {0}<br>問題: {1}
external.annotations.open.file=開啟註解檔案
inspection.io.stream.constructor.description=可以使用 'Files' 方法建置 'InputStream' 和 'OutputStream'
inspection.input.stream.constructor.message=可以使用 'Files.newInputStream' 建置 'InputStream'
inspection.output.stream.constructor.message=可以使用 'Files.newOutputStream' 建置 'OutputStream'
popup.title.effective.visibility=有效可見性
introduce.parameter.inlay.title.delegate=代理
introduce.parameter.inlay.tooltip.delegate=通過多載方法委託
introduce.parameter.advertisement.text=按 {0} 通過多載方法進行委託，或按 {1} 顯示更多選項
intention.family.name.set.explicit.variable.type=設定顯式變數類型
intention.name.set.variable.type=將變數類型設定為 ''{0}''
notification.group.setup.external.annotations=載入外部註解失敗
inspection.bulk.file.attributes.read.description=可以使用批量 'Files.readAttributes' 調用，而不是多個檔案特性調用
inspection.replace.with.bulk.file.attributes.read.fix.family.name=取代為批量 'Files.readAttributes' 調用
inspection.bulk.file.attributes.read.message=多個檔案特性調用可以取代為單個 'Files.readAttributes' 調用
progress.title.collect.method.overriders=收集方法覆寫器...
settings.inlay.java.implicit.types.description=當推斷的類型可能無法從賦值的右側部分看清時(例如，使用工廠方法時)，使用 var 關鍵字宣告的局部變數。
inspection.missingJavadoc.display.name=缺少 Javadoc
inspection.missingJavadoc.label.minimalVisibility=最小可見性:
inspection.missingJavadoc.label.requiredTags=必需標記:
inspection.javadocDeclaration.display.name=Javadoc 宣告問題
unresolved.class.reference.repair.message=嘗試解析類引用
remove.var.keyword.text=移除 'var'
javadoc.description.inferred.annotation.hint=i
intention.family.name.upgrade.jdk=升級 JDK
intention.name.upgrade.jdk.to=將 JDK 升級到 {0}+
inspection.javadoc.blank.lines.display.name=空行應取代為 <p> 以換行
inspection.javadoc.blank.lines.message=空白行將被忽略
inspection.javadoc.blank.lines.fix.name=插入 <p>
inspection.javadoc.blank.lines.fix.family.name=將空白行取代為 <p>
methods.to.override.generate.javadoc=生成缺失的 JavaDoc
inspection.javadoc.link.as.plain.text.display.name=指定為純文本的鏈接
inspection.javadoc.link.as.plain.text.message=指定為純文本的鏈接
class.can.be.record.suppress.conversion.if.annotated=如果類用以下項註解，則禁止轉換:
class.can.be.record.suppress.conversion.if.annotated.fix.name=如果用 ''{0}'' 註解，則禁止記錄轉換
class.can.be.record.suppress.conversion.if.annotated.fix.family.name=禁止記錄轉換
class.can.be.record.conversion.make.member.more.accessible=當轉換使成員更易於存取時:
advanced.setting.compiler.lower.process.priority=以較低優先級執行編譯
advanced.setting.compiler.lower.process.priority.description=在 Windows 上以 IDLE 優先級執行外部 JPS 行程，在 Linux/MacOS 上以 nice 級別 10 執行
action.title.infer.nullity.annotations=推斷可空性註解
intention.family.name.box.primitive.in.conditional.branch=裝箱條件分支中的基元值
progress.title.detecting.jdk=正在檢測 JDK
inspection.replace.javadoc.display.name=可用 Javadoc 取代的註釋
inspection.replace.with.javadoc=取代為 Javadoc 註釋
inspection.replace.with.javadoc.comment=可以將註釋轉換為 Javadoc
assignment.array.element.to.itself.problem.descriptor=陣列元素被分配給自己
inspection.unused.parameter.delete.family=安全刪除未使用的參數
inspection.unused.parameter.problem.descriptor=未使用參數 <code>#ref</code>
inspection.redundant.stream.optional.call.fix.bind.name=將 ''{0}()'' 步驟與前一個 ''{1}()'' 步驟合併
intention.category.annotations=Java/註解
intention.category.boolean=Java/布林值
intention.category.comments=Java/註釋
intention.category.concurrency=Java/並發
intention.category.control.flow=Java/控制流
intention.category.declaration=Java/宣告
intention.category.imports=Java/匯入
intention.category.junit=Java/JUnit
intention.category.other=Java/其他
intention.category.refactorings=Java/重構
intention.category.streams=Java/流
intention.category.strings=Java/字串
intention.category.try.statements=Java/Try 語句
intention.category.code.style=Java/程式碼樣式
intention.category.expressions=Java/表達式
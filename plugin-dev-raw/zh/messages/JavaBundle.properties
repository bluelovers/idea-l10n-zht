abstract.class.not.allowed=不允許抽象類別
access.static.via.instance=通過實例參照存取 static 成員
accessible.name.change.modifier=更改修飾符
action.GotoSuperClass.MainMenu.text=超類別或接口(_U)
action.GotoSuperClass.description=導覽到當前類別擴展或實作的類別的宣告
action.GotoSuperClass.text=轉到超類別或接口(_U)
action.analyzing.cyclic.dependencies.in.scope={0}的迴圈相依
action.create.new.class=建立新的類別
action.create.new.class.description=建立新 Java 類別
action.create.new.module-info.description=建立新的 module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=建立新的 package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=分析迴圈相依
action.description.copy.whole.thread.dump.to.clipboard=將整個執行緒傾印複製到剪貼簿
action.description.group.by.scope=按作用域類型(產品、測試、庫)分組
action.description.group.threads.with.identical.stacktraces=組合具有相同堆疊追蹤的執行緒
action.description.infer.nullity.annotations=推斷為 null 性註解
action.description.mark.directory.as.a.0.for.generated.files=為生成的檔案將目錄標記為{0}
action.description.mark.directory.as.an.ordinary.0=將目錄標記為普通{0}
action.description.show.only.threads.containing.a.specific.string=僅顯示包含特定字串的執行緒
action.dfa.from.stacktrace.text=尋找 ''{0}'' 可以是 {1} 的原因
action.expand.static.import.text=展開靜態匯入
action.find.similar.stack.call.diverged=行號可能出現分叉。嘗試在 ''{0}.{1}()'' 內尋找當前位置
action.find.similar.stack.call.location.not.found=''{0}.{1}()'' 內沒有類似的位置
action.find.similar.stack.call.methods=與 ''{0}.{1}()'' 類似的方法
action.find.similar.stack.call.methods.not.found=沒有與 ''{0}.{1}()'' 類似的方法
action.find.similar.stack.call.similar.calls=''{0}.{1}()'' 內的可能位置
action.go.to.implementation.text=轉到實作
action.go.to.overriding.methods.text=轉到覆寫方法
action.go.to.subclass.text=轉到子類別
action.go.to.super.method.text=轉到 super 方法
action.group.by.package=軟體套件
action.group.by.scope.type=按作用域類型分組
action.implement.method=實作方法
action.implement.methods=實作方法
action.override.method=覆寫方法
action.override.methods=覆寫方法
action.sort.by.percent.classes.which.overrides.method.description=按覆寫方法的類別百分比排序
action.sort.by.percent.classes.which.overrides.method.text=按覆寫方法的類別百分比排序
action.text.0.on.parameter.1=在參數 ''{1}'' 上{0}
action.text.choose.class.in.0=選擇 {0} 中的類別…
action.text.copy.to.clipboard=複製到剪貼簿
action.text.edit.template=編輯模板
action.text.enter.class.name=輸入類別名…
action.text.generated.root.0=生成的{0}
action.text.merge.identical.stacktraces=合併相同的堆疊追蹤
action.text.show.methods.to.implement=顯示要實作的方法
action.text.unmark.generated.0=取消標記生成的{0}
action.title.infer.nullity.annotations=推斷為 null 性註解
add.methods.dialog.or=\ 或
add.to.permits.list=將 ''{0}'' 新增到 sealed 類別 ''{1}'' 的 permit 列表
add.to.permits.list.family.name=將類別新增到 permits 列表
adds.ext.library.preview=將庫 ''{0}'' 新增到模組 ''{1}''
adds.ext.library.preview.import=將庫 ''{0}'' 新增到模組 ''{1}'' 的相依項並匯入 ''{2}''
adds.library.preview=將{0, choice, 1#庫“{1}”|2#其中一個{2}}新增到模組 ''{3}'' 的相依項並匯入未解析的 ''{4}''
adds.library.preview.no.import=將{0, choice, 1#庫“{1}”|2#其中一個{2}}新增到模組 ''{3}'' 的相依項
adds.module.dependencies.preview=將{0, choice, 1#模組“{1}”|2#其中一個{2}}新增到模組 ''{3}'' 的相依項並匯入未解析的類別
advanced.setting.code.vision.java.minimal.usages=Code Vision: 顯示嵌入提示所需的最小用法數量
advanced.setting.compiler.automake.allow.when.app.running=即使開發的應用程式當前正在執行，也允許自動 make 啟動
advanced.setting.compiler.automake.allow.when.app.running.description=自動啟動 make 最終可能會刪除該套用程序所需的一些類別。
advanced.setting.compiler.lower.process.priority=以較低優先級執行編譯
advanced.setting.compiler.lower.process.priority.description=在 Windows 上以 IDLE 優先級執行外部 JPS 程序，在 Linux/MacOS 上以 nice 級別 10 執行
advanced.settings.group.compiler=編譯器
advanced.settings.group.java=Java
align.types.in.multi.catch=在多 catch 中對齊類型
annotate.intention.chooser.title=選擇要新增的註解
annotation.types.cannot.be.inlined=註解類型無法內聯
assignment.array.element.to.itself.problem.descriptor=陣列元素被分配給自己
assignment.to.declared.variable.problem.descriptor=變數''{0}''是自我賦值初始化
assignment.to.itself.problem.descriptor=變數''{0}''是分配給自己
assignment.to.itself.quickfix.name=移除自我賦值
base.package.parameter.wizard.label=基礎軟體套件(&P):
base.package.project.wizard.error.x.not.valid.package={0} 不是有效的軟體套件名稱
bean.property=Bean屬性
boolean.method.is.always.inverted.display.name=布爾方法總是反向的
boolean.method.is.always.inverted.problem.descriptor=始終反轉對布爾方法 '#ref()' 的呼叫
button.add=新增…
button.add.blank=新增空白
button.add.class=新增類別…
button.add.dependency=新增相依項
button.add.package=新增軟體套件…
button.add.pattern=新增模式…
button.annotations=註解…
button.base.method=基方法(&B)
button.code.patterns=程式碼模式…
button.current.method=當前方法(&C)
button.text.settings=設定…
button.to.another.directory=到目錄(&D)
button.to.another.source.root=到來源根(&S)
caller.chooser.referenced.code.title=參照程式碼
cast.expression=插入轉換表達式
cast.to.0=轉換為''{0}''
change.color.command.text=更改顏色
change.signature.from.usage.short.name=<html> 更改 {0}({1}) 的簽名</html>
change.uid.action.name=隨機更改 'serialVersionUID' 初始設定式
checkbox.after.description=在描述後
checkbox.after.parameter.descriptions=在參數描述後
checkbox.after.return.tag=在return後
checkbox.align.parameter.descriptions=對齊參數說明
checkbox.align.thrown.exception.descriptions=對齊拋出異常說明
checkbox.annotate.local.variables=註解區域變數
checkbox.collapse.annotations=註解
checkbox.collapse.anonymous.classes=匿名類別
checkbox.collapse.closures="閉包" (在 Java 8 前，實作一個方法的匿名類別)
checkbox.collapse.end.of.line.comments=行尾註釋序列
checkbox.collapse.generic.constructor.parameters=<html>通用建構函式和方法參數</html>
checkbox.collapse.i18n.messages=I18n 字串
checkbox.collapse.inferred.type=使用推斷類型取代 'var'
checkbox.collapse.inner.classes=內部類別
checkbox.collapse.multiline.comments=多行註釋
checkbox.collapse.one.line.methods=<html>一行方法<html>
checkbox.collapse.simple.property.accessors=<html>簡單屬性存取器</html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.comments.and.javadoc.count.as.content=註釋和 javadoc 計為內容
checkbox.declare.var.type=對區域變數宣告使用 'var'
checkbox.deprecated.members=棄用的成員
checkbox.do.not.indent.top.level.class.members=不縮排頂層類別成員
checkbox.do.not.wrap.after.single.annotation=單個註解後不換行
checkbox.do.not.wrap.one.line.comments=一行註釋不分行
checkbox.don.t.warn.in.case.of.multiline.lambda=如果 'List.replaceAll()' 的參數為多行 lambda，則不發出警告
checkbox.enable.javadoc.formatting=啟用JavaDoc格式
checkbox.enable.leading.asterisks=啟用前導星號
checkbox.generate.p.on.empty.lines=在空行中生成 "<p>"
checkbox.html.report.inaccessible.symbols=<html>報告無法存取的符號<br>(javadoc 工具可能無法建立超鏈接)
checkbox.ignore.chains=忽略可鏈接方法
checkbox.ignore.fields.used.in.multiple.methods=忽略多個方法中使用的欄位
checkbox.insert.imports.for.inner.classes=插入匯入到內部類別
checkbox.iterate.unknown.stream.sources.via.stream.iterator=通過 Stream.iterator() 迭代未知的流源
checkbox.keep.empty.lines=保留空行
checkbox.keep.empty.param.tags=保持空 @param 標籤
checkbox.keep.empty.return.tags=保持空 @return 標籤
checkbox.keep.empty.throws.tags=保持空 @throws 標籤
checkbox.keep.invalid.tags=保持無效標籤
checkbox.make.generated.local.variables.final=將生成的區域變數設為 final
checkbox.make.generated.parameters.final=將生成的參數設為 final
checkbox.param.description.on.new.line=參數描述在新行
checkbox.param.indent.on.continuation=縮排連續線
checkbox.prefer.longer.names=提升較長的名稱
checkbox.preserve.line.feeds=保留換行
checkbox.spaces.around.annotation.eq=註解值對中的 '=' 周圍
checkbox.spaces.before.colon.in.foreach=在 foreach 中的冒號之前
checkbox.spaces.before.deconstruction.list=解構列表
checkbox.spaces.inside.one.line.enum=在一行枚舉大括號內
checkbox.spaces.record.header=記錄標頭
checkbox.spaces.within.deconstruction.list=解構列表
checkbox.suggest.conversion.to.map.computeifabsent=建議轉換為 Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=建議轉換為 Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=建議轉換為 Map.merge
checkbox.suggest.conversion.to.map.putifabsent=建議轉換為 Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=建議轉換為 Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=建議取代，即使 lambda 可能有副作用
checkbox.suppress.with.suppresswarnings=使用 @SuppressWarnings 禁止
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=將 'get(k) != null' 視為與 'containsKey(k)' 相同 (可能更改語意)
checkbox.use.fully.qualified.class.names=使用完全限定類別名
checkbox.use.single.class.import=使用單個類別匯入
checkbox.use.throws.rather.than.exception=用 @throws 而不是 @exception
checkbox.warn.if.only.foreach.replacement.is.available=只要 'forEach' 取代可用，就發出警告
checkbox.warn.if.the.loop.is.trivial=迴圈不重要時發出警告
checkbox.wrap.at.right.margin=在右頁邊距處換行
choose.class=選擇類別
choose.super.class.popup.title=選擇超類別
chooser.text.choose.where.to.save.0=選擇要儲存 ''{0}'' 的位置
chooser.title.select.path.to.save.jar=選擇要儲存 Jar 的路徑
class.can.be.record.conversion.make.member.more.accessible=當轉換使成員更易於存取時:
class.can.be.record.conversion.strategy.convert.silently=無提示轉換
class.can.be.record.conversion.strategy.do.not.convert=不建議轉換
class.can.be.record.conversion.strategy.show.members=在衝突檢視中顯示受影響的成員
class.can.be.record.display.name=類別可以為記錄
class.can.be.record.quick.fix=轉換為記錄
class.can.be.record.suggest.renaming.accessors=建議重新命名 get/is 存取器
class.can.be.record.suppress.conversion.if.annotated=如果類別用以下項註解，則禁止轉換:
class.can.be.record.suppress.conversion.if.annotated.fix.family.name=禁止記錄轉換
class.can.be.record.suppress.conversion.if.annotated.fix.name=如果用 ''{0}'' 註解，則禁止記錄轉換
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=無法內聯類別，因為其建構函式的呼叫未解析
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=無法內聯類別，因為無法解析其實作的一個接口
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=無法內聯類別，因為其具有帶非常數初始設定式的 static 欄位
class.cannot.be.inlined.because.it.has.static.initializers=無法內聯類別，因為其具有 static 初始設定式
class.cannot.be.inlined.because.it.has.static.inner.classes=無法內聯類別，因為其具有 static 內部類別
class.cannot.be.inlined.because.it.has.static.methods=無法內聯類別，因為其具有 static 方法
class.cannot.be.inlined.because.it.has.static.non.final.fields=無法內聯類別，因為其具有 static 非 final 欄位
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=無法內聯類別，因為其具有未從自身超類別繼承的欄位的用法
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=無法內聯類別，因為其具有自身類別文字的用法
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=無法內聯類別，因為其具有自身內部類別的用法
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=無法內聯類別，因為其用作 'this' 限定符
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=無法內聯類別，因為其用於 'catch' 子句
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=無法內聯類別，因為其用於 'throws' 子句
class.cannot.be.inlined.because.its.constructor.contains.return.statements=無法內聯類別，因為其建構函式包含 'return' 語句
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=無法內聯類別，因為無法解析其超類別
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=無法內聯類別，因為其方法的部分用法並非繼承自其超類別或接口
class.decorator.or.has.default.constructor=''{0}'' 應具有預設建構函式或者實作 ''Decorator'' 模式
class.filter.editor.add.dialog.title=新的過濾器
class.filter.editor.choose.class.title=選擇類別
class.filter.editor.table.model.column.name.isActive=活躍
class.filter.editor.table.model.column.name.pattern=模式
class.has.no.default.constructor=''{0}'' 沒有預設的建構函式
class.is.not.a.subclass=''{0}'' 未分配到 ''{1}''
class.is.not.concrete=''{0}'' 不是一個具體類別
class.is.not.public=''{0}'' 不為 public
class.not.found.error.message=未找到類別 ''{0}''
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=模式必須是有效的 java 限定名稱，僅接受 '*' 作為佔位符
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=方法模式 ''{0}'' 必須是有效的 java 關鍵字，僅接受 ''*'' 作為佔位符
class.patterns.panel.add.class=新增類別
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=如果限定名稱符合，則將程式碼標記為入口點
code.style.generation.override.method.signature=覆寫方法簽名
code.style.generation.repeat.synchronized.modifier=重複 synchronized 修飾符(&S)
code.style.generation.replace.null.check=將 null 檢查取代為 Objects::nonNull 或 Objects::isNull
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=在前綴 ''{0}'' 中不是有效的 java 關鍵字部分
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=在後綴 ''{0}'' 中不是有效的 java 關鍵字部分
code.style.generation.use.class.isInstance=如果可能，請使用 Class::isInstance 和 Class::cast
code.style.generation.use.integer.sum=如果可能，請使用 Integer::sum 等
code.style.settings.angle.spacing.brackets=尖括號
code.style.settings.spacing.after.closing.angle.bracket=右尖括號之後
code.style.settings.spacing.around.type.bounds=類型界限周圍
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number} 個實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number} 個覆寫}
column.name.class.entry.point=類別
column.name.method.entry.point=方法
column.name.with.subclasses.entry.point=包含子類別
combobox.paste.insert.imports=貼上時插入 import(&I):
command.create.class.from.template=從模板建立類別
command.create.new.subdirectory=建立新子目錄
command.name.delegate.detected.change=委託
command.name.generate.tostring=生成 toString()
command.name.insert.block.statement=插入塊語句
command.name.replace.type=取代類型
command.name.updating.package.statement=更新 package 語句
comment.the.class.will.be.created.in.the.package.0=類別將在軟體套件 ''{0}'' 中建立
compiler.options=編譯器選項
completion.class.name.hint.2=再次按{0}可以在搜尋時忽略模組相依關係
completion.generate.via.wizard=(通過嚮導生成)
completion.inner.scope=內部
completion.inner.scope.tail.text=(來自 {0} 塊)
completion.no.suggestions.of.type=沒有類型為{0}的建議
completion.override.implement.methods=覆寫/實作方法…
completion.smart.aslist.hint=再次按{0}尋找{1}的集合(Array)
completion.smart.chain.hint=再次按{0}搜尋方法的呼叫鏈
completion.smart.hint=按{0}僅顯示適合類型的變數
completion.smart.toar.hint=再次按{0}尋找{1}的集合
completion.smart.type.generate.anonymous.body=生成匿名體
completion.unknown.type=未知類型{0}
configurable.EqualsHashCodeTemplatesPanel.display.name=模板
configurable.GenerateToStringConfigurable.display.name=設定
configurable.TemplatesPanel.display.name=模板
configure.annotations.option=組態註解…
conflict.message.method.will.override.method.base.class=重新命名的 {0} 將覆寫基 {1} 的方法
convert.compareto.expression.to.equals.call=將 'compareTo()' 表達式轉換為 'equals()' 呼叫
convert.compareto.expression.to.equals.call.may.change.semantics=將 'compareTo()' 表達式轉換為 'equals()' 呼叫 (可能更改語意)
copy.abstract.method.intention.name=使用現有實作''{0}''
copy.abstract.method.no.existing.implementations.found=沒有找到現有的實作
copy.abstract.method.popup.title=選擇要複製的實作
copy.abstract.method.title=使用 abstract 方法實作
copy.paste.reference.notification=<html>已新增 {0} 個{0, choice, 1#匯入|2#匯入}<p><span><a href=''show''>檢查新增的匯入…</a></span></html>
create.class.mapping.dialog.title=選擇 {0} 類別
cyclic.dependencies.progress.text=正在建置相依關係圖
cyclic.dependencies.scope.dialog.module.button={0}模組''{1}'' (&M)
cyclic.dependencies.scope.dialog.project.button={0}整個專案(&P)
cyclic.dependencies.scope.dialog.title=指定{0}作用域
cyclic.dependencies.scope.include.test.sources.option=包含測試程式碼(&T)
cyclic.dependencies.tree.cycle.node.text=迴圈
cyclic.dependencies.usage.view.initial.text=從左邊樹選擇分析的軟體套件
cyclic.dependencies.usage.view.root.node.text=在軟體套件 ''{1}'' 中使用軟體套件 ''{0}''
dataflow.from.here=流出此處的數據流
dataflow.to.here=流入此處的數據流
deannotate.intention.action.family.name=取消註解
deannotate.intention.action.several.text=取消註解…
deannotate.intention.action.text=取消註解 {0}
deannotate.intention.chooser.title=選擇要刪除的註解
default.package.presentable.name=<預設>
default.param.value.warning=具有所選簽名的{0, choice, 0#建構函式|1#方法}已存在
dependant.sdk.unsatisfied.dependency.message=需要先組態 Java SDK
dependencies.libraries.node.text=庫
dependencies.tree.node.default.package.abbreviation=<預設軟體套件>
destination.combo.source.root.not.expected.conflict=應為測試根，但選擇了來源根
destination.combo.test.root.not.expected.conflict=應為來源根，但選擇了測試根
dfa.constraint.0.not.null={0}(非 null)
dfa.constraint.not.null=非 null
dfa.constraint.null.or.0=null 或 {0}
dialog.create.class.destination.package.label=目標軟體套件:
dialog.create.class.label=建立 {0}:
dialog.create.class.name=建立{0}{1}
dialog.create.class.package.chooser.title=選擇目標軟體套件
dialog.edit.template.checkbox.smart.type.completion=類型符合補全(&O)
dialog.edit.template.checkbox.use.static.import=盡可能使用靜態匯入(&I)
dialog.import.on.paste.title=選擇要匯入的類別
dialog.import.on.paste.title2=選擇要匯入的元素
dialog.import.on.paste.title3=選擇要移除的匯入
dialog.message.0.update.existing.class={0}。更新現有的類別?
dialog.message.class.not.found=找不到模板類別 ''{0}''
dialog.message.create.test.in.the.same.source.root=在相同的來源根中建立測試?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=推斷為 null 性註解需要將專案語言級別設定為 1.5 或更高。
dialog.message.jetbrains.annotations.library.is.missing=缺少 JetBrains 註解庫。\n沒有庫，IntelliJ IDEA 將無法執行分析。要新增嗎?
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0#模組|2#模組}{1}{0, choice, 0#不|2#不}參照具有 IntelliJ IDEA 為 null 性註解的 ''{2}'' 庫。是否要立即新增{0, choice, 0#相依項|2#相依項}?
dialog.message.no.places.found.to.infer.nullable.notnull=未找到要推斷 @Nullable/@NotNull 的位置
dialog.message.parameter.has.write.usages.inline.not.supported=參數具有寫入用法。不支持內聯
dialog.message.template.not.applicable=模板不適用
dialog.message.template.not.found=找不到模板
dialog.paste.on.import.text=<html>您所貼上的程式碼段使用了在新上下文中無法通過匯入存取的類別。<br/>請選擇要匯入到新檔案中的類別。</html>
dialog.paste.on.import.text2=<html>您所貼上的程式碼段使用了在新上下文中無法通過匯入存取的元素。<br/>請選擇要匯入到新檔案中的元素。</html>
dialog.paste.on.import.text3=<html>您貼上的程式碼段在當前上下文中引入了新的匯入。<br/>選擇您想要消除的匯入。</html>
dialog.title.check.configuration=檢查組態…
dialog.title.check.functional.interface.candidates=檢查功能接口候選項…
dialog.title.choose.0.parameters=選擇 {0} 參數
dialog.title.choose.annotation=選擇 {0} 註解
dialog.title.choose.class=選擇類別
dialog.title.configure.annotations=組態註解
dialog.title.configure.code.patterns=組態程式碼模式
dialog.title.copy.template=複製模板
dialog.title.create.class.in.package=在軟體套件中建立類別
dialog.title.create.missed.tests=建立缺少的測試
dialog.title.create.new.template=建立新模板
dialog.title.edit.method.contract=編輯方法協定
dialog.title.edit.range=編輯 ''{0}'' 的範圍
dialog.title.infer.nullity=推斷為 null 性
dialog.title.infer.nullity.results=推斷為 null 性結果
dialog.title.move.directory=移動目錄
dialog.title.no.test.roots.found=未找到測試根
dialog.title.process.duplicates=處理重複項
dialog.title.super.method.found=發現 super 方法
dialog.title.testdatapath.file.generate=從類別生成檔案到 @TestDataPath
dialog.title.testdatapath.method.generate=從 @TestDataPath 生成方法
disable.report.inaccessible.symbols.fix=不報告無法存取的符號
do.not.import.inner.classes.for=按短名稱排除內部類別:
do.not.import.inner.classes.no.classes=未定義內部類別
edit.contract.dialog.checkbox.impure.method=方法可能會產生副作用(&S)
edit.contract.dialog.hint=<html>請指定約定文本<p>範例: <code>_, null -> false</code><br><small>請參閱意圖動作描述了解詳細資訊</small></html>
edit.contract.dialog.mutates.hint=指定可以改變的逗號分隔元素<p>範例: <code>this,param1</code><p>如果未指定副作用，則留空。
edit.range.dialog.message=如果不受限制則留空
edit.range.error.invalid.value=無效值
edit.range.should.not.be.greater.than.to=不應大於 'to'
edit.range.should.not.be.less.than.from=不應小於 'from'
edit.range.value.should.be.bigger.than=不應大於 {0}
edit.range.value.should.be.less.than=不應小於 {0}
editbox.blanklines.around.initializer=初始設定式周圍:
editbox.class.count.to.use.import.with.star=將 import 與 '*' 搭配使用的類別計數:
editbox.names.count.to.use.static.import.with.star=將靜態 import 與 '*' 搭配使用的名稱計數:
empty.title=空
encapsulate.fields.dialog.javadoc.title=Javadoc
enum.constant.ordinal=枚舉常數序數: 
enum.not.allowed=枚舉不被允許
enums.cannot.be.inlined=枚舉無法內聯
environment.key.description.project.jdk=專案 JDK 的絕對路徑
environment.key.description.project.jdk.name=專案 JDK 的 IDE 可見名稱。
error.attempt.to.generate.constructor.for.anonymous.class=不能新增建構函式到匿名類別
error.hint.no.expression.found=找不到表達式
error.message.ide.does.not.support.starting.processes.using.old.java=IDE 不支持使用 Java {0} 啟動 Java 程序，支援的最低版本為 1.7。更改執行組態以使用較新的 Java 版本。
error.package.already.contains.package-info=''package-info.java'' 的軟體套件已經存在“{0}”
error.package.already.contains.package.html=軟體套件 ''{0}'' 已經有一個 ''package.html'' 檔案。仍要建立 ''package-info.java''?
error.package.html.found.title=發現“package.html”
error.text.this.is.not.a.valid.java.class.name=這不是有效的 Java 類別名
exclude.0.from.auto.import=從自動匯入中排除 ''{0}''
exclude.0.from.completion=從補全中排除 ''{0}''
exclude.accessors=排除存取器(&E)
exclude.from.completion.group=從自動匯入和補全中排除:
exclude.from.imports.no.exclusions=新增類別、軟體套件或成員
exclude.from.imports.no.exclusions.2=以從自動匯入和補全中排除
exclude.import.wildcard.comment=使用 * 萬用字元排除指定類別或軟體套件的所有成員
exclude.table.mask=類別、軟體套件或成員
exclude.table.scope.column=作用域
export.to.html.generate.hyperlinks.checkbox=生成超鏈接指向類別 (&H)
external.annotation.prompt=外部註解提示
external.annotations.external.option=從外部新增(&E)
external.annotations.in.code.option=新增程式碼(&C)
external.annotations.open.file=開啟註解檔案
external.annotations.problem.parse.error=檔案: {0}<br>問題: {1}
external.annotations.problem.title=無法讀取外部註解
external.annotations.root.chooser.description=外部註解將被儲存在相應的目錄
external.annotations.root.chooser.title=選擇{0}的外部註解根
external.annotations.roots=註解根
external.annotations.suggestion.message=<html><body>如果您的程式碼中不需要註解，可以使用外部存儲。<br>要組態外部註解，請指定放置包含註解的檔案的根目錄</body></html>
extract.interface.command.name=提取接口
extract.superclass.command.name=提取超類別
extracted.class.should.have.unique.name=已提取類別應具有唯一名稱。已有一個內部類別使用名稱 ''{0}''
filetype.spi.description=服務提供程序接口
find.field.accessors.prompt=搜尋欄位 ''{0}'' 的存取器?
find.field.accessors.title=已找到欄位存取器
find.jar.hint.text.no.libraries.found.for.fqn=未找到 ''{0}'' 的庫
find.options.include.accessors.base.checkbox=搜尋存取器的基方法(&E)
find.options.include.accessors.base.checkbox.comment=預設使用頂層層次結構方法作為尋找用法目標
find.options.include.accessors.checkbox=搜尋存取器(&A)
find.options.include.overloaded.methods.checkbox=多載方法(&V)
find.options.search.overriding.methods.checkbox=在覆寫方法中搜尋(&O)
find.what.derived.classes.checkbox=派生類別(&D)
find.what.derived.interfaces.checkbox=派生接口(&D)
find.what.fields.usages.checkbox=欄位的用法(&F)
find.what.implementing.classes.checkbox=實作類別(&I)
find.what.implementing.methods.checkbox=實作方法(&I)
find.what.implicit.to.string.checkbox=隱式呼叫(&M)
find.what.methods.usages.checkbox=方法的用法 (&M)
find.what.overriding.methods.checkbox=覆寫方法(&R)
find.what.search.for.base.methods.checkbox=搜尋基方法用法(&E)
find.what.search.for.base.methods.checkbox.comment=預設使用頂層層次結構方法作為尋找用法目標
find.what.usages.checkbox=用法 (&U)
find.what.usages.of.classes.and.interfaces=類別和接口的用法 (&C)
fix.move.to.source.root=移至來源根
generate.button.title=生成
generate.constructor.already.exists=建構函式已存在
generate.constructor.fields.chooser.title=選擇要通過建構函式初始化的欄位
generate.constructor.super.constructor.chooser.title=選擇超類別建構函式
generate.delegate.target.chooser.title=選擇目標生成的代表
generate.equals.and.hashcode.already.defined.title=生成 'equals()' 和 'hashCode()'
generate.equals.and.hashcode.already.defined.warning=對於類別 {0}，已定義方法 ''boolean equals(Object)'' 和 ''int hashCode()''。是否要將其刪除並繼續?
generate.equals.and.hashcode.already.defined.warning.anonymous=對於此匿名類別，已定義方法 'boolean equals(Object)' 和 'int hashCode()'。是否要將其刪除並繼續?
generate.equals.hashcode.accept.sublcasses=接受子類別作為 equals() 方法的參數(&S)
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>雖然通常不符合 Object.equals() 的約定，<br>但要使生成的方法與生成代理子類別的框架(如 Hibernate)一起正常工作，<br>可能需要接受子類別。</body></html>
generate.equals.hashcode.equals.fields.chooser.title=選擇要包含在 equals() 中的欄位(&F)
generate.equals.hashcode.hashcode.fields.chooser.title=選擇要包含在 hashCode() 中的欄位(&F)
generate.equals.hashcode.internal.error=內部錯誤
generate.equals.hashcode.non.null.fields.chooser.title=選擇所有非 null 欄位(&F)
generate.equals.hashcode.template=模板(&T):
generate.equals.hashcode.use.getters=在程式碼生成過程中使用 &getters
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode()不支持陣列
generate.equals.hashcode.wizard.title=生成 equals() 和 hashCode()
generate.equals.no.fields.for.generation=找不到要包含在 equals/hashCode 中的欄位
generate.equals.template.title=Equals 模板:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals()不支持嵌套的陣列
generate.equals.warning.generated.equals.could.be.incorrect=生成的Object[]的equals()可能不正確
generate.file.extension.text=輸入檔案副檔名: .php、.java、.kt、.cpp …
generate.file.extension.validation.error=檔案副檔名 ''{0}'' 無效。必須以 ''.'' 開頭，不能包含空格，也不能為空
generate.getter.and.setter.error.no.fields=找不到要為之生成 getter/setter 的欄位
generate.getter.and.setter.error.no.fields.without.getters.and.setters=找不到沒有 getter/setter 的欄位
generate.getter.and.setter.error.setters.for.read.only.not.generated=未生成唯讀欄位的 setter
generate.getter.error.no.fields=找不到要為之生成 getter 的欄位
generate.getter.error.no.fields.without.getters=找不到沒有 getter 的欄位
generate.getter.fields.chooser.title=選擇要生成 Getter 的欄位
generate.getter.setter.header.visibility.hint.=根據“檔案 | 設定 | 編輯器 | 程式碼樣式 | Java | 程式碼生成”套用可見性
generate.getter.setter.title=選擇要生成 Getter 和 Setter 的欄位
generate.getter.template=Getter 模板(&G):
generate.hashcode.template.title=HashCode 模板:
generate.members.implement.command=實作
generate.members.nothing.to.insert=未找到要插入的內容
generate.method.nofiles.warn=在類別 {0} 中找不到測試方法
generate.method.nosuites.warn=在 @TestDataPath("{0}") 中找不到測試套件
generate.missed.tests.action.error.no.tests.found=找不到測試。
generate.missed.tests.action.failed.to.detect.framework=無法檢測到 {0} 的測試框架
generate.quickfix.files=建立 QF 方案(使用 '.after' 後綴)
generate.record.constructor.title=生成記錄建構函式
generate.select.default.modifier.text=選擇修飾符
generate.setter.fields.chooser.title=選擇要生成 Setter 的欄位
generate.setter.template=Setter 模板(&S):
generate.setters.no.fields=找不到要為之生成 setter 的欄位
generate.setters.no.fields.without.setters=找不到沒有 setter 的欄位
generate.test.support.method.error.cannot.generate.method=無法生成方法: {0}
generate.test.support.method.error.method.already.exists=方法 {0} 已存在
generate.test.support.method.error.no.template.found.for.framework=沒有找到 {0} 的模板: {1}
generate.tostring.already.exist.border=當方法已存在時
generate.tostring.available.implicit.variables.label=可用的隱式變數:<br/>{0}
generate.tostring.exclude..transient=排除 transient 欄位
generate.tostring.exclude.by.field.name=按名稱排除欄位 (reg exp)
generate.tostring.exclude.by.field.type=按類型名稱排除欄位 (reg exp)
generate.tostring.exclude.by.name=按名稱排除方法 (reg exp)
generate.tostring.exclude.by.return.type=按返回值類型名稱排除方法 (reg exp)
generate.tostring.exclude.constant.fields=排除常數欄位
generate.tostring.exclude.enum.fields=排除枚舉欄位
generate.tostring.exclude.logger=排除記錄器欄位 (Log4j、JDK 日誌記錄、Jakarta Commons 日誌記錄)
generate.tostring.exclude.static.fields=排除 static 欄位
generate.tostring.fully.qualified.class.name=在程式碼生成中使用完全限定類別名 ($classname)
generate.tostring.getters.in.generated.code=在程式碼生成中啟用 getter ($methods)
generate.tostring.handle.exception.error.message=執行動作時拋出不可恢復的異常 - 請參閱 IDEA 日誌以獲取詳細資訊 (堆疊追蹤應位於 idea.log 中):\n{0}
generate.tostring.handle.exception.plugin.warning.message=執行動作時拋出 PluginException - 請參閱 IDEA 日誌以獲取詳細資訊 (堆疊追蹤應位於 idea.log 中):\n{0}
generate.tostring.handle.exception.velocity.error.message=生成程式碼時出現 Velocity 錯誤 - 請參閱 IDEA 日誌以獲取更多詳細資訊 (堆疊追蹤應位於 idea.log 中):\n{0}
generate.tostring.insert.border=在哪裡插入?
generate.tostring.method.already.exists.dialog.me=ssage=取代現有的 {0} 方法
generate.tostring.method.already.exists.dialog.title=方法已存在
generate.tostring.move.to.generated.checkbox=將文字游標移至生成的方法
generate.tostring.settings=設定
generate.tostring.sort.ascending=升序
generate.tostring.sort.checkbox=對元素進行排序
generate.tostring.sort.descending=降序
generate.tostring.sort.super=超類別成員優先
generate.tostring.tab.title=toString() 生成設定
generate.tostring.template.label=模板(&T):
generate.tostring.title=生成 toString()
goto.super.class.chooser.title=選擇超類別或接口
group.javadoc.alignment=對齊
group.javadoc.blank.lines=空行
group.javadoc.invalid.tags=無效標籤
group.javadoc.other=其他
gutter.implemented.method=已實作方法
gutter.implementing.method=實作方法
gutter.overridden.method=覆寫的方法
gutter.overriding.method=覆寫方法
gutter.service=服務
gutter.sibling.inherited.method=同級繼承的方法
header.method.to.be.converted=要轉換的方法
hide.out.of.cyclic.packages.action.description=隱藏沒有迴圈相依的軟體套件
hide.out.of.cyclic.packages.action.text=隱藏沒有迴圈相依的軟體套件
highlight.exceptions.thrown.chooser.title=選擇異常類別以醒目提示
highlight.imported.classes.chooser.title=選擇匯入醒目提示的類別
highlight.imported.members.chooser.title=選擇匯入醒目提示的成員
highlight.overridden.classes.chooser.title=選擇醒目提示其中覆寫的方法的類別
highlight.suppressed.warnings.choose.inspections=選擇檢查以醒目提示此項中的已禁止問題
highlight.throws.class.name=醒目提示顯示 Throws {0}
highlight.throws.popup.throwing.places=拋出 {0} 的位置
highlight.throws.popup.usages={0} 的用法
hint.text.added.imports=，已新增 {0} 個{1, choice, 0#匯入|1#匯入}
hint.text.not.valid.java.identifier=不是有效的 Java 關鍵字
hint.text.occurrences.were.inlined={0} 個符合項已內聯
hint.text.press.to.go.through.inlined.occurrences=按 {0} 遍歷 {1} 個已內聯符合項
hint.text.rearranged.imports=已重新排列匯入
hint.text.removed.imports=已移除 {0} 個{1, choice, 0#匯入|1#匯入}
hint.text.tostring.method.could.not.be.created.from.template=無法從模板 ''{0}'' 建立 ''toString()'' 方法
hint.text.tostring.template.invalid=toString() 模板 ''{0}'' 無效
icon.preview=圖標預覽
ignore.imports.and.formatting=忽略匯入和格式設定
ignored.suppressions=已忽略禁止:
illegal.name.validation.info=非法名稱: {0}
implement.abstract.method.potential.implementations.with.weaker.access=找到具有較弱存取權限的潛在實作: {0}
implement.method.no.methods.to.implement=找不到要實作的方法
import.layout.panel.all.other.imports=所有其他匯入
import.layout.panel.blank.line.entry=<空行>
import.layout.panel.down.button=下
import.layout.panel.up.button=上
import.layout.static.imports.separately=單獨布局靜態匯入
import.statically=靜態匯入
include.accessors=包含存取器(&I)
increase.language.level.preview.description=模組 ''{0}'' 的語言級別將被更改為 ''{1}''
infer.nullity.progress=正在對結果進行後期處理…
inlay.MethodChainsInlayProvider.description=呼叫鏈中的方法返回值類型。
inlay.annotation.hints.external.annotations=存儲在原始碼外部的註解。<br>當您需要註解時，這些註解會很有用，但不能將其新增到原始碼(例如，在使用庫程式碼時)。<br><br><a href='https://www.jetbrains.com/help/idea/external-annotations.html'>文檔</a>
inlay.annotation.hints.inferred.annotations=IntelliJ IDEA 通過掃描庫和專案程式碼生成的註解。這些註解可以幫助您理解程式碼協定，並提高靜態分析的能力。註解包括: <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href='https://www.jetbrains.com/help/idea/inferring-nullity.html#inferred-annotations'>文檔</a>
inlay.parameters.java.build.like.method=返回方法本身動作的類別的實例的方法，例如，StringBuilder 鏈中的呼叫或 Java 8 Stream API 中的中間動作。
inlay.parameters.java.clear.expression.type=使用複雜表達式作為實參的方法呼叫，例如，三元運算符或 Java 13 switch 語句。
inlay.parameters.java.enums=使用參數化建構函式的枚舉常數宣告。
inlay.parameters.java.method.name.contains.parameter.name=從方法名中清除預期實參時接受單個實參的方法，如存取器方法。
inlay.parameters.java.multiple.params.same.type=對具有同一類型的多個非文字實參的方法的呼叫。
inlay.parameters.java.new.expr=對參數化建構函式的呼叫。
inlay.parameters.java.simple.sequentially.numbered=接受多個參數的方法，這些參數的名稱由一個字母後跟一個數字組成。
insert.override.annotation=插入 @Override 註解(&O)
inspection.anonymous.2.method.ref.display.name=匿名類型可被取代為方法參照
inspection.assert.quickfix=斷言''{0}''
inspection.bulk.file.attributes.read.description=可使用批量 'Files.readAttributes()' 呼叫
inspection.bulk.file.attributes.read.message=多個檔案特性呼叫可被取代為單個 'Files.readAttributes()' 呼叫
inspection.capturing.cleaner=已傳遞到 Cleaner.register() 的可執行物件捕獲 ''{0}'' 參照
inspection.capturing.cleaner.description=清理器捕獲物件參照
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=更改變數類型並移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=將 ''{0}'' 的類型更改為 ''{1}'' 並移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.message=可以通過將 ''{0}'' 的類型更改為 ''{1}'' 來移除轉換
inspection.cast.can.be.removed.narrowing.variable.type.name=太弱的變數類型導致不必要的轉換
inspection.charset.object.can.be.used.display.name=可以使用標準 'Charset' 物件
inspection.charset.object.can.be.used.fix.family.name=使用字符集常數
inspection.charset.object.can.be.used.message=可以改用{0}
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=冗餘的 'Collection.addAll()' 呼叫
inspection.collection.factories.fix.family.name=取代集合工廠回調
inspection.collection.factories.fix.name=取代為 ''{0}.{1}()'' 呼叫
inspection.collection.factories.message=可被取代為 ''{0}.{1}()'' 呼叫
inspection.collection.factories.option.ignore.non.constant=僅在內容為常數時報告
inspection.collection.factories.option.suggest.ofentries=建議 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=可迭代物件用作 vararg
inspection.collection.used.as.vararg.message=可迭代物件作為 vararg 傳遞: 很可能應為陣列
inspection.comparator.combinators.display.name=可以使用 'Comparator' 連結符
inspection.comparator.result.comparison.display.name=compare 方法的可疑用法
inspection.comparator.result.comparison.fix.family.name=修正比較結果
inspection.comparator.result.comparison.problem.display.name=比較方法的結果與特定常數對比
inspection.condition.covered.by.further.condition.display.name=條件由進一步的條件覆蓋
inspection.conditional.break.in.infinite.loop=將條件移至迴圈中
inspection.conditional.break.in.infinite.loop.allow.condition.fusion=允許與現有迴圈條件合併
inspection.conditional.break.in.infinite.loop.description=迴圈內條件中斷
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=不建議取代為 'do while'
inspection.conditional.break.in.infinite.loop.suggest.conversion.when.if.is.single.stmt.in.loop=當 'if' 是迴圈中的單條語句時建議轉換
inspection.conditional.can.be.optional.display.name=條件可被取代為 Optional
inspection.convert.2.method.ref.display.name=lambda 可被取代為方法參照
inspection.convert.2.streamapi.display.name=可以通過 Stream API 摺疊迴圈
inspection.convert.to.local.quickfix=轉換為當地
inspection.data.flow.constant.values.display.name=常量值
inspection.data.flow.display.name=為 null 性和數據流問題
inspection.data.flow.filter.notnull.quickfix=插入'filter(Objects::nonNull)'步驟
inspection.data.flow.ignore.assert.statements=忽略 assert 語句
inspection.data.flow.nullable.quickfix.option=對可 null 值的方法/欄位/參數建議使用 @Nullable 註解
inspection.data.flow.optional.of.nullable.misuse.display.name=具有 null 或非 null 實參的 Optional.ofNullable
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=報告使用 null 文字實參用法的非 null 必需參數
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=報告始終返回非 null 值的可 null 方法
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=報告僅在某些程式碼路徑上發生的問題
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=將未註解的成員和參數視為 @Nullable
inspection.data.flow.true.asserts.option=不報告條件被靜態證明始終為 true 的斷言
inspection.data.flow.use.computeifpresent.quickfix=將 'compute' 取代為 'computeIfPresent'
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=當常數存儲在變數中時發出警告
inspection.dead.code.option.applet=小程序
inspection.dead.code.option.external=非 Java 檔案中使用的類別
inspection.dead.code.option.main=<html><code>void main(String args[])</code> 方法</html>
inspection.dead.code.option.servlet=Servlet
inspection.default.annotation.param=預設註解參數值
inspection.duplicate.branches.in.switch.default.message='switch' 中的分支是預設分支的重複項
inspection.duplicate.branches.in.switch.delete.fix.family.name=刪除冗餘 'switch' 分支
inspection.duplicate.branches.in.switch.delete.fix.name=刪除冗餘 'switch' 分支
inspection.duplicate.branches.in.switch.display.name='switch' 中存在重複分支
inspection.duplicate.branches.in.switch.merge.fix.family.name=合併 'switch' 中的重複分支
inspection.duplicate.branches.in.switch.merge.fix.name=與 ''{0}'' 合併
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=與預設的 'switch' 分支合併
inspection.duplicate.branches.in.switch.message='switch' 中存在重複分支
inspection.duplicate.expressions.complexity.threshold=表達式複雜性閾值
inspection.duplicate.expressions.display.name=同一表達式存在多個符合項
inspection.duplicate.expressions.introduce.variable.fix.family.name=引入變數
inspection.duplicate.expressions.introduce.variable.fix.name=為 ''{0}'' 引入變數
inspection.duplicate.expressions.message=<code>#ref</code> 的多個匹配項 #loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=取代為表達式的其他可變符合項
inspection.duplicate.expressions.replace.other.occurrences.fix.name=將 ''{0}'' 取代為 ''{1}'' 的其他符合項
inspection.duplicate.expressions.reuse.variable.fix.family.name=重用變數
inspection.duplicate.expressions.reuse.variable.fix.name=為 ''{1}'' 重用變數 ''{0}''
inspection.empty.method.delete.quickfix=刪除不必要的方法
inspection.empty.method.display.name=空方法
inspection.empty.method.problem.descriptor=方法只呼叫它的 super
inspection.empty.method.problem.descriptor1=空方法覆寫空方法
inspection.empty.method.problem.descriptor2=該方法為空
inspection.empty.method.problem.descriptor3=該方法和所有它的derivables是空的
inspection.empty.method.problem.descriptor4=此方法的所有實作都為空
inspection.endless.stream.description=非短路動作消耗無限流
inspection.equals.hashcode.display.name='equals()' 和 'hashCode()' 未配對
inspection.equals.hashcode.generate.equals.quickfix=生成 'equals()'
inspection.equals.hashcode.generate.equals.quickfix.preview=開啟一個對話框以組態 'equals()' 生成。
inspection.equals.hashcode.generate.hashcode.quickfix=生成 'hashCode()'
inspection.equals.hashcode.generate.hashcode.quickfix.preview=開啟一個對話框以組態 'hashCode()' 生成。
inspection.excessive.lambda.fix.family.name=常數取代lambda
inspection.excessive.lambda.fix.name=使用沒有lambda的''{0}''方法
inspection.excessive.lambda.message=過度使用 lambda
inspection.excessive.lambda.usage.display.name=過度使用 lambda
inspection.excessive.range.check.display.name=過度範圍檢查
inspection.explicit.argument.can.be.lambda.display.name=顯式實參可以是 lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=將顯式實參取代為函式
inspection.explicit.argument.can.be.lambda.fix.name=使用包含函式實參的 ''{0}'' 方法
inspection.explicit.argument.can.be.lambda.message=顯式實參可以轉換為 lambda
inspection.explicit.array.filling.description=可被取代為單個 ''Arrays.{0}()'' 方法呼叫
inspection.explicit.array.filling.display.name=顯式陣列填充
inspection.explicit.array.filling.fix.family.name=將迴圈取代為 ''Arrays.{0}()'' 方法呼叫
inspection.explicit.array.filling.no.suggestion.for.set.all=不建議使用 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=新增陣列的冗餘初始化
inspection.explicit.array.filling.suggest.set.all=建議 'Arrays.setAll()'
inspection.export.results.callees=呼叫鏈
inspection.export.results.implicit.constructor=隱式建構函式 -
inspection.export.results.overrides.library.methods=覆寫庫方法
inspection.export.results.package=軟體套件
inspection.export.results.type.references=以下使用這種類型
inspection.field.can.be.local.display.name=可以為本地欄位
inspection.field.can.be.local.problem.descriptor=欄位可以被轉換為一個區域變數
inspection.field.can.be.local.quickfix.constructor=將欄位轉換為建構函式中的區域變數
inspection.field.can.be.local.quickfix.initializer=將欄位轉換為初始設定式部分中的區域變數
inspection.field.can.be.local.quickfix.one.method=將欄位轉換為方法 ''{0}'' 中的區域變數
inspection.fill.permits.list.display.name=密封類別的 permits 子句中缺失同一檔案子類別
inspection.fill.permits.list.fix.name=將缺失的子類別新增到 permits 子句
inspection.fill.permits.list.no.missing.inheritors=密封類別沒有缺失的繼承者
inspection.fold.expression.fix.family.name=折疊表達式
inspection.fold.expression.into.stream.display.name=表達式可以折疊到流鏈中
inspection.fold.expression.into.stream.fix.name=將表達式折疊到流鏈中
inspection.fold.expression.into.string.display.name=表達式可以折疊到 'String.join' 中
inspection.fold.expression.into.string.fix.name=將表達式折疊到 'String.join' 中
inspection.forward.compatibility.name=前向相容性
inspection.frequently.used.inheritor.inspection.display.name=類別可以擴展常用的基類別
inspection.functional.expression.can.be.folded.display.name=函式表達式可以折疊
inspection.fuse.stream.operations.display.name=後續步驟可以融合到Stream API鏈中
inspection.fuse.stream.operations.fix.family.name=將更多語句融入 Stream API 鏈
inspection.fuse.stream.operations.fix.name=將 {0} 融合到Stream API 鏈中
inspection.fuse.stream.operations.message=流可能被拓展取代 {0}
inspection.fuse.stream.operations.option.strict.mode=不建議使用 'toList()' 或 'toSet()' 收集器
inspection.handle.signature.change.type.fix.name=將類型更改為 ''{0}''
inspection.handle.signature.field.cannot.resolve=無法解析欄位''{0}''
inspection.handle.signature.field.not.static=欄位 ''{0}'' 不為 static
inspection.handle.signature.field.static=欄位 ''{0}'' 為 static
inspection.handle.signature.field.type=欄位''{0}''的類型是''{1}''
inspection.handle.signature.method.abstract=方法 ''{0}'' 在 ''{1}'' 中是 abstract 方法
inspection.handle.signature.method.not.static=方法 ''{0}'' 不為 static
inspection.handle.signature.method.static=方法 ''{0}'' 為 static
inspection.handle.signature.name=MethodHandle/VarHandle 類型不符合
inspection.handle.signature.not.subclass=呼叫者類別 ''{0}'' 必須是 ''{1}'' 的子類別
inspection.handle.signature.use.constructor.fix.family.name=使用建構函式多載之一
inspection.handle.signature.use.constructor.fix.name=使用建構函式''{0}''
inspection.handle.signature.use.method.fix.family.name=使用方法多載之一
inspection.handle.signature.use.method.fix.name=使用方法''{0}''
inspection.idempotent.loop.body=冪等迴圈體
inspection.illegal.character=非法字元
inspection.inconsistent.text.block.indent.message=文本塊縮排由制表符和空格組成
inspection.inconsistent.text.block.indent.name=文本塊中的空格縮排不一致
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=將空格取代為制表符({0} 個空格 = 1 個制表符)
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=將空格取代為制表符(1 個空格 = 1 個制表符)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=將制表符取代為空格(1 個制表符 = {0} 個空格)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=將制表符取代為空格(1 個制表符 = 1 個空格)
inspection.input.stream.constructor.message=可以使用 'Files.newInputStream()' 建置 'InputStream'
inspection.insert.literal.underscores.display.name=不可讀的數字文字
inspection.insert.literal.underscores.family.name=將下劃線插入數字文字
inspection.io.stream.constructor.description=可以使用 'Files' 方法建置 'InputStream' 和 'OutputStream'
inspection.java.8.collection.remove.if.display.name=迴圈可被取代為 'Collection.removeIf()'
inspection.java.8.list.replace.all.display.name=迴圈可被取代為 'List.replaceAll()'
inspection.java.8.map.api.display.name=可簡化的 'Map' 運算
inspection.java.9.collection.factory.display.name=不可變集合建立可被取代為集合工廠呼叫
inspection.javadoc.blank.lines.display.name=空行應取代為 <p> 以換行
inspection.javadoc.blank.lines.fix.family.name=將空白行取代為 <p>
inspection.javadoc.blank.lines.fix.name=插入 <p>
inspection.javadoc.blank.lines.message=空白行將被忽略
inspection.javadoc.label.text=附加 Javadoc 標記:
inspection.javadoc.link.as.plain.text.display.name=指定為純文本的鏈接
inspection.javadoc.link.as.plain.text.message=指定為純文本的鏈接
inspection.javadoc.lint.display.name=Javadoc中的HTML問題(DocLint)
inspection.javadoc.method.problem.missing.param.tag=參數{0}缺少必需的標籤 <code>@param</code>
inspection.javadoc.method.problem.missing.tag.description={0}標籤說明已丟失
inspection.javadoc.option.ignore.deprecated=忽略標記為 @deprecated 的元素
inspection.javadoc.option.ignore.period=忽略期問題
inspection.javadoc.option.ignore.self.ref=忽略指向自己的Javadoc
inspection.javadoc.option.ignore.simple=忽略簡單的屬性存取器
inspection.javadoc.option.ignore.throws=忽略重複的'throws'標籤
inspection.javadoc.option.tab.title=類別
inspection.javadoc.option.tab.title.field=欄位
inspection.javadoc.option.tab.title.inner.class=內部類別
inspection.javadoc.option.tab.title.method=方法
inspection.javadoc.option.tab.title.module=模組
inspection.javadoc.option.tab.title.package=軟體套件
inspection.javadoc.problem.add.param.tag=為參數''{0}''新增標籤 @param
inspection.javadoc.problem.add.param.tag.family=新增缺少的Javadoc參數標籤
inspection.javadoc.problem.add.tag=新增標籤 @{0}{1}
inspection.javadoc.problem.add.tag.family=新增缺少的 Javadoc 標籤
inspection.javadoc.problem.cannot.resolve=無法解析符號{0}
inspection.javadoc.problem.descriptor=要求Javadoc不在
inspection.javadoc.problem.descriptor1=文檔中缺少句號。Javadoc 工具使用該句號生成概述頁面的註釋
inspection.javadoc.problem.disallowed.tag=此處不允許使用標籤{0}
inspection.javadoc.problem.duplicate.param=重複的參數''{0}'' @param 標記
inspection.javadoc.problem.duplicate.tag=重複的 @{0} 標記
inspection.javadoc.problem.duplicate.throws=重複 @throws 或 @exception 標記為異常''{0}''
inspection.javadoc.problem.inaccessible=無法從此處存取符號 {0}
inspection.javadoc.problem.missing.tag=需要標記{0}是缺失的
inspection.javadoc.problem.missing.tag.description={0}在 @{1} 標記之後丟失
inspection.javadoc.problem.name.expected=應為名稱
inspection.javadoc.problem.pointing.to.itself=Javadoc指向本身
inspection.javadoc.problem.see.tag.expecting.ref=類別/方法參照，參照文本或HTML鏈接，預計後 @see tag
inspection.javadoc.problem.snippet.tag.is.not.available='@snippet' 標記在此語言級別不可用
inspection.javadoc.problem.wrong.tag=錯誤標籤{0}
inspection.javadoc.ref.display.name=宣告在Javadoc參照中有問題
inspection.javadocDeclaration.display.name=Javadoc 宣告問題
inspection.join.declaration.and.assignment.display.name=賦值可與宣告聯接
inspection.join.declaration.and.assignment.fix.family.name=聯接宣告和賦值
inspection.join.declaration.and.assignment.message=賦值可與 ''{0}'' 的宣告聯接
inspection.labeled.switch.rule.redundant.code.block.display.name=標記的 switch 規則具有冗餘程式碼塊
inspection.labeled.switch.rule.redundant.code.block.message=標記規則的程式碼塊冗餘
inspection.labeled.switch.rule.redundant.code.fix.name=取消標記規則的程式碼塊換行
inspection.lambda.can.be.method.call.display.name=lambda 可被取代為方法呼叫
inspection.lambda.to.method.call.fix.family.name=用方法呼叫取代lambda表達式
inspection.lambda.to.method.call.fix.name=用''{0}''取代lambda表達式
inspection.magic.constant.display.name=魔術常數
inspection.magic.constants.should.be.one.of.values=應當為以下之一: {0}{1,choice,0#|1#或其組合}
inspection.manual.min.max.calculation.description=可被取代為 ''Math.{0}()'' 呼叫
inspection.manual.min.max.calculation.disable.for.non.integral=停用 float 和 double
inspection.manual.min.max.calculation.display.name=手動最小值/最大值計算
inspection.map.foreach.display.name=可以使用 Map.forEach()
inspection.map.foreach.option.no.loops=不要報告迴圈
inspection.meaningless.record.annotation.description=無意義的記錄註解
inspection.meaningless.record.annotation.message.method=註解不起任何作用: 它的目標是 METHOD，但顯式宣告了相應的存取器
inspection.meaningless.record.annotation.message.method.and.parameter=註解不起任何作用: 它的目標是 METHOD 和 PARAMETER，但顯式宣告了存取器和規範建構函式
inspection.meaningless.record.annotation.message.parameter=註解不起任何作用: 它的目標是 PARAMETER，但顯式宣告了規範建構函式
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=匿名s #ref #loc 可被取代為方法參照
inspection.message.can.be.replaced.with.0.constructor=可被取代為 ''{0}'' 建構函式
inspection.message.can.be.replaced.with.files.readstring=可被取代為 'Files.readString()'
inspection.message.can.be.replaced.with.files.writestring=可被取代為 'Files.writeString()'
inspection.message.can.be.replaced.with.optional.of.nullable=可被取代為 Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=可被取代為函式樣式的單個表達式
inspection.message.can.be.replaced.with.string.repeat=可被取代為 'String.repeat()'
inspection.message.external.snippet.differs.from.inline.snippet=外部程式碼段與內嵌程式碼段不同
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=''filter().{0}().isPresent()'' 鏈可被取代為 ''anyMatch()''
inspection.message.full.description=完整描述
inspection.message.lambda.parameter.type.is.redundant=Lambda 參數類型冗餘
inspection.message.pattern.variables.can.be.replaced.with.cast=將 'instanceof' 與模式一起使用
inspection.message.pattern.variables.can.be.replaced.with.cast.family.name=無模式取代
inspection.message.pattern.variables.can.be.replaced.with.cast.fix.name=將 ''{0}'' 取代為轉換
inspection.message.pattern.variables.can.be.replaced.with.cast.preserve.option=嘗試在快速修復期間保留模式中未使用的變數
inspection.message.pseudo.functional.style.code=偽函式樣式程式碼
inspection.message.record.can.be.converted.to.class=記錄可以轉換為類別
inspection.message.redundant.default.parameter.value.assignment=冗餘的預設參數值賦值
inspection.message.replace.optional.with.if.statements=將 Optional 取代為 if 語句
inspection.message.snippet.file.not.found=找不到程式碼段檔案 ''{0}''
inspection.message.snippet.region.not.found=找不到區域
inspection.missingJavadoc.display.name=缺少 Javadoc
inspection.missingJavadoc.label.minimalVisibility=最小可見性:
inspection.missingJavadoc.label.requiredTags=必需標記:
inspection.move.field.assignment.to.initializer.display.name=欄位賦值可以移至初始設定式中
inspection.no.jdk.error.message=沒有為此專案正確組態 JDK。無法進行檢查。
inspection.no.modules.error.message=此專案不包含模組。無法進行檢查。
inspection.notnull.field.not.initialized.display.name=@NotNull 欄位未初始化
inspection.notnull.field.not.initialized.message=必須初始化 {0} 欄位
inspection.notnull.field.not.initialized.option.implicit=忽略可以隱式初始化的欄位
inspection.notnull.field.not.initialized.option.setup=忽略在 setUp() 方法中初始化的欄位
inspection.null.value.for.optional.assigned.ignore.fix.name=將 Optional 與 null 比較時不發出警告
inspection.null.value.for.optional.assigned.message=Optional 值與 null 比較
inspection.null.value.for.optional.context.assignment=分配
inspection.null.value.for.optional.context.declaration=宣告
inspection.null.value.for.optional.context.lambda=lambda表達式
inspection.null.value.for.optional.context.parameter=參數
inspection.null.value.for.optional.context.return=return 語句
inspection.null.value.for.optional.fix.family.name=取代空的可選方法
inspection.null.value.for.optional.message=Null 用於 {0} 中的 ''Optional'' 類型
inspection.null.value.for.optional.option.comparisons=報告 Optional 與 null 的比較
inspection.nullable.problems.display.name=@NotNull/@Nullable 問題
inspection.nullable.problems.ignore.external.notnull=忽略外部 @NotNull(&I)
inspection.nullable.problems.method.overrides.notnull.option=報告覆寫 @Nullable 的 @NotNull 參數，反之亦然(&P)
inspection.nullable.problems.method.overrides.option=報告未註解的參數或方法覆寫 @NotNull (&A)
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=報告註解欄位的非註解 setter 參數或 getter(&S)
inspection.nullable.problems.notnull.overrides.option=報告覆寫非註解物件的 @NotNull 參數(&P)
inspection.nullable.problems.notnull.parameters.with.null.literal.option=報告使用 null 文字實參的 @NotNull 參數
inspection.obvious.null.check.display.name=使用明顯非 null 實參呼叫 null 檢查方法
inspection.optional.assigned.to.null.display.name=Optional 類型的 null 值
inspection.optional.get.without.is.present.display.name=在不進行 isPresent() 檢查的情況下呼叫 Optional.get()
inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> 未進行 ''isPresent()'' 檢查
inspection.optional.get.without.is.present.method.reference.message=<code>#ref</code> 未進行 'isPresent()' 檢查
inspection.optional.is.present.display.name=非函式樣式 'Optional.isPresent()' 用法
inspection.optional.to.if.display.name='Optional' 可被取代為 'if' 語句序列
inspection.output.stream.constructor.message=可以使用 'Files.newOutputStream()' 建置 'OutputStream'
inspection.overflowing.loop.index.inspection.description=迴圈執行零次或無限次
inspection.overflowing.loop.index.inspection.name=迴圈執行零次或無限次
inspection.overwritten.key.array.message=被覆蓋的陣列元素
inspection.overwritten.key.display.name=被覆蓋的 Map、Set 或陣列元素
inspection.overwritten.key.map.message=重複的Map key
inspection.overwritten.key.set.message=重複的 Set 元素
inspection.parameter.can.be.local.display.name=從不讀取作為參數傳遞的值
inspection.parameter.can.be.local.problem.descriptor=參數可以被轉化為一個區域變數
inspection.preview.feature=預覽功能警告
inspection.preview.feature.0.is.preview.api.message={0} 是預覽 API，可能會在將來的版本中移除
inspection.quickfix.assert.family=斷言
inspection.raw.use.of.parameterized.type.problem.descriptor=參數化類別 <code>#ref</code> 的原始使用 #loc
inspection.read.write.string.can.be.used.display.name=可以使用 'Files.readString()' 或 'Files.writeString()'
inspection.redundant.array.creation.display.name=冗餘陣列建立
inspection.redundant.array.creation.for.varargs.call.descriptor=呼叫 vararg 方法的冗餘陣列建立
inspection.redundant.array.creation.quickfix=移除顯式陣列建立
inspection.redundant.explicit.close=冗餘 'close()'
inspection.redundant.file.creation.description=<code>#ref</code> 冗餘 #loc
inspection.redundant.file.creation.display.name=建立冗餘 'File' 實例
inspection.redundant.file.creation.quickfix=取代為檔名
inspection.redundant.lambda.parameter.type.display.name=冗餘 lambda 參數類型
inspection.redundant.null.check.always.fail.message=Null 檢查始終失敗: {0} 永不為 null
inspection.redundant.null.check.fix.family.name=移除冗餘 null 檢查
inspection.redundant.null.check.fix.notnull.family.name=移除錯誤的 '!= null'
inspection.redundant.null.check.message=冗餘 null 檢查: {0} 永不為 null
inspection.redundant.operation.on.empty.array.message=陣列 <code>#ref</code> 始終為空
inspection.redundant.operation.on.empty.collection.message=集合 <code>#ref</code> 始終為空
inspection.redundant.operation.on.empty.container.display.name=空容器上存在冗餘動作
inspection.redundant.operation.on.empty.map.message=映射 <code>#ref</code> 始終為空
inspection.redundant.record.constructor.can.be.compact.message=規範建構函式可以轉換為壓縮形式
inspection.redundant.record.constructor.canonical.message=冗餘規範建構函式
inspection.redundant.record.constructor.compact.message=冗餘壓縮建構函式
inspection.redundant.record.constructor.description=冗餘記錄建構函式
inspection.redundant.record.constructor.fix.family.name=將規範建構函式轉換為壓縮形式
inspection.redundant.record.constructor.statement.message=壓縮建構函式中存在冗餘欄位賦值
inspection.redundant.stream.optional.call.display.name='Stream' 或 'Optional' 呼叫鏈中存在冗餘步驟
inspection.redundant.stream.optional.call.explanation.at.most.one=流最多包含一個元素
inspection.redundant.stream.optional.call.explanation.distinct=鏈中存在先前的 'distinct()' 呼叫
inspection.redundant.stream.optional.call.explanation.distinct.set=收集到集時，元素將保持不重複
inspection.redundant.stream.optional.call.explanation.filter=判定始終為 'true'
inspection.redundant.stream.optional.call.explanation.map.flatMap=上一個 'map()' 呼叫可以取代 'flatMap()' 步驟
inspection.redundant.stream.optional.call.explanation.parallel=存在會覆寫此呼叫的後續 ''{0}()'' 呼叫
inspection.redundant.stream.optional.call.explanation.parallel.single=從單個元素建立的流不會並行化
inspection.redundant.stream.optional.call.explanation.parallel.source=流是通過 'parallelStream()' 建立的，所以它已經是並行的
inspection.redundant.stream.optional.call.explanation.sequential.source=流是通過 'stream()' 建立的，所以它已經是順續的
inspection.redundant.stream.optional.call.explanation.sorted=後續的 ''{0}()'' 呼叫不依賴於排序順序
inspection.redundant.stream.optional.call.explanation.sorted.parallel=後續的 ''{0}()'' 動作不依賴於並行流的排序順序
inspection.redundant.stream.optional.call.explanation.sorted.twice=鏈中存在後續的 'sorted()' 呼叫
inspection.redundant.stream.optional.call.explanation.unordered=鏈中存在先前的 'unordered()' 呼叫
inspection.redundant.stream.optional.call.fix.bind.name=將 ''{0}()'' 步驟與前一個 ''{1}()'' 步驟合併
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=收集到 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=移除冗餘的呼叫鏈
inspection.redundant.stream.optional.call.fix.name=移除 ''{0}()'' 呼叫
inspection.redundant.stream.optional.call.fix.replace.terminal=取代終端動作
inspection.redundant.stream.optional.call.fix.replace.terminal.text=將終端動作取代為 ''{0}()''
inspection.redundant.stream.optional.call.message=冗餘的 ''{0}()'' 呼叫
inspection.redundant.stream.optional.call.message.with.explanation=冗餘的 ''{0}()'' 呼叫: {1}
inspection.redundant.stream.optional.call.option.streamboxing=報告 Stream.map() 中的冗餘裝箱
inspection.redundant.unmodifiable.call.description=不可修改的集合包裝器的冗餘用法
inspection.redundant.unmodifiable.call.display.name=''{0}'' 包裝器的冗餘用法
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=解包實參
inspection.reflect.handle.invocation.argument.not.array=實參不是陣列類型
inspection.reflect.handle.invocation.argument.not.exact=實參類型應該是 ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=類型 ''{0}'' 的實參不能為 ''null''
inspection.reflect.handle.invocation.receiver.incompatible=回調接收類型不相容: ''{0}''
inspection.reflect.handle.invocation.receiver.null=呼叫接收器為 'null'
inspection.reflect.handle.invocation.result.not.assignable=應該被轉換為''{0}''或其超類別
inspection.reflect.handle.invocation.result.not.exact=應該被轉換為''{0}''
inspection.reflect.handle.invocation.result.null=返回值總是'null'
inspection.reflect.handle.invocation.result.void=返回值類型為'void'
inspection.reflection.invocation.argument.count=應為{0,choice,0# 0 個實參|1# 1 個實參|1< {0} 個實參}
inspection.reflection.invocation.argument.not.assignable=實參不能分配給 ''{0}''
inspection.reflection.invocation.array.not.assignable=陣列專案具有不相容的類型
inspection.reflection.invocation.item.count={0,choice,0#空陣列|1#1個陣列項|1<{0}個數組項}是預期的
inspection.reflection.invocation.item.not.assignable=陣列項不能分配給''{0}''
inspection.reflection.invocation.name=反射呼叫實參不符合
inspection.reflection.member.access.cannot.resolve.constructor.arguments=無法使用指定的實參類型解析建構函式
inspection.reflection.member.access.cannot.resolve.field=無法解析欄位 ''{0}''
inspection.reflection.member.access.cannot.resolve.method=無法解析方法''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=無法使用指定的實參類型解析方法''{0}''
inspection.reflection.member.access.check.exists=檢查該欄位/方法是否存在於非 final 類別中
inspection.reflection.member.access.check.exists.exclude.chooser=要排除的類別
inspection.reflection.member.access.check.exists.exclude.label=排除類別:
inspection.reflection.member.access.constructor.not.public=建構函式不為 public
inspection.reflection.member.access.field.not.in.class=欄位''{0}''未在類別''{1}''中宣告
inspection.reflection.member.access.field.not.public=欄位 ''{0}'' 不為 public
inspection.reflection.member.access.fix.family.name=使用適當的反射方法
inspection.reflection.member.access.method.not.in.class=方法''{0}''未在類別''{1}''中宣告
inspection.reflection.member.access.method.not.public=方法 ''{0}'' 不為 public
inspection.reflection.member.access.name=對不存在或不可見的類別成員的反射存取
inspection.reflection.visibility.name=跨模組問題的反射存取
inspection.remove.literal.underscores.display.name=數字文字中的下劃線
inspection.remove.literal.underscores.family.name=從數字文字中移除下劃線
inspection.replace.inefficient.stream.count.display.name=以 count() 結尾的低效 Stream API 呼叫鏈
inspection.replace.javadoc.display.name=可用 Javadoc 取代的註釋
inspection.replace.methodref.ternary.quickfix=取代為 null 檢查 lambda
inspection.replace.ternary.quickfix=取代為''{0}!= null嗎?''
inspection.replace.with.bulk.file.attributes.read.fix.family.name=取代為批量 'Files.readAttributes()' 呼叫
inspection.replace.with.bulk.fix.family.name=取代大量方法呼叫
inspection.replace.with.bulk.fix.name=用批量 ''{0}()'' 呼叫取代迭代
inspection.replace.with.bulk.message=迭代可被取代為批量 ''{0}()'' 呼叫
inspection.replace.with.bulk.wrap.arrays=使用 'Arrays.asList()' 包裝陣列
inspection.replace.with.enhanced.switch.statement.fix.name=取代為增強的 'switch' 語句
inspection.replace.with.javadoc=取代為 Javadoc 註釋
inspection.replace.with.javadoc.comment=可以將註釋轉換為 Javadoc
inspection.replace.with.old.style.switch.statement.fix.name=取代為舊式 'switch' 語句
inspection.replace.with.regular.string.literal.fix=取代為正則字串文字
inspection.replace.with.switch.expression.fix.family.name=遷移到增強的 switch
inspection.replace.with.switch.expression.fix.name=取代為 'switch' 表達式
inspection.replace.with.text.block.fix=取代為文本塊
inspection.replace.with.trivial.lambda.fix.family.name=取代為普通 lambda
inspection.replace.with.trivial.lambda.fix.name=取代為返回 ''{0}'' 的 lambda
inspection.require.non.null=將 null 檢查取代為 Objects/Stream static 呼叫
inspection.require.non.null.description=Null 檢查可被取代為方法呼叫
inspection.require.non.null.message={0, choice, 1#''if'' 語句|2#條件表達式}可被取代為對 ''{1}()'' 的呼叫
inspection.require.non.null.no.warning.replacement.bigger=取代長度大於原始長度時不發出警告
inspection.require.non.null.quickfix=將{0, choice, 1# ''if'' 語句|2#條件表達式}取代為 ''{1}()'' 呼叫
inspection.return.separated.from.computation.descriptor=返回與 ''{0}'' 的值的計算分離
inspection.return.separated.from.computation.family.quickfix=將'返回'更接近結果的計算
inspection.return.separated.from.computation.name=與結果計算分離的 'return'
inspection.return.separated.from.computation.quickfix=將“return”更接近計算''{0}''的值
inspection.same.parameter.display.name=方法參數始終具有相同的值
inspection.same.parameter.fix.family.name=內聯參數為常量值
inspection.same.parameter.fix.name=內聯參數 ''{0}'' 的值 ''{1}''
inspection.same.parameter.problem.descriptor=參數 <code>#ref</code> 的實際值始終為 ''{0}''
inspection.simplifiable.comparator.comparing.message=不必要的 ''{0}()'' 呼叫
inspection.simplifiable.comparator.display.name=可以簡化 Comparator 方法
inspection.simplifiable.comparator.entry.comparator.message=可以改用 ''{0}''
inspection.simplifiable.comparator.fix.comparing.family.name=移除冗餘呼叫
inspection.simplifiable.comparator.fix.entry.comparator.family.name=使用預定義的 'Map.Entry' 比較運算符方法
inspection.simplifiable.comparator.fix.remove.name=移除 ''{0}()'' 呼叫
inspection.simplifiable.comparator.fix.replace.name=移除 ''{0}()'' 呼叫並使用 ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=簡化將 'max' 取代為 'min' 的比較運算符方法
inspection.simplifiable.comparator.fix.reversed.name=取代為簡化比較運算符的 ''{0}''
inspection.simplifiable.comparator.reversed.message=如果 ''{0}()'' 呼叫取代為 ''{1}()''，則可以簡化比較運算符方法
inspection.simplify.collector.display.name=可簡化的收集器
inspection.simplify.collector.fix.family.name=簡化級聯器
inspection.simplify.collector.fix.name=使用 ''Collectors.{0}()'' 收集器
inspection.simplify.collector.message=可以使用 ''{0}()'' 收集器簡化
inspection.simplify.for.each.extract.intermediate.operations=提取中間動作
inspection.simplify.foreach.display.name=可簡化的 forEach() 呼叫
inspection.simplify.optional.call.chains.display.name=可以簡化 Optional 呼叫鏈
inspection.simplify.stream.api.call.chains.display.name=可以簡化 Stream API 呼叫鏈
inspection.slow.abstract.set.remove.all.description=呼叫 'set.removeAll(list)' 可能較為緩慢
inspection.slow.abstract.set.remove.all.fix.family.name=使用 'Set.remove' 而不是 'Set.removeAll'
inspection.slow.list.contains.all.description=對 'list.containsAll(collection)' 的呼叫可能具有較差性能
inspection.slow.list.contains.all.fix.family.name=包裝在 'HashSet' 建構函式中
inspection.slow.list.contains.all.fix.name=將 ''{0}'' 包裝在 ''HashSet'' 建構函式中
inspection.sorted.collection.with.non.comparable.keys.display.name=包含不可比較元素的排序集合
inspection.sorted.collection.with.non.comparable.keys.message=包含不可比較元素的排序集合的建構
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=不報告不可比較的類型參數
inspection.static.pseudo.functional.style.method.display.name=Guava 偽函式呼叫可被轉換為 Stream API 呼叫
inspection.stream.api.migration.can.be.replaced.with.call=可被取代為 ''{0}'' 呼叫
inspection.stream.to.loop.display.name=Stream API 呼叫鏈可被取代為迴圈
inspection.string.repeat.can.be.used.display.name=可以使用 String.repeat()
inspection.surround.if.family=使用 if 包圍
inspection.surround.if.quickfix=使用 ''if ({0}{1})'' 包圍
inspection.suspicious.list.remove.display.name=迴圈中的 'List.remove()' 可疑
inspection.suspicious.return.byte.input.stream.convert.to.unsigned = 轉換為無符號位元組
inspection.suspicious.return.byte.input.stream.name = 從 'InputStream.read()' 返回的可疑位元組
inspection.suspicious.ternary.in.varargs.description=vararg 呼叫中的三元運算符包含陣列和非陣列分支
inspection.suspicious.ternary.in.varargs.display.name=vararg 方法呼叫中的可疑三元運算符
inspection.suspicious.ternary.in.varargs.quickfix=包裝在陣列初始設定式中
inspection.switch.expression.backward.expression.migration.inspection.name='switch' 表達式可被取代為舊式 'switch' 語句
inspection.switch.expression.backward.migration.inspection.name=增強的 'switch'
inspection.switch.expression.backward.statement.migration.inspection.name='switch' 語句可被取代為舊式 'switch' 語句
inspection.switch.expression.migration.expression.max.statements=一個分支中要轉換為 switch 表達式的最大語句數
inspection.switch.expression.migration.inspection.name=語句可被取代為增強的 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch 語句可被取代為增強的 'switch'
inspection.switch.expression.migration.option.expression.max.statements=不報告在單個分支中有超過 {0} 條{0, choice, 1#語句|2#語句}的 switch
inspection.switch.expression.migration.warn.only.on.expression=僅在可以轉換為表達式時顯示警告
inspection.switch.labeled.rule.can.be.code.block.display.name=標記的 switch 規則可以具有程式碼塊
inspection.switch.labeled.rule.can.be.code.block.expression.message=標記規則的結果表達式可以使用程式碼塊包裝
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=使用程式碼塊包裝標記規則的結果表達式
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=使用程式碼塊包裝標記規則的語句
inspection.switch.labeled.rule.can.be.code.block.statement.message=標記規則的語句可以使用程式碼塊包裝
inspection.text.block.backward.migration.message=文本塊可以轉換為正則字串文字
inspection.text.block.backward.migration.name=文本塊可被取代為正則字串文字
inspection.text.block.migration.concatenation.message=串聯可被取代為文本塊
inspection.text.block.migration.name=可以使用文本塊
inspection.text.block.migration.string.message=字串可被取代為文本塊
inspection.text.block.migration.suggest.literal.replacement=應用於單字串文字
inspection.trailing.whitespaces.in.text.block.message=文本塊內有尾隨空格字元
inspection.trailing.whitespaces.in.text.block.name=文本塊中的尾隨空格
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=移除尾隨空格字元
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=轉義尾隨空格字元
inspection.trivial.functional.expression.usage.display.name=函式表達式的普通用法
inspection.unchecked.warning.display.name=未檢查的警告
inspection.undeclared.service.usage.message=服務 ''{0}'' 的使用未在模組資訊中宣告
inspection.undeclared.service.usage.name=服務的使用未在 'module-info' 中宣告
inspection.unused.assignment.display.name=未使用的賦值
inspection.unused.assignment.option=報告可取代為二元表達式的前綴表達式
inspection.unused.assignment.option1=報告未使用更改值的後綴表達式
inspection.unused.assignment.option2=報告冗餘的初始設定式
inspection.unused.assignment.option3=報告其值從未使用的模式變數
inspection.unused.assignment.option4=報告其值從未使用的迭代參數
inspection.unused.assignment.problem.descriptor1=變數 <code>#ref</code> #loc 從未使用
inspection.unused.assignment.problem.descriptor2=變數 <code>{0}</code> 初始設定式 <code>#ref</code> #loc 冗餘
inspection.unused.assignment.problem.descriptor3=賦給 <code>#ref</code> #loc 的值 <code>{0}</code> 從未使用
inspection.unused.assignment.problem.descriptor4=在 <code>#ref</code> #loc 更改的值從未使用
inspection.unused.assignment.problem.descriptor5=模式變數 <code>#ref</code> #loc 的值從未使用
inspection.unused.assignment.problem.descriptor6=foreach 迭代參數 <code>#ref</code> #loc 的值從未使用
inspection.unused.assignment.remove.assignment.quickfix=刪除冗餘分配
inspection.unused.assignment.remove.quickfix=移除冗餘的初始設定式
inspection.unused.display.name=未使用的宣告
inspection.unused.parameter.composer=參數 <code>#ref</code> 未用於任何實作
inspection.unused.parameter.composer1=參數 <code>#ref</code> 未在此方法中使用，也未在其覆寫方法中使用
inspection.unused.parameter.delete.family=安全刪除未使用的參數
inspection.unused.parameter.delete.quickfix=安全刪除未使用的參數 ''{0}''
inspection.unused.parameter.problem.descriptor=未使用參數 <code>#ref</code>
inspection.unused.return.value.display.name=方法可以為 'void'
inspection.unused.return.value.make.void.quickfix=使方法無效
inspection.unused.return.value.problem.descriptor=方法的返回值從未使用過
inspection.unused.symbol.check.accessors=Getter/Setter
inspection.unused.symbol.check.classes=類別:
inspection.unused.symbol.check.fields=欄位:
inspection.unused.symbol.check.inner.classes=內部類別:
inspection.unused.symbol.check.localvars=區域變數
inspection.unused.symbol.check.methods=方法:
inspection.unused.symbol.check.parameters=參數位置:
inspection.unused.symbol.check.parameters.excluding.hierarchy=排除層次結構
inspection.use.bulk.operation.display.name=可以使用批量動作代替迭代
inspection.value.based.warnings=基於值的警告
inspection.value.based.warnings.synchronization=嘗試對基於值的類別的實例同步
inspection.variable.assigned.to.itself.display.name=變數被賦值給自己
inspection.wrapper.type.may.be.primitive.display.name=包裝器類型可能是基元
inspection.wrapper.type.may.be.primitive.fix.name=將包裝器類型轉換為基元類型
inspection.wrapper.type.may.be.primitive.name=類型可能是基元
intention.add.explicit.type.arguments.family=新增顯式類型實參
intention.add.on.demand.static.import.family=新增按需靜態匯入
intention.add.on.demand.static.import.text=為 ''{0}'' 新增按需靜態匯入
intention.add.single.member.import.text=為 ''{0}'' 新增 import
intention.add.single.member.static.import.family=新增單成員靜態匯入
intention.add.single.member.static.import.text=為 ''{0}'' 新增靜態匯入
intention.assign.field.from.parameter.family=分配參數場
intention.assign.field.from.parameter.text=將參數分配給欄位 ''{0}''
intention.bind.fields.from.parameters.family=將參數綁定到欄位
intention.bind.fields.from.parameters.text=將 {0} 個參數綁定到欄位
intention.break.string.on.line.breaks.text=在 '\\n' 上斷開字串
intention.category.annotations=Java/註解
intention.category.collections=Java/集合
intention.category.comments=Java/註釋
intention.category.concurrency=Java/並發
intention.category.conditional.operator=Java/條件
intention.category.control.flow=Java/控制流
intention.category.declaration=Java/宣告
intention.category.expressions=Java/表達式
intention.category.i18n=Java/國際化
intention.category.imports=Java/匯入
intention.category.junit=Java/JUnit
intention.category.other=Java/其他
intention.category.refactorings=Java/重構
intention.category.streams=Java/流
intention.category.strings=Java/字串
intention.category.try.statements=Java/Try 語句
intention.compose.function.family=將嵌套函式呼叫取代為組合
intention.compose.function.text=取代嵌套函式呼叫和取代後的呼叫
intention.convert.color.representation.family=轉換顏色表示
intention.convert.color.representation.text=轉換為''新顏色{0}''
intention.convert.compact.constructor.to.canonical=將壓縮建構函式轉換為規範建構函式
intention.convert.to.single.return.command.text=將主體轉換成單個出口點形式
intention.convert.to.single.return.name=將正文轉換成單個出口點形式
intention.convert.to.single.return.progress.title=將正文轉換成單個出口點形式
intention.create.field.from.parameter.family=建立欄位參數
intention.create.field.from.parameter.text=為參數 ''{0}'' 建立欄位
intention.create.switch.statement=建立 switch 語句
intention.create.test.dialog.choose.super.class=選擇超類別
intention.create.test.dialog.class.name=類別名:
intention.create.test.dialog.fix.library=修正
intention.create.test.dialog.generate=生成:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found={0}庫在該模組中未找到
intention.create.test.dialog.select.methods=為以下物件生成測試方法(&M):
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=顯示繼承的方法(&I)
intention.create.test.dialog.super.class=超類別:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=測試庫(&L):
intention.encapsulate.field.text=封裝領域
intention.error.cannot.create.class.message=無法建立類別''{0}''
intention.error.cannot.create.class.title=建立類別失敗
intention.error.make.sealed.class.different.modules=有些繼承者位於不同模組中
intention.error.make.sealed.class.different.packages=模組未命名，某些繼承者位於不同的軟體套件中
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=部分繼承者為匿名或區域
intention.error.make.sealed.class.inheritors.not.in.java.file=有些繼承者不在 Java 檔案中
intention.error.make.sealed.class.interface.has.no.inheritors=接口沒有繼承者
intention.error.make.sealed.class.is.used.in.functional.expression=類別用於函式表達式
intention.extract.if.condition.family=提取if條件
intention.extract.if.condition.text=提取if({0})
intention.extract.map.step.family=提取分離映射方法
intention.extract.map.step.text=提取變數''{0}''到''{1}''動作
intention.extract.method.text=提取方法
intention.extract.set.from.comparison.chain.duplicates={0} 在此類別中檢測到 {1} 個可以使用新建立的集取代的程式碼{1,choice,1#段|2#段}。要取代{1,choice,1#它|2#它們}嗎?
intention.extract.set.from.comparison.chain.family=從比較鏈提取 Set
intention.family.add.javadoc=新增 Javadoc
intention.family.copy.abstract.method.implementation=複製 abstract 方法實作
intention.family.create.a.class.in.package=在軟體套件中建立類別
intention.family.edit.method.contract=編輯方法協定
intention.family.edit.range=編輯範圍
intention.family.expand.static.import=展開靜態匯入
intention.family.fix.bounded.wildcards=修復有界萬用字元
intention.family.make.external.annotations.explicit=使外部註解為顯式
intention.family.make.inferred.annotations.explicit=使推斷的註解為顯式
intention.family.move.it=移動它
intention.family.name.box.primitive.in.conditional.branch=裝箱條件分支中的基元值
intention.family.name.convert.record.to.class=將記錄轉換為類別
intention.family.name.dismiss=關閉
intention.family.name.ignore.project=不再在此專案中顯示
intention.family.name.make.sealed=密封類別
intention.family.name.move.class.to.test.root=將類別移至測試根
intention.family.name.move.member.into.class=將成員移至類別
intention.family.name.set.explicit.variable.type=設定顯式變數類型
intention.family.name.synchronize.inline.snippet=同步內聯程式碼段
intention.family.name.upgrade.jdk=升級 JDK
intention.family.put.arguments.on.one.line=將實參放在同一行中
intention.family.put.arguments.on.separate.lines=將實參放在單獨的行中
intention.family.put.parameters.on.one.line=將參數放在同一行中
intention.family.put.parameters.on.separate.lines=將參數放在單獨的行中
intention.family.put.record.components.on.one.line=將記錄組件放在一行
intention.family.put.record.components.on.separate.lines=將記錄組件放在單獨的行中
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=將 Optional 存在條件取代為函式樣式表達式
intention.family.sort.content=對內容進行排序
intention.family.swap.if.statements=交換 'if' 語句
intention.family.unimplement.interface.class=取消實作接口/類別
intention.family.variable.access.from.inner.class=移入匿名物件
intention.implement.abstract.class.default.text=實作抽象類別
intention.implement.abstract.class.family=實作抽象類別或接口
intention.implement.abstract.method.command.name=實作方法
intention.implement.abstract.method.error.no.classes.message=沒有發現這類方法可以實作
intention.implement.abstract.method.error.no.classes.title=沒有找到的類別
intention.implement.abstract.method.family=實作 abstract 方法
intention.implement.abstract.method.searching.for.descendants.progress=正在搜尋後代…
intention.implement.abstract.method.text=實作方法 ''{0}''
intention.inline.map.family=內聯流映射方法
intention.inline.map.inline.text=將 ''{0}()'' 主體內聯到下一個 ''{1}()'' 呼叫中
intention.inline.map.merge.text=合併 ''{0}()'' 呼叫和 ''{1}()'' 呼叫
intention.introduce.variable.text=引入區域變數
intention.invert.if.condition=反轉 'if' 條件
intention.make.final.fixer.if=通過將初始設定式移至 ''if'' 語句高效地將 ''{0}'' 設為 final
intention.make.final.fixer.stream=使用流 API 高效地將 ''{0}'' 設為 final
intention.make.sealed.class.hint.title=使其密封
intention.make.sealed.class.task.title.set.inheritors.modifiers=正在設定繼承者修飾符
intention.merge.filter.family=合併過濾器
intention.merge.filter.text=合併過濾器鏈
intention.move.field.assignment.to.declaration=移動指派到欄位宣告
intention.move.initializer.to.constructor=將初始設定式移至建構函式
intention.move.initializer.to.set.up=將初始設定式移至 setUp 方法
intention.name.collapse.into.loop=摺疊到迴圈中
intention.name.copy.to.final.temp.variable={1, choice, 0#|1#高效地}將 ''{0}'' 複製到 final 臨時變數
intention.name.extract.method.to.new.interface=將方法 ''{0}'' 提取到新接口
intention.name.iterate.over=迭代 {0}
intention.name.make.variable.final=將{1, choice, 0#“{0}”|1#變數}設為 final
intention.name.move.class.to.test.root=將 ''{0}'' 移至測試根
intention.name.move.into.if.branches=上移至 'if' 語句分支
intention.name.pull.method.up=向上拉取方法 ''{0}''
intention.name.pull.method.up.and.make.it.abstract.conditionally=將方法 ''{0}'' 拉取到 ''{1}''{2, choice, 0#並將其設為 abstract|1#}
intention.name.pull.method.up.make.it.abstract=向上拉取方法 ''{0}'' 並使其抽象
intention.name.set.variable.type=將變數類型設定為 ''{0}''
intention.name.transform.variables.into.final.one.element.array=將{1, choice, 0#“{0}”|1#變數}轉換成 final 單元素數組
intention.name.upgrade.jdk.to=將 JDK 升級到 {0}+
intention.override.method.text=覆寫方法 ''{0}''
intention.replace.concatenation.with.formatted.output.family=更換連線與格式化輸出
intention.replace.concatenation.with.formatted.output.text=用'java.text.MessageFormat.format()'取代'+'
intention.split.declaration.assignment.text=拆分為宣告和賦值
intention.split.declaration.family=拆分宣告
intention.split.filter.family=拆分過濾器
intention.split.filter.text=拆分為過濾器鏈
intention.split.if.family=分裂如果
intention.split.if.text=拆分為 2 條 'if' 語句
intention.split.switch.branch.with.several.case.values.copy.text=複製 'switch' 分支
intention.split.switch.branch.with.several.case.values.family=將包含多個 case 值的 switch 分支拆分成單獨的 'switch' 分支
intention.split.switch.branch.with.several.case.values.split.text=拆分 'switch' 分支的值
intention.surround.resource.with.ARM.block=使用 try-with-resources 包圍
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=將方法協定新增到 ''{0}()''...
intention.text.add.range.to.0=將範圍新增到 ''{0}''...
intention.text.annotate.externally=在外部註解
intention.text.collapse.repeating.annotations=摺疊重複註解
intention.text.create.a.class.in.0=在 ''{0}'' 中建立類別
intention.text.create.a.class.in.package.preview=開啟一個對話框以在軟體套件 ''{0}'' 中建立類別
intention.text.edit.method.contract.of.0=編輯 ''{0}()'' 的方法協定…
intention.text.edit.range.of.0=編輯 ''{0}'' 的範圍…
intention.text.fix.method.0.parameters.with.bounded.wildcards=修復包含有界萬用字元的方法 ''{0}'' 參數
intention.text.generate.missed.test.methods=生成缺少的測試方法
intention.text.implements.list.remove.others=移除其他 ''{0} 參照
intention.text.replace.implements.with.static.import=將實作取代為靜態匯入
intention.text.replace.static.import.with.qualified.access.to.0=將靜態匯入取代為 {0} 的限定存取
intention.text.unimplement.0=取消實作{0}
intention.unroll.loop.family=展開迴圈
intention.unwrap.else.branch=解包 'else' 分支
intention.unwrap.else.branch.changes.semantics=解包 'else' 分支(更改語意)
intention.use.single.member.static.import.text=對 ''{0}'' 使用靜態匯入
intention.wrap.with.unmodifiable=使用不可修改的集合或映射包裝
intention.wrap.with.unmodifiable.list=使用不可修改的列表包裝
intention.wrap.with.unmodifiable.map=使用不可修改的映射包裝
intention.wrap.with.unmodifiable.set=使用不可修改的集包裝
interface.not.allowed=不允許接口
interfaces.cannot.be.inlined=接口無法內聯
introduce.functional.variable.accessibility.conflict=變數 {0} 不是有效的 final 變數，無法在函式表達式中存取
introduce.functional.variable.interface.chooser.title=選擇適用的函式接口: {0} -> {1}
introduce.functional.variable.nothing.found.message=找不到適用的函式接口
introduce.parameter.advertisement.text=按 {0} 通過多載方法進行委託，或按 {1} 顯示更多選項
introduce.parameter.inlay.title.delegate=委託
introduce.parameter.inlay.tooltip.delegate=通過多載方法委託
introduce.parameter.object.no.accessor.conflict.message=欄位 ''{1}'' 需要 {0, choice, 0#Getter|1#Setter}
introduce.variable.change.semantics.warning=提取所選表達式將改變整個表達式的語意。
introduce.variable.change.type.adv=按 {0} 更改類型
introduce.variable.reassign.adv=按 {0} 重新分配現有變數
invalid.extracted.class.name=''{0}'' 是無效的已提取類別名
invert.quickfix.preview=開啟一個對話框以反轉所選布林值並選擇其新名稱。
java.completion.tag={0, choice, 1#標籤:|2#標籤:}
java.implicit.types.inlay.provider.name=隱式類型
java.line.markers=Java 行標記
java.method.chains.inlay.provider.name=方法鏈
java.platform.module.system.name=Java 平台模組系統
java.preview.features.accept.notification.link=接受
java.preview.features.alert.title=實驗性功能警報
java.preview.features.legal.notice=您必須接受測試版 Java 規範的法律通知條款才能啟用對“{0}”的支援。<br/><br/><b>根據 Java Community Process (JCP) 開發的早期規範草案的實作僅用於測試和評估目的，與 JCP 的任何規範都不相容。</b>{1}
java.preview.features.notification.title=Java 預覽功能
java.preview.features.warning=較新的 IDE 版本可能會停止對預覽功能的支援。發佈 Java {0} 時，{1} (預覽)語言級別的支援可能會中斷
java.terms.exception=異常
java.terms.instance.initializer=實例初始設定式
java.terms.of.annotation.type=註解類型{1}的{0}
java.terms.of.anonymous.class=匿名類別的{0}
java.terms.of.class=類別 {1} 的 {0}
java.terms.of.enum=枚舉 {1} 的 {0}
java.terms.of.interface=接口 {1} 的 {0}
java.terms.region=區域
java.terms.static.initializer=static 初始設定式
java.terms.type.parameter=類型參數
java.terms.variable.of.method={0}/{1}
javadoc.apiNote=API 說明:
javadoc.author=作者:
javadoc.candidates.not.found=<html>找不到方法呼叫 <b>{0}</b> 的候選者。</html>
javadoc.constructor.candidates=<html>新的候選 <b>{0}</b>() 是:<br>{1}</html>
javadoc.deprecated=已棄用
javadoc.description.copied.from.class=來自類別:
javadoc.description.copied.from.field=來自欄位:
javadoc.description.copied.from.interface=來自接口:
javadoc.description.inferred.annotation.hint=i
javadoc.documentation.url.checked=已檢查以下文檔 {0, choice, 1#URL|2#URL}:
javadoc.edit.api.docs.paths=編輯 API 文檔路徑
javadoc.gen.error.module.source.path.is.not.evaluated=IDEA 無法生成 Javadoc，因為無法評估 module-source-path
javadoc.gen.error.modules.without.module.info=IDEA 無法生成 Javadoc，因為模組 {0} 不含 module-info.java 檔案
javadoc.generate.arguments=命令行實參:
javadoc.generate.exited=\n"javadoc" 完成，退出程式碼為 $EXIT_CODE$
javadoc.generate.heap.size=最大堆大小(&M):
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=在 -sourcepath 中包含 JDK 和庫源
javadoc.generate.link.to.jdk.documentation.option=鏈接到 JDK 文檔 (使用 -link 選項)
javadoc.generate.locale=區域設定(&L):
javadoc.generate.no.classes.in.selected.packages.error=選定的作用域不包含Java類別
javadoc.generate.no.javadoc.tool=無法生成 JavaDoc - 在 {0} 或 {1} 上找不到 javadoc 工具。請在“設定 | 專案結構”中指定有效的 Java SDK。
javadoc.generate.no.jdk=無法生成 JavaDoc - 沒有為專案組態 Java SDK。請在“設定 | 專案結構”中指定 Java SDK。
javadoc.generate.ok=生成
javadoc.generate.open.in.browser=生成文檔並用瀏覽器開啟 (&G)
javadoc.generate.options.hierarchy=生成層次結構樹
javadoc.generate.options.index=生成索引
javadoc.generate.options.index.per.letter=每個字母單獨的索引
javadoc.generate.options.navigator=生成導覽列
javadoc.generate.options.separator=JavaDoc 選項
javadoc.generate.output.directory=輸出目錄 (&D):
javadoc.generate.output.directory.browse=瀏覽輸出目錄
javadoc.generate.scope.row=可見性級別:
javadoc.generate.sources.progress=尋找資源來生成Javadoc
javadoc.generate.tag.list.deprecated=棄用列表
javadoc.generate.temp.file.does.not.exist=臨時檔案不存在或無法開啟
javadoc.generate.temp.file.error=無法建立臨時檔案
javadoc.generate.title=生成 JavaDoc
javadoc.generate.validation.error=指定輸出目錄。
javadoc.implNote=實作<br>說明:
javadoc.implSpec=實作<br>要求:
javadoc.method.in.class={0}在類別{1}裏邊
javadoc.method.in.interface=接口 {1} 中的 {0}
javadoc.method.overrides=覆寫:
javadoc.method.specified.by=指定的:
javadoc.option.automatically.insert.closing.tag.javadoc=在 JavaDoc 中自動插入結束標記
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=請參閱:
javadoc.settings.title=Javadoc
javadoc.since=自:
javadoc.snippet.error.both.substring.and.regex=@{0}: 應指定正則表達式或子字串，但不應同時指定
javadoc.snippet.error.duplicate.attribute=@{0}: 重複的特性: ''{1}''
javadoc.snippet.error.malformed.regular.expression=@{0}: 格式錯誤的正則表達式: {1}
javadoc.snippet.error.malformed.replacement=@{0}: 格式錯誤的正則表達式取代 ''{1}'': {2}
javadoc.snippet.error.markup.tag.expected=應為標記標籤或特性
javadoc.snippet.error.missing.required.attribute=@{0}: 缺少 ''{1}'' 特性
javadoc.snippet.error.regex.too.complex=@{0}: 過於複雜的正則表達式 ''{1}''
javadoc.snippet.error.unknown.enum.value=@{0}: 未知的{1} ''{2}''；僅支援 {3}
javadoc.snippet.error.unsupported.attribute=@{0}: 不受支援的特性: ''{1}''
javadoc.snippet.not.found=找不到程式碼段: {0}
javadoc.snippet.region.not.found=找不到區域: {0}
javadoc.type.parameters=類型參數:
javadoc.version=版本:
jrt.node.short=[JRT]
label.add.math.max.0.count.to.avoid.possible.semantics.change=新增 Math.max(0, count) 以避免可能的語意更改
label.canonical.constructor=規範建構函式
label.class.filter.editor.add.dialog.filter.pattern=輸入過濾器模式:
label.class.pattern.syntax.explanation=將此方法留空以表示建構函式\n任何 * 將符合限定名稱中的一個或多個字元(包括點)
label.compact.constructor=壓縮建構函式
label.contract=約定(&C):
label.enter.fully.qualified.class.name=輸入完全限定類別名
label.entry.points=入口點:
label.forbid.api.usages=禁止使用比以下版本更新的 API
label.forbid.api.usages.project=(根據專案設定)
label.from.inclusive=自(包含)(&F):
label.ignore.complicated.fix=當無法提供快速修復時忽略
label.implementation=實作:
label.implements.method.of_class_or_interface.name=實作{0, choice, 0#接口|1#類別} ''{1}'' 的方法。
label.implements.method.of_interfaces=以下類別/接口的實作方法:
label.jvm.class.name=JVM 類別名
label.jvm.field.name=JVM 欄位名稱
label.jvm.method.name=JVM 方法名稱
label.maximal.reported.method.visibility=最大方法可見性:
label.method=方法 ''{0}''
label.minimal.reported.method.usage.count=要報告參數的最小方法使用計數:
label.mutates=改變(&M):
label.name.prefix=名稱前綴:
label.name.suffix=名稱後綴:
label.naming.field=欄位:
label.naming.local.variable=區域變數:
label.naming.parameter=參數:
label.naming.static.field=static 欄位:
label.naming.subclass=子類別:
label.naming.test.class=測試類別:
label.new.template.name=新模板名稱:
label.overrides.method.of_class_or_interface.name=覆寫{0, choice, 0#接口|1#類別} ''{1}'' 的方法。
label.show.import.popup.for=顯示自動匯入工具提示:
label.to.inclusive=結束(包含)(&T):
label.unused.declaration.reachable.from.tests.option=當入口點位於測試源中時，將被呼叫方標記為:
lambda.tree.node.presentation=Lambda
leave.in.same.source.root.item=留在同一來源根中
library.classes.cannot.be.inlined=庫類別無法內聯
line.marker.recursive.call=遞迴呼叫
line.marker.type.external.annotations=外部註解
line.marker.type.inferred.contract.annotations=推斷約定註解
line.marker.type.inferred.nullability.annotations=推斷為 null 性註解
link.configure.classes.excluded.from.completion=組態從補全中排除的類別
list.item.configuration=[組態] {0}
list.item.suite=[套件] {0}
listbox.import.package=軟體套件
listbox.import.static=static
listbox.import.with.subpackages=以及子軟體套件
live.template.context.consumer.function=使用者函式
live.template.context.declaration=宣告
live.template.context.else='else' 位置
live.template.context.expression=表達式
live.template.context.statement=語句
loading.additional.annotations=正在載入其他註解…
macro.array.variable=arrayVariable()
macro.class.name=類別名
macro.classpath.entry=該元素所屬的類別路徑中的條目
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=檔案完全合格軟體套件
macro.file.package=檔案軟體套件
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=JavaDoc輸出目錄
macro.project.classpath=專案的類別路徑
macro.variable.of.type=variableOfType(Type)
megabytes.unit=MB
methods.to.implement.chooser.title=選擇要實作的方法
methods.to.override.chooser.title=選擇要覆寫的方法
methods.to.override.generate.javadoc=生成缺失的 JavaDoc
methods.to.override.implement.chooser.title=選擇覆蓋/實作的方法
module.not.in.requirements=模組 ''{0}'' 的要求中缺少模組 ''{1}''
module.package.not.exported=模組 ''{0}'' 不會將軟體套件 ''{1}'' 匯入到模組 ''{2}''
module.package.not.open=模組 ''{0}'' 不會開啟模組 ''{2} ''的軟體套件 ''{1}''
module.type.java.description=Java 模組用於開發<b>基於 JVM 的</b>桌面和 Web 應用程式，包括使用 <b>Java EE</b> 和其他企業開發框架的應用程式。
module.type.java.name=Java模組
move.class.import.from.default.package.conflict=無法從預設軟體套件存取 {0}
move.classes.destination.class.not.found.message=未找到目標類別
move.classes.invalid.destination.package.name.message=''{0}'' 是無效的目標軟體套件名稱
move.inner.select.target.package.title=選擇目標軟體套件
move.member.enum.conflict=枚舉類型不適用於當前上下文
move.member.final.initializer.conflict=final {0}的初始設定式將被留下。
multiple.usages.of.static.import.found=已找到靜態匯入的多個用法
navigate.to.duplicate.fix=導覽到重複位置
no.jre.description=<無 JRE>
no.methods.overriding.0.are.found=沒有發現覆寫 {0, choice, 0#|1#“{1}”|2#這些類別} 的方法
no.patterns=沒有類別模式組態
node.call.hierarchy.unknown.jsp=未知的jsp
node.hierarchy.java.lang.object=所有類別都派生自 java.lang.Object
non.code.annotations.explanation.external.and.inferred.available=外部和<i>推斷</i>註解可用。
non.code.annotations.explanation.external.available=外部註解可用。
non.code.annotations.explanation.full.signature=完整簽名:
non.code.annotations.explanation.inferred.available=<i>推斷</i>註解可用。
notification.content.added.annotations=已新增 {0} {0, choice, 1#註解|2#註解}
notification.content.change.jdk=更改 JDK
notification.content.was.set.up=已為專案設定了 JDK ''{0}''
notification.group.jdk.resolve.problems=無法解析 JDK
notification.group.jshell=發生了JShell 問題
notification.group.language.level=預覽 Java 語言級別需要接受授權
notification.group.legacy.library=舊版庫依賴於 IDE 安裝
notification.group.preview.features=預覽 Java 語言級別可能會中斷
notification.group.redundant.exports=可以移除冗餘的匯出/開啟
notification.group.repository=JAR 檔案已與儲存庫同步
notification.group.setup.external.annotations=載入外部註解失敗
notification.group.setup.sdk=JDK 已組態
notification.group.source.searcher=找不到 JAR 檔案的源
notification.group.testintegration=無法為 @TestDataPath 生成測試
notification.navigation.to.overriding.classes=索引更新時無法導覽到覆寫類別
notification.navigation.to.overriding.methods=索引更新時無法導覽到覆寫方法
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=已成功將完整執行緒傾印複製到剪貼簿
null.check.surrounder.description=if (expr != null) {…}
nullable.notnull.annotation.used.label=用於生成程式碼的註解:
nullable.notnull.annotations.panel.title={0}註解:
nullable.notnull.annotations.runtime.instrumentation.tooltip=為非 null 註解的方法和參數新增執行時斷言
nullable.notnull.configuration.dialog.title=可以為 null/非 null 組態
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=導覽到 'null' 實參用法
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.preview=顯示將 'null' 作為實參傳遞的用法列表。
nullable.stuff.inspection.navigate.null.argument.usages.view.name=參數 {0} 的 ''null'' 實參用法
offline.inspections.jdk.not.found=找不到 {0}
offline.inspections.library.urls.were.not.resolved=未解析模組 ''{2}'' 中庫 ''{1}'' 的根 {0}
offline.inspections.library.was.not.resolved=請組態庫''{0}''用於模組''{1}''
offline.inspections.no.source.roots=未檢測到模組 ''{0}'' 的來源根
open.settings.dialog.for.module.preview.text=開啟模組 ''{0}'' 的設定對話框
options.java.attribute.descriptor.abstract.class=類別和接口//抽象類別
options.java.attribute.descriptor.abstract.method=方法//abstract 方法
options.java.attribute.descriptor.annotation.attribute.name=註解//註解特性名稱
options.java.attribute.descriptor.annotation.name=註解//註解名稱
options.java.attribute.descriptor.anonymous.class=類別和接口//匿名類別
options.java.attribute.descriptor.class=類別和接口//類別
options.java.attribute.descriptor.constructor.call=方法//建構函式呼叫
options.java.attribute.descriptor.constructor.declaration=方法//建構函式宣告
options.java.attribute.descriptor.enum=類別和接口//枚舉
options.java.attribute.descriptor.implicit.anonymous.parameter=參數//隱式的匿名類別參數
options.java.attribute.descriptor.inherited.method=方法//繼承的方法
options.java.attribute.descriptor.instance.field=類別欄位//實例欄位
options.java.attribute.descriptor.instance.final.field=類別欄位//實例化final欄位
options.java.attribute.descriptor.interface=類別和接口//接口
options.java.attribute.descriptor.javadoc.comment=註釋//JavaDoc//文本
options.java.attribute.descriptor.javadoc.markup=註釋//JavaDoc//標記
options.java.attribute.descriptor.javadoc.tag=註釋//JavaDoc//標籤
options.java.attribute.descriptor.javadoc.tag.value=註釋//JavaDoc//標籤值
options.java.attribute.descriptor.lambda.parameter=參數//Lambda 參數
options.java.attribute.descriptor.method.call=方法//方法呼叫
options.java.attribute.descriptor.method.declaration=方法//方法宣告
options.java.attribute.descriptor.method.imported.call=方法//static 匯入方法呼叫
options.java.attribute.descriptor.package.private=可見性//Package-private
options.java.attribute.descriptor.private=可見性//Private
options.java.attribute.descriptor.protected=可見性//Protected
options.java.attribute.descriptor.public=可見性//Public
options.java.attribute.descriptor.reassigned.local.variable=變數//重新分配區域變數
options.java.attribute.descriptor.reassigned.parameter=參數//重新分配參數
options.java.attribute.descriptor.static.field=類別欄位//靜態欄位
options.java.attribute.descriptor.static.final.field=類別欄位//常數(static final 欄位)
options.java.attribute.descriptor.static.final.imported.field=類別欄位//常數 (static final 匯入欄位)
options.java.attribute.descriptor.static.imported.field=類別欄位//靜態匯入欄位
options.java.attribute.descriptor.static.method=方法//靜態方法
options.java.attribute.descriptor.type.parameter=參數//類型參數
options.java.display.name=Java
override.implement.broken.file.template.message=請更正“覆寫/實作的方法體”模板
override.implement.broken.file.template.title=檔案模板錯誤
override.methods.error.no.methods=找不到要覆寫的方法
package.chooser.modal.progress.title=正在搜尋軟體套件...
package.classes=軟體套件類別:
package.dependencies.production.node.text=生產類別
package.dependencies.test.node.text=測試類別
package.pattern.provider.hint.label=使用 <b>*.txt</b> 符合專案中的 'txt' 檔案，使用 <b>file:path_in_project//*</b> 遞迴符合目錄中的所有檔案，使用 <b>src:foo..*</b> 遞迴符合軟體套件中的所有類別。
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=執行時映像(JLink)
packaging.jlink.compression.first.level=字串共享
packaging.jlink.compression.level=壓縮級別
packaging.jlink.compression.second.level=Zip
packaging.jlink.compression.zero.level=不壓縮
packaging.jlink.verbose.tracing=啟用詳細追蹤
paste.class.command.name=貼上類別 ''{0}''
please.report.a.bug=請報告錯誤
popup.content.tests.were.not.found.in.module=在模組 ''{0}'' 中找不到測試。
popup.content.tests.were.not.found.in.module.search.in.dependencies=改為在模組相依項中搜尋
popup.content.tests.were.not.found.in.module.use.instead=改用{0, choice, 0#模組 {1} |1# \n{2} 之一\n}
popup.title.choose.framework=選擇框架
popup.title.choose.test=選擇測試
popup.title.debug.recent.tests=偵錯最近的測試
popup.title.effective.visibility=有效可見性
popup.title.select.a.jar.file=選擇 JAR 檔案
popup.title.select.qualified.name=選擇限定名稱
popup.title.select.target.code.block=選擇目標程式碼塊
postfix.template.condition.array.name=陣列
postfix.template.condition.boolean.name=布爾
postfix.template.condition.non.void.name=非 void
postfix.template.condition.not.primitive.type.name=非基元類型
postfix.template.condition.number.name=數字
postfix.template.condition.void.name=void
postfix.template.editor.choose.class.title=選擇類別
postfix.template.language.level.title=最低語言級別:
postfix.template.provider.name=Java
presentable.text.anonymous.class=匿名類別
presentable.text.code.display=程式碼
presentable.text.code.from.context=來自 {0} 的程式碼
presentable.text.invalid.element.name=無效
press.0.to.see.inheritors.of.1=按 {0} 以檢視 {1} 的繼承者
press.0.to.see.non.imported.classes=按 {0} 以檢視未匯入的類別
pressing.0.twice.without.a.class.qualifier=不使用類別限定符，按 {0} 兩次會顯示所有可存取的 static 方法
progress.creating.class=建立類別{0}
progress.title.calculate.applicable.types=計算適用類型…
progress.title.check.applicability=檢查適用性…
progress.title.checking.if.class.exists=檢查目標類別 ''{0}'' 是否存在
progress.title.collect.method.overriders=收集方法覆寫器…
progress.title.detect.overridden.methods=檢查覆寫方法
progress.title.detecting.jdk=正在檢測 JDK
progress.title.download.library.descriptor=下載庫檔案描述子
progress.title.find.references.in.implement.extends.lists=在實作/展開列表中尋找參照…
progress.title.finding.cause=正在尋找原因
progress.title.looking.for.jdk=正在尋找 JDK…
progress.title.looking.for.libraries=正在尋找庫
progress.title.optimize.imports=最佳化 import…
progress.title.preprocess.usages=預處理用法
progress.title.restore.references=正在還原參照
progress.title.search.for.overriding.methods=搜尋覆寫方法…
progress.title.searching.for.sub.classes=正在搜尋子類別
project.problems.fix.description=發現與 ''{0}'' 相關的問題
project.problems.fix.text=顯示相關問題
project.problems.hint.text={0} 個相關{0, choice, 0#問題|2#問題}
project.problems.title=相關問題
project.problems.window.title={0} 的相關問題
prompt.choose.base.class.of.the.hierarchy=選擇要搜尋的層次結構的基類別
prompt.create.non.existing.package=軟體套件 {0} 不存在。\n是否要建立?
prompt.delete.class={0,choice,1#類別|2#類別}
prompt.delete.field=個欄位
prompt.delete.interface=個接口
prompt.delete.method=個方法
prompt.delete.package={0,choice,1#軟體套件|2#軟體套件}
prompt.delete.type.parameter={0,choice,1#類型參數|2#類型參數}
prompt.do.you.want.to.action_verb.the.method.from_class=要改為對基{0,choice,1#方法|2#方法}{1}嗎?
psi.error.incorrect.class.template.message=無法建立{0} - {1}模板不正確。
psi.search.overriding.progress=搜尋覆蓋方法
pull.members.up.fix.name=將成員上移
pull.up.accessible.conflict={0} 無法存取
pull.up.accessible.conflict.1=無法從 {1} 存取 {0}
pull.up.concrete.inherit.abstract.method.conflict=具體的{0}將繼承一個新的抽象方法
pull.up.members.usage.view.description.code.references.node=將成員向上拉取到“{0}”的類別
pull.up.members.usage.view.description.processed.elements.node=從類別 {0} 上移成員
push.down.anonymous.conflict=無法將實作推送到匿名類別
push.down.missed.implementation.conflict=非抽象 {0} 將錯過 {1} 的實作
push.down.static.nonstatic.conflict=static {0} 無法推送到非 static {1}
push.down.super.method.call.changed.conflict=super 方法呼叫將解析為另一種方法
push.method.down.command.name=向下推送方法…
qualify.static.access.command.name=限定 static 存取
qualify.static.call.fix.text=限定 static 呼叫
qualify.static.constant.access=限定 static 常數存取
quickfix.add.variable.family.name=初始化變數
quickfix.add.variable.text=初始化變數 ''{0}''
quickfix.family.avoid.mutation.using.stream.api=使用 Stream API 避免變異
quickfix.family.change.javadoc.to=更改為…
quickfix.family.find.cause=尋找原因
quickfix.family.remove.javadoc.tag=移除標記
quickfix.family.remove.redundant.parameter=刪除冗餘參數
quickfix.family.remove.redundant.parameter.types=刪除冗餘參數類型
quickfix.family.replace.cast.type=取代轉換類型
quickfix.family.replace.inefficient.stream.count=取代低效的 Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=將 Optional 鏈取代為 if 語句
quickfix.family.replace.stream.api.chain.with.loop=將 Stream API 鏈取代為迴圈
quickfix.family.replace.with.java.stream.api.pipeline=取代為 Java Stream API 管道
quickfix.family.replace.with.magic.constant=取代為魔術常數
quickfix.family.replace.with.method.reference=取代為方法參照
quickfix.family.replace.with.optional.of.nullable.chain=取代為 Optional.ofNullable() 鏈
quickfix.family.replace.with.stream.api.equivalent=取代為 Stream API 對等項
quickfix.family.simplify.foreach.lambda=簡化 forEach lambda
quickfix.family.simplify.stream.call.chain=簡化流呼叫鏈
quickfix.family.use.flatmap=使用 'flatMap'
quickfix.family.wrap.with.mutable.collection=使用可變集合包裝
quickfix.find.cause.description=嘗試醒目提示導致此警告的程式碼元素，並解釋它們的確切作用。
quickfix.name.find.jar.on.web=在 web 上尋找 JAR
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (可能無法在 JDK 11.0.2 之前的版本上執行)
quickfix.text.avoid.mutation.using.stream.api.0.operation=使用 Stream API ''{0}()'' 動作避免變異
quickfix.text.remove.javadoc.0=移除 ''@{0}'' 標記
quickfix.text.remove.javadoc.0.1=移除 @{0} {1}
quickfix.text.remove.not.null.annotation=移除非 null 註解
quickfix.text.replace.0.stream.with.1.2=將 {0}.stream() 取代為 {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=將 ''collect({0}())'' 取代為 ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=將 ''filter().{0}().isPresent()'' 取代為 ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=將 ''stream().{0}()'' 取代為 ''{1}()''{2}
quickfix.text.replace.url.with.html=將 URL 取代為 HTML 鏈接
quickfix.text.suffix.may.change.semantics=\ (可能更改語意)
quickfix.text.wrap.0.with.1=用 ''{1}'' 包裝 ''{0}''
radio.button.subclass.of.0=''{0}'' 的子類別
radio.button.unused.declaration.unused.option=未使用
radio.button.unused.declaration.used.option=已使用
radio.button.with.provider.method=帶有 'provider()' 方法
radio.use.fully.qualified.class.names.in.javadoc=在 JavaDoc 中使用完全限定類別名:
radio.use.fully.qualified.class.names.in.javadoc.always=始終
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=如果尚未匯入
radio.use.fully.qualified.class.names.in.javadoc.never=切勿使用短名稱和新增匯入
raw.use.of.parameterized.type.ignore.new.objects.option=忽略新物件的建構
raw.use.of.parameterized.type.ignore.overridden.parameter.option=忽略覆寫方法的參數類型
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=在自動快速修復不可用時忽略
raw.use.of.parameterized.type.ignore.type.casts.option=忽略類型轉換
raw.use.of.parameterized.type.ignore.uncompilable.option=忽略類型參數無法編譯的位置
raw.variable.type.can.be.generic.cast.quickfix=將轉換類型更改為 {0}
raw.variable.type.can.be.generic.cast.quickfix.family=參數化轉換類型
raw.variable.type.can.be.generic.family.quickfix=向類型新增泛型參數
raw.variable.type.can.be.generic.quickfix=將{0}的類型更改為{1}
refactoring.method.reference.to.lambda.conflict=方法參照將轉換為 lambda
remove.var.keyword.text=移除 'var'
rename.package.class.already.exist.conflict=具有限定名稱 ''{0}''  的類別已存在
rename.package.command.name=重新命名軟體套件
rename.package.ignored.name.warning=正在嘗試建立具有忽略名稱的軟體套件，結果將不可見
rename.package.invalid.name.error=不是有效的軟體套件名稱
rename.super.base.chooser.popup.title={0} {1, choice, 0#實作|1#覆寫} {2} 的方法
rename.super.methods.chooser.popup.title={0} 具有 super 方法
replace.implements.with.static.import.field.usages.progress=尋找常數欄位用法…
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' 不應具有零個核心執行緒
scheduled.thread.pool.executor.with.zero.core.threads.display.name=帶零個核心執行緒的 'ScheduledThreadPoolExecutor'
scope.hierarchy={0}的層次結構
sdk.cannot.create=無法建立 SDK
sdk.configured.sdkmanrc=''{0}'' 被設定為專案 JDK。
sdk.configured.sdkmanrc.title=JDK 已組態 (.sdkmanrc)
sdk.java.no.classes=無法在''{0}''中找到JDK classes
section.title.inspection.suspicious.names.ignore.methods=忽略方法:
separator.annotations.to.copy=要複製的註解
separator.mark.as.entry.point.if.annotated.by=如果已註解，則標記為入口點:
separator.mark.field.as.implicitly.written.if.annotated.by=如果已註解，則將欄位標記為隱式寫入:
set.language.level=設定語言級別
set.language.level.to.0=設定語言級別為{0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=註解
settings.inlay.java.builder.like.methods=類似於建置器的方法
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=複雜表達式作為實參
settings.inlay.java.enum.constants=枚舉常數
settings.inlay.java.external.annotations=外部註解
settings.inlay.java.implicit.types=隱式類型
settings.inlay.java.implicit.types.description=當推斷的類型可能無法從賦值的右側部分看清時(例如，使用工廠方法時)，使用 var 關鍵字宣告的區域變數。
settings.inlay.java.inferred.annotations=推斷註解
settings.inlay.java.inheritors=繼承者
settings.inlay.java.insert.annotation=插入註解
settings.inlay.java.methods.with.same.named.numbered.parameters=包含相同名稱的編號參數的方法
settings.inlay.java.new.expressions='New' 表達式
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=在具有相同類型的多個參數的情況下的非文字
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=具有方法名稱中包含的名稱的參數
settings.inlay.java.show.hints.for=顯示以下項的提示:
settings.inlay.java.show.parameter.hints.for=為以下物件顯示參數提示:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=陣列初始設定式、switch、條件、參照、實例、賦值、呼叫、限定、類型轉換、類別物件存取表達式。
settings.inlay.java.turn.off.external.annotations=關閉外部註解
settings.inlay.java.turn.off.inferred.annotations=關閉推斷註解
settings.inlay.java.usages=用法
show.import.popup.for.classes=類別(&C)
show.import.popup.for.static.methods.and.fields=Static 方法和欄位(&S)
show.siblings.choose.super.class.title=選擇超類別或接口
show.siblings.find.usages.class.title=超類別/接口
show.siblings.find.usages.method.title=super 方法
side.effects.expression.presentation=表達式 ''{0}''
side.effects.expressions.assigned.to.the.variable=分配到變數 ''{0}'' 的表達式
side.effects.non.fixable.message=<html><body>  表達式 ''{0}'' 中可能存在副作用<br>您可以<b>移除</b>類別參照以及涉及的全部表達式</body></html>
side.effects.pattern.message=<html>\n<body>\n{0} 中可能存在副作用<br>\n您可以:\n<br>\n-\\&nbsp;<b>移除</b>變數用法以及所有涉及的表達式，或<br>\n-\\&nbsp;<b>自行將分配到變數的表達式轉換</b>到語句中。<br>\n<div style="padding-left: 0.6cm;">\n  即<br>\n  <table border="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  成為: <br>\n  <table border="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=Optional 鏈可被消除
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=Optional 鏈可被取代為 'String.valueOf()'
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name=取代為 'String.valueOf()'
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=移除冗餘的 Optional 鏈
simplify.optional.chain.inspection.map.or.else.description=Optional 鏈可以簡化
simplify.optional.chain.inspection.optional.rewrapping.description=不必要的 Optional 重新包裝
simplify.optional.chain.inspection.optional.rewrapping.name=解包
simplify.optional.chain.inspection.or.else.non.null.fix.description=null 檢查可被 'ifPresent' 消除
simplify.optional.chain.inspection.or.else.non.null.fix.name=將 null 檢查取代為 ifPresent()
simplify.optional.chain.inspection.or.else.return.fix.description=null 檢查可被消除
simplify.optional.chain.inspection.or.else.return.fix.name=將 null 檢查取代為 {0}({1})
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=從可選鏈中移除冗餘步驟
simplify.optional.chain.inspection.to.x=將可選鏈簡化為 ''{0}''
simplify.stream.collection.creation.fix.name=取代為 ''{0}'' 建構函式
simplify.stream.inspection.iterate.take.while.fix.message=可被取代為三實參 'iterate()'
simplify.stream.inspection.iterate.take.while.fix.name=取代為三實參 'iterate()'
simplify.stream.inspection.message.can.be.replaced=''{0}'' 可被取代為 ''{1}''
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' 可被取代為 ''{1}'' (可能會改變語意)
simplify.stream.match.negation.fix.name=將 {0} 取代為 {1}(…)
simplify.stream.remove.boolean.identity.fix.message=可以與上一個 'map()' 呼叫合併
simplify.stream.remove.boolean.identity.fix.name=與上一個 'map()' 呼叫合併
simplify.stream.replace.support.with.collection.fix.message=可被取代為 ''{0}.{1}()'' 呼叫
simplify.stream.replace.support.with.collection.fix.name=取代為 ''{0}.{1}()'' 呼叫
simplify.stream.replace.with.element.iteration.fix.message=可被取代為元素迭代
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=顯式使用 Stream 元素
simplify.stream.simple.stream.of.message=不必要的單元素 Stream
simplify.stream.swap.filter.and.map.fix.message=可以交換 'filter()' 和 'map()'
simplify.stream.swap.filter.and.map.fix.name=交換 'filter()' 和 'map()'
slice.filter.parse.error.enum.constant.not.found=找不到枚舉常數: {0}
slice.filter.parse.error.expression.must.evaluate.to.constant=表達式的求值結果必須為常數: {0}
slice.filter.parse.error.incorrect.constant.expected.number=常數不正確(應為數字): {0}
slice.filter.parse.error.incorrect.constant.type=常數類型不正確(要求: {0})
slice.filter.parse.error.incorrect.expression=表達式不正確: {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''!null'' 篩選器不適用於基元類型 {0}
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=''null'' 篩選器不適用於基元類型 {0}
slice.usage.message.assertion.violated=(違反斷言!)
slice.usage.message.in.file.stopped.here=(在 {0} 檔案中 - 在此處停止)
slice.usage.message.location=({0} 中)
slice.usage.message.tracking.container.contents=(正在追蹤容器 ''{0}{1}'' 內容)
sort.threads.by.name=按名稱對執行緒排序
sort.threads.by.type=按類型對執行緒排序
special.annotations.annotations.list=附加特殊註解:
special.annotations.annotations.preview=將 ''@{0}'' 新增到此檢查將忽略的註解列表中
special.annotations.list.add.annotation.class=新增註解類別
special.annotations.list.annotation.class=註解類別
special.annotations.list.annotation.pattern=新增註解模式
special.annotations.list.annotation.pattern.message=新增註解模式
special.annotations.list.remove.pattern=移除
spi.extension.error.message=註冊的擴展應實作{0}
spi.no.provider.error.message=未找到服務提供程序“{0}”
status.bar.overridden.methods.highlighted.message=找到 {0} 個被覆寫的{0, choice, 1#方法|2#方法}(再次按 {1} 以移除醒目提示，按 Escape 以移除所有醒目提示)
stream.to.loop.inspection.message.replace.foreach.call.with.loop=將 'forEach()' 呼叫取代為迴圈
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=將 Stream API 鏈取代為迴圈
surround.with.cast=使用轉換包圍
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=!(表達式實例類型)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=Catch 體的檔案模板無效!
surround.with.try.catch.incorrect.template.title=使用 try/catch 包圍
surround.with.try.catch.template=try / catch
switch.stmt.template.description=switch (expr) {…}
tab.title.entry.points=入口點
tab.title.infer.nullity.preview=推斷為 null 性預覽
tab.title.members.to.report=要報告的成員
tab.title.slices.grouped.by.nullness=\ (按為 null 性分組)
table.cell.constructors=建構函式
target.code.block.presentable.text=包含塊
title.cannot.create.class=無法建立類別
title.code.vision=Code Vision
title.code.vision.inlay.hints=Code Vision
title.import.layout=匯入布局
title.javadoc=JavaDoc
title.naming=命名
title.naming.final.modifier=變數宣告
title.naming.functional.expressions=Lambda 體
title.naming.variable=變數
title.package.not.found=找不到軟體套件
title.packages=軟體套件
title.packages.to.use.import.with=將 import 與 '*' 搭配使用的軟體套件
title.related.problems.inlay.hints=相關問題
to.import.a.method.statically.press.0=要靜態匯入方法，請按 {0}
todo.index.not.available=不適用
tooltip.anonymous=匿名
tooltip.has.several.functional.implementations=有多個函式實作
tooltip.implements.method=實作方法
tooltip.implements.method.in=在以下位置實作方法:
tooltip.is.functionally.implemented.in=函式實作位置:
tooltip.is.implemented.by=實作物件:
tooltip.is.implemented.by.several.subclasses=由多個子類別實作
tooltip.is.implemented.in=在以下位置實作:
tooltip.is.implemented.in.several.subclasses=在多個子類別中實作
tooltip.is.overridden.by.several.subclasses=被多個子類別覆寫
tooltip.is.overridden.in=在以下位置被覆寫:
tooltip.is.overridden.in.several.subclasses=在多個子類別中被覆寫
tooltip.is.subclassed.by=被以下類別子類別化
tooltip.overrides.method=覆寫方法
tooltip.overrides.method.in=在以下位置覆寫方法:
tooltip.reassigned.local.variable=重新賦值的區域變數
tooltip.reassigned.parameter=重新賦值的參數
tooltip.recursive.call=遞迴呼叫
tooltip.via.subclass=通過子類別
type.information.constraints=約束
type.information.local.object=本地物件
type.information.locality=本地性
type.information.mutability=可變性
type.information.not.equal.to=不等於
type.information.nullability=為 null 性
type.information.range=範圍
type.information.type=類型
type.information.value=值
type.migration.cannot.convert.message=無法將表達式 <b>{0}</b> 的類型{3, choice, 0#|1#從 '<'b'>'{1}'<'/b'>' }轉換為 <b>{2}</b>
type.migration.cannot.convert.tooltip=無法將表達式的類型從 {0} 轉換為 {1}
type.migration.cannot.convert.vararg.message=無法將呼叫 <b>{0}</b> 從 vararg 轉換為非 vararg
type.migration.cannot.convert.vararg.tooltip=無法將呼叫從 vararg 轉換為非 vararg
type.migration.command.name=TypeMigration
type.migration.dialog.message.disjunction.type.not.applicable=只有 catch 塊參數可以遷移到聯合類型
type.migration.dialog.message.invalid.type=''{0}'' 不是有效的類型
type.migration.dialog.message.vararg.type.not.applicable=只有方法的最後一個參數可以遷移到 vararg 類型
type.migration.dialog.message.void.not.applicable=只有方法返回類型可以遷移到 'void'
type.migration.getter.rename.suggestion.always.migrate.method.names=始終遷移方法名稱
type.migration.getter.rename.suggestion.never.migrate.method.names=從不遷移方法名稱
type.migration.getter.rename.suggestion.text=由於返回值類型已遷移到 ''{2}''，getter 名稱是否從 ''{0}'' 遷移到 ''{1}''?
type.migration.multi.root.toolwindow.title=遷移 {0} 的類型
type.migration.processed.elements.header=類型遷移的根
type.migration.replaced.notification=取代為 {0}
type.migration.single.root.toolwindow.title=將 {0} 的類型從 ''{1}'' 遷移到 ''{2}''
type.parameters.cannot.be.inlined=類型參數無法內聯
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=vararg 參數的未檢查的泛型陣列建立
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=。原因: ''{0}'' 具有原始類型，因此消除了 {1} 的結果
unchecked.warning.inspection.settings.ignore.unchecked.assignment=忽略未檢查的賦值
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=忽略作為原始類型成員的未檢查的呼叫
unchecked.warning.inspection.settings.ignore.unchecked.cast=忽略未檢查的轉換
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=忽略 vararg 參數的未檢查的泛型陣列建立
unchecked.warning.inspection.settings.ignore.unchecked.overriding=忽略未檢查的覆寫
unresolved.class.reference.repair.message=嘗試解析類別參照
unscramble.detect.analyze.threaddump.from.clipboard.item=自動檢測和分析從 IntelliJ IDEA 外部複製到剪貼簿的執行緒傾印
unscramble.log.path.label=日誌檔案: (&L)
unscramble.no.unscrambler.item=<未安裝譯碼器>
unscramble.normalize.button=標準化 (&N)
unscramble.stacktrace.caption=將一個堆疊追蹤或完整的執行緒傾印放在此處:
unscramble.unscrambled.deadlock.tab=<死鎖>
unscramble.unscrambled.stacktrace.tab=<堆疊追蹤>
unscramble.unscrambled.threaddump.tab=<執行緒>
unscramble.unscrambler.combobox=譯碼器(&S):
unscramble.use.unscrambler.checkbox=譯碼堆疊追蹤(&U)
unwrap.anonymous=開啟 'anonymous...'
unwrap.array.initializer=解包陣列初始設定式
unwrap.conditional=開啟 'f ? a : b'
unwrap.lambda=取消 'lambda...' 換行
unwrap.switch.expression=解包 'switch' 表達式
unwrap.switch.statement=解包 'switch' 語句
unwrap.synchronized=解包 'synchronized…'
update.external.annotations=更新外部註解
usage.target.exception=異常
usage.target.package.in.directory={0} (在 {1} 中)
usages.telescope={0,choice, 0#0 個用法|1#1 個用法|2#{0,number} 個用法}
use.external.annotations=使用外部註解 (&E)
validator.text.class.not.found=找不到類別
validator.text.no.annotation=必須為註解
validator.text.not.valid.class.name=不是有效的類別名
validator.text.wrong.superclass=錯誤的超類別
vm.option.description.category=類別:
vm.option.description.default.value=預設值:
vm.option.description.description=描述:
vm.option.description.diagnostic=診斷
vm.option.description.experimental=實驗性
vm.option.description.option=選項:
vm.option.description.product=產品
vm.option.description.requires=\ (要求 {0})
vm.option.description.standard=標準
vm.option.description.type=類型:
warning.java.file.outside.source.root=Java 檔案位於模組來源根之外，因此不會被編譯
where.do.you.want.to.move.directory.prompt={0}\n\n要將目錄移至另一個來源根還是另一個目錄?
wrap.return.value.anonymous.class.presentation=匿名{0}
wrap.return.value.created.class.not.accessible.conflict=建立的類別將無法在呼叫位置存取
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=現有類別沒有適當的建構函式
wrap.return.value.existing.class.does.not.have.getter.conflict=現有類別沒有所選欄位的 getter
wrapping.annotation.parameters=註解參數
wrapping.deconstruction.patterns=解構模式
wrapping.multi.catch.types=多 catch 中的類型
wrapping.record.components=記錄組件
wrapping.text.blocks=文本塊
wrong.package.statement=錯誤的 package 語句
checkbox.simplify.condition.true=簡化“condition == true”
checkbox.simplify.condition1.true.condition2=簡化“condition1 ? true : condition2”
checkbox.simplify.if.condition1.return.true.return.condition2=簡化“if (condition1) return true; return condition2;”
checkbox.simplify.if.true.while.false=簡化“if (true)”、“while (false)”
clang.based.inspection.api.notes.issue=API 說明問題
clang.based.inspection.arc.and.properties=ARC 和 @properties
clang.based.inspection.concepts.issue=概念問題
clang.based.inspection.coroutines.issue=協同程序問題
clang.based.inspection.dependency.directive.source.minimization.issue=相依項指令源最小化問題
clang.based.inspection.lexical.or.preprocessor.issue=詞法或預處理程序問題
clang.based.inspection.openmp.issue=OpenMP 問題
clang.based.inspection.vtable.issue=VTable ABI 問題
configurable.naming.convention.header.guard.style=標頭檔保護符樣式:
configurable.naming.convention.several.rules.hint=如果一種實體類型有多個規則，將使用列表中的最後一個。
inspection.accessors.were.overridden=被覆寫的存取器
inspection.arc.issues=ARC 問題
inspection.array.index.out.of.bounds.display.name=陣列索引超出範圍
inspection.assign.in.condition=條件表達式中存在 '='
inspection.assign.in.condition.with.self=包含 'self' 的條件表達式中的 '='
inspection.clangd.general=Clangd 錯誤和警告
inspection.constant.conditions=恒定條件
inspection.constant.function.result.display.name=常數函式結果
inspection.constant.parameter.display.name=常數參數
inspection.context.sensitive.analysis=上下文相關分析
inspection.dangling.pointer.display.name=懸空指針
inspection.deprecated.api=使用了棄用 API
inspection.dfa.group.display.name=數據流分析
inspection.display.name.simplifiable.statement=可簡化語句
inspection.endless.loop.display.name=無盡迴圈
inspection.functions.group.display.name=函式
inspection.global.unused.analysis=全域未使用的分析
inspection.group.name.general=一般
inspection.hides.class.scope=隱藏的類別作用域
inspection.hiding.non.virtual.function=隱藏了非虛擬函式
inspection.inconsistent.naming=命名不一致
inspection.infinite.recursion.display.name=無限遞迴
inspection.kr.unspecified.parameters=通過 K&R 未指定參數語法將實參傳遞至函式
inspection.local.value.escapes.scope.display.name=區域值轉義作用域
inspection.loop.condition.is.not.updated=迴圈條件未在迴圈內更新
inspection.message.address.local.variable.may.escape.function=此區域變數的地址可以轉義該函式
inspection.message.calls.unreachable={0} 的所有呼叫都不可到達
inspection.message.condition.always.false=條件始終為 false
inspection.message.condition.always.false.when.reached=條件滿足後始終為 false
inspection.message.condition.always.true=條件始終為 true
inspection.message.condition.always.true.when.reached=條件滿足後始終為 true
inspection.message.endless.loop=無盡迴圈
inspection.message.error.after.macro.substitution=巨集取代後出錯: 
inspection.message.expression.can.be.simplified.to=此表達式可以簡化為 ''{0}''
inspection.message.file.too.complex.to.perform.context.sensitive.data.flow.analysis=此檔案過於複雜，無法執行上下文相關的數據流分析
inspection.message.file.too.complex.to.perform.data.flow.analysis=此檔案過於複雜，無法執行數據流分析
inspection.message.hides.non.virtual.function={0} 從 {1} 中隱藏了一個非虛擬函式
inspection.message.if.statement.has.identical.branches='if' 語句的分支相同
inspection.message.infinite.recursion=無限遞迴
inspection.message.invalid.suffix.on.raw.string=原始字串的後綴無效
inspection.message.is.never.used={0} 從未使用
inspection.message.may.point.to.deallocated.memory={0} 可能指向已取消分配的記憶體
inspection.message.may.point.to.invalidated.memory={0} 可能指向無效記憶體
inspection.message.may.point.to.out.of.scope.memory={0} 可能指向超出作用域的記憶體
inspection.message.misses.call.to.super.dealloc.at.last.statement={0} 在最後一條語句中錯過了對 [super dealloc] 的呼叫
inspection.message.modern.syntax.can.be.used=可以使用現代語法
inspection.message.never.used={0}{1, choice, 0#已被符合，從未被存取|1# 從未使用}
inspection.message.non.localized.string=未本地化的字串: {0}
inspection.message.not.released.in.dealloc.method={0} 未在 ''dealloc'' 方法中釋放
inspection.message.not.updated.in.loop=迴圈條件中使用的 {0} 未在迴圈中更新
inspection.message.only.assigned.but.never.accessed={0}只是被分配，從未被存取
inspection.message.reference.may.be.choice.null=指針可能為 {0, choice, 0#nil|1#null}
inspection.message.statement.can.be.simplified=此語句可以簡化
inspection.message.unreachable.code=無法存取的程式碼
inspection.message.unterminated.string.literal=未終止的字串文字
inspection.message.value.never.used=從未使用值
inspection.message.was.not.declared.in={0} 未在 {1} 中宣告
inspection.method.is.later.in.the.scope=方法宣告在作用域中位於後半部分
inspection.missing.return.display.name=缺少返回
inspection.modern.syntax=可以使用現代語法
inspection.name.unconstrained.variable.type=無約束變數類型
inspection.naming.convention.edit.settings.link=編輯程式碼樣式設定
inspection.naming.convention.rename.fix=重命名為 {0}
inspection.naming.convention.rename.header.guard.fix=將標頭檔保護符重命名為 {0}
inspection.non.localized.string=未本地化的字串
inspection.not.implemented.functions.display.name=未實作的函式
inspection.not.implements.protocol=未實作的協議
inspection.not.in.hierarchy.message=不位於層次結構訊息中
inspection.not.initialized.variable.display.name=未初始化的變數
inspection.not.released.var=版本應在 'dealloc' 或其被呼叫方中
inspection.null.dereference.display.name=Null 取消參照
inspection.option.unused.variable.initializers=警告未使用的變數初始設定式
inspection.replace.enable_if.with.require=將 enable_if 取代為要求
inspection.sending.dealloc='dealloc' 直接發送
inspection.simplifiable.statement=可簡化語句
inspection.simplify=簡化 {0}
inspection.simplify.condition=簡化“condition == true”
inspection.simplify.ternary=簡化“condition1 ? true : condition2”
inspection.unreachable.calls.display.name=無法存取的函式呼叫
inspection.unreachable.code.display.name=無法存取的程式碼
inspection.unused.class.display.name=未使用的類別
inspection.unused.concept.display.name=未使用的概念
inspection.unused.directive.display.name=未使用的 import 指令
inspection.unused.expression.result.display.name=未使用的表達式結果
inspection.unused.global.declaration.display.name=未使用的全域宣告
inspection.unused.import.statement.display.name=未使用的 import 語句
inspection.unused.include.directive.completely.not.directly=檢測未直接使用
inspection.unused.include.directive.completely.not.required=不需要檢測
inspection.unused.include.directive.completely.unused=檢測完全未使用
inspection.unused.instance.variable.display.name=未使用的實例變數
inspection.unused.local.variable.display.name=未使用的區域變數
inspection.unused.localization.display.name=未使用的本地化
inspection.unused.macro.display.name=未使用的巨集
inspection.unused.method.display.name=未使用的方法
inspection.unused.parameter.display.name=未使用的參數
inspection.unused.property.display.name=未使用的屬性
inspection.unused.struct.display.name=未使用的結構
inspection.unused.template.parameter.display.name=未使用的模板參數
inspection.unused.type.alias.display.name=未使用的類型別名
inspection.unused.value.display.name=未使用的值
inspection.usage.of.api.unavailable=使用不可用的 API
intention.dialog.message.change.type.as.well=是否還要更改 {0} 的類型?
intention.dialog.message.existing.default.values.removed={0} 參數的現有預設值將被移除。是否繼續?
intention.family.name.add.bridge.cast=新增橋式轉換
intention.family.name.add.call.to.super.dealloc=將呼叫新增到 [super dealloc]
intention.family.name.add.return.statement=新增 return 語句
intention.family.name.change.to.nil=更改為 'nil'
intention.family.name.change.type.to.auto=將類型 ''{0}'' 更改為 ''auto''
intention.family.name.convert.literal.type=轉換文字類型: 新增 '@'
intention.family.name.delete.method=刪除方法
intention.family.name.extract.assignment=提取賦值
intention.family.name.inline.parameter=內聯參數
intention.family.name.leave.initializer={0}並保留初始設定式
intention.family.name.make.default=將 {0} 設為預設值
intention.family.name.remove=移除 {0}
intention.family.name.remove.declaration=移除{1, choice, 0#{0}|1#宣告:|2#名稱:}
intention.family.name.remove.directive=移除指令
intention.family.name.remove.extra.initializers=移除額外初始設定式
intention.family.name.remove.initializer=移除初始設定式
intention.family.name.remove.statement=移除語句
intention.family.name.safe.delete=安全刪除
intention.family.name.send.message=發送 ''{0}'' 訊息
intention.family.name.simplify=簡化 {0}
intention.family.name.simplify.choice=簡化 {1, choice, 0#表達式|1#{0}}
intention.family.name.simplify.condition=將條件簡化為 ''{0}''
intention.family.name.simplify.expression=簡化表達式
intention.family.name.use.enum.constant=使用枚舉常數
intention.import.command.name=匯入 {0}
intention.import.popup.title=要匯入的符號
intention.name.add=新增“{0}”
intention.name.add.call.to.base.constructor=新增 ''{0}'' 基建構函式的呼叫
intention.name.add.constructor.initializer=為 {0} 新增建構函式初始設定式
intention.name.add.last.parameter=將最後一個 ''{0}'' 參數新增到 {1}
intention.name.add.parameters=將參數新增到 {0}
intention.name.add.suffix=新增後綴
intention.name.add.type.modifier=將 {0} 設為 {1}
intention.name.call=呼叫 {0}
intention.name.cast.expression.to=將表達式轉換為 ''{0}''
intention.name.change.format.specifier=將格式說明符更改為 ''{0}''
intention.name.change.signature=將 {0} 的簽名更改為 ''{1}''
intention.name.change.superclass=將 {0} 的超類別從 ''{1}'' 更改為 ''{2}''
intention.name.change.type=將 {1} 的 {0, choice, 0#返回 |1#}類型更改為 ''{2}''{3}
intention.name.change.visibility=將 {0} 設為 {1}
intention.name.choice.enable.disable=為 {2} {0, choice, 0#啟用 ''|1#停用 ''}{1}''
intention.name.choice.superclass={1, choice, 0#{0} |1#}{2} 的超類別 
intention.name.class=類別
intention.name.cpp.class=C++ 類別
intention.name.create.new=新增 {0}
intention.name.create.new.category=使用 {1} 在 {0} 上新增類別
intention.name.delete=刪除 {0}
intention.name.import=匯入 {0}
intention.name.import.from=從 {0}
intention.name.import.which={0, choice, 0#哪一個|1#符號} ''{1}''
intention.name.initialize=初始化 {0}
intention.name.inline=內聯{0}
intention.name.leave.initializer={0}並保留初始設定式
intention.name.make=將 {0} 設為 {1}
intention.name.make.class.method.instance.method=設為 ''{0}{1, choice, 0#'' 類別方法|1#'' 實例方法}
intention.name.make.function.const=將{0}設為{1, choice, 0#常數|1#非常數}
intention.name.make.function.virtual=設為 {0}::{1}{2, choice, 0# 純虛擬|1# 虛擬}
intention.name.make.function.volatile=將{0}設為{1, choice, 0#易失|1#非易失}
intention.name.move.declaration=移動 {0}{1} 的宣告
intention.name.predeclare.protocol.class=預宣告{0, choice, 0#協議 ''|1#類別 ''|2#結構 ''}{1}''
intention.name.remove=移除 {0}
intention.name.remove.last.parameter=從 {1} 移除最後一個 ''{0}'' 參數
intention.name.remove.type.modifier=將 {0} 設為非 {1}
intention.name.rename=重新命名 {0}
intention.name.rename.reference=重新命名參照
intention.name.reuse.previous.declaration=重用 {0} 的上一個宣告
intention.name.safe.delete=安全刪除 {0}
intention.name.set.superclass=將 ''{0}'' 設為{1}
intention.name.simplify=簡化 {0}
intention.name.static=static
intention.name.use.constant=使用常數 ''{0}''
intentions.add.braces.statement=將大括號新增到 ''{0}'' 語句
intentions.add.constructor.initializer.for.field=為欄位新增建構函式初始設定式
intentions.add.initializer=新增初始設定式
intentions.add.modifier=新增 ''{0}''
intentions.add.parameter.initWith=作為參數新增到 'initWith…'
intentions.add.parameters.to.constructor=將 {0} 作為參數新增到建構函式
intentions.add.super.constructor.call=新增缺少的基建構函式呼叫
intentions.add.super.protocol.by.class=按類別採用協議
intentions.add.super.protocol.by.private.category=按私有類別採用協議
intentions.cast.expression=轉換表達式
intentions.change.arc.attribute=更改 ARC 特性
intentions.change.function.const.action=更改 const 限定符
intentions.change.function.signature=更改函式簽名
intentions.change.function.volatile.action=更改 volatile 限定符
intentions.change.gcc.attribute.action=更改特性 ''{0}''
intentions.change.method.signature.add.parameters=新增參數
intentions.change.method.staticness.action=將方法設為實例/類別
intentions.change.property.attribute.action=更改屬性特性
intentions.change.superclass=更改超類別
intentions.change.type=更改類型
intentions.change.type.capitalized=更改類型
intentions.change.visibility=更改可見性
intentions.check.raw.string=檢查原始字串
intentions.convert.id.to.instance=將 'id' 返回值類型取代為 'instancetype'
intentions.convert.objc.literal=切換至 Objective-C 文字
intentions.convert.to.instance.variable=轉換為實例變數
intentions.convert.to.property=轉換為屬性
intentions.convert.type=轉換類型
intentions.create.implementation=建立 {0} 的實作
intentions.create.interface=為 {0} 建立接口
intentions.create.matching.constructor=建立與基類別符合的建構函式
intentions.create.matching.constructor.in=在 {0} 中建立預設建構函式
intentions.create.missing.default.switch.case=建立缺少的 default case
intentions.create.missing.switch.cases=建立缺少的 switch case
intentions.create.new.constructor=建立新的建構函式 ''{0}()''
intentions.create.new.matching.constructor=在 {0} 個符合基類別中建立新的建構函式
intentions.deMorgan.law=德摩根定律
intentions.declare.member.in=宣告位置: 
intentions.declare.method.in=在 {0} 中宣告方法
intentions.declare.method.in.interface=在接口中宣告方法
intentions.declare.method.in.private.category=在私有類別中宣告方法
intentions.declare.property.as.readwrite=在私有類別中將屬性宣告為 'readwrite'
intentions.extract.category=提取此類別的類別
intentions.extract.if=提取 'if'
intentions.extract.if.with.text=提取 ''if ({0})''
intentions.extract.private.category=提取此類別的私有類別
intentions.extract.protocol=提取此類別的協議
intentions.extract.super.class=提取超類別
intentions.extract.super.protocol=提取超級協議
intentions.flip.binary.operation=翻轉二元運算
intentions.flip.operator=翻轉 {0}
intentions.flip.operator.to=將 {0} 翻轉為 {1}
intentions.generate.property=生成屬性
intentions.group=C 和 C++
intentions.group.control.flow=C 和 C++/控制流
intentions.group.declarations=C 和 C++/宣告
intentions.group.definition=C 和 C++/定義
intentions.group.objc=Objective-C
intentions.group.operators=C 和 C++/運算符
intentions.implement.accessor.methods=實作存取器方法
intentions.implement.accessor.methods.for=為 {0} 實作存取器方法
intentions.implement.method=實作 {0}
intentions.implement.required.methods=實作接口 ''{0}'' 的必需方法
intentions.import.predeclare.symbol=匯入/預宣告符號
intentions.insert.cast.use.modern=使用 C++ 轉換運算符
intentions.introduce.typedef=引入 typedef
intentions.introduce.typedef.for.type=為類型 {0} 引入 typedef
intentions.invert.if.condition=反轉 'if' 條件
intentions.merge.if.else=合併 'if else'
intentions.merge.nested.ifs=合併嵌套的 'if'
intentions.migrate.to.arc=遷移到 ARC
intentions.move.instance.variables=將實例變數移至實作
intentions.move.to.interface=移至接口
intentions.move.to.private.category=移至私有類別
intentions.predeclare.function=預宣告 {0}
intentions.release.variables=釋放變數
intentions.remove.braces.statement=從 ''{0}'' 語句中移除大括號
intentions.remove.private.category.message=移除空的私有類別?
intentions.remove.private.category.title=移除私有類別
intentions.remove.subj=移除 ''{0}''
intentions.remove.suppression=移除禁止
intentions.remove.unnecessary.parentheses=移除不必要的圓括號
intentions.rename.reference=重新命名參照
intentions.rename.symbol=重新命名符號
intentions.replace.and.with.or=將 '\\&\\&' 取代為 '||'
intentions.replace.if.else.with.ternary=將 'if else' 取代為 '?:'
intentions.replace.or.with.and=將 '||' 取代為 '\\&\\&'
intentions.replace.ternary.with.if.else=將 '?:' 取代為 'if else'
intentions.replace.type.with.auto=將類型取代為 'auto'
intentions.reuse.declaration=重用宣告
intentions.split.declaration=拆分為宣告和賦值
intentions.split.function=將函式分為宣告和定義
intentions.split.function.progress.text=正在確定定義位置…
intentions.split.into.separate.declarations=拆分為單獨的宣告
intentions.suppress.all.for.file=禁止對檔案的所有 {0} 診斷
intentions.suppress.for=對 {0} 禁止
intentions.suppress.for.file=對檔案禁止
intentions.suppress.for.method=對方法/函式禁止
intentions.suppress.for.statement=對語句禁止
intentions.suppress.option.for=禁止 {1} 的“{0}”
intentions.surround.with.if.responds=使用 "if ([ respondsToSelector: ])" 包裝
intentions.switch.property.dot.method=切換 '.' 和方法表示法
intentions.switch.to.dot.notation=切換至 '.' 表示法
intentions.switch.to.getter.notation=切換至 getter 方法表示法
intentions.switch.to.setter.notation=切換至 setter 方法表示法
intentions.synthesize.property=合成屬性
intentions.wrap.with.stringFormat=使用 'stringWithFormat' 包裝
no.suggestions.for.members=沒有關於 {0} 成員的建議
no.suggestions.for.properties.of.class=沒有關於類別 {0} 屬性的建議
progress.text.evaluating.unused.symbols=正在對未使用的符號求值
quick.fix.add_return_statement=新增 return 語句
quick.fix.append.nil.argument=追加“nil”實參
quick.fix.change.format.specifier=更改格式說明符
quick.fix.change.pure.specifier=將純指定符更改為 '= 0'
quick.fix.copy.superclass.from.interface=從接口複製超類別
quick.fix.copy.superclass.to.interface=將超類別複製到接口
quick.fix.insert.keyword=插入 ''{0}''
quick.fix.make_default=將 {0} 設為預設值
quick.fix.optimize.imports=最佳化 import
quick.fix.optimize.includes=最佳化 include
quick.fix.place.parentheses.around=將括號置於
quick.fix.remove.accessor=移除存取器
quick.fix.remove.arguments=移除實參
quick.fix.remove.attribute=移除特性
quick.fix.remove.declaration=移除宣告
quick.fix.remove.extra.declarators=移除額外宣告符
quick.fix.remove.from.base.classes.list=從基類別列表中移除 ''{0}''
quick.fix.remove.initializer=移除初始設定式
quick.fix.remove.instance.variable.list=移除實例變數列表
quick.fix.remove.method.body=移除方法體
quick.fix.remove.property=移除屬性
quick.fix.remove.protocols.list=移除協議列表
quick.fix.remove.pure.specifier=移除純指定符
quick.fix.remove.redundant.cast=移除冗餘轉換
quick.fix.remove.statement=移除語句
quick.fix.remove.superclass=移除超類別
quick.fix.remove.superclass.reference=移除超類別參照
quick.fix.remove.synthesize.dynamic.statement=移除 '@synthesize'/'@dynamic' 語句
quick.fix.remove.synthesize.statement=移除 '@synthesize' 語句
quick.fix.remove.useless.import=移除無用的匯入
quick.fix.remove.useless.include=移除無用的 include
quick.fix.remove.user.defined.getter.method=移除使用者定義的 getter 方法
quick.fix.remove.user.defined.setter.method=移除使用者定義的 setter 方法
quick.fix.send.release.message.instead.dealloc=發送“release”訊息而非“dealloc”
unused.inspection.run.in.headers=在標頭檔中執行檢查
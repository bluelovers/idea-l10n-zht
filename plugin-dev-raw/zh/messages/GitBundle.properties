abort=中止
abort.operation.cherry.pick.name=優選
abort.operation.dialog.msg=中止 {0}{1}?
abort.operation.dialog.title=中止 {0}
abort.operation.failed={0} 中止失敗
abort.operation.indicator.text=git {0} --abort{1}
abort.operation.merge.name=合併
abort.operation.progress.title=正在中止 {0} 程序
abort.operation.rebase.name=重定基底
abort.operation.revert.name=還原
abort.operation.succeeded={0} 中止成功
action.CopyPathFromRepositoryRootProvider.text=版本庫根路徑
action.Git.Add.text=新增
action.Git.Branches.text=分支(_B)…
action.Git.BrowseRepoAtRevision.text=在修訂版中顯示版本庫
action.Git.CheckoutRevision.text=簽出修訂
action.Git.CherryPick.Abort.text=中止優選
action.Git.Clone.text=克隆…
action.Git.Commit.Stage.text=提交…
action.Git.Compare.Selected.Heads.description=顯示所選分支 head 之間的差異
action.Git.Compare.Selected.Heads.title=顯示檔案差異
action.Git.Compare.Selected.description=相互比較選定分支
action.Git.Compare.Selected.description.disabled=從同一版本庫中選擇分支
action.Git.Compare.Selected.title=比較分支
action.Git.Compare.With.Current.title=與當前分支進行比較
action.Git.CompareWithBranch.text=與分支或標籤比較…
action.Git.Configure.Remotes.text=管理遠端…
action.Git.CreateNewBranch.FromCommit.description=從所選提交開始建立新分支
action.Git.CreateNewBranch.FromCommit.text=新增分支…
action.Git.CreateNewBranch.text=新增分支…
action.Git.CreateNewTag.description=建立指向此提交的新標籤
action.Git.CreateNewTag.text=新增標記…
action.Git.Delete.Branch.title=刪除{0,choice,1#分支|2#分支}
action.Git.Drop.Commits.text=刪除提交
action.Git.Drop.Selected.Changes.text=刪除所選更改
action.Git.Fetch.description.fetch.in.progress=正在獲取…
action.Git.Fetch.text=獲取
action.Git.Fetch.title=獲取所有遠端
action.Git.Fixup.To.Commit.description=建立 fixup 提交
action.Git.Fixup.To.Commit.description.nothing.to.commit=沒有要提交的內容
action.Git.Fixup.To.Commit.text=Fixup…
action.Git.InMemory.Extract.Selected.Changes.description=根據所選更改建立一個新的提交，並將其直接放置在歷史記錄中原始提交之後
action.Git.InMemory.Extract.Selected.Changes.text=將所選更改獲取到單獨的提交…
action.Git.InMemory.Reword.Commit.description=通過記憶體中重定基底更改提交訊息
action.Git.InMemory.Reword.Commit.text=編輯提交訊息…(記憶體中)
action.Git.Init.Stage.error=向 Git 新增檔案失敗
action.Git.Init.Vcs.Toolbar.Widget.text=建立 Git 版本庫…
action.Git.Init.error=Git init 失敗
action.Git.Init.text=建立 Git 版本庫…
action.Git.Interactive.Rebase.description=顯示互動重定基底的對話框，可以在該對話中對提交執行壓縮、fixup、重新排序、移除和改寫
action.Git.Interactive.Rebase.text=從這裡進行互動重定基底…
action.Git.Loading.Branches.progress=正在載入分支…
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.description=選擇分支後，按此分支篩選日誌
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.text=更新分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.description=使用所選分支更新日誌中的分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.text=更新日誌中的分支篩選器
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.description=選擇分支後，在日誌中導覽到該分支 HEAD
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.text=在日誌中導覽到分支 Head
action.Git.Log.Branches.Navigate.Log.To.Selected.Branch.text=在日誌中導覽到所選分支 Head
action.Git.Log.DeepCompare.description=醒目提示尚未優選到當前分支的提交
action.Git.Log.DeepCompare.text=無優選提交
action.Git.Log.Edit.Remote.text=編輯遠端
action.Git.Log.Hide.Branches.text=隱藏 Git 分支
action.Git.Log.Remove.Remote.text=移除{0,choice,1#遠端|2#遠端}
action.Git.Log.Show.Branches.text=分支
action.Git.Log.Show.Command.text=顯示指令的 Git 日誌
action.Git.Log.text=顯示 Git 版本庫日誌…
action.Git.Merge.Abort.text=中止合併
action.Git.Merge.text=合併…
action.Git.New.Branch.description=僅選擇一個分支以繼續建立新分支
action.Git.New.Branch.dialog.title=從 {0} 建立分支
action.Git.Pull.text=拉取…
action.Git.Push.Tag.text=推送標籤
action.Git.Push.Tag.text.to=推送到{1,choice,0#|1# {2} 中的} {0}
action.Git.PushUpToCommit.description=推送所有之前的提交，包括所選提交
action.Git.PushUpToCommit.text=推送此前所有提交…
action.Git.Rebase.Abort.text=中止重定基底
action.Git.Rebase.Continue.text=繼續重定基底
action.Git.Rebase.Skip.progress.title=重定基底期間跳過提交…
action.Git.Rebase.Skip.text=跳過提交
action.Git.Rebase.operation.name=重定基底
action.Git.Rebase.text=重定基底…
action.Git.Reset.In.Log.text=將當前分支重設到此處…
action.Git.Reset.text=重設 HEAD…
action.Git.ResolveConflicts.text=解決衝突…
action.Git.Revert.Abort.text=中止還原
action.Git.Revert.In.Log.description=生成新提交，這會還原在原始提交中所做的更改
action.Git.Revert.In.Log.template.text=還原{0,choice,1#提交|2#提交}
action.Git.Revert.In.Log.text=還原提交
action.Git.RevertResolved.confirmation=是否要還原已解析的{0,choice,1#檔案|2#檔案}: {1}?
action.Git.RevertResolved.confirmation.title=還原已解析的檔案
action.Git.RevertResolved.progress=正在還原已解決的衝突…
action.Git.RevertResolved.text=還原已解決
action.Git.Reword.Commit.description=通過 git rebase 或 amend 的改寫選項更改提交訊息
action.Git.Reword.Commit.text=編輯提交訊息…
action.Git.Show.My.Branches.description.calculating.branches.progress=正在計算我的分支
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有獨佔提交都是由“我”(即當前 Git 作者)執行的，則此分支為“我的”。
action.Git.Show.My.Branches.description.not.all.roots.indexed=並沒有為所有版本庫編制索引。
action.Git.Show.My.Branches.description.not.graph.ready=該日志尚未就緒，請稍候。
action.Git.Show.My.Branches.description.not.support.indexing=某些版本庫不支持索引。
action.Git.Show.My.Branches.title=顯示我的分支
action.Git.Show.Stage.text=顯示暫存區域
action.Git.Show.Stash.With.Shelf.description=開啟“隱藏和擱置”頁籤
action.Git.Show.Stash.With.Shelf.text=顯示隱藏和擱置
action.Git.Show.Stash.description=開啟“Git 隱藏”頁籤
action.Git.Show.Stash.text=顯示 Git 隱藏
action.Git.ShowBranches.pretty.description=顯示分支
action.Git.ShowBranches.text=顯示分支
action.Git.Squash.Commits.description=互動重定基底以將所選提交合併為一個提交
action.Git.Squash.Commits.text=壓縮提交…
action.Git.Squash.Into.Commit.description=提交本地更改，以便將其壓縮到所選提交中
action.Git.Squash.Into.Commit.text=壓縮到…
action.Git.Stage.Add.All.description=將所有未暫存的更改和未追蹤的檔案新增到索引
action.Git.Stage.Add.All.text=全部暫存
action.Git.Stage.Add.Tracked.description=將追蹤檔案中所有未暫存的更改新增到索引
action.Git.Stage.Add.Tracked.text=暫存全部已追蹤項
action.Git.Stage.Compare.Local.Staged.text=與暫存版本比較
action.Git.Stage.Compare.Staged.Head.text=與 HEAD 版本比較
action.Git.Stage.Compare.Staged.Local.text=與本地版本比較
action.Git.Stage.Compare.Three.Versions.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.Disable.description=停用暫存區域並切換到更改列表
action.Git.Stage.Disable.text=變更列表
action.Git.Stage.Enable.description=使用原生 Git 暫存概念進行提交
action.Git.Stage.Enable.text=暫存區域
action.Git.Stage.Show.Local.description=在編輯器中顯示當前檔案的本地內容
action.Git.Stage.Show.Local.text=顯示本地版本
action.Git.Stage.Show.Staged.description=在編輯器中顯示當前檔案的暫存內容
action.Git.Stage.Show.Staged.text=顯示暫存版本
action.Git.Stage.ThreeSideDiff.description=顯示包含 HEAD、暫存和本地版本的差異視窗，從中可以互動地將更改新增到暫存區域
action.Git.Stage.ThreeSideDiff.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.ToggleCommitAll.description=沒有暫存檔案時提交所有檔案
action.Git.Stage.ToggleCommitAll.text=無任何內容暫存時全部提交
action.Git.Stash.Apply.description=套用所選隱藏
action.Git.Stash.Apply.text=套用(&A)
action.Git.Stash.Clear.description=清除所有隱藏
action.Git.Stash.Clear.in.root.description=清除所選根中的所有隱藏
action.Git.Stash.Clear.in.root.text=清除 {0} 中的隱藏(&C)
action.Git.Stash.Clear.text=清除(&C)
action.Git.Stash.Drop.description=丟棄所選隱藏
action.Git.Stash.Drop.text=刪除(&D)
action.Git.Stash.Pop.description=彈出所選隱藏
action.Git.Stash.Pop.text=彈出(&P)
action.Git.Stash.Refresh.description=重新整理隱藏列表
action.Git.Stash.Refresh.text=重新整理隱藏
action.Git.Stash.Silently.text=無提示隱藏
action.Git.Stash.Toggle.Split.Preview.text=預覽差異
action.Git.Stash.UnstashAs.description=彈出或套用選定的隱藏作為新分支(帶或不帶索引)
action.Git.Stash.UnstashAs.text=取消隱藏(&U)…
action.Git.Stash.text=隱藏更改…
action.Git.Tag.text=新增標記…
action.Git.Toggle.Favorite.title=標記/取消標記為收藏項
action.Git.Toolbar.ShowMoreActions.description=VCS 動作
action.Git.Toolbar.ShowMoreActions.text=版本控制
action.Git.Uncommit.description=撤消最後一次提交並將其更改放入所選更改列表
action.Git.Uncommit.text=撤消提交…
action.Git.Unshallow.failure.title=無法取消淺層化版本庫
action.Git.Unshallow.progress.title=正在取消淺層化版本庫…
action.Git.Unshallow.text=取消淺層化版本庫
action.Git.Unstash.text=取消隱藏更改…
action.Git.Update.Selected.description=從追蹤的遠端獲取並使用 {1} 或像 `git fetch branch:branch` 一樣的快進(如果可能)更新所選{0,choice,1#分支|2#分支}
action.Git.Update.Selected.description.already.running=更新已在執行
action.Git.Update.Selected.description.select.non.current=僅選擇非當前分支
action.Git.Update.Selected.description.tracking.not.configured=沒有為所選{0,choice,1#分支|2#分支}組態追蹤分支
action.Git.Update.Selected.text=更新所選
action.New.Branch.disabled.fresh.description=無法在空版本庫中建立新分支。首先進行初始提交
action.New.Branch.disabled.several.commits.description=選擇單個提交以建立新分支
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=刪除追蹤的分支
action.NotificationAction.GitDeleteBranchOperation.text.restore=還原
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=檢視提交
action.NotificationAction.GitDeleteTagOperation.text.restore=還原
action.NotificationAction.GitMergeAction.text.view.commits=檢視提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=檢視提交
action.NotificationAction.GithubNotifications.text.configure=組態…
action.NotificationAction.text.resolve=解決…
action.description.cant.revert.merge.commit=不允許還原合併提交
action.fetch.text=獲取
action.git.branches.group.by.prefix.text=按前綴分組
action.git.branches.popup.filter.by.action.single.text=在搜尋結果中顯示動作
action.git.branches.popup.filter.by.action.text=動作
action.git.branches.popup.filter.by.repository.text=版本庫
action.git.branches.show.recent.text=顯示最近的分支
action.git.branches.show.tags.text=顯示標籤
action.git.update.force.pushed.branch.description=對可能強制推送的當前分支執行更新。此動作可以利用現有的“更新專案”動作(例如，當存在本地合併提交時)。
action.git.update.force.pushed.branch.not.all.local.commits.chery.picked=並非所有本地提交都是從 {0} 分支中優選的
action.git.update.force.pushed.branch.progress=正在執行強制推送的分支更新…
action.git.update.force.pushed.branch.success=可能強制推送的分支更新成功
action.git.update.force.pushed.branch.text=更新強制推送的分支
action.git4idea.commands.TestGitHttpLoginDialogAction.text=測試 Git 登入對話框
action.gpg.agent.configuration.text=組態 GPG 代理
action.label.add.unstaged.range=暫存
action.label.add.unstaged.range.tooltip=向索引中新增新的更改
action.label.reset.staged.range=取消暫存
action.label.reset.staged.range.tooltip=移除索引中的更改
action.main.toolbar.git.Branches.text=VCS 小工具
action.main.toolbar.git.MergeRebase.text=VCS 合併/重定基底小工具
action.main.toolbar.git.project.not.trusted.separator.text=安全模式，版本控制不可用
action.not.possible.in.fresh.repo.checkout=簽出
action.not.possible.in.fresh.repo.generic=動作
action.selected.directory.text=選定{0,choice,1#目錄|2#目錄}
action.selected.file.text=選定{0,choice,1#檔案|2#檔案}
activity.name.abort.command=Git abort {0}
activity.name.checkout=Git checkout
activity.name.cherry.pick=Git cherry-pick
activity.name.merge=Git merge
activity.name.rebase=Git rebase
activity.name.reset=Git reset
activity.name.revert=Git revert
activity.name.stash=Git stash
activity.name.undo.commit=Git undo commit
activity.name.unstash=Git unstash
add.adding=正在新增檔案…
advanced.setting.git.branch.cleanup.symbol=分支名稱清理符號
advanced.setting.git.branch.cleanup.symbol.description=將在 Git 分支名稱中代替停用符號的符號
advanced.setting.git.clone.recurse.submodules=遞迴克隆專案中的子模組
advanced.setting.git.clone.recurse.submodules.description=啟用後，從 Git 呼叫 'git clone --recurse-submodules' 簽出，即克隆主版本庫與所有子模組 (如有)
advanced.setting.git.commit.do.not.run.commit.hooks=不執行 Git 提交掛鈎
advanced.setting.git.commit.do.not.run.commit.hooks.description=啟用後，提交始終使用 '--no-verify' 選項執行
advanced.setting.git.read.content.with=從 Git 讀取時套用內容轉換
advanced.setting.git.read.content.with.description=從 Git 讀取檔案內容時為 'git cat-file' 指令使用 '--filters' 或 '--textconv' 標誌
advanced.setting.git.recent.projects.show.branch=在最近專案列表中顯示分支名稱
advanced.setting.git.recent.projects.show.branch.description=分支名稱將顯示在歡迎頁面和主選單中的最近專案列表中
advanced.setting.git.search.everywhere.tab.enabled=在“隨處搜尋”中顯示 Git 頁籤
advanced.setting.git.update.incoming.outgoing.info=檢查傳入和傳出提交
advanced.setting.git.update.incoming.outgoing.info.description=在“分支”彈出視窗中更新具有傳入/傳出提交的分支資訊
advanced.setting.git.use.push.force.with.lease=使用安全強制推送
advanced.setting.git.use.push.force.with.lease.description=從 IDE 呼叫強制推送時使用 '--force-with-lease'，而非僅使用 '--force'
advanced.setting.git.use.schannel.on.windows=使用 Windows 憑證存儲
advanced.setting.git.use.schannel.on.windows.description=強制 Git 使用 Windows 憑證存儲來驗證 SSL 連線。適用於 Git 2.14 及更高版本。
advanced.settings.git=版本控制. Git
annotate.cannot.annotate.dir=無法註解目錄
annotate.line.mismatch.exception=正在為第 {0} 行新增資訊，但應當為第 {1} 行新增資訊
annotate.output.lack.data=第 {0} 行的輸出缺少必要的資料
annotate.repository.is.shallow=淺層版本庫中的註解可能不準確
annotations.options.detect.movements.across.files=檢測跨檔案的移動
annotations.options.detect.movements.within.file=檢測檔案內的移動
annotations.options.group=選項
annotations.options.ignore.whitespaces=忽略空格
apply.changes.applied.for.commits={0} {1,choice,1#項提交|2#{1,number} 項提交} 來自於 {2}
apply.changes.everything.applied={0} 中的所有更改已被{1}
apply.changes.nothing.to.do=沒要有{0}的內容
apply.changes.operation.canceled={0} 已取消
apply.changes.operation.failed={0} 失敗
apply.changes.operation.performed.with.conflicts={0}已執行，但存在衝突
apply.changes.operation.successful={0}成功
apply.changes.operation.successful.for.commits=但是，對以下{1, choice,1#提交|2#提交}成功進行了{0}:
apply.changes.resolving.conflicts.progress.title=正在解決衝突…
apply.changes.restore.notification.description=本地更改已在{0}之前儲存
apply.changes.restore.notification.title=還原本地更改
apply.changes.save.and.retry.operation={0}更改並重試
apply.changes.skipped={0} {1,choice,1#被|2#被}跳過，因為所有更改已被{2}。
apply.changes.unresolved.conflicts.notification.abort.action.text=中止{0}
apply.changes.unresolved.conflicts.notification.resolve.action.text=解決…
apply.changes.unresolved.conflicts.text=工作樹中有未解決的衝突。
apply.conflict.dialog.description.label.text=在由 {2} 執行的提交 {1} 的{0}過程中發生衝突{3}
blob.not.found=找不到 Blob: {0} - {1}
branch.checking.out.branch.from.process=正在從 {1} 簽出 {0}…
branch.checking.out.new.branch.process=正在簽出新分支 {0}…
branch.checking.out.process=正在簽出 {0}…
branch.creating.branch.process=正在建立分支 {0}…
branch.deleting.branch.process=正在刪除 {0}…
branch.deleting.remote.branch=正在刪除 {0}…
branch.deleting.tag.on.remote.process=正在刪除遠端分支上的標記 {0}…
branch.direction.panel.base.repo.label=base 版本庫:
branch.direction.panel.branch.label=分支:
branch.direction.panel.head.repo.label=head 版本庫:
branch.direction.panel.save.button=儲存
branch.direction.panel.select.link=選擇…
branch.direction.panel.warning.not.synced=本地分支未與遠端分支同步。\n''{0}'' 分支將與 ''{1}'' 同步。
branch.direction.panel.warning.push=''{0}'' 沒有遠端分支。\n將在 ''{1}'' 上建立新的遠端分支。
branch.merging.process=正在合併 {0}…
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合併來自分支 {0} 的所有提交
branch.not.fully.merged.dialog.repository.label=版本庫:
branch.not.fully.merged.dialog.restore.button=還原(&R)
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合併到 {1}。<br/>以下是未合併提交的列表。
branch.not.fully.merged.dialog.title=分支未完全合併
branch.operation.could.not.0.operation.name.1.reference=無法{0} {1}
branch.operation.in={0} ({1} 中)
branch.rebasing.onto.process=正在重定基底到 ''{0}''…
branch.rebasing.process=正在重定基底 {0}…
branch.renaming.branch.process=正在將 {0} 重命名為 {1}…
branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由於存在未合併的檔案而無法{0}
branch.ui.handler.delete.all=全部刪除
branch.ui.handler.delete.remote.branches=刪除遠端 {0,choice,1#分支|2#分支}
branch.ui.handler.delete.remote.branches.question=刪除遠端 {0,choice,1#分支|2#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同時刪除追蹤本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=刪除追蹤本地分支:
branch.ui.handler.do.not.rollback=不回滾
branch.ui.handler.merge.error.notification.title=仍然存在未解決的檔案。
branch.ui.handler.merge.notification.description=以下檔案存在未解決的衝突。您需要先解決它們，然後再{0}。
branch.ui.handler.rollback=回滾
branch.ui.handler.unmerged.files.error.notification.text=您需要在{0}之前解決所有合併衝突。<br/>解決衝突後，請不要忘記在切換到另一個分支之前將檔案提交到當前分支。
branch.ui.handler.unmerged.files.error.resolve.conflicts.action.text=解決衝突…
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您需要先解決所有合併衝突，然後才能{0}。<br/>{1}
branch.worker.could.not.create.tag=無法{1,choice,0#|1#|2# 在 {2} 中}建立標記 {0}
branches.action.delete=刪除(&D)
branches.action.pull.into.branch.using.merge=使用“合併”拉入 {0}
branches.action.pull.into.branch.using.merge.description=使用合併拉入 {0}
branches.action.pull.into.branch.using.merge.selected=使用“合併”拉入當前分支
branches.action.pull.into.branch.using.rebase=使用“重定基底”拉入 {0}
branches.action.pull.into.branch.using.rebase.description=使用重定基底拉入 {0}
branches.action.pull.into.branch.using.rebase.selected=使用“重定基底”拉入當前分支
branches.branch.0=分支 ''{0}''
branches.branches=分支
branches.checking.existing.commits.process=正在檢查現有提交…
branches.checkout=簽出
branches.checkout.and.rebase.error.current.with.same.name=無法覆蓋當前分支 {0}
branches.checkout.and.rebase.failed=簽出和重定基底失敗
branches.checkout.and.rebase.onto.branch=簽出並重定基底到 {0}
branches.checkout.and.rebase.onto.current=簽出並重定基底到當前分支
branches.checkout.and.rebase.onto.current.process=正在簽出 {0} 並重定基底到當前分支
branches.checkout.and.rebase.onto.in.one.step=簽出 {0}，並在一個步驟中將其重定基底到 {1} (類似於 `git rebase HEAD {2}`)
branches.checkout.local=簽出本地分支
branches.checkout.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是簽出 ''{0}''?
branches.checkout.s=簽出 {0}
branches.checkout.tag.or.revision=簽出標記或修訂…
branches.checkout.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是刪除本地提交?
branches.compare.the.current.working.tree.with=將當前工作樹與 {0} 中的樹進行比較
branches.compare.with.branch=與{0}比較
branches.compare.with.current=與當前分支進行比較
branches.create.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要在其他版本庫中建立分支?
branches.create.new.branch.dialog.title=建立新分支
branches.create.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要刪除本地提交?
branches.current.branch=當前分支
branches.current.branch.name=當前
branches.drop.local.commits=刪除本地提交
branches.enter.reference.branch.tag.name.or.commit.hash=輸入參照(分支、標記)名稱或提交雜湊:
branches.fetch.finished=已獲取 {0} 個目標
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.merge.into=將 {0} 合併到 {1} 中
branches.merge.into.current=合併到當前分支
branches.new.branch.from.branch=從 {0} 新增分支…
branches.new.branch.from.branch.current=從當前位置新增分支…
branches.new.branch.from.branch.description=從 {0} 建立新分支
branches.rebase.current.onto.selected=將當前分支重定基底到所選分支
branches.rebase.is.not.possible.in.the.detached.head.state=在游離的 HEAD 狀態下無法重定基底
branches.rebase.onto=將 {0} 變基到 {1}
branches.rebase.onto.selected.commit=將 {0} 重定基底到所選提交
branches.rebase.onto.selected.commit.description=將 {0} 變基到 {1}
branches.remote.branches=遠端分支
branches.remote.branches.in.repo={0} 中的遠端分支
branches.rename.branch=重新命名分支 {0}
branches.selected.branch.name=已選擇
branches.show.commits.in=在{0}中顯示{1}中缺少的提交
branches.show.diff.with.working.tree=顯示與工作樹的差異
branches.tag.0=標記 ''{0}''
branches.tags=標記
branches.tags.in.repo={0} 中的標籤
branches.there.are.incoming.and.outgoing.commits=存在傳入和傳出提交
branches.there.are.incoming.commits=存在傳入提交
branches.there.are.outgoing.commits=存在傳出提交
branches.tooltip.number.incoming.commits={0} 個傳入{0,choice,1#提交|2#提交}
branches.tooltip.number.incoming.commits.in.repositories={1} 個{1, choice, 1#版本庫|2#版本庫}中的 {0} 個傳入{0,choice,1#提交|2#提交}
branches.tooltip.number.outgoing.commits={0} 個傳出{0,choice,1#提交|2#提交}
branches.tooltip.number.outgoing.commits.in.repositories={1} 個{1, choice, 1#版本庫|2#版本庫}中的 {0} 個傳出{0,choice,1#提交|2#提交}
branches.tooltip.some.incoming.commits.not.fetched=一些傳入提交未被獲取
branches.tracking.branch.doesn.t.configured.for.s=沒有為 {0} 組態追蹤分支
branches.update=更新
branches.update.failed=更新失敗
branches.update.info.process=更新分支資訊…
branches.update.is.already.running=更新已在執行
branches.updating.process=正在更新分支…
button.changes.excluded.from.commit.commit.anyway=仍然提交
button.crlf.fix.dialog.commit.as.is=按原樣提交
button.crlf.fix.dialog.fix.and.commit=修復並提交
button.don.t.rollback=不回滾
button.rollback=回滾
button.set.name.and.commit.template=設定並{0}
changes.retrieving=檢索修訂 {0} 的更改
changes.view.merge.action.text=合併
changes.view.rollback.action.text=回滾
checkbox.dont.warn.again=不再警告(&W)
checkbox.run.git.hooks=執行 Git 掛鈎(&H)
checkbox.set.config.property.globally=全域設定屬性(&G)
checkout.0=簽出 {0}
checkout.and.rebase=重定基底到遠端
checkout.new.branch.operation.branch.was.created=已建立分支 {0}
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1#根|2#根}{3}上簽出 {0} 並刪除 {1}
checkout.new.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
checkout.new.branch.operation.error.during.rollback=回滾期間出錯
checkout.new.branch.operation.errors.during.checkout=簽出期間出錯:
checkout.new.branch.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不過，{0,choice,1#版本庫|2#版本庫}的簽出已成功:
checkout.new.branch.operation.rollback.successful=回滾成功
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回上一個分支並刪除 {0})以使分支不出現分叉。
checkout.operation.checked.out=已簽出 {0}
checkout.operation.checked.out.new.branch.from=已從 {1} 中簽出新分支 {0}
checkout.operation.could.not.checkout.error=無法簽出 {0}
checkout.operation.could.not.checkout.error.title=無法簽出 {0}
checkout.operation.error.during.rollback=回滾期間出錯
checkout.operation.errors.during.checkout=簽出期間出錯:
checkout.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.operation.force.checkout=強制簽出(&F)
checkout.operation.however.checkout.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的簽出已成功:
checkout.operation.in={1,choice,0#|1#{2}中的}{0}
checkout.operation.name=簽出
checkout.operation.previous.branch=上一個分支
checkout.operation.revision.not.found=在{0,choice,0#|1#{1}中}未找到修訂
checkout.operation.rollback.action=回滾
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回 {0})以使分支不出現分叉。
cherry.pick.applied=套用
cherry.pick.name=優選
clone.dialog.checking.git.version=正在檢查 Git 版本…
clone.dialog.shallow.clone=淺層化克隆，歷史記錄被截斷為
clone.dialog.shallow.clone.depth=提交
column.name.commit.signature=GPG 簽名
combobox.item.file.invalid=(無效)
commit.action.commit.and.rebase.text=提交並重定基底…
commit.action.name=提交 (&I)
commit.author=作者(&U):
commit.author.diffs=<html>作者與預設不同</html>
commit.author.with.committer={0}，通過 {1}
commit.check.warning.title.commit.during.rebase=正在版本庫中進行重定基底: {0}。在重定基底期間提交可能會導致提交丟失。
commit.check.warning.title.commit.during.rebase.details=有關 Git 重定基底的更多資訊
commit.check.warning.title.commit.with.detached.head=版本庫處於游離的 HEAD 狀態: {0}
commit.check.warning.title.commit.with.detached.head.details=有關游離的 HEAD 的更多資訊
commit.check.warning.title.large.file=您即將向版本庫提交一個大檔案: {0} 個{0,choice,1#檔案|2#檔案}，總大小為 {1}MB。\n不建議在 Git 版本庫中存儲大檔案。請考慮使用 Git LFS。
commit.check.warning.user.name.email.not.set=未設定 Git user.name 和 user.email
commit.options.create.extra.commit.with.file.movements=使用檔案移動建立額外提交
commit.options.sign.off.commit.checkbox=Sign-off 提交(&G)
commit.options.sign.off.commit.message.line=在提交訊息結尾添加以下行:<br/>Signed-off by: {0}
commit.signature.bad=錯誤的 GPG 簽名
commit.signature.fingerprint=簽名指紋:
commit.signature.none=無 GPG 簽名
commit.signature.signed.by=通過密鑰簽名:
commit.signature.unverified=未驗證的 GPG 簽名
commit.signature.unverified.reason.cannot.verify=無法驗證(例如，缺少密鑰)
commit.signature.unverified.reason.expired=過期的簽名
commit.signature.unverified.reason.expired.key=使用過期的密鑰建立
commit.signature.unverified.reason.revoked.key=使用撤消的密鑰建立
commit.signature.unverified.reason.unknown=未知有效性
commit.signature.unverified.with.reason=未驗證的 GPG 簽名: {0}
commit.signature.verified=已驗證的 GPG 簽名
common.current.branch=當前分支:
common.current.branch.tooltip=當前已簽出的分支。
common.git.root=Git 根(&R):
common.git.root.tooltip=選擇 Git VCS 根
common.local.branches=公共本地分支
common.no.active.branch=<無活動分支>
common.refreshing=正在重新整理檔案
common.remote.branches=公共遠端分支
common.suffix.in.one.repository=在 {0} 中
common.suffix.in.several.repositories=在 {0} 個版本庫中
common.tags=常用標籤
computing.annotation=正在計算 {0} 的註解
conflict.resolver.unmerged.files.check.error.notification.description.text=由於錯誤，無法檢查工作樹中是否有未合併的檔案。{0}
conflicts.accept.progress=正在解析 {0,choice,1#個衝突|2#個衝突}
conflicts.accept.theirs.action.text=接受他們的更改
conflicts.accept.yours.action.text=接受您的更改
conflicts.loading.status=正在載入合併衝突…
conflicts.merge.window.error.message=找不到 {0} 的檔案
conflicts.merge.window.error.title=無法解決衝突
conflicts.resolve.action.text=解決
conflicts.type.added.by.them=由他們新增
conflicts.type.added.by.you=由您新增
conflicts.type.both.added=均已新增
conflicts.type.both.deleted=均已刪除
conflicts.type.both.modified=均已修改
conflicts.type.deleted.by.them=由他們刪除
conflicts.type.deleted.by.you=由您刪除
convert.language.extra.commit.commit.message=將 .{0} 重命名為 .{1}
convert.language.extra.commit.description=.{0} > .{1} 重新命名的額外提交
create.branch.operation.branch.created=已建立分支 {0}
create.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
create.branch.operation.deleted.branch=已刪除 {0}
create.branch.operation.error.during.rollback=回滾期間出錯
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不過，已在以下{0,choice,1#版本庫|2#版本庫}中建立分支:
create.branch.operation.name=建立分支
create.branch.operation.rollback.successful=回滾成功
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(刪除 {0})以使分支不出現分叉。
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未刪除
delete.branch.operation.collecting.unmerged.commits.process=正在收集未合併的提交…
delete.branch.operation.could.not.restore.branch.error=無法還原 {0}
delete.branch.operation.deleted.branch=已刪除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已刪除的分支:</b> {0}
delete.branch.operation.error.during.rollback.of.branch.deletion=分支刪除回滾期間出錯
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的分支刪除已成功:
delete.branch.operation.name=分支刪除
delete.branch.operation.restoring.branch.process=正在還原分支 {0}…
delete.branch.operation.unmerged.commits.were.discarded=未合併的提交已被捨棄
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(在這些根中重新建立 {0})以使分支不出現分叉。
delete.remote.branch.operation.also.deleted.local.branches=同時刪除了本地 {0,choice,1#分支|2#分支}: {1}
delete.remote.branch.operation.couldn.t.find.remote.by.name=無法按名稱尋找遠端: {0}
delete.remote.branch.operation.deleted.remote.branch=已刪除遠端分支 {0}
delete.remote.branch.operation.deleting.process=正在刪除 {0}
delete.remote.branch.operation.failed.to.delete.remote.branch=無法刪除遠端分支 {0}
delete.remote.tag.operation.deleted.tag.on.remotes=<b>已刪除{0,choice,1#遠端|2#遠端}上的標記:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=無法刪除 {1,choice,1#遠端|2#遠端} 上的標記 {0}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>標記在{0,choice,1#遠端|2#遠端}上不存在:</b> {1}
delete.tag.operation.could.not.find.tag=找不到標記 {0}
delete.tag.operation.could.not.find.tag.in=在 {0} 中找不到標記
delete.tag.operation.could.not.restore.tag=無法還原 {0}
delete.tag.operation.delete.on.remote=在{0,choice,1#遠端|2#遠端}上刪除
delete.tag.operation.deleted.tag=<b>已刪除的標記:</b> {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=標記刪除回滾期間出錯
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的標籤刪除已成功:
delete.tag.operation.restored.tag=已還原標記 {0}
delete.tag.operation.restoring.tag.process=正在還原標記 {0}…
delete.tag.operation.rollback.successful=回滾成功
delete.tag.operation.tag.was.not.deleted=未刪除標記 {0}
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以回滾(在這些根中重新建立 {0})以使標記不出現分叉。
dialog.message.rebasing.merge.commits=您即將重定基底存在衝突的合併提交。\n\n如果您不想再次解決衝突，請選擇“合併”; 如果要將歷史記錄線性化，仍可進行重定基底。
dialog.message.untracked.files.will.be.overwritten.by.operation=這些未追蹤的檔案將被{0}覆蓋
dialog.message.update.branch=您即將從 {1} 更新 {0}。\n\n如果要建立合併提交，請選擇“合併”；如果要重定基底到 {1}，請選擇“重定基底”。
dialog.title.could.not.operation=無法{0}
dialog.title.local.changes.prevent.from.operation=本地更改阻止{0}
dialog.title.rebasing.merge.commits=正在重定基底合併提交
dialog.title.untracked.files.preventing.operation=阻止{0}的未追蹤檔案
dialog.title.update.branch=更新 {0}
diff.find.error=正在尋找差異的修訂: {0}
editor.promo.close.link=不再顯示
editor.promo.commit.text=使用提交接口直接從 {0} 提交。
editor.promo.commit.try.link=嘗試
editor.promo.help.link=了解詳情
error.cannot.delete.file=無法刪除檔案: {0}
error.cant.set.user.name.email=無法設定 user.name 和 user.email
error.commit.cant.collect.partial.changes=無法收集要提交的部分更改
error.commit.cant.commit.multiple.changelists=無法一次提交多個更改列表中的更改
error.commit.cant.commit.with.unmerged.paths=由於您有未合併的檔案，因此無法提交。
error.commit.cant.create.message.file=建立提交訊息檔案失敗
error.dialog.title=錯誤
error.git.parse.not.a.revision.number=字串 ''{0}'' 不表示修訂號
error.git.parse.unknown.file.status=未知檔案狀態: {0}
error.git.repository.not.found=該版本庫不再存在: {0}
error.git.version.check.failed=執行 ''git --version'' 時出錯。離開程式碼: {0}，錯誤: {1}
error.list.title={0} 錯誤:
error.no.changed.files.no.commit.message=修改要提交的檔案並指定提交訊息
error.no.changed.files.to.commit=修改要提交的檔案
error.no.selected.roots.to.commit=選擇要提交的根
error.no.staged.changes.no.commit.message=暫存要提交的檔案並指定提交訊息
error.no.staged.changes.to.commit=暫存要提交的檔案
error.occurred.during=''{0}'' 時出錯
error.unresolved.conflicts=解決衝突以提交
errors.message=Git 動作以多個錯誤結束: {0}
errors.message.item=\n{0}
exception.message.could.not.stash.root.error=無法隱藏 {0}: {1}
executable.error.git.not.installed=未安裝 Git
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路徑無效
executable.mac.fix.path.action=修正路徑
exportable.Git.Application.Settings.presentable.name=Git
fetch.action.name=獲取
fetch.pruned.obsolete.remote.references=刪除過時的遠端 {0,choice,1#參照|2#參照}: {1}
fetching=正在獲取…
find.git.error.title=執行 Git 時出錯
find.git.success.title=Git 執行成功
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支援，某些延伸模組功能可能無法工作。<br>支援的最低版本是 <em>{1}</em>。</html>
git.add.to.exclude.file.action.description=將條目新增到 .git/info/exclude
git.add.to.exclude.file.action.text=.git/info/exclude
git.branches.popup.loading.tags=正在載入 Git 標籤…
git.branches.popup.search.field.actions.empty.text={0,choice,1#和|2#、}動作
git.branches.popup.search.field.empty.text=搜尋分支{0}{1}
git.branches.popup.search.field.repositories.empty.text={0,choice,1#和|2#、}版本庫
git.branches.popup.tree.accessible.name=分支樹
git.branches.popup.tree.no.branches=找不到分支 ''{0}''
git.branches.popup.tree.no.nodes=找不到 ''{0}''
git.commit.message.empty.title=提交訊息為空
git.commit.nothing.to.commit.error.message=沒有要提交的內容
git.compare.branches.empty.status={0} 包含來自 {1} 的所有提交
git.compare.branches.explanation.message=存在於 {0} 中但不存在於 {1} 中的提交
git.compare.branches.tab.name=比較
git.compare.branches.tab.suffix={0} 和 {1}
git.compare.with.branch.search.field.empty.text=搜尋分支{0,choice,0#|1#和標籤}
git.compare.with.branch.search.not.found=找不到 ''{0}''
git.compare.with.tag.file.not.found.in.tag=標記 ''{2}'' 中不存在{0,choice,1#檔案|2#目錄} {1}
git.compare.with.tag.loading.error.title=無法載入標記
git.compare.with.tag.modal.progress.loading.tags=正在載入標記…
git.compare.with.tag.popup.title=選擇要比較的標記
git.content.transform.filters=篩選器
git.content.transform.none=無
git.content.transform.textconv=TextConv
git.error.cant.process.output=無法處理 Git 輸出: {0}
git.error.exit=Git 程序離開，程式碼為 {0}
git.executable.detect.progress.title=正在檢測 Git 可執行檔案
git.executable.error.bash.not.found=找不到 bash 可執行檔案
git.executable.error.file.not.found=沒有此類別檔案: {0}
git.executable.new.version.update.available=更新為 Git {0}
git.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.notification.description=Git 可執行檔案的路徑可能無效。
git.executable.notification.title=無法啟動 Git
git.executable.unknown.error.message=無法啟動 Git 程序: {0}
git.executable.validation.cant.identify.executable.message=無法識別 Git 可執行檔案 {0} 的版本
git.executable.validation.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.validation.error.no.response.in.n.attempts.message=無法識別 Git 可執行檔案的版本: {0,choice,0#|2# {0} 次嘗試後}無響應
git.executable.validation.error.start.title=無法執行 Git
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.version.title=Git 版本 {0} 不受支援
git.executable.validation.error.wsl.start.title=無法在 WSL 中執行 Git
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，請參閱 <a href='https://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a> 了解可能的解決方案。
git.executable.validation.error.xcode.message=執行“sudo xcodebuild -license”並重試(需要管理員權限)
git.executable.validation.error.xcode.title=接受 XCode/iOS 授權以執行 Git
git.executable.version.is=Git 版本為 {0}
git.executable.version.progress.title=正在識別 Git 版本
git.fetch.progress=正在獲取…
git.history.diff.handler.choose.parent.popup=選擇要比較的父項
git.history.diff.handler.git.show.error=執行 git show {0}:{1} 時出錯
git.history.diff.handler.load.changes.process=正在載入更改…
git.history.diff.handler.no.changes.in.file.info=此合併提交中的檔案 {0} 無更改
git.integration.could.not.git.init=無法 git init {0}
git.integration.created.git.repository.in=已在 {0} 中建立 Git 版本庫
git.light.cant.find.current.revision.exception.message=找不到 {0} 的當前修訂
git.light.status.bar.display.name=Git
git.light.status.bar.text=Git: {0}
git.light.status.bar.tooltip=當前 Git 分支: {0}
git.log.action.checkout.group=簽出
git.log.action.checkout.revision.full.text=簽出修訂 ''{0}''
git.log.action.checkout.revision.short.text=修訂 ''{0}''
git.log.branches.search.field.accessible.description=按 {0} 轉到 VCS 日誌表篩選器
git.log.branches.search.field.accessible.name=Git 分支搜尋
git.log.branches.tree.accessible.name=Git 分支
git.log.cherry.picked.highlighter.cancelled.message=已取消對 ''{0}'' 中未選取提交的醒目提示，因為分支篩選器已被更改。
git.log.cherry.picked.highlighter.error.message=無法與分支 {0} 進行比較
git.log.cherry.picked.highlighter.process=正在比較分支…
git.log.cherry.picked.highlighter.select.branch.popup=選擇源分支
git.log.diff.handler.changes.between.revisions.in.paths.title={2} 中 {0} 與 {1} 之間的更改
git.log.diff.handler.changes.between.revisions.title={0} 與 {1} 之間的更改
git.log.diff.handler.local.version.content.title=本地
git.log.diff.handler.local.version.name=本地版本
git.log.external.loading.process=正在載入 Git 日誌…
git.log.external.tab.description={0} 的日誌
git.log.external.window.title=Git 日誌
git.log.refGroup.local=本地
git.log.show.commit.in.log.process=正在搜尋修訂 {0}
git.new.tag.dialog.tag.name.label=輸入新標記的名稱
git.new.tag.dialog.title=在 {0}上建立新標記
git.open.exclude.file.action.description=在編輯器中開啟 .git/info/exclude
git.open.exclude.file.action.text=開啟 .git/info/exclude
git.recent.projects.show.branch.mode.always=所有專案
git.recent.projects.show.branch.mode.for.duplicate.names=同名專案
git.recent.projects.show.branch.mode.never=從不
git.rename.branch.could.not.rename.from.to=無法將 {0} 重命名為 {1}
git.rename.branch.could.not.unset.upstream=無法取消設定分支 {0} 的上游
git.rename.branch.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的重新命名已成功:
git.rename.branch.renamed.back.to=已重新命名回 {0}
git.rename.branch.rollback.failed=回滾失敗
git.rename.branch.rollback.successful=回滾成功
git.rename.branch.was.renamed.to=分支 {0} 已被重命名為 {1}
git.rename.branch.you.may.rename.branch.back=您可以回滾(將分支重新命名回 {0})以使分支不出現分叉。
git.reset.button=重設
git.reset.dialog.description=<nobr>這會將當前分支 HEAD 重設為所選提交，<nobr/><br><nobr>並根據所選模式更新工作樹和索引:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者 {1}
git.reset.dialog.description.source.in.repository={0} ({1} 內)
git.reset.dialog.title=Git 重設
git.reset.failed.notification.title=重設失敗
git.reset.hard.button=硬重設(&H)
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>檔案將還原為所選提交的狀態。<nobr/><br><nobr>警告: 任何本地更改都將丟失。<nobr/>
git.reset.mode.keep=保留
git.reset.mode.keep.description=<nobr>檔案將還原為所選提交的狀態，<nobr/><br><nobr>但本地更改將保持不變。<nobr/>
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=檔案不會更改，差異也不進行暫存。
git.reset.mode.soft=軟
git.reset.mode.soft.description=檔案不會更改，差異將暫存以進行提交。
git.reset.operation=重設
git.reset.partially.failed.notification.msg={0} 重設成功\n但 {1} 重設失敗:\n{2}
git.reset.partially.failed.notification.title=重設部分失敗
git.reset.process=Git 重設
git.reset.successful.notification.message=重設成功
git.rollback=回滾(&R)
git.running=執行: {0}
git.status.bar.widget.name=Git 分支
git.status.bar.widget.text.cherry.pick=正在 {0} 中優選
git.status.bar.widget.text.merge=正在合併 {0}
git.status.bar.widget.text.rebase=正在重定基底 {0}
git.status.bar.widget.text.revert=正在 {0} 中還原
git.status.bar.widget.text.unknown=<未知>
git.status.bar.widget.tooltip.detached=Git: 游離的 HEAD 不指向任何分支
git.status.bar.widget.tooltip.rebasing=Git: 正在進行重定基底
git.status.copied=已複製
git.status.index=在暫存區域中{0}
git.status.not.changed=未更改
git.status.renamed=已重新命名
git.status.type.changed=已更改類型
git.status.unmerged=已取消合併
git.status.unmerged.both=兩者{0}
git.status.unmerged.index=我們{0}
git.status.unmerged.work.tree=由他人{0}
git.status.untracked=已取消追蹤
git.status.work.tree=在工作目錄中{0}
git.tag.could.not.create.tag=無法建立標記
git.tag.created.tag.successfully=已成功建立標記 {0}。
git.toolbar.widget.no.loaded.repo=Git
git.toolbar.widget.no.repo=版本控制
git.toolbar.widget.no.repo.tooltip=為專案組態版本控制
git.undo.action.cant.undo.commit.failure=無法撤消提交
git.undo.action.could.not.load.changes.of.commit=無法載入 {0} 的更改
git.undo.action.description=所選提交不是當前分支中的最後一次提交
git.undo.action.failed.notification.title=撤消提交失敗
git.undo.action.operation=撤消提交
git.undo.action.refreshing.changes.process=正在重新整理更改…
git.undo.action.select.target.changelist.title=選擇目標更改列表
git.undo.action.successful.notification.message=撤消提交成功
git.undo.action.undoing.last.commit.process=正在撤消最後一次提交…
git.update.commits.matching.filters={0,choice,1#{0} 個提交|2#{0} 個提交}與篩選器匹配
git.update.files.updated.in.commits=已更新 {1,choice,1#{1} 個提交|2#{1} 個提交}中的 {0,choice,1#{0} 個檔案|2#{0} 個檔案}
git.update.no.commits.matching.filters=沒有與篩選器符合的提交
git.update.operation=更新
git.update.project.partially.updated.title=專案已部分更新
git.update.repo.was.skipped=已跳過 {0} ({1})
git.update.skipped.repositories=已跳過 {0} 個版本庫:
git4idea.vcs.name=Git
git4idea.vcs.name.with.mnemonic=&Git
gpg.error.see.documentation.link.text=參閱 GPG 設定指南
gpg.error.text=提交簽名失敗
gpg.jb.manual.link=Set_up_GPG_commit_signing
gpg.pinentry.agent.configuration.configuration.backup.exception=無法建立組態備份
gpg.pinentry.agent.configuration.confirmation.text=GPG 代理將被組態為使用 {0} 內建 pinentry 程序。<br/><br/>如果 {0} 未處於有效狀態，將使用當前組態的 pinentry 程序: <tt>{1}</tt>
gpg.pinentry.agent.configuration.confirmation.title=更新 GPG 代理組態
gpg.pinentry.agent.configuration.confirmation.yes=更新
gpg.pinentry.agent.configuration.detect.default.pinentry.exception=無法檢測 pinentry 程序
gpg.pinentry.agent.configuration.exception=無法更新 GPG 組態: {0}
gpg.pinentry.agent.configuration.launcher.generation.exception=無法生成 pinentry 啟動器
gpg.pinentry.agent.configuration.read.exception=無法讀取 GPG 組態
gpg.pinentry.agent.configuration.save.exception=無法儲存更新的 GPG 組態
gpg.pinentry.configuration.error.title=GPG 代理組態失敗
gpg.pinentry.configuration.global.suggestion.do.not.ask.again.display.name=GPG 代理組態(建議)
gpg.pinentry.configuration.proposal.configure=組態…
gpg.pinentry.configuration.proposal.message=要{0,choice,0#在遠端主機上|1#在 WSL 中|2#}支援 GPG 提交簽名，請將 GPG 代理組態為使用 {1} 內建 pinentry 程序
gpg.pinentry.configuration.proposal.title=GPG 代理組態
gpg.pinentry.configuration.suggestion.do.not.ask.again.display.name=GPG 代理組態(無效提交後的建議)
gpg.pinentry.configured.successfully.backup.message=已在 <code>{0}</code> 中建立現有組態的備份
gpg.pinentry.configured.successfully.message=GPG 代理組態已在 <code>{0}</code> 中更新
gpg.pinentry.configured.successfully.title=GPG 代理組態成功
gpg.pinentry.default.description=請輸入密碼短語以解鎖 GPG 私鑰:
gpg.pinentry.jb.manual.link=Set_up_GPG_pinentry_for_commit_signing
gpg.pinentry.title=解鎖 GPG 私鑰
group.Git.Branch.Tracked.name=追蹤分支動作
group.Git.Branch.Tracked.name.withBranch=追蹤分支 ''{0}''
group.Git.CheckoutGroup.description=簽出所選修訂或所選提交中的分支
group.Git.CheckoutGroup.text=簽出
group.Git.ContextMenu.text=&Git
group.Git.HEAD.Branch.Filter.title=HEAD(當前分支)
group.Git.Local.Branch.title=本地
group.Git.Log.Branches.Grouping.Settings.text=分組依據
group.Git.Log.Branches.Settings.Separator.text=點擊時
group.Git.Log.Branches.Settings.text=分支窗格設定
group.Git.Log.ShareLogIndexData.text=共享 Git 日誌索引資料
group.Git.MainMenu.LocalChanges.text=未提交的更改(_U)
group.Git.MainMenu.MergeActions.text=合併(_M)
group.Git.MainMenu.RebaseActions.text=重定基底(_R)
group.Git.Menu.text=&Git
group.Git.Recent.Branch.in.repo.title={0} 中最近的分支
group.Git.Recent.Branch.title=最近
group.Git.Remote.Branch.title=遠端
group.Git.Stage.Configure.text=組態本地更改
group.Git.Stage.Index.File.Menu.text=Git
group.Git.Stage.Ui.Settings.text=檢視選項
group.Git.Tags.loading.text=正在載入…
group.Git.Tags.title=標籤
group.MainToolbarVCSGroup.text=VCS 組
group.Vcs.ToolbarWidget.ShareProject.text=在以下平台上共享專案:
history.filters.unsupported.error.message=不支持按“{0}”篩選歷史記錄
history.for.revision.filters.unsupported.error.message=不支持按“{0}”篩選修訂歷史記錄
in.branches.all.repositories=在所有版本庫中
in.memory.rebase.data.contains.empty.reword.message.for.entry=記憶體中重定基底資料包含條目的空改寫訊息: {0}
in.memory.rebase.data.contains.entry.with.unsupported.action=記憶體中重定基底資料包含具有不受支援動作的條目: {0}
in.memory.rebase.data.contains.missing.reword.message.for.entry=記憶體中重定基底資料包含條目缺失的改寫訊息: {0}
in.memory.rebase.fail.head.move=在提交編輯動作期間 HEAD 發生移動
in.memory.rebase.failed.rebase.data=無法生成有效的記憶體中重定基底資料
in.memory.rebase.interactive.failed.message=正在回退到一般重定基底
in.memory.rebase.interactive.failed.title=記憶體中重定基底失敗
in.memory.rebase.log.change.extract.action.progress.indicator.title=正在獲取更改…
in.memory.rebase.log.changes.action.operation.extract.name=獲取所選更改
in.memory.rebase.log.changes.extract.action.description.all.changes.selected=無法從提交中獲取所有更改
in.memory.rebase.log.changes.extract.action.failure.title=無法獲取所選更改
in.memory.rebase.log.changes.extract.action.notification.successful.title=已獲取的更改
in.memory.rebase.log.changes.extract.action.notification.undo.failed.title=撤消獲取更改失敗
in.memory.rebase.log.changes.extract.action.notification.undo.not.allowed.title=無法撤消獲取更改
in.memory.rebase.log.changes.extract.action.progress.indicator.undo.title=正在撤消獲取更改…
in.memory.rebase.log.changes.extract.dialog.description.label=由 {1} 從提交 {0} 中獲取的更改
in.memory.rebase.log.changes.extract.dialog.title=新的提交訊息
in.memory.rebase.log.changes.extract.failed.title=無法獲取所選更改
in.memory.rebase.log.interactive.action.notification.successful=重定基底成功
in.memory.rebase.log.interactive.action.notification.undo.failed.title=撤消互動重定基底失敗
in.memory.rebase.log.interactive.action.notification.undo.not.allowed.title=無法撤消互動重定基底
in.memory.rebase.log.interactive.action.progress.indicator.undo.title=正在撤消互動重定基底…
in.memory.rebase.log.interactive.failed.title=互動重定基底失敗
in.memory.rebase.log.reword.failed.title=改寫失敗
in.memory.rebase.log.squash.failed.title=壓縮失敗
in.memory.split.tree.mixed.error=無法獲取所選更改
in.memory.split.tree.submodules.error=不支持通過 git 子模組條目拆分樹
init.destination.directory.description=選擇將在其中建立新 Git 版本庫的目錄。
init.destination.directory.title=建立 Git 版本庫
init.warning.already.under.git=所選目錄 <tt>{0}</tt> 已在 Git 下。\n確定要建立新的 VCS 根嗎?
init.warning.title=Git Init
initializing.title=正在初始化版本庫…
install.download.and.install.action=下載並安裝
install.downloading.progress=正在下載…
install.general.error=無法安裝 Git
install.installing.progress=正在安裝…
install.mac.error.couldnt.start.command.line.tools=無法啟動 Command Line Tools 安裝
install.mac.requesting.command.line.tools=正在請求 XCode Command Line Developer Tools
install.success.message=已安裝 Git
label.changes.excluded.from.commit.are.you.sure.want.to.continue=確定要從合併提交中排除這些更改過的檔案嗎?
label.credential.store.key.http.password=Git HTTP
label.diff.content.title.submodule.suffix={0} (子模組)
label.name.email.not.defined.in.n.roots={0,choice,1#根|2#根}中未定義 Git 的 user.name 和 user.email 屬性
label.user.email=電子郵件(&E):
label.user.name=名稱(&N):
link.label.commit.with.detached.head.read.more=閱讀有關游離的 HEAD 的更多資訊
link.label.commit.with.unfinished.rebase.read.more=閱讀有關 Git 重定基底的更多資訊
link.label.editor.notification.merge.conflicts.resolve.in.progress=正在解決合併衝突
link.label.editor.notification.merge.conflicts.suggest.resolve=檔案存在未解決的合併衝突
link.label.merge.conflicts.resolve.in.progress.cancel.resolve=取消解決
link.label.merge.conflicts.resolve.in.progress.focus.window=顯示解析衝突視窗
link.label.merge.conflicts.suggest.resolve.show.window=解決衝突…
local.changes.freeze.message.git.operation.prefix=Git {0}
local.changes.save.policy.shelve=擱置
local.changes.save.policy.stash=隱藏
local.changes.would.be.overwritten.by.merge.view.them.action=檢視這些變更
log.command.empty.text=[<options>] [<revision-range>] [[--] <path>...]
log.parser.exception.message.could.not.parse.output=無法解析 Git 日誌輸出“{0}”
log.parser.exception.message.error.command.line={0}\n命令行: [{1}]
log.parser.exception.message.error.parsing.line=解析第“{0}”行時出錯
login.dialog.button.login=登入
login.dialog.error.password.cant.be.empty=密碼不能為空
login.dialog.error.username.cant.be.empty=用戶名不能為空
login.dialog.label.login.to.url=登入 {0}
login.dialog.login.with.selected.provider=使用 {0} 登入…
login.dialog.password.label=密碼:
login.dialog.prompt.enter.credentials=輸入憑證:
login.dialog.select.login.way.credentials=輸入憑證
login.dialog.select.login.way.use.helper=使用憑證幫助程序
login.dialog.username.label=用戶名:
mention.in=\ ({0} 中)
merge.action.after.update.label=更新後
merge.action.before.update.label=更新前
merge.action.name=合併
merge.action.operation.failed=Git {0} 失敗
merge.branch.already.merged=分支 ''{0}'' 已被合併
merge.branch.field.placeholder=指定分支
merge.branch.into.current.title=合併到 {0}
merge.branch.loading.branches.progress=正在載入未合併的分支…
merge.branch.popup.empty.text=無分支
merge.branch.title=合併更改
merge.commit.message.label=提交訊息:
merge.dialog.customizer.collecting.details.progress=正在收集提交詳細資訊…
merge.dialog.customizer.filter.by.conflicted.file.checkbox=按衝突檔案篩選
merge.dialog.customizer.show.details.link.label=顯示詳細資訊
merge.dialog.description.cherry.pick.label.text=在優選{2,choice,0#|1#由 {3}{4} 執行的}{0,choice,1#提交 {1}|2#多個提交}期間出現衝突
merge.dialog.description.merge.label.text=將{0,choice,1#分支 {1} |2#分叉的分支}合併到{2,choice,1#分支 {3}|2#分叉的分支}
merge.dialog.description.rebase.conflict.current.commit=當前提交 {0} 由 {1} 完成:
merge.dialog.description.rebase.with.hash.label.text=正在{0,choice,0#|1#將分支 {1} }變基到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=正在{0,choice,0#|1#將分支 {1} }重定基底到分支 {2}{3,choice,0#|1#，修訂 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=正在{0,choice,0#|1#將分支 {1} }重定基底到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地更改
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=正在從 {1} 重定基底 {0}
merge.dialog.diff.right.title.cherry.pick.label.text=來自優選 {0} 的更改
merge.dialog.diff.right.title.default.with.hash.label.text=來自 {0} 的更改
merge.dialog.diff.right.title.default.with.onto.branch.label.text=來自分支 {0}{1,choice,0#|1#，修訂 {2}} 的更改
merge.dialog.diff.right.title.default.without.onto.info.label.text=來自分叉分支的更改
merge.dialog.diff.right.title.rebase.with.branch.label.text=已重定基底的提交和來自 {0} 的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已重定基底的提交
merge.dialog.diff.title.changes.from.branch.label.text=來自 {0} 的更改
merge.error.unable.to.read.merge.head=無法讀取檔案 {0}: {1}
merge.no.branch.selected.error=應選擇該合併分支。
merge.no.matching.branch.error=沒有符合分支。
merge.operation.already.up.to.date=已處於最新狀態
merge.operation.branch.merged.with.conflicts={0} 已合併，但存在衝突
merge.operation.could.not.merge.branch=無法合併 {0}
merge.operation.delete.branch.action=刪除 {0}
merge.operation.error.during.rollback=回滾期間出錯
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的合併已成功:
merge.operation.merged.to=已將 {0} 合併到 {1}
merge.operation.name=合併
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(重設為合併之前的提交)以使分支不出現分叉。
merge.option.allow.unrelated.histories=允許合併不具有共同上級的歷史記錄
merge.option.ff.only=僅在可以快進時合併
merge.option.msg=指定合併提交的訊息
merge.option.no.commit=不提交合併結果
merge.option.no.ff=即使可以快進也建立合併提交
merge.option.no.verify=繞過預合併和提交訊息掛鈎
merge.option.squash=為所有合併更改建立一個提交
merge.options.modify=修改選項
merge.options.modify.popup.title=新增合併選項
merge.progress.indicator.loading.unmerged.files.title=正在載入未合併的檔案…
merge.tool.column.status.deleted=已刪除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的更改
merge.tool.column.theirs.with.branch.status=他人的更改({0})
merge.tool.column.yours.status=您的更改
merge.tool.column.yours.with.branch.status=您的更改({0})
merge.unresolved.conflicts.remaining.notification.body=有掛起的未解決的衝突。
merge.unresolved.conflicts.remaining.notification.title=正在掛起未解決的衝突
merge.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續更新。
merge.update.project.generic.error.title=無法完成更新
merging.title=將更改合併到 {0}
message.unresolved.conflicts.prevent.commit=由於有未解決的衝突，無法提交更改。
modal.commit.deprecation.notification.description=模態提交模式已移至一個將在 {0} {1} 中解綁的延伸模組
new.branch.dialog.branch.name=分支名稱:
new.branch.dialog.branch.root.all.name=所有
new.branch.dialog.branch.root.all.override.warning=根將位於不同的分支上。某些分支動作不會同時在所有根上執行。
new.branch.dialog.branch.root.name=根:
new.branch.dialog.checkout.branch.checkbox=簽出分支(&C)
new.branch.dialog.error.branch.already.exists=分支名稱 {0} 已存在
new.branch.dialog.error.branch.clashes.with.directory=分支名稱 {0} 與同名的本地分支目錄衝突
new.branch.dialog.error.branch.clashes.with.remote=分支名稱 {0} 與同名的遠端分支衝突
new.branch.dialog.error.branch.name.empty=指定新分支的名稱
new.branch.dialog.error.branch.name.head=HEAD 是保留關鍵字
new.branch.dialog.error.branch.name.invalid=分支名稱 {0} 無效
new.branch.dialog.operation.checkout.description=簽出現有分支，並在其他版本庫中建立新分支
new.branch.dialog.operation.checkout.name=簽出
new.branch.dialog.operation.create.description=在其他版本庫中建立新分支
new.branch.dialog.operation.create.name=建立
new.branch.dialog.operation.rename.name=重新命名
new.branch.dialog.overwrite.existing.branch.checkbox=覆蓋現有分支(&R)
new.branch.dialog.overwrite.existing.branch.warning=更改名稱或覆蓋現有分支
new.branch.dialog.set.tracking.branch.checkbox=設定追蹤分支(&T)
new.branch.dialog.unset.upstream.branch.checkbox=取消設定上游分支(&T)
no.revisions.available=無修訂
notification.content.branch.in.repo.has.no.tracked.branch={0} {1} 沒有追蹤的分支
notification.content.couldn.t.authorize=授權錯誤
notification.content.couldnt.collect.updated.files.info={0} 更新成功，但由於發生了一個錯誤，我們無法收集更新的更改
notification.content.detached.state.in.root.checkout.branch=您處於“游離的 HEAD”狀態，這表明您不在任何分支 {0} 上<br/>簽出分支以更新專案。
notification.content.fetch.failed.couldn.t.authorize=獲取失敗: 授權錯誤
notification.content.fetched.successfully=已成功獲取
notification.content.untracked.files.prevent.operation.move.or.commit=在 {0} 前移動或提交<br/>{1}
notification.content.updating.root.failed.with.error=更新 {0} 失敗，出現錯誤: {1}
notification.ignore.file.generation.error.text.files.progress.title=無法生成 .gitignore 檔案
notification.title.can.t.update.no.current.branch=無法更新: 無當前分支
notification.title.couldn.t.reset.merge=無法中止合併動作
notification.title.couldnt.collect.updated.files.info=無法收集已更新檔案的資訊
notification.title.error.merging=合併錯誤
notification.title.error.updating.root=更新 {0} 期間出錯
notification.title.fetch.details=獲取詳細資訊
notification.title.fetch.failed=獲取失敗
notification.title.fetch.failure=獲取失敗
notification.title.fetch.success=獲取成功
notification.title.git.operation.failed=Git {0} 失敗
notification.title.unstash.failed=取消隱藏失敗
notification.title.unstash.failed.index.conflict=由於索引衝突，取消隱藏失敗
notification.title.untracked.files.prevent.operation=未追蹤的檔案會阻止{0}
notification.title.update.failed=更新失敗
open.in.browser.error=無法在瀏覽器中開啟
open.in.browser.getting.revision=正在獲取最新的檔案修訂
open.in.browser.getting.revision.error=無法檢索檔案的最新修訂
operation.action.message=多個 Git 根有未完成的 {0} 程序，請選擇要對其執行動作的根。
operation.name.loading.revision=載入修訂
operation.name.validating.revision.0=驗證修訂 {0}
output.parse.exception.unexpected.end.message=文本在 ''{0}'' 意外結束
paths.affected.title=提交 {0} 中受影響的路徑
post.commit.check.load.changes.error=無法為 {1} 載入根 {0} 中的更改
preserving.process.local.changes.not.restored.error.title=未還原本地更改
progress.checking.line.separator.issues=正在檢查行分隔符問題…
progress.details.refreshing.files.for.root=正在重新整理根 {0} 的檔案
progress.finishing.conflict.resolve=正在解決衝突
progress.setting.config.value=正在更新 Git 組態…
progress.setting.user.name.email=正在設定 Git 用戶名…
progress.text.merging.repository=正在合併 {0}…
progress.title.calculating.commit.messages=正在計算提交訊息
progress.title.creating.git.repository=正在建立 Git 版本庫…
progress.title.enabling.git=正在啟用 Git…
progress.title.moving.files=正在移動檔案…
progress.title.reverting.n.commits=正在還原{0,choice,1#提交|2#提交}
progress.title.update=更新
progress.title.validating.revision=正在驗證修訂…
progress.update.destination.remote=遠端
pull.action.name=拉取
pull.branch.field.placeholder=指定分支
pull.branch.no.matching.remotes=無遠端
pull.branch.not.selected.error=應選擇要從中拉取的分支。
pull.branch.nothing.to.pull=無分支
pull.button=拉取
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支
pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到 {0}
pull.fetch.failed.notification.text=選擇一個本地版本庫和一個遠端版本庫
pull.fetch.failed.notification.title=無法載入遠端分支
pull.option.ff.only=僅在可以快進時合併
pull.option.no.commit=合併，但不提交結果
pull.option.no.ff=即使可以快進也建立合併提交
pull.option.rebase=在傳入更改上重定基底當前分支
pull.option.squash.commit=為所有拉取更改建立一個提交
pull.options.modify.popup.title=新增拉取選項
pull.remote.not.selected=選擇要從中拉取的遠端版本庫
pull.repository.not.selected.error=選擇一個版本庫
pulling.title=從 {0} 中拉取更改
push.dialog.preview.commits.before.push=對於向不受保護分支的提交和推送，應在推送之前預覽提交
push.dialog.prohibited.branch.configurable.path={0} | 版本控制 | Git
push.dialog.push.tags=推送標記(&T)
push.dialog.push.tags.combo.all=所有
push.dialog.push.tags.combo.current.branch=當前分支
push.dialog.target.panel.add.remote=新增遠端
push.dialog.target.panel.adding.remote=正在新增遠端…
push.dialog.target.panel.can.t.push=無法推送
push.dialog.target.panel.couldnt.add.remote=無法新增遠端: {0}
push.dialog.target.panel.define.remote=定義遠端
push.dialog.target.panel.empty.repository=空版本庫
push.dialog.target.panel.new=新增
push.dialog.target.panel.new.and.upstream=新增和上游
push.dialog.target.panel.upstream.checkbox=設定上游
push.dialog.target.panel.upstream.label=上游
push.failed.error.message=推送失敗: {0}
push.local.history.system.label.after=推送後
push.local.history.system.label.before=推送前
push.notification.description.force.pushed=強制推送 {0} 到 {1}
push.notification.description.new.branch=已推送 {0} 到新分支 {1}
push.notification.description.new.branch.with.many.tags=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch.with.single.tag=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.push.with.lease.rejected=使用 Force-with-lease 推送 {0} 到 {1} 被拒
push.notification.description.pushed=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}
push.notification.description.pushed.many.tags=已推送 {0} 標籤到 {1}
push.notification.description.pushed.single.tag=已推送標籤 {0} 到 {1}
push.notification.description.pushed.with.many.tags=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將 {2} 標籤推送到 {3}
push.notification.description.pushed.with.single.tag=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將標籤 {2} 推送到 {3}
push.notification.description.rejected=推送到 {0} 被拒
push.notification.description.rejected.and.cancelled=推送被拒，更新被取消
push.notification.description.rejected.and.conflicts=由於更新期間發生衝突，推送被取消。<br/>檢查是否已正確解決衝突，然後再次呼叫推送。
push.notification.description.rejected.and.failed=因發生錯誤，推送被拒，更新失敗
push.notification.description.rejected.and.incomplete=由於更新過程中並未解決所有衝突，推送被取消。<br/>請解決衝突並再次呼叫推送
push.notification.description.rejected.by.remote=推送 {0} 到 {1} 被遠端拒絕
push.notification.description.rejected.by.remote.without.target={0} 的推送被遠端拒絕
push.notification.description.up.to.date=所有內容都已處於最新狀態
push.notification.force.push.anyway.action=仍然強制推送
push.notification.force.push.progress.title.pushing=正在推送…
push.notification.force.with.lease.help=何為 Force-with-Lease?
push.notification.force.with.lease.help.description.first=Force-with-lease 推送阻止覆寫尚未獲取到本地版本庫的遠端更改
push.notification.force.with.lease.help.description.second=獲取最新更改，以確認能否安全捨棄更改並重複執行推送動作
push.notification.partially.failed.title=推送部分失敗
push.notification.partially.rejected.title=推送部分被拒
push.notification.push.failed.title=推送失敗
push.notification.rejected.title=推送被拒
push.notification.single.repo.success.description=推送動作期間收到 {0} 個{0, choice,1#提交|2#提交}
push.notification.successful.title=推送成功
push.notification.update.action=更新
push.notification.view.files.action=檢視在推送期間更新的檔案
push.notification.view.filtered.commits.actions=檢視與篩選器符合的 {0} 個{0,choice,1#提交|2#提交}
push.notification.view.received.commits.action=檢視收到的{0,choice,1#提交|2#提交}
push.rejected.dialog.title=推送被拒
push.rejected.many.repos=當前分支的推送被拒:
push.rejected.many.repos.item={1} 中的 {0}
push.rejected.many.repos.single.branch=當前分支“{0}”的推送被拒。
push.rejected.merge=合併(&M)
push.rejected.merge.needed=推送前需要合並遠端更改。
push.rejected.merge.needed.with.problem=在推送前，必須先合併遠端更改。<br/><br/>在這種情況下，強烈建議進行<b>合併</b>，因為存在未推送的合併提交。\n<br/>進行重定基底可能導致問題。
push.rejected.only.one.git.repo=當前分支“{0}”的推送被拒。
push.rejected.rebase=重定基底(&R)
push.rejected.rebase.anyway=仍然重定基底
push.rejected.remember.checkbox=請記住更新方法，並在日後進行無提示更新(&S)。稍後可以在“{0} | 版本控制”中進行更改。<br/>
push.rejected.specific.repo=版本庫“{1}”中的當前分支“{0}”推送被拒。
push.up.to.commit.allowed.progress.title=正在檢查是否允許推送到選定的提交…
push.up.to.commit.getting.reference.progress.title=正在獲取對 HEAD 的提交參照…
push.upto.here.failed.dialog.title=無法啟動推送
rebase.abort.and.rollback.dialog.message=僅中止 {0} 中的重定基底還是同時回滾 {1} 中的重定基底?
rebase.abort.and.rollback.dialog.no.button.text=僅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止並回滾
rebase.abort.dialog.message=中止{0} 中的重定基底?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止重定基底
rebase.abort.notification.failed.title=中止重定基底失敗
rebase.abort.notification.successful.message=中止重定基底成功
rebase.abort.notification.warning.rollback.failed.message={0}中的回滾失敗:{1}{2}
rebase.abort.notification.warning.rollback.failed.title=重定基底回滾失敗
rebase.abort.notification.warning.rollback.failed.with.repo.message=成功中止 {0} 中的重定基底，但 {1}:{2}{3} 中的回滾失敗
rebase.abort.progress.indicator.command.in.repo.title={0} ({1} 內)
rebase.abort.rollback.successful.rebase.dialog.message=是否要回滾 {0} 中成功的重定基底?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=回滾
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然重定基底
rebase.confirmation.dialog.published.commits.message.first=您正在嘗試重定基底一些已推送到受保護分支的提交。
rebase.confirmation.dialog.published.commits.message.second=對這些提交進行重定基底將使提交重複，這是不推薦的，而且很可能是不需要的。
rebase.confirmation.dialog.published.commits.title=重定基底已發佈的提交
rebase.conflict.diff.dialog.left.title=正在從 {1} 重定基底 {0}
rebase.conflict.diff.dialog.right.simple.title=已重定基底的提交
rebase.conflict.diff.dialog.right.with.branch.title=已重定基底的提交和來自 {0} 的提交
rebase.couldnt.resolve.file=無法解析 {0}
rebase.dialog.branch.field=源分支
rebase.dialog.error.base.not.selected=選擇新基
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在
rebase.dialog.error.branch.not.selected=選擇要切換到的分支
rebase.dialog.error.branch.or.tag.not.exist=沒有這樣的分支或標記
rebase.dialog.error.rebase.in.progress=此 Git 根目錄已經在進行互動重定基底
rebase.dialog.error.upstream.not.selected=選擇上游
rebase.dialog.help=顯示 Git 重定基底幫助
rebase.dialog.new.base=新基礎(分支或雜湊)
rebase.dialog.old.base=原基礎(分支或雜湊)
rebase.dialog.progress.loading.tags=正在載入標記…
rebase.dialog.root.invalid.label.text=(無效)
rebase.dialog.start.rebase=重定基底
rebase.dialog.target=分支或雜湊
rebase.dialog.title=重定基底
rebase.entry.action.name.drop=刪除
rebase.entry.action.name.edit=編輯
rebase.entry.action.name.fixup=Fixup
rebase.entry.action.name.pick=選取
rebase.entry.action.name.reword=改寫
rebase.entry.action.name.squash=壓縮
rebase.entry.action.name.unknown=未知
rebase.entry.action.name.update.ref=更新參照
rebase.git.operation.name=重定基底
rebase.help.link=git-scm.com 上的 git 重定基底
rebase.help.popup.ad.text=按空格開啟外部鏈接
rebase.help.rebase.branch=將基於一個分支的分支重定基底到另一個分支:
rebase.interactive.dialog.cancel.reword.warning.body=輸入的提交訊息將會丟失
rebase.interactive.dialog.cancel.reword.warning.cancel=取消改寫
rebase.interactive.dialog.cancel.reword.warning.continue=繼續編輯
rebase.interactive.dialog.cancel.reword.warning.title=取消改寫
rebase.interactive.dialog.discard.modifications.cancel=取消重定基底
rebase.interactive.dialog.discard.modifications.continue=繼續重定基底
rebase.interactive.dialog.discard.modifications.discard=捨棄
rebase.interactive.dialog.discard.modifications.message=捨棄更改並取消重定基底?
rebase.interactive.dialog.git.commands=Git 指令
rebase.interactive.dialog.git.commands.column.action=動作
rebase.interactive.dialog.git.commands.column.hash=雜湊
rebase.interactive.dialog.git.commands.column.subject=主題
rebase.interactive.dialog.reset.link.text=重設
rebase.interactive.dialog.reword.hint.text=按 {0} 套用更改
rebase.interactive.dialog.start.rebase=啟動重定基底
rebase.interactive.dialog.stop.to.edit.text=停止以編輯
rebase.interactive.dialog.title=正在重定基底提交
rebase.interactive.dialog.view.git.commands.text=檢視 Git 指令
rebase.interactive.edit.commit.message.dialog.title=Git 提交訊息
rebase.interactive.edit.commit.message.ok.action.title=繼續重定基底
rebase.interactive.noop.dialog.text=由於當前分支直接位於基礎分支的正下方或它們指向同一個提交，因此沒有要重定基底的提交('noop' 情況)。\n是否要繼續? (這會將當前分支重設為基礎分支)
rebase.interactive.noop.dialog.title=Git 重定基底
rebase.interactive.unstructured.editor.dialog.root.label=Git 根: {0}
rebase.log.action.loading.commit.message.failed.message=無法載入{0,choice,1#提交|2#提交}的更改
rebase.log.action.operation.rebase.name=重定基底
rebase.log.action.operation.reword.name=改寫
rebase.log.action.progress.indicator.loading.commit.message.title=正在載入{0,choice,1#提交|2#提交}詳細資訊…
rebase.log.changes.action.operation.drop.name=刪除所選更改
rebase.log.changes.drop.action.description.all.changes.selected=無法刪除提交中的所有更改
rebase.log.changes.drop.action.failure.title=無法刪除所選更改
rebase.log.changes.drop.action.notification.successful.title=更改已刪除
rebase.log.changes.drop.action.notification.undo.failed.title=撤消刪除更改失敗
rebase.log.changes.drop.action.notification.undo.not.allowed.title=無法撤消刪除更改
rebase.log.changes.drop.action.progress.indicator.title=正在刪除更改…
rebase.log.changes.drop.action.progress.indicator.undo.title=正在撤消刪除更改…
rebase.log.changes.drop.failed.title=無法刪除所選更改
rebase.log.commit.editing.action.commit.not.in.head.error.text=該提交不在當前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=該提交已被推送到受保護分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所選提交已{0}父項
rebase.log.commit.editing.action.initial.commit.dialog.text=確定要編輯初始提交嗎?
rebase.log.commit.editing.action.initial.commit.dialog.title=正在編輯初始提交
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜尋包含所選提交的分支…
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.commit.editing.action.prohibit.state.grafting=優選期間不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合併期間不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=重定基底期間不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=還原期間不能{0}
rebase.log.create.fixup.commit.action.failure.title=無法建立 Fixup 提交
rebase.log.create.squash.commit.action.failure.title=無法建立壓縮提交
rebase.log.drop.action.confirmation.message=是否要從 <b>{1}</b> 分支刪除 {0} 個{0,choice,1#提交|2#提交}?
rebase.log.drop.action.confirmation.message.detached.head=版本庫處於分離的 HEAD 狀態。是否要刪除 {0} 個{0,choice,1#提交|2#提交}?
rebase.log.drop.action.confirmation.title=刪除{0,choice,1#提交|2#提交}
rebase.log.drop.action.custom.text=刪除{0,choice,1#提交|2#提交}
rebase.log.drop.action.failure.title=無法刪除提交
rebase.log.drop.progress.indicator.title=正在刪除{0, choice, 1#提交|2#提交}…
rebase.log.drop.success.notification.title=已刪除 {0} 個{0,choice,1#提交|2#提交}
rebase.log.drop.undo.failed.title=撤消刪除失敗
rebase.log.drop.undo.impossible.title=無法撤消刪除
rebase.log.drop.undo.progress.title=正在撤消刪除…
rebase.log.interactive.action.failure.title=無法啟動重定基底
rebase.log.multiple.commit.editing.action.cant.find.head=在包含選定{0,choice,1#提交|2#提交}的版本庫中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自外部版本庫
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自不同的版本庫
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在檢查是否允許編輯所選提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在當前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 個父項
rebase.log.reword.action.failure.title=無法編輯提交訊息
rebase.log.reword.action.notification.successful.title=已更改提交訊息
rebase.log.reword.action.notification.undo.failed.title=撤消提交訊息編輯失敗
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=版本庫已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=無法撤消提交訊息編輯
rebase.log.reword.action.progress.indicator.title=正在改寫…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改寫…
rebase.log.reword.dialog.description.label=編輯由 {1} 執行的提交 {0} 的訊息
rebase.log.reword.dialog.failed.pushed.to.protected.message=無法編輯所選{0,choice,1#提交|2#提交}: 提交 {1} 已被推送到受保護的分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=無法編輯所選{0,choice,1#提交|2#提交}: 版本庫狀態已更改
rebase.log.reword.dialog.title=編輯提交訊息
rebase.log.squash.action.failure.title=無法壓縮提交
rebase.log.squash.new.message.dialog.label=編輯已壓縮提交的訊息
rebase.log.squash.new.message.dialog.title=已壓縮提交訊息
rebase.log.squash.progress.indicator.title=正在壓縮…
rebase.log.squash.success.notification.title=提交已壓縮
rebase.log.squash.undo.failed.title=撤消壓縮失敗
rebase.log.squash.undo.impossible.title=無法撤消壓縮
rebase.log.squash.undo.progress.title=正在撤消壓縮…
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=來自當前分支的提交已被推送到受保護的分支 {0}
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=繼續
rebase.notification.action.retry.text=重試
rebase.notification.action.stage.and.retry.text=暫存並重試
rebase.notification.action.view.shelf.text=檢視擱置…
rebase.notification.action.view.stash.text=檢視隱藏…
rebase.notification.all.conflicts.resolved.continue.rebase.action.text=繼續重定基底(&T)
rebase.notification.all.conflicts.resolved.text=所有衝突都已解決。是否要繼續重定基底?
rebase.notification.all.conflicts.resolved.title=解決衝突
rebase.notification.conflict.title=由於衝突，重定基底停止
rebase.notification.continue.failed.stage.changes.text=無法暫存追蹤檔案中的更改
rebase.notification.continue.failed.unstaged.changes.text=追蹤檔案中存在未暫存的更改，阻止繼續重定基底
rebase.notification.editing.title=重定基底已停止，可以進行編輯
rebase.notification.failed.continue.title=繼續重定基底失敗
rebase.notification.failed.rebase.title=重定基底失敗
rebase.notification.no.rebase.in.progress.abort.title=無法中止重定基底
rebase.notification.no.rebase.in.progress.continue.title=無法繼續重定基底
rebase.notification.no.rebase.in.progress.message=沒有正在進行的重定基底
rebase.notification.not.allowed.empty.repository.message=版本庫 {0} 為空。
rebase.notification.not.allowed.grafting.message.first={0} 中有一個未完成的優選程序。
rebase.notification.not.allowed.grafting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.merging.message.first={0} 中有一個未完成的合併程序。
rebase.notification.not.allowed.merging.message.second=在開始重定基底前，應先完成合併。
rebase.notification.not.allowed.message=無法在 {0} 中進行重定基底。
rebase.notification.not.allowed.rebasing.message.first={0} 中有一個未完成的重定基底程序。
rebase.notification.not.allowed.rebasing.message.second=在開始另一個重定基底前，應先完成這項動作。
rebase.notification.not.allowed.reverting.message.first={0} 中有一個未完成的還原程序。
rebase.notification.not.allowed.reverting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.title=不允許重定基底
rebase.notification.not.started.title=重定基底未啟動
rebase.notification.saved.local.changes.part.shelf.text=重定基底前已擱置本地更改。
rebase.notification.saved.local.changes.part.stash.text=重定基底前已隱藏本地更改。
rebase.notification.successful.rebased.checkout.message=已簽出{0,choice,0#|1# {1} }並將其重定基底{2,choice,0#|1#到 {3}}
rebase.notification.successful.rebased.message=已{0,choice,0#|1#將 {1} }重定基底{2,choice,0#|1#到 {3}}
rebase.notification.successful.title=重定基底成功
rebase.operation.name=重定基底
rebase.option.interactive=在重定基底之前編輯提交
rebase.option.keep.empty=重定基底期間不移除空提交
rebase.option.onto=為重定基底的提交指定新基
rebase.option.rebase.merges=重新建立提交拓撲
rebase.option.root=重定基底分支中的所有提交
rebase.option.switch.to.branch=選擇另一個要重定基底的分支
rebase.option.update.refs=自動更新指向重定基底的提交的分支
rebase.options.modify.dialog.title=新增重定基底選項
rebase.progress.indicator.aborting.title=正在中止重定基底程序…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解決的衝突…
rebase.progress.indicator.continue.title=正在繼續重定基底程序…
rebase.progress.indicator.preparing.title=正在準備重定基底…
rebase.progress.indicator.retry.title=正在重試重定基底程序…
rebase.progress.indicator.title=正在重定基底…
rebase.simple.editor.dialog.title=Git 編輯器
rebase.tracked.files.with.unstaged.changes.empty.text=沒有未暫存的檔案
rebase.tracked.files.with.unstaged.changes.title=具有未暫存更改的追蹤檔案
rebase.update.project.abort.task.title=正在中止重定基底…
rebase.update.project.conflict.error.notification.description=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
rebase.update.project.conflict.error.notification.title=無法繼續重定基底
rebase.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續重定基底。
rebase.update.project.notification.abort.error.message=中止重定基底時出錯
rebase.update.project.notification.abort.success.message=已中止重定基底
rebase.update.project.notification.failed.message=無法繼續重定基底。{0}
rebase.update.project.notification.failed.title=重定基底錯誤
rebase.using.log.couldnt.start.error=由於 IDE 生成的 'git-rebase-todo' 檔案無效，因此無法執行重定基底。是否要使用 Git 原生檔案生成來重試重定基底?
rebasing.merge.commits.button.cancel=取消
rebasing.merge.commits.button.merge=合併
rebasing.merge.commits.button.rebase=重定基底
reference.validating.progress.indicator.title=正在驗證修訂…
remote.dialog.add.remote=新增遠端
remotes.changing.remote.error.message=無法將遠端 {0} 更改為 {1} ''{2}''
remotes.changing.remote.error.title=更改遠端
remotes.changing.remote.progress=正在更改遠端…
remotes.define.duplicate.remote.name.validation.message=遠端名稱 ''{0}'' 已被使用
remotes.define.empty.remote.name.validation.message=遠端名稱不能為空
remotes.define.empty.remote.url.validation.message=遠端 URL 不能為空
remotes.define.invalid.remote.name.validation.message=遠端名稱包含非法字元
remotes.define.remote=定義遠端
remotes.define.remote.name=名稱:
remotes.define.remote.url=URL:
remotes.dialog.adding.remote=正在新增遠端…
remotes.dialog.cannot.add.remote.error.message=無法新增遠端 {0} ''{1}''
remotes.dialog.remove.remote.message=移除{0,choice,1#遠端|2#遠端}{1}?
remotes.dialog.remove.remote.title=移除{0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.error.message=無法移除{0, choice, 1#遠端|2#遠端} {1}
remotes.dialog.removing.remote.error.title=移除{0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.progress=正在移除{0,choice,1#遠端|2#遠端}…
remotes.dialog.title=Git 遠端
remotes.fetch.remote.text=獲取遠端
remotes.operation.error.message=在 {1} 中{0}:\n{2}
remotes.operation.not.executed.message=動作未執行
remotes.remote.column.name=名稱
remotes.remote.column.url=URL
remove.removing=正在移除檔案…
rename.branch.operation.name=重新命名
repositories=版本庫
repository.action.missing.roots.misconfigured=組態的 Git 根都不在 Git 下。組態的目錄中必須包含“.git”目錄。
repository.action.missing.roots.title=沒有 Git 根
repository.action.missing.roots.unconfigured.message=沒有為專案組態 Git 根。
repository.not.found.error=找不到 {0} 的已組態 Git 版本庫
reset.action.name=重設 Head…
reset.commit.invalid=指定的提交表達式未通過驗證。
reset.commit.label=為提交(&C):
reset.commit.tooltip=由於重設動作而將成為當前 HEAD 的提交。
reset.title=重設 Head
reset.type=重設類型(&T):
reset.type.tooltip=<html>重設類型(另請參閱 <code>git reset</code> man 頁面):<ul><li><b>Mixed</b> 將重設索引，但不會重設工作樹</li><li><b>Soft</b> 將保留索引和工作樹，只是移動 HEAD 指針</li><li><b>Hard</b> 將重設索引和工作樹。<em>工作樹中的更改會丟失</em></li></ul></html>
reset.validate=驗證(&V)
resetting.title=正在重設 HEAD…
restore.conflict.dialog.description.label.text=在 {0} 之前儲存的未提交更改與 {1} 中的檔案衝突
restore.conflict.diff.dialog.left.shelf.title=擱置中的未提交更改
restore.conflict.diff.dialog.left.stash.title=隱藏中的未提交更改
restore.conflict.diff.dialog.right.title=來自 {0} 的更改
restore.notification.failed.shelf.message=在{0}之前，您未提交的更改已儲存至擱置。
restore.notification.failed.show.changes.action=檢視已儲存的更改…
restore.notification.failed.stash.message=在{0}之前，您的未提交的更改已儲存至隱藏。
restore.notification.failed.title=未還原本地更改
revert.operation.applied=還原
revert.operation.name=還原
revision.load.contents=載入修訂內容
revision.number.cannot.parse.output=無法解析輸出: [{0}]
save.load.conflict.dialog.diff.left.title=您未提交的更改
save.load.conflict.dialog.diff.right.title=遠端更改
save.notification.failed.shelf.text=無法擱置本地未提交的更改:
save.notification.failed.stash.text=無法隱藏本地未提交的更改:
save.notification.failed.title=無法儲存 {0} 上未提交的更改
search.everywhere.group.full.name=Git 參照
search.everywhere.group.name=Git
search.everywhere.items.commit.by.hash=提交(按雜湊)
search.everywhere.items.commit.by.message=提交(按訊息)
search.everywhere.items.local.branch=本地分支
search.everywhere.items.remote.branch=遠端分支
search.everywhere.items.tag=標記
search.scope.project.git.exclude.ignored=專案檔案，不包括 Git 忽略的檔案
search.scope.project.git.tracked=Git 追蹤的專案檔案
separator.Git.Stage.Configure.display.as=顯示為
separator.git.branches.popup.filter.by=在搜尋結果中新增
separator.show=顯示
settings.add.suffix=在挑選推送到受保護分支的提交時，新增 'cherry-picked from <hash>' 後綴
settings.auto.update.on.push.rejected=如果當前分支的推送被拒，則自動更新
settings.bad.file.names=提交名稱可能會導致其他系統出現問題的檔案時發出警告
settings.clean.working.tree=使用以下方法清理工作樹:
settings.commit.group.title=提交
settings.configure.sign.gpg.do.not.sign.table.text=不簽署
settings.configure.sign.gpg.error.no.available.keys.found.text=找不到適用的私鑰
settings.configure.sign.gpg.error.table.text=錯誤: {0}
settings.configure.sign.gpg.for.repo.dialog.title=組態 GPG 密鑰 {0}
settings.configure.sign.gpg.for.repos.dialog.title=組態 GPG 密鑰
settings.configure.sign.gpg.gpg.kep.table.column.name=GPG 密鑰
settings.configure.sign.gpg.loading.table.text=正在載入…
settings.configure.sign.gpg.root.table.column.name=根
settings.configure.sign.gpg.synced.with.gitconfig.text=與 gitconfig 同步
settings.configure.sign.gpg.with.key.checkbox.text=使用 GPG 密鑰簽署提交:
settings.credential.helper=使用憑證幫助程序
settings.crlf=如果即將提交 CRLF 行分隔符，則發出警告
settings.detached.head=在游離的 HEAD 中或重定基底期間提交時發出警告
settings.enable.staging.area=啟用暫存區域
settings.enable.staging.area.comment=這將停用更改列表支援。僅適用於非強制回應提交介面。
settings.enable.stashes.and.shelves=將隱藏和擱置合併到一個頁籤中
settings.explicitly.check=顯式檢查遠端分支上的傳入提交:
settings.explicitly.check.condition.comment=需要在“進階設定”中啟用 ''{0}'' 選項
settings.filter.update.info=按路徑過濾“更新專案”資訊:
settings.git.fetch.tag.mode.always=始終
settings.git.fetch.tag.mode.default=自動
settings.git.fetch.tag.mode.default.description=遵循 git 組態
settings.git.fetch.tag.mode.never=從未
settings.git.fetch.tag.mode.prune=同步
settings.git.fetch.tags.label=獲取標記:
settings.git.incoming.change.strategy.text.always=始終
settings.git.incoming.change.strategy.text.auto=自動
settings.git.incoming.change.strategy.text.never=從不
settings.git.option.group=Git
settings.git.update.method.branch.default=分支預設
settings.git.update.method.merge=合併
settings.git.update.method.merge.description=&將傳入更改合併到當前分支
settings.git.update.method.rebase=重定基底
settings.git.update.method.rebase.description=&在傳入更改上重定基底當前分支
settings.label.sign.gpg.commits.enabled.different.keys.text=提交使用不同的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.n.roots.of.m.text=提交使用 {1} 的 {0} 個{0,choice,1#根|2#根}中的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.text=提交使用 GPG 密鑰簽署: {0}
settings.label.sign.gpg.commits.no.roots.text=專案中沒有 Git 根
settings.label.sign.gpg.commits.not.configured.text=未組態使用 GPG 密鑰簽署提交
settings.large.files=提交大於以下大小的檔案時發出警告:
settings.large.files.suffix=MB
settings.protected.branched=受保護分支:
settings.protected.branched.validation=跳過無效的受保護分支模式 ''{0}'': {1}
settings.push.dialog=顯示提交和推送的推送對話框
settings.push.dialog.for.protected.branches=僅在提交到受保護分支時顯示推送對話框
settings.push.group.title=推送
settings.show.rebase.log.drop.confirmation=要求確認刪除提交
settings.show.rebase.log.drop.confirmation.description=適用於 Git
settings.sign.gpg.configure.link.text=組態 GPG 密鑰…
settings.stash=隱藏
settings.stash.show.diff.group=呼叫“顯示差異”時，比較隱藏的更改:
settings.stash.show.diff.with.head=與父提交
settings.stash.show.diff.with.local=與檔案的本地版本
settings.synchronize.branch.protection.rules=從 GitHub 載入分支保護規則
settings.synchronize.branch.protection.rules.description=將 GitHub 規則新增到本地規則中，並在每次獲取時進行同步
settings.update.group.title=更新
settings.update.method=更新方法:
share.action.remote.is.on.host=遠端已經在 {0} 上:
share.action.remotes.are.on.host={0} 上已經有以下遠端:
share.anyway.button=仍然共享
share.error.cannot.find.git.repo=找不到 Git 版本庫
share.error.cannot.finish=無法完成 {0} 共享過程
share.error.created.project=專案建立成功
share.error.failed.to.create.repo=無法建立版本庫
share.error.init.commit.failed=({0})，但初始提交失敗:<br/>
share.error.project.is.on.host=專案已在 {0} 上
share.error.push.failed=({0})，但初始推送失敗:<br/>{1}
share.error.push.no.current.branch=({0})，但初始推送失敗: 沒有當前分支
share.error.unknown=未知錯誤
share.error.unknownHost=未知主機: {0}
share.process=正在 {0} 中共享專案…
share.process.adding.files=正在將檔案新增到 git…
share.process.adding.gh.as.remote.host=正在將 {0} 新增為遠端主機…
share.process.creating.git.repository=正在建立空 git 版本庫…
share.process.creating.repository=正在建立 {0} 版本庫…
share.process.empty.project.created=已在 {0} 上成功建立空版本庫
share.process.loading.account.info=正在載入 {0} 的帳戶資訊
share.process.performing.commit=正在執行提交…
share.process.pushing.to.host.master=正在推送至 {0} {1}…
share.process.retrieving.username=正在檢索用戶名…
share.process.successfully.shared=在 {0} 中成功共享專案
share.untracked.files.dialog.title=為初始提交新增檔案
show.diff.between.dialog.could.not.load.diff.with.branch.error=無法載入與 {0} 的差異: {1}
show.diff.between.dialog.no.differences.empty.text=無差異
show.diff.between.dialog.title={0}與當前工作樹之間的更改
smart.operation.dialog.don.t.operation.name=不{0}
smart.operation.dialog.git.operation.name.problem=Git {0} 問題
smart.operation.dialog.north.panel.label.shelf.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1}可以擱置這些更改，{0}，並在之後取消擱置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1} 可以隱藏這些更改，{0}，並在之後取消隱藏。</html>
smart.operation.dialog.ok.action.shelf.description=擱置本地更改，{0}，取消擱置
smart.operation.dialog.ok.action.stash.description=隱藏本地更改，{0}，取消隱藏
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}並覆蓋本地更改
smart.operation.dialog.smart.operation.name=智能{0}
stage.add.action.text=暫存
stage.add.error.title=無法暫存檔案
stage.add.no.content.action.text=在沒有內容的情況下暫存
stage.add.process=正在暫存檔案…
stage.add.range.command.name=暫存更改
stage.commit.all.text=全部提交(&I)
stage.commit.failed=無法提交 {0}
stage.commit.process=正在提交暫存更改…
stage.commit.successful=已提交 {0}: {1}
stage.content.local=本地
stage.content.staged=已暫存
stage.default.status=沒有要提交的內容，工作樹是乾淨的
stage.default.status.help=暫存區域入門
stage.diff.local.content.exception.message=無法獲取本地檔案: ''{0}''
stage.diff.staged.content.exception.message=無法獲取暫存內容: ''{0}''
stage.loading.status=正在載入更改…
stage.reset.action.text=取消暫存
stage.reset.error.title=無法取消暫存檔案
stage.reset.process=正在取消暫存檔案…
stage.revert.action.text=回滾
stage.revert.error.title=無法回滾檔案
stage.revert.process=正在回滾檔案…
stage.revert.staged.range.command.name=回滾暫存的更改
stage.revert.unstaged.range.command.name=回滾未暫存的更改
stage.tree.node.ignored=已忽略
stage.tree.node.staged=已暫存
stage.tree.node.unmerged=已取消合併
stage.tree.node.unstaged=未暫存
stage.tree.node.untracked=已取消追蹤
stage.vfs.editor.notification.link=開啟本地版本
stage.vfs.editor.notification.text=這是暫存版本的 ''{0}''
stage.vfs.editor.tab.tooltip=''{0}'' 的暫存版本
stage.vfs.presentable.file.name=已暫存: {0}
stage.vfs.read.process=正在從 Git 索引讀取 {0}
stage.vfs.shutdown.process=正在關閉 Git 索引 VFS
stage.vfs.write.process=正在將 {0} 寫入 Git 索引
stash.action.name=隱藏
stash.button=建立隱藏
stash.changes.non.empty.index.for.roots.notification.text={0} 中的暫存區域包含對儲存到隱藏的其他檔案的修改
stash.changes.non.empty.index.notification.action=不再顯示
stash.editor.diff.preview.empty.title=隱藏
stash.editor.diff.preview.id.change.title={0}: {1}
stash.empty.text.help.link=隱藏和擱置入門
stash.enable.stashes.link=啟用並檢視 Git 隱藏
stash.error=無法隱藏 {0}
stash.error.can.not.stash.changes.now=現在無法隱藏更改
stash.files.action.text=隱藏檔案
stash.files.error.message=無法隱藏檔案
stash.files.in.roots.success={0} 中的檔案已成功隱藏
stash.files.progress.title=正在隱藏檔案
stash.files.success=檔案已成功隱藏
stash.keep.index=保留索引(&I)
stash.keep.index.tooltip=如果選中此複選框，所有已新增到索引中的更改將保持不變
stash.load.changes.error=無法在解析為 {1} 的隱藏中載入根 {0} 中的更改
stash.message=訊息(&M):
stash.message.tooltip=在此處輸入隱藏訊息
stash.progress.indicator.title=正在隱藏來自 ''{0}'' 的更改…
stash.root.node.title=隱藏
stash.tab.name=儲藏
stash.title=隱藏
stash.unstash.changes.current.branch.label=當前分支:
stash.unstash.changes.in.root.dialog.title=取消隱藏 {0} 中的更改
stash.unstash.conflict.dialog.description.label.text=更新前隱藏的未提交更改與更新後的檔案衝突。
stash.unstash.progress.indicator.title=正在消除對 ''{0}'' 的更改…
stash.unstash.unresolved.conflict.warning.notification.message=您的未提交更改已儲存到隱藏。<br/>取消隱藏未完成，您的工作樹中有未解決的合併<br/>請解決衝突並刪除隱藏。
stash.unstash.unresolved.conflict.warning.notification.resolve.conflicts.action=解決衝突…
stash.unstash.unresolved.conflict.warning.notification.show.stash.action=檢視已儲存的更改…
stash.unstash.unresolved.conflict.warning.notification.title=本地更改已還原，但存在衝突
stash.view.stashes.link=檢視 Git 隱藏
stashes.and.shelves.tab.name=儲藏和擱置
stashing.progress.title=正在隱藏更改…
stashing.title=正在隱藏更改…
stats.wrong.git.shortlog.response=Git 快捷日誌輸出中出現意外行 ''{0}''
status.exception.message.format.message.xstatus.ystatus.line.output={0} xStatus=[{1}]，yStatus=[{2}]，行=[{3}]\n輸出:\n{4}
status.exception.message.line.is.too.short=此行過短
status.exception.message.missing.path=缺少初始路徑
status.exception.message.unexpected=意外的狀態符號
status.exception.message.unexpected.status=意外的狀態符號: ''{0}''
status.exception.message.unexpected.xstatus.ystatus=意外的狀態符號: ''{0}{1}''
tab.title.conflicts=衝突
tab.title.repo.root.name.at.revision={1} 的 {0}
tag.action.name=標記
tag.button=建立標籤
tag.commit.label=提交(&C)
tag.commit.tooltip=輸入要標記的提交或物件的名稱，或留空以使用 HEAD。
tag.error.creating.message.file.message=無法建立訊息檔案: {0}
tag.error.invalid.commit=該提交或物件名稱無效。
tag.error.tag.exists=存在同名的標記。
tag.force=強制(&F)
tag.force.tooltip=強制建立標記，即使已存在另一個具有此名稱的標記。
tag.getting.existing.tags=正在獲取現有標記…
tag.message.label=訊息(&M):
tag.message.tooltip=如果訊息不為空，則建立帶註解的標記。
tag.name.label=標記名稱(&N):
tag.name.tooltip=在此處輸入新的標記名稱。
tag.progress.title=正在新增標記…
tag.title=標記
tag.validate=驗證(&V)
tag.validate.tooltip=點擊此按鈕驗證要標記的提交
text.crlf.fix.dialog.description.proposed.fix=如果選擇<b>修正並提交</b>，將執行 {0}。<br/>如果選擇<b>按原樣提交</b>，則不會更改組態值。
text.crlf.fix.dialog.description.warning=您即將把 CRLF 行分隔符提交到 Git 版本庫。<br/>建議將 {0} Git 特性設定為 {1}，以免發生行分隔符問題。
text.crlf.fix.notification.description.warning=您即將向 Git 版本庫提交 CRLF 行分隔符
title.changes.excluded.from.commit=已從合併提交中排除更改
title.crlf.fix.dialog=行分隔符警告
title.sudo.command.install.git=安裝 Git
title.unresolved.conflicts.pre.commit.check=未解決的衝突
title.user.name.email.not.specified=未定義 Git 用戶名
tooltip.run.git.hooks=如果未選中，會在即將進行的提交中使用 '--no-verify' 選項跳過 Git 掛鈎
tooltip.run.git.hooks.disabled=已在“進階設定”中停用執行 Git 掛鈎
tracked.branch.fix.dialog.branch.placeholder=指定分支
tracked.branch.fix.dialog.not.on.branch.message=將跳過以下版本庫:
tracked.branch.fix.dialog.not.on.branch.title=游離的 HEAD 中的 Git 版本庫
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=設為追蹤分支
tracked.branch.fix.dialog.title=更新
unexpected.tree.entries.error=意外的樹條目: {0}
unexpected.tree.object.error=意外的樹物件: {0}
unshallow.repository.notification.message=檢測到淺層版本庫
unshallow.repository.notification.success.title=版本庫已轉換為完整版本庫
unshallow.repository.notification.title=此版本庫可以轉換為完整版本庫
unstash.action.name=取消隱藏
unstash.branch.label=作為新分支(&B):
unstash.branch.tooltip=如果輸入非空名稱，該隱藏將作為新分支簽出
unstash.button.apply=套用隱藏
unstash.button.branch=分支
unstash.button.pop=消除隱藏
unstash.clear=清除(&C)
unstash.clear.confirmation.message=移除所有隱藏? 此動作無法撤消。
unstash.clear.confirmation.title=移除所有隱藏?
unstash.clear.tooltip=刪除版本庫中的所有隱藏
unstash.clearing.stashes=正在清除隱藏…
unstash.conflict.dialog.description.label.text=取消隱藏 {0} 時發生衝突
unstash.conflict.diff.dialog.left.title=本地更改
unstash.conflict.diff.dialog.right.title=來自隱藏的更改
unstash.dialog.remove.stash.progress.indicator.title=正在移除隱藏 {0}…
unstash.dialog.show.stashes.error.dialog.title=無法顯示隱藏列表
unstash.dialog.stash.list.load.progress.indicator.title=正在載入隱藏列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消隱藏未完成，您的工作樹中存在未解決的合併。
unstash.dialog.unresolved.conflict.warning.notification.title=取消隱藏期間未解決衝突
unstash.dialog.unresolved.conflict.warning.resolve.conflicts.action=解決衝突…
unstash.drop=刪除(&D)
unstash.drop.confirmation.message=<html>是否要移除 {0}?<br/>“{1}”</html>
unstash.drop.confirmation.title=移除隱藏 {0}?
unstash.drop.tooltip=刪除所選隱藏
unstash.error.can.not.unstash.changes.now=現在無法取消隱藏更改
unstash.operation.name=取消隱藏
unstash.pop.stash=消除隱藏(&P)
unstash.pop.stash.tooltip=如果選中，則該隱藏在套用後會被刪除
unstash.reinstate.index=復原索引(&I)
unstash.reinstate.index.tooltip=嘗試復原索引以及工作樹更改
unstash.stash.applied=已成功套用隱藏
unstash.stashes=隱藏(&S):
unstash.title=取消隱藏更改
unstash.unstashed.with.conflicts.error.title=已取消隱藏，但存在衝突
unstash.unstashing=正在取消隱藏…
unstash.view=檢視(&V)
unstash.view.dialog.title=受 {0} 影響的路徑
unstash.view.tooltip=檢視所選隱藏
update.checks.not.supported.git.2.9.required=不支持更新檢查。需要 Git 2.9 及以上版本
update.notification.choose.upstream.branch=選擇上游分支
update.notification.update.error=無法更新
update.options.display.name=Git 更新設定
update.process.error.additional.description.unfinished.rebase=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
update.process.error.description.unfinished.rebase=您有未完成的重定基底程序。必須先解決這些衝突，然後才能更新。
update.process.error.message.unfinished.merge=您有未完成的合併。必須先解決這些衝突，然後才能更新。
update.process.error.message.unmerged.files=檢測到未合併的檔案。必須先解決這些衝突，然後才能更新。
update.process.error.notification.title=無法設定上游分支
update.process.generic.error.title=無法更新
update.process.nothing.to.update=沒有要更新的內容
update.process.progress.title=正在更新…
update.skip.root.reason.detached.head=游離的 HEAD
update.skip.root.reason.no.tracked.branch=無追蹤分支
util.remote.renderer.none=無
validation.error.email.no.at=電子郵件地址必須包含 '@' 符號
validation.warning.set.name.email.for.git=您必須為 Git 指定用戶名和電子郵件
vcs.history.action.gitlog=在 Git 日誌中顯示
vcs.log.archiving.log.index.data=正在歸檔 Git 日誌索引資料…
vcs.log.create.archive.with.log.index.data=傾印 Git 日誌索引資料
vcs.log.status.bar.extracting.log.index.data=正在獲取 Git 日誌索引資料…
vcs.log.status.bar.replacing.log.index.data=正在取代 Git 日誌索引資料…
vcs.log.use.log.index.data=使用共享 Git 日誌索引資料
vfs.listener.add.single.prompt=是否要安排將以下檔案新增到 Git?\n{0}\n\n如果您選擇“取消”，以後仍可以手動新增。
vfs.listener.add.single.title=將檔案新增到 Git
vfs.listener.add.title=將檔案新增到 Git
vfs.listener.checking.ignored=正在檢查忽略的檔案…
vfs.listener.delete.single.prompt=是否要從 Git 中刪除以下檔案?\n{0}\n\n如果您選擇“取消”，以後仍可以手動刪除。
vfs.listener.delete.single.title=從 Git 中刪除檔案
vfs.listener.delete.title=從 Git 中刪除檔案
warning.message.commit.with.bad.windows.file.name.bad.character=某些檔名包含 Windows 不允許的字元: ''{0}''。\n如果提交，可能無法在 Windows 上檢出 Git 版本庫。
warning.message.commit.with.bad.windows.file.name.reserved=某些檔案使用 Windows 不允許的保留名稱: ''{0}。\n如果提交，將無法在 Windows 上檢出 Git 版本庫。
warning.message.commit.with.detached.head=以下路徑中的 Git 版本庫處於<b>游離的 HEAD</b> 狀態: <br/>{0}<br/>您可以進行檢查，嘗試做出更改並提交，但務必簽出分支，以免丟失您的工作。<br/>否則，可能會丟失所做的更改。
warning.message.commit.with.unfinished.rebase=以下路徑中的 Git 版本庫有一個<b>未完成的重定基底</b>程序: <br/> {0}<br/>您可能想<b>繼續重定基底</b>而不是提交。<br/>在重定基底期間提交可能會導致提交丟失。
warning.title.commit.with.bad.windows.file.name=檔名不允許在 Windows 上使用
warning.title.commit.with.detached.head=在游離的 HEAD 中提交
warning.title.commit.with.unfinished.rebase=未完成重定基底程序
warning.your.local.changes.would.be.overwritten.by=您的本地更改將被 {0} 覆蓋。\n提交、{1}或還原您的更改以繼續。
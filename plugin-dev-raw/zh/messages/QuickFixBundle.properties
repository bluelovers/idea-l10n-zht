access.static.field.via.class.reference.text=通過參照類別 ''{1}'' 限定 static ''{0}'' 存取
access.static.method.via.class.reference.text=通過參照類別 ''{1}'' 限定 static ''{0}'' 呼叫
access.static.via.class.reference.family=通過類別參照限定 static 成員存取
access.static.via.class.reference.title=通過類別參照限定 static 成員存取
add.0.to.classpath=將 ''{0}'' 新增到類別路徑中
add.annotation.attribute.name=新增 ''{0}\=''
add.annotation.attribute.name.family.name=新增註解特性名稱
add.catch.clause.family=將異常新增到 catch 子句
add.catch.clause.text=新增 'catch' 子句
add.class.to.extends.list=使 ''{0}'' 擴展 ''{1}''
add.compiler.option.fix.name=將 ''{0}'' 新增到模組編譯器選項
add.constructor.parameter.name=新增建構函式參數
add.constructor.parameters=新增建構函式參數
add.default.branch.to.variable.initializing.switch.fix.name=將 ''default'' 分支新增到初始化 ''{0}'' 的 ''switch'' 語句中
add.default.constructor.family=新增預設建構函式
add.default.constructor.text=將 {0} 無實參建構函式新增到 {1}
add.docTag.to.custom.tags=將 ''@{0}'' 新增到自訂標記
add.docTag.to.custom.tags.preview=將此標記新增到此檢查將忽略的自訂標記列表中。
add.exception.from.field.initializer.to.constructor.throws.family.text=向類別建構函式簽名新增異常
add.exception.from.field.initializer.to.constructor.throws.text=新增類別{0, choice, 0\#預設建構函式|1\#建構函式|2\#建構函式}簽名的異常
add.exception.to.existing.catch.chooser.title=選擇 Catch 塊
add.exception.to.existing.catch.family=向現有 Catch 子句新增異常
add.exception.to.existing.catch.generic=向現有 Catch 子句新增異常
add.exception.to.existing.catch.no.replacement=將 ''{1}'' 新增到具有 ''{0}'' 的 catch
add.exception.to.existing.catch.replacement=用更通用的 ''{1}'' 取代 ''{0}''
add.exception.to.throws.family=向方法簽名新增異常
add.exception.to.throws.header=向方法簽名新增{0, choice, 0\#異常|2\#異常}
add.exception.to.throws.hierarchy=更改層次結構中的所有方法
add.exception.to.throws.only.this=只更改此方法
add.exception.to.throws.text=新增{0, choice, 0\#異常|2\#異常}到方法簽名
add.finally.block.family=新增 'finally' 塊
add.import=新增匯入
add.interface.to.implements.list=使 ''{0}'' 實作 ''{1}''
add.library.copy.files.to.radio.button=將''{0}''庫檔案複製到 (&C)
add.library.description.choose.folder=選擇要複製的庫所在的目錄
add.library.error.cannot.copy=無法將 ''{0}'' 複製到 ''{1}''\n({2})
add.library.error.not.found=庫檔案 ''{0}'' 不存在
add.library.title.choose.folder=選擇目錄
add.library.title.dialog=將 ''{0}'' 庫新增到專案
add.library.use.bundled.library.radio.button=使用{1}分發中的''{0}'' (&U)
add.method.body.text=新增方法體
add.method.family=新增方法
add.method.qualifier.fix.family=新增方法限定符
add.method.qualifier.fix.text=將限定符 ''{0}'' 新增到方法
add.method.text=將方法 ''{0}'' 新增到類別 ''{1}''
add.missing.annotation.parameters.fix=新增缺少的註解參數 - {0}
add.missing.annotation.single.parameter.fix=新增缺少的註解參數 ''{0}''
add.missing.nested.patterns.fix.text=新增缺少的嵌套模式{0, choice, 1\#|2\#}
add.missing.str.processor=新增 'STR.' 處理器
add.modifier.fix=將 ''{0}'' 設為{1}
add.modifier.fix.family=設為{0}
add.new.array.family=新增缺少的新表達式
add.new.array.text=新增 ''new {0}[]''
add.parameter.from.usage.text=將 ''{0}'' 作為第 {1,number,ordinal} 個{2}新增到{3} ''{4}'' 中
add.qualifier=新增限定符
add.qualifier.original.class.chooser.title=原始類別
add.return.statement.text=新增 'return' 語句
add.runtime.exception.to.throws.family=向方法簽名新增執行時異常
add.runtime.exception.to.throws.header=向方法簽名新增執行時異常
add.runtime.exception.to.throws.text=將 ''{0}'' 新增到方法簽名
add.type.arguments.single.argument.text=新增顯式類型實參
add.type.arguments.text=新增顯式類型實參到第 {0, choice, 1\#1|2\#2|3\#3|4\#{0,number}} 個實參
add.typecast.cast.text=將{1}轉換為 ''{0}''
add.typecast.convert.text=將{1}轉換為 ''{0}''
add.typecast.family=新增類型轉換
add.typecast.text=轉換到 ''{0}''
adjust.method.accepting.functional.expression.fix.family.name=調整接受函式表達式的方法
adjust.method.accepting.functional.expression.fix.text=將 ''{0}()'' 取代為 ''{1}()''
adjust.package.family=調整軟體套件名稱
adjust.package.text=將軟體套件名稱設定為 ''{0}''
annotations.fix=註解
anonymous.class.presentation=派生自 {0} 的匿名類別
bring.variable.to.scope.family=將變數引入作用域
bring.variable.to.scope.text=將 ''{0}'' 引入作用域
cannot.change.field.exception=無法更改欄位 ''{0}'' 類型。\n原因\: {1}
cannot.create.java.file.error.text=無法在{1}中建立 {0}.java\: {2}
cannot.create.java.file.error.title=檔案建立失敗
cannot.create.java.package.error.text=無法在{1}中建立 {0}\: {2}
cannot.create.java.package.error.title=軟體套件建立失敗
change.class.signature.family=更改類別簽名
change.class.signature.text=更改 ''{0}'' 的簽名以符合 ''{1}''
change.extends.list.family=擴展類別自
change.method.parameters.family=更改方法參數
change.method.parameters.text=將方法參數更改為 ''{0}''
change.method.signature.from.usage.family=從用法更改方法簽名
change.method.signature.from.usage.text=將 ''{0}'' 的簽名更改為 ''{1}({2})''
change.new.operator.type.family=更改新運算符類型
change.new.operator.type.text=將 ''{0}'' 更改為 ''new {1}{2}''
change.parameter.class.family=更改參數類別
change.parameter.from.usage.text=將{2} ''{3}'' 的第 {0,number,ordinal} 個{1}從 ''{4}'' 更改為 ''{5}''
change.to.append.family=修正 StringBuilder 追加
change.to.append.text=更改為 ''{0}''
change.type.family=更改類型
change.type.text=將類型更改為 ''{0}''
choose.class.to.move.popup.title=選擇要移動的類別
choose.constructors.to.add.parameter.to=選擇要向其新增參數的建構函式
choose.default.value.parameters.popup.title=選擇預設值參數
choose.fields.to.generate.constructor.parameters.for=選擇要為其生成建構函式參數的欄位
class.initializer.presentation={0} 類別初始設定式
class.to.import.chooser.title=要匯入的類別
collection.addall.can.be.replaced.with.constructor.fix.description='\#ref()' 方法可被取代為參數化建構函式呼叫
collection.addall.can.be.replaced.with.constructor.fix.family.name=將 'addAll()/putAll()' 呼叫取代為參數化建構函式呼叫
collection.addall.can.be.replaced.with.constructor.fix.name=將 ''{0}()'' 呼叫取代為參數化建構函式呼叫
collection.addall.can.be.replaced.with.constructor.fix.options.dialog.title=新增要檢查的類別
collection.addall.can.be.replaced.with.constructor.fix.options.label=要檢查的類別\:
collection.to.array.family.name=套用轉換 '.toArray()'
collection.to.array.text=套用轉換 ''.toArray({0})''
convert.primitive.to.boxed.type=將基元類型轉換為裝箱類型
convert.to.string.family=修正字元字面量
convert.to.string.text=轉換為字串字面量
convert.variable.to.field.in.anonymous.class.fix.name=將 ''{0}'' 移至匿名物件
create.accessor.for.unused.field.family=建立未使用欄位的存取器
create.annotation.family=將註解新增到宣告
create.annotation.text=註解為 @{0}
create.block=建立塊
create.class.from.new.family=從新的運算符建立類別
create.class.from.usage.family=從用法建立類別
create.class.from.usage.text=建立{0} ''{1}''
create.constant.from.usage.family=從用法建立常數
create.constructor.body.command=建立建構函式體
create.constructor.family=建立建構函式
create.constructor.from.new.family=從新的運算符建立建構函式
create.constructor.from.new.text=建立建構函式
create.constructor.from.super.call.family=從 super() 呼叫建立建構函式
create.constructor.from.this.call.family=從 this() 呼叫建立建構函式
create.constructor.matching.super=建立符合 super 的建構函式
create.constructor.text=在 ''{0}'' 中建立建構函式
create.element.in.class=在 ''{2}'' 中建立{0} ''{1}''
create.field.from.usage.family=從用法建立欄位
create.field.text=建立欄位 {0}
create.getter=建立 Getter
create.getter.and.setter.for.field=為 ''{0}'' 建立 getter 和 setter
create.getter.for.field=為 ''{0}'' 建立 getter
create.getter.setter=建立 getter/setter
create.inner.class.from.usage.text=建立內部{0} ''{1}''
create.local.from.instanceof.usage.family=從 instanceof 用法建立區域變數
create.local.from.instanceof.usage.text=插入 ''({0}){1}'' 宣告
create.local.from.usage.family=從用法建立本地
create.member.from.usage.family=從用法建立成員
create.method.body=建立方法體
create.method.from.usage.family=從用法建立方法
create.method.from.usage.text=建立方法 ''{0}''
create.parameter.from.usage.family=從用法建立參數
create.property.from.usage.family=從用法建立屬性
create.property.from.usage.full.text=在 ''{1}'' 中建立屬性 ''{0}''
create.property.from.usage.text=建立屬性 ''{0}''
create.property.text=建立屬性 {0}
create.read.only.property.from.usage.full.text=在 ''{1}'' 中建立唯讀屬性 ''{0}''
create.read.only.property.from.usage.text=建立唯讀屬性 ''{0}''
create.service=建立服務
create.service.implementation=建立服務實作
create.service.implementation.fix.family.name=建立服務實現類別
create.service.implementation.fix.name=建立類別 ''{0}''
create.service.interface.fix.family.name=建立服務
create.service.interface.fix.name=建立服務 ''{0}''
create.setter=建立 Setter
create.setter.for.field=為 ''{0}'' 建立 setter
create.type.parameter.from.usage.chooser.title=要新增類型參數的位置
create.type.parameter.from.usage.family=從用法建立類型參數
create.type.parameter.from.usage.text=建立類型參數 ''{0}''
create.write.only.property.from.usage.full.text=在 ''{1}'' 中建立只寫屬性 ''{0}''
create.write.only.property.from.usage.text=建立只寫屬性 ''{0}''
defer.final.assignment.with.temp.family=使用臨時變數推遲最終賦值
defer.final.assignment.with.temp.text=使用臨時變數推遲 ''{0}'' 賦值
delete.body.text=刪除方法體
delete.catch.family=刪除 catch
delete.catch.text=刪除 ''{0}'' 的 catch
delete.reference.fix.text=刪除參照
delete.return.fix.family=刪除 return
delete.return.fix.side.effects.text=刪除 return {0} 並提取副作用
delete.return.fix.text=刪除 return {0}
delete.unreachable.statement.fix.text=刪除不可到達的語句
enable.optimize.imports.on.the.fly=啟用 '設定 | 編輯器 | 一般 | 自動匯入 | 動態最佳化 import'
exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
extend.sealed.name=使 ''{0}'' {1, choice, 1\#擴展|2\#實作} ''{2}''
extend.sealed.title=使 ''{0}'' {1, choice, 1\#擴展|2\#實作} ''{2}''，並
extract.side.effects=提取副{0, choice, 1\#作用|2\#作用}
extract.side.effects.convert.to.if=作為 'if' 語句提取副作用
extract.side.effects.family.name=刪除提取副作用的語句
field.to.import.chooser.title=要匯入的欄位
fix.add.special.annotation.family=新增到特殊註解
fix.add.special.annotation.text=將 ''{0}'' 新增到特殊註解列表
fix.add.write.annotation.description=將 ''@{0}'' 新增到標記隱式寫入欄位的註解列表中。<p>之後可以在“入口點 | 註解”下的“未使用的宣告”檢查設定中編輯此列表。
fix.add.write.annotation.text=假設由 ''@{0}'' 註解的欄位為隱式寫入
fix.argument.family=修正實參
fix.expression.role.argument=實參
fix.expression.role.expression=表達式
fix.expression.role.lambda.return=lambda 返回值
fix.expression.role.literal=字面量
fix.expression.role.nth.argument={0, choice, 1\#第 1|2\#第 2|3\#第 3|4\#第 {0,number}} 個實參
fix.expression.role.qualifier=限定符
fix.javadoc.family=修正 Javadoc
fix.modifiers.family=修正修飾符
fix.parameter.type.family=修正參數類型
fix.parameter.type.text=使 ''{0}'' 在此處獲取類型為 ''{1}'' 的參數
fix.receiver.parameter.name.family=修復接收器參數的名稱
fix.receiver.parameter.type.family=修正接收器參數類型
fix.receiver.parameter.type.text=更改為封閉類別類型
fix.return.type.family=修正返回值類型
fix.return.type.or.predecessor.text=使 ''{0}'' 返回 ''{1}'' 或上級
fix.return.type.text=使 ''{0}'' 返回 ''{1}''
fix.single.character.string.to.char.literal.family=修正字面量類型
fix.single.character.string.to.char.literal.text=將 {0} 更改為 {1}({2} 字面量)
fix.super.method.return.type.family=修復 Super 方法返回值類型
fix.super.method.return.type.text=使 ''{0}'' 返回 ''{1}''
fix.throws.list.add.exception=將 ''{0}'' 新增到 ''{1}'' throws 列表
fix.throws.list.family=修正 throws 列表
fix.throws.list.remove.exception=從 ''{1}'' throws 列表移除 ''{0}''
fix.unused.symbol.injection.family=新增到相依項注入註解
fix.unused.symbol.injection.text=如果用 ''{0}'' 註解，則禁止未使用的警告
fix.update.modifier.change.inheritors=更改此方法和繼承者
fix.update.modifier.change.this=只更改此方法
fix.variable.type.family=修正變數類型
fix.variable.type.text=將{0} ''{1}'' 的類型更改為 ''{2}''
generate.overloaded.method.or.constructor.with.default.parameter.values=使用預設參數值生成多載{0}
generate.overloaded.method.with.default.parameter.values=使用預設參數值生成多載方法
implement.methods.fix=實作方法
implement.or.extend.fix.family=實作/擴展所需的基類別
import.class.fix=匯入類別
initialize.final.field.in.constructor.choose.dialog.title=選擇要向其新增初始化的建構函式
initialize.final.field.in.constructor.name=在建構函式中初始化
insert.empty.parenthesis=插入 '()'
insert.new.fix=插入 new
insert.sam.method.call.fix.family.name=插入單一 abstract 方法呼叫
insert.sam.method.call.fix.name=插入 ''.{0}'' 以呼叫函式式接口方法
insert.super.constructor.call.family=插入基類別建構函式呼叫
intention.move.parenthesis.name=修復右括號位置
iterate.iterable=迭代
java.8.collection.removeif.inspection.description=此迴圈可被取代為 'Collection.removeIf'
java.8.collection.removeif.inspection.fix.name=將此迴圈取代為 'Collection.removeIf'
java.8.list.replaceall.inspection.description=迴圈可被取代為 'List.replaceAll'
java.8.list.replaceall.inspection.fix.name=將迴圈取代為 'List.replaceAll'
java.8.list.sort.inspection.description=Collections.sort 可被取代為 List.sort
java.8.list.sort.inspection.fix.name=取代為 List.sort
java.8.map.api.inspection.description=可被取代為單個 ''Map.{0}'' 方法呼叫
java.8.map.api.inspection.fix.family.name=取代為單個 Map 方法呼叫
java.8.map.api.inspection.fix.text=取代為 ''{0}'' 方法呼叫
java.9.merge.module.statements.fix.family.name=與其他 ''{0}'' 指令合併
java.9.merge.module.statements.fix.name=與其他 ''{0} {1}'' 指令合併
make.annotation.applicable.to.0.fix=使註解適用於 {0}
make.class.an.interface.family=使類別成為接口
make.class.an.interface.text=將 ''{0}'' 設為接口
make.final.family=設為 final
make.interface.an.class.text=使 ''{0}'' 設為類別
make.receiver.parameter.first.family=將接收器參數作為第一項
make.receiver.parameter.first.text=將 'this' 移到列表開頭
make.vararg.parameter.last.family=將 vararg 參數設定為最後應參數
make.vararg.parameter.last.text=將 ''{0}'' 移至列表的末尾
merge.duplicate.attributes.family=合併重複特性
method.to.import.chooser.title=要匯入的方法
module.info.add.directive.family.name=將指令新增到 module-info.java
module.info.add.exports.name=將 ''exports {0}'' 指令新增到 module-info.java
module.info.add.opens.name=將 ''opens {0}'' 指令新增到 module-info.java
module.info.add.requires.name=將 ''requires {0}'' 指令新增到 module-info.java
module.info.add.uses.name=將 ''uses {0}'' 指令新增到 module-info.java
move.0.from.module.1.to.2=將 ''{0}'' 從模組 ''{1}'' 移至 ''{2}''
move.0.in.1=移動 ''{1}'' 中的 ''{0}''…
move.bound.class.to.front.fix.text=將界限 ''{0}'' 移至類型參數 ''{1}'' 的界限列表的開頭
move.catch.up.family=上移 'catch'
move.catch.up.text=將 ''{0}'' 的 catch 移至 ''{1}'' 之前
move.class.0.to.package.text=將{0} ''{1}'' 移至軟體套件 ''{2}''
move.class.in.extend.list.family=在擴展列表中移動類別
move.class.to.package.family=移至軟體套件
move.class.to.package.text=移至軟體套件 ''{0}''
move.class.to.separate.file.family=將類別移至單獨的檔案
move.class.to.separate.file.text=將類別 ''{0}'' 移至 ''{0}.java''
move.file.to.source.root.text=將檔案移至來源根
move.switch.branch.up.family=將 switch 分支上移
move.switch.branch.up.text=將 switch 分支 ''{0}'' 移至 ''{1}'' 之前
navigate.duplicate.element.text=導覽到重複的 {0}
navigate.variable.declaration.family=導覽到變數宣告
navigate.variable.declaration.text=導覽到上一個變數宣告 ''{0}''
negation.broader.scope.family=否定更寬的範圍
negation.broader.scope.text=更改為 ''\!({0})''
new.method.body.template.error.text=請更正“新方法體”模板
new.method.body.template.error.title=檔案模板錯誤
optimize.imports.fix=最佳化 import
orderEntry.fix.add.dependency.on.module=新增對模組 ''{0}'' 的相依
orderEntry.fix.add.dependency.on.module.choose=新增對模組的相依…
orderEntry.fix.add.library.to.classpath=將庫 ''{0}'' 新增到類別路徑
orderEntry.fix.choose.module.to.add.dependency.on=選擇要相依的模組
orderEntry.fix.circular.dependency.warning=新增對模組 ''{0}'' 的相依將在模組 ''{1}'' 和 ''{2}'' 之間引入迴圈相依關係。\n新增相依關係?
orderEntry.fix.family.add.library.to.classpath=將庫新增到類別路徑
orderEntry.fix.family.add.library.to.classpath.options=將庫新增到類別路徑…
orderEntry.fix.family.add.module.dependency=新增模組相依項
orderEntry.fix.title.circular.dependency.warning=迴圈相依關係警告
permute.arguments=重新排列實參
popup.title.choose.library.to.add.dependency.on=選擇要相依的庫
qualify.method.call.family=限定方法呼叫
qualify.method.call.fix=使用 ''{0}'' 限定呼叫
record.delegate.to.canonical.constructor.fix.name=Delegate to canonical constructor
remove.annotation.fix.family=移除註解
remove.annotation.fix.text=移除 ''@{0}'' 註解
remove.class.from.extends.list=使 ''{0}'' 不擴展 ''{1}''
remove.interface.from.implements.list=使 ''{0}'' 不實現 ''{1}''
remove.modifier.fix=將 ''{0}'' 設為非{1}
remove.modifier.fix.family=設為非 {0}
remove.one.modifier.fix=移除 ''{0}'' 修飾符
remove.override.fix.family=移除覆寫
remove.override.fix.text=從方法宣告中移除覆寫註解
remove.parameter.from.usage.text=從{2} ''{3}'' 中移除第 {0,number,ordinal} 個{1}
remove.parameter.list=移除參數列表
remove.qualifier.action.text=移除限定符
remove.qualifier.fix=移除限定符
remove.redundant.arguments.family=移除冗餘實參
remove.redundant.arguments.text=移除冗餘實參以呼叫 ''{0}''
remove.redundant.nested.patterns.fix.text=移除冗餘的嵌套模式{0, choice, 1\#|2\#}
remove.redundant.str.processor=移除冗餘的 'STR' 處理器
remove.suppression.action.family=移除禁止
remove.suppression.action.name=移除 ''{0}'' 禁止
remove.unreachable.branches=移除不可到達的分支
remove.unused.element.family=移除未使用的{0}
rename.wrong.reference.family=重新命名錯誤參照
rename.wrong.reference.text=重新命名參照
replace.for.each.loop.with.iterator.for.loop=將 'for each' 迴圈取代為迭代器 'for' 迴圈
replace.import.module.fix.text=將 'import module' 取代為單類別 import
replace.with.getter=取代為 getter
replace.with.getter.setter=取代為 getter/setter
replace.with.list.access.text=取代為列表存取
replace.with.qualifier.text=取代為限定符
replace.with.qualifier.text.role=將 {0} 取代為限定符
replace.with.setter=取代為 setter
replace.with.type.pattern.fix=取代為類型模式
reuse.variable.declaration.family=重用上一個變數
reuse.variable.declaration.text=重用上一個變數 ''{0}''
safe.delete.family=安全刪除
safe.delete.text=安全刪除 ''{0}''
seal.class.from.permits.list.fix=密封繼承者
searching.for.usages.progress.title=正在搜尋用法…
setup.jdk.location.family=設定 JDK 位置
setup.jdk.location.text=設定 JDK
side.effect.action.cancel=取消(&C)
side.effect.action.remove=移除(&R)
side.effect.action.transform=轉換(&T)
side.effects.warning.dialog.title=發現副作用
simplify.boolean.expression.extracting.side.effects=(提取副作用)
simplify.boolean.expression.family=簡化布爾表達式
simplify.boolean.expression.text=將 ''{0}'' 簡化為 {1}
static.import.constant.kind.text=static 常數
static.import.constant.text=匯入 static 常數
static.import.method.choose.method.to.import=選擇匯入的方法
static.import.method.kind.text=static 方法
static.import.method.text=匯入 static 方法
super.class.constructors.chooser.title=選擇超類別建構函式
surround.annotation.parameter.value.with.quotes=使用引號包圍註解參數值
surround.with.array.initialization=使用陣列初始化包圍
surround.with.try.catch.fix=使用 try/catch 包圍
target.class.chooser.title=選擇目標類別
target.method.chooser.title=選擇目標方法
uidesigner.change.bound.field.type=更改綁定的欄位類型
uidesigner.change.gui.component.type=更改 GUI 組件類型
unwrap.array.initializer.fix=將陣列初始設定式取代為其元素
wrap.expression.using.static.accessor.family=包裝表達式
wrap.expression.using.static.accessor.text=使用 ''{0}()'' 包裝
wrap.expression.using.static.accessor.text.role=使用 ''{0}()'' 封裝 {1}
wrap.with.adapter.call.family.name=使用呼叫或新物件適應
wrap.with.adapter.parameter.multiple.text=使用 ''{1}'' 適應{0, choice, 1\#第 1 個|2\#第 2 個|3\#第 3 個|4\#第 {0,number} 個}實參
wrap.with.adapter.parameter.single.text=使用 ''{0}'' 適應實參
wrap.with.adapter.text=使用 ''{0}'' 適應
wrap.with.adapter.text.role=使用 ''{0}'' 適應 {1}
wrap.with.block=使用塊包裝
wrap.with.optional.parameter.text=使用 ''java.util.Optional'' 包裝第 {0, choice, 1\#1|2\#2|3\#3|4\#{0,number}} 個實參
wrap.with.optional.single.parameter.text=使用 'java.util.Optional' 包裝

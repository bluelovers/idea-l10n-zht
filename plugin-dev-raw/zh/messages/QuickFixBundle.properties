add.import=添加導入
class.to.import.chooser.title=要導入的類
method.to.import.chooser.title=要導入的方法
field.to.import.chooser.title=要導入的字段
access.static.via.class.reference.family=通過類引用訪問 static
access.static.via.class.reference.text=通過類 ''{2}'' 引用訪問 static ''{1}.{0}''
add.default.function Object() { [native code] }.family=添加預設構造函數
add.default.function Object() { [native code] }.text=將 {0} 無參構造函數添加到 {1}
add.catch.clause.family=將異常添加到 catch 子句
add.catch.clause.text=添加 'catch' 子句
add.finally.block.family=添加 'finally' 塊
add.exception.to.throws.inherited.method.warning.text=方法 ''{0}'' 被繼承。\n\
您是否希望在整個方法層次結構中向方法簽名添加異常?
method.is.inherited.warning.title=方法被繼承
add.exception.to.throws.text=添加{0, choice, 0#異常|2#異常}到方法簽名
add.exception.to.throws.family=向方法簽名添加異常
add.exception.to.existing.catch.family=向現有 Catch 子句添加異常
add.exception.to.existing.catch.generic=向現有 Catch 子句添加異常
add.exception.to.existing.catch.replacement=用更通用的 ''{1}'' 替換 ''{0}''
add.exception.to.existing.catch.no.replacement=將 ''{1}'' 添加到具有 ''{0}'' 的 catch
add.exception.to.existing.catch.chooser.title=選擇 Catch 塊

add.method.body.text=添加方法體
add.method.family=添加方法
add.method.text=將方法 ''{0}'' 添加到類 ''{1}''
add.new.array.family=添加缺少的新表達式
add.new.array.text=添加 ''new {0}[]''
add.return.statement.text=添加 'return' 語句
add.runtime.exception.to.throws.text=向方法簽名添加運行時異常
add.runtime.exception.to.throws.family=向方法簽名添加運行時異常
add.typecast.family=添加類型轉換
add.typecast.text=轉換到 ''{0}''
add.qualifier.typecast.text=將限定符轉換為 ''{0}''
add.docTag.to.custom.tags=將 {0} 添加到自定義標籤
fix.javadoc.family=修正 Javadoc
adjust.package.family=調整軟件包名稱
adjust.package.text=將軟件包名稱設置為 ''{0}''
bring.variable.to.scope.family=將變量引入範圍
bring.variable.to.scope.text=將 ''{0}'' 引入範圍

cast.parameter.text=將{0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個}實參轉換為 ''{1}''
cast.single.parameter.text=將實參轉換為 ''{0}''

add.type.arguments.text=添加顯式類型實參到第{0, choice, 1#1|2#2|3#3|4#{0,number}}個實參
add.type.arguments.single.argument.text=添加顯式類型實參

change.class.signature.text=更改 ''{0}'' 的簽名以匹配 ''{1}''
change.class.signature.family=更改類簽名

uidesigner.change.bound.field.type=更改綁定的字段類型
cannot.change.field.exception=無法更改字段 ''{0}'' 類型。\n\
原因: {1}

# {0} - original keyword (extends or implements), {1} - proposed keyword (implements or extends), {2} - class name
exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
uidesigner.change.gui.component.type=更改 GUI 組件類型
change.method.signature.from.usage.family=從用法更改方法簽名

# {0} - original method signature including name, {1} - method name, {2} - proposed new parameters list
change.method.signature.from.usage.text=將 ''{0}'' 的簽名更改為 ''{1}({2})''
add.parameter.from.usage.text=將 ''{0}'' 作為第 {1,number,ordinal} 個{2}添加到{3} ''{4}'' 中
remove.parameter.from.usage.text=從{2} ''{3}'' 中移除第 {0,number,ordinal} 個{1}
change.parameter.from.usage.text=將{2} ''{3}'' 的第 {0,number,ordinal} 個{1}從 ''{4}'' 更改為 ''{5}''
searching.for.usages.progress.title=正在搜索用法…
create.class.from.new.family=從新的運算符創建類
create.class.from.usage.family=從用法創建類
# suppress inspection "UnusedProperty"
create.class.from.usage.text=創建{0} ''{1}''
create.inner.class.from.usage.text=創建內部{0} ''{1}''
create.element.in.class=在 ''{2}'' 中創建{0} ''{1}''
# suppress inspection "UnusedProperty"
create.constant.from.usage.family=從用法創建常量
# suppress inspection "UnusedProperty"
create.function Object() { [native code] }.from.new.family=從新的運算符創建構造函數
create.function Object() { [native code] }.from.new.text=創建構造函數
# suppress inspection "UnusedProperty"
create.function Object() { [native code] }.from.super.call.family=從 super() 調用創建構造函數
# suppress inspection "UnusedProperty"
create.function Object() { [native code] }.from.this.call.family=從 this() 調用創建構造函數
create.function Object() { [native code] }.family=創建構造函數
create.function Object() { [native code] }.text=在 ''{0}'' 中創建構造函數
create.function Object() { [native code] }.matching.super=創建匹配 super 的構造函數
super.class.constructors.chooser.title=選擇超類構造函數
create.field.from.usage.family=從用法創建字段
target.class.chooser.title=選擇目標類
new.method.body.template.error.text=請更正“新方法體”模板
new.method.body.template.error.title=文件模板錯誤
cannot.create.java.file.error.text=無法在{1}中創建 {0}.java: {2}
cannot.create.java.file.error.title=文件創建失敗
cannot.create.java.package.error.text=無法在{1}中創建 {0}: {2}
cannot.create.java.package.error.title=軟件包創建失敗
create.accessor.for.unused.field.family=創建未使用字段的訪問器
create.getter.for.field=為 ''{0}'' 創建 getter
create.setter.for.field=為 ''{0}'' 創建 setter
create.getter.and.setter.for.field=為 ''{0}'' 創建 getter 和 setter
create.local.from.usage.family=從用法創建本地
create.local.from.instanceof.usage.family=從 instanceof 用法創建局部變量
create.local.from.instanceof.usage.text=插入 ''({0}){1}'' 聲明
create.member.from.usage.family=從用法創建成員
create.method.from.usage.family=從用法創建方法
create.method.from.usage.text=創建方法 ''{0}''
create.type.parameter.from.usage.family=從用法創建類型形參
create.type.parameter.from.usage.text=創建類型形參 ''{0}''
create.type.parameter.from.usage.chooser.title=用於添加類型形參的位置
create.parameter.from.usage.family=從用法創建形參
create.property.from.usage.family=從用法創建屬性
create.property.from.usage.text=創建屬性 ''{0}''
create.property.from.usage.full.text=在 ''{1}'' 中創建屬性 ''{0}''
create.read.only.property.from.usage.text=創建唯讀屬性 ''{0}''
create.read.only.property.from.usage.full.text=在 ''{1}'' 中創建唯讀屬性 ''{0}''
create.write.only.property.from.usage.text=創建只寫屬性 ''{0}''
create.write.only.property.from.usage.full.text=在 ''{1}'' 中創建只寫屬性 ''{0}''
# suppress inspection "UnusedProperty"
create.getter=創建 Getter
# suppress inspection "UnusedProperty"
create.setter=創建 Setter
create.annotation.family=將注解添加到聲明
create.annotation.text=注解為 @{0}
defer.final.assignment.with.temp.family=使用臨時變量推遲最終賦值
defer.final.assignment.with.temp.text=使用臨時變量推遲 ''{0}'' 賦值
delete.catch.family=刪除 catch
delete.catch.text=刪除 ''{0}'' 的 catch
delete.body.text=刪除方法體
enable.optimize.imports.on.the.fly=啟用 '設置 | 編輯器 | 常規 | 自動導入 | 即時優化 import'
generify.family=泛化文件
generify.text=嘗試泛化 ''{0}''
implement.methods.fix=實現方法
import.class.fix=導入類
insert.new.fix=插入新的
insert.super.function Object() { [native code] }.call.family=插入基類構造函數調用
insert.super.function Object() { [native code] }.call.text=插入 ''{0}''
make.class.an.interface.family=使類成為接口
make.class.an.interface.text=將 ''{0}'' 設為接口
make.interface.an.class.text=使 ''{0}'' 設為類
make.vararg.parameter.last.family=將 vararg 形參設置為最後應形參
make.vararg.parameter.last.text=將 ''{0}'' 移至列表的末尾
make.receiver.parameter.first.family=將接收器形參作為第一項
make.receiver.parameter.first.text=將 'this' 移到列表開頭
fix.parameter.type.family=修正形參類型
fix.parameter.type.text=使 ''{0}'' 在此處獲取類型為 ''{1}'' 的形參
fix.return.type.family=修正返回類型
fix.return.type.or.predecessor.text=使 ''{0}'' 返回 ''{1}'' 或前置符
fix.return.type.text=使 ''{0}'' 返回 ''{1}''
fix.throws.list.family=修正 throws 列表
fix.throws.list.add.exception=將 ''{0}'' 添加到 ''{1}'' throws 列表
fix.throws.list.remove.exception=從 ''{1}'' throws 列表移除 ''{0}''
fix.modifiers.family=修正修飾符

anonymous.class.presentation=派生自 {0} 的匿名類
# {0} owner class name
class.initializer.presentation={0} 類初始值設定項
add.modifier.fix=將 ''{0}'' 設為{1}
remove.modifier.fix=將 ''{0}'' 設為非{1}
add.modifier.fix.family=設為 {0}
remove.modifier.fix.family=設為非 {0}

change.inheritors.visibility.warning.text=是否將繼承者的可見性更改為基方法的可見性?
change.inheritors.visibility.warning.title=更改繼承者
move.class.in.extend.list.family=在擴展列表中移動類
move.bound.class.to.front.fix.text=將界限 ''{0}'' 移至類型形參 ''{1}'' 的界限列表的開頭
move.catch.up.family=上移 Catch
move.catch.up.text=將 ''{0}'' 的 catch 移動到 ''{1}'' 之前
move.class.to.separate.file.family=將類移至單獨的文件
move.class.to.separate.file.text=將類 ''{0}'' 移至 ''{0}.java''
move.class.to.package.family=將類移至軟件包
move.class.to.package.text=移至軟件包 ''{0}''

# change if (!a == b) ...  =>  if (!(a == b)) ...
negation.broader.scope.family=否定更寬的範圍
negation.broader.scope.text=更改為 ''!({0})''

optimize.imports.fix=優化 import
remove.qualifier.fix=移除限定符
remove.unused.element.family=移除未使用的{0}
rename.wrong.reference.family=重命名錯誤引用
rename.wrong.reference.text=重命名引用
reuse.variable.declaration.family=重用變量聲明
reuse.variable.declaration.text=重用上一個變量 ''{0}'' 聲明
navigate.variable.declaration.family=導航到變量聲明
navigate.variable.declaration.text=導航到上一個變量聲明 ''{0}''
navigate.duplicate.element.text=導航到重複的 {0}
safe.delete.family=安全刪除
safe.delete.text=安全刪除 ''{0}''
setup.jdk.location.family=設置 JDK 位置
setup.jdk.location.text=設置 JDK
side.effects.warning.dialog.title=發現副作用
simplify.boolean.expression.family=簡化布爾表達式
simplify.boolean.expression.text=將 ''{0}'' 簡化為 {1}
fix.super.method.return.type.family=修復 Super 方法返回類型
fix.super.method.return.type.text=使 ''{0}'' 返回 ''{1}''
surround.with.try.catch.fix=使用 try/catch 環繞
make.final.family=設為 final
# suppress inspection "UnusedProperty"
make.final.copy.to.temp=將 ''{0}'' 複製到 {1} 臨時變量
fix.variable.type.family=修正變量類型
fix.variable.type.text=將{0} 的類型由''{1}''更改為 ''{2}''
fix.receiver.parameter.type.family=修正接收器形參類型
fix.receiver.parameter.type.text=更改為封閉類類型

# Sample: Boolean b = "true"; -> Boolean b = Boolean.function valueOf() { [native code] }("true");
wrap.expression.using.static.accessor.family=包裝表達式
wrap.expression.using.static.accessor.text=使用 ''{0}()'' 包裝

# {0} - qualified class name suggested to be imported.
side.effect.action.remove=移除(&R)
side.effect.action.transform=轉換(&T)
side.effect.action.cancel=取消(&C)
side.effect.message1=<html><body>分配給變量 ''{0}'' 的表達式中可能存在副作用<br>您可以: <ul><li><b>移除</b>涉及的變量用法以及所有表達式</li></body></html>
# {0} - variable name, {1} - variable type, {2} - expression with side effect, {3} - same expression transformed to hold the effect

change.parameter.class.family=更改形參類

change.extends.list.family=擴展類自
add.class.to.extends.list=使 ''{0}'' 擴展 ''{1}''
remove.class.from.extends.list=使 ''{0}'' 不擴展 ''{1}''
add.interface.to.implements.list=使 ''{0}'' 實現 ''{1}''
remove.interface.from.implements.list=使 ''{0}'' 不實現 ''{1}''
convert.method.to.function Object() { [native code] }=使方法成為構造函數

create.field.text=創建字段 {0}
create.property.text=創建屬性 {0}
add.function Object() { [native code] }.parameter.name=添加構造函數形參
remove.suppression.action.name=移除 ''{0}'' 禁止
remove.suppression.action.family=移除禁止
remove.qualifier.action.text=移除限定符
fix.argument.family=修正實參
change.new.operator.type.text=將 ''{0}'' 更改為 ''new {1}{2}''
change.new.operator.type.family=更改新運算符類型

fix.unused.symbol.injection.family=添加到依賴項注入注解
fix.unused.symbol.injection.text=如果用 ''{0}'' 注解，則禁止未使用的警告
fix.add.special.annotation.family=添加到特殊注解
fix.add.special.annotation.text=將 ''{0}'' 添加到特殊注解列表

orderEntry.fix.add.dependency.on.module=添加對模塊 ''{0}'' 的依賴
orderEntry.fix.add.dependency.on.module.choose=添加對模塊的依賴…
orderEntry.fix.choose.module.to.add.dependency.on=選擇要依賴的模塊
orderEntry.fix.family.add.module.dependency=添加模塊依賴項
orderEntry.fix.add.library.to.classpath=將庫 ''{0}'' 添加到類路徑
orderEntry.fix.family.add.library.to.classpath=將庫添加到類路徑
orderEntry.fix.circular.dependency.warning=添加對模塊 ''{0}'' 的依賴將在模塊 ''{1}'' 和 ''{2}'' 之間引入循環依賴關係。\n\
添加依賴關係?
orderEntry.fix.title.circular.dependency.warning=循環依賴關係警告
static.import.method.text=導入 static 方法
static.import.method.choose.method.to.import=選擇導入的方法
static.import.constant.text=導入 static 常量

add.library.title.dialog=將 ''{0}'' 庫添加到項目
add.library.title.choose.folder=選擇目錄
add.library.description.choose.folder=選擇要複製的庫所在的目錄
add.library.error.not.found=庫文件 ''{0}'' 不存在
add.library.error.cannot.copy=無法將 ''{0}'' 複製到 ''{1}''\n\
({2})
add.library.use.bundled.library.radio.button=使用{1}分發中的''{0}'' (&U)
add.library.copy.files.to.radio.button=將''{0}''庫文件複製到 (&C)

permute.arguments=重新排列實參
fix.single.character.string.to.char.literal.text=將 {0} 更改為 {1}({2} 文字)
fix.single.character.string.to.char.literal.family=修正文字類型

change.to.append.family=修正 StringBuilder 追加
change.to.append.text=更改為 ''{0}''

convert.to.string.family=修正字符文字
convert.to.string.text=轉換為字符串文字

initialize.final.field.in.function Object() { [native code] }.name=在構造函數中初始化
initialize.final.field.in.function Object() { [native code] }.choose.dialog.title=選擇要添加初始化的構造函數

remove.redundant.arguments.text=移除冗餘實參以調用 ''{0}''
remove.redundant.arguments.family=移除冗餘參數

replace.with.list.access.text=替換為列表訪問

add.qualifier=添加限定符
add.qualifier.original.class.chooser.title=原始類

annotations.fix=注解
add.missing.annotation.parameters.fix=添加缺少的注解形參 - {0}
add.missing.annotation.single.parameter.fix=添加缺少的注解形參 ''{0}''

add.method.qualifier.fix.text=將限定符 ''{0}'' 添加到方法
add.method.qualifier.fix.family=添加方法限定符

collection.addall.can.be.replaced.with.function Object() { [native code] }.fix.options.column.title=已檢查類
collection.addall.can.be.replaced.with.function Object() { [native code] }.fix.options.dialog.title=添加要檢查的類
collection.addall.can.be.replaced.with.function Object() { [native code] }.fix.options.label=要檢查的類:
collection.addall.can.be.replaced.with.function Object() { [native code] }.fix.description='#ref()' 方法可以替換為形參化構造函數調用
collection.addall.can.be.replaced.with.function Object() { [native code] }.fix.family.name=將 'addAll()/putAll()' 調用替換為形參化構造函數調用
collection.addall.can.be.replaced.with.function Object() { [native code] }.fix.name=將 ''{0}()'' 調用替換為形參化構造函數調用

add.exception.from.field.initializer.to.function Object() { [native code] }.throws.text=添加類{0, choice, 0#預設構造函數|1#構造函數|2#構造函數}簽名的異常
add.exception.from.field.initializer.to.function Object() { [native code] }.throws.family.text=向類構造函數簽名添加異常
java.8.map.api.inspection.fix.text=替換為 ''{0}'' 方法調用
java.8.map.api.inspection.description=可以替換為單個 ''Map.{0}'' 方法調用
java.8.map.api.inspection.fix.family.name=替換為單個 Map 方法調用
java.8.collection.removeif.inspection.description=此循環可以替換為 'Collection.removeIf'
java.8.collection.removeif.inspection.fix.name=將此循環替換為 'Collection.removeIf'
java.8.list.sort.inspection.description=Collections.sort 可以替換為 List.sort
java.8.list.sort.inspection.fix.name=替換為 List.sort

wrap.with.optional.parameter.text=使用 ''java.util.Optional'' 包裝第 {0, choice, 1#1|2#2|3#3|4#{0,number}} 個實參
wrap.with.optional.single.parameter.text=使用 'java.util.Optional' 包裝

move.file.to.source.root.text=將文件移至源根
delete.return.fix.family=刪除 return
delete.return.fix.text=刪除 return {0}
delete.return.fix.side.effects.text=刪除 return {0} 並提取副作用

delete.reference.fix.text=刪除引用
delete.unreachable.statement.fix.text=刪除不可到達的語句

extract.side.effects.convert.to.if=作為 'if' 語句提取副作用
extract.side.effects=提取副{0, choice, 1#作用|2#作用}
extract.side.effects.family.name=刪除提取副作用的語句

module.info.add.directive.family.name=將指令添加到 module-info.java
module.info.add.requires.name=將 ''requires {0}'' 指令添加到 module-info.java
module.info.add.exports.name=將 ''exports {0}'' 指令添加到 module-info.java
module.info.add.uses.name=將 ''uses {0}'' 指令添加到 module-info.java

collection.to.array.text=應用轉換 ''.toArray({0})''
collection.to.array.family.name=應用轉換 '.toArray()'

insert.sam.method.call.fix.name=插入 ''.{0}'' 以調用函數接口方法
insert.sam.method.call.fix.family.name=插入單一 abstract 方法調用

wrap.with.adapter.call.family.name=使用適配器調用或對象包裝
wrap.with.adapter.text=使用 ''{0}'' 包裝
wrap.with.adapter.parameter.single.text=使用 ''{0}'' 包裝實參
wrap.with.adapter.parameter.multiple.text=使用 ''{1}'' 包裝第 {0, choice, 1#1|2#2|3#3|4#{0,number}} 個實參

java.9.merge.module.statements.fix.family.name=與其他 ''{0}'' 指令合併
java.9.merge.module.statements.fix.name=與其他 ''{0} {1}'' 指令合併


adjust.method.accepting.functional.expression.fix.family.name=調整接受函數表達式的方法
adjust.method.accepting.functional.expression.fix.text=將 ''{0}()'' 替換為 ''{1}()''

add.compiler.option.fix.name=將 ''{0}'' 添加到模塊編譯器選項

create.service.implementation.fix.family.name=創建服務實現類
create.service.implementation.fix.name=創建類 ''{0}''

create.service.interface.fix.family.name=創建服務
create.service.interface.fix.name=創建服務 ''{0}''

convert.variable.to.field.in.anonymous.class.fix.name=將 ''{0}'' 移動到匿名對象
change.method.parameters.text=將方法參數更改為 ''{0}''
change.method.parameters.family=更改方法參數

add.default.branch.to.variable.initializing.switch.fix.name=將 ''default'' 分支添加到初始化 ''{0}'' 的 ''switch'' 語句中

insert.empty.parenthesis=插入 '()'
remove.parameter.list=移除形參列表

convert.primitive.to.boxed.type=將基元類型轉換為裝箱類型

choose.class.to.move.popup.title=選擇要移動的類
move.0.in.1=移動 ''{1}'' 中的 ''{0}''…
move.0.from.module.1.to.2=將 ''{0}'' 從模塊 ''{1}'' 移動到 ''{2}''

add.0.to.classpath=將 ''{0}'' 添加到類路徑中

iterate.iterable=迭代

choose.fields.to.generate.function Object() { [native code] }.parameters.for=選擇要為其生成構造函數形參的字段
choose.constructors.to.add.parameter.to=選擇要向其添加形參的構造函數
add.function Object() { [native code] }.parameters=添加構造函數形參

add.annotation.attribute.name.family.name=添加注解特性名稱
add.annotation.attribute.name=添加 ''{0}=''

replace.with.getter.setter=替換為 getter/setter
replace.with.getter=替換為 getter
replace.with.setter=替換為 setter

wrap.with.block=使用塊包裝
create.block=創建塊

replace.for.each.loop.with.iterator.for.loop=將 'for each' 循環替換為迭代器 'for' 循環

surround.annotation.parameter.value.with.quotes=使用引號環繞注解形參值
surround.with.array.initialization=通過數組初始化環繞

create.service.implementation=創建服務實現
create.service=創建服務

choose.default.value.parameters.popup.title=選擇默認值參數
generate.overloaded.method.or.function Object() { [native code] }.with.default.parameter.values=使用預設形參值生成重載{0}
generate.overloaded.method.with.default.parameter.values=使用預設形參值生成重載方法

remove.unreachable.branches=移除不可到達的分支
set.inspection.option.fix=設置檢查選項
simplify.boolean.expression.extracting.side.effects=(提取副作用)
intention.move.parenthesis.name=修復右括號位置

extend.sealed.title=擴展密封類並標記為
implement.sealed.title=實現密封接口並標記為

implement.or.extend.fix.family=實現/擴展所需的基類
implement.or.extend.fix.implement.text=實現 ''{0}''
implement.or.extend.fix.extend.text=擴展 ''{0}''

seal.class.from.permits.list.fix=密封繼承者

unwrap.array.initializer.fix=將數組初始值設定項替換為其元素
orderEntry.fix.family.add.library.to.classpath.options=將庫添加到類路徑…
popup.title.choose.library.to.add.dependency.on=選擇要依賴的庫
replace.with.type.pattern.fix=替換為類型模式
add.annotation.target.fix=添加 ''{0}'' 目標
add.annotation.target.family=添加注解目標
merge.duplicate.attributes.family=合併重複特性
move.switch.branch.up.family=將 switch 分支上移
move.switch.branch.up.text=將 switch 分支 ''{0}'' 移動到 ''{1}'' 之前
change.type.family=更改類型
change.type.text=改變類型到''{0}''
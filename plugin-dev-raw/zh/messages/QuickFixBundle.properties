add.import=添加匯入
class.to.import.chooser.title=要匯入的類
method.to.import.chooser.title=要匯入的方法
field.to.import.chooser.title=要匯入的欄位
access.static.via.class.reference.family=通過類引用存取 static
access.static.via.class.reference.text=通過類 ''{2}'' 引用存取 static ''{1}.{0}''
add.default.constructor.family=添加預設構造函數
add.default.constructor.text=將 {0} 無實參構造函數添加到 {1}
add.catch.clause.family=將異常添加到 catch 子句
add.catch.clause.text=添加 'catch' 子句
add.finally.block.family=添加 'finally' 塊
add.exception.to.throws.inherited.method.warning.text=方法 ''{0}'' 被繼承。\n\
您是否希望在整個方法層次結構中向方法簽名添加異常?
method.is.inherited.warning.title=方法被繼承
add.exception.to.throws.text=添加{0, choice, 0#異常|2#異常}到方法簽名
add.exception.to.throws.family=向方法簽名添加異常
add.exception.to.existing.catch.family=向現有 Catch 子句添加異常
add.exception.to.existing.catch.generic=向現有 Catch 子句添加異常
add.exception.to.existing.catch.replacement=用更通用的 ''{1}'' 取代 ''{0}''
add.exception.to.existing.catch.no.replacement=將 ''{1}'' 添加到具有 ''{0}'' 的 catch
add.exception.to.existing.catch.chooser.title=選擇 Catch 塊

add.method.body.text=添加方法體
add.method.family=添加方法
add.method.text=將方法 ''{0}'' 添加到類 ''{1}''
add.new.array.family=添加缺少的新表達式
add.new.array.text=添加 ''new {0}[]''
add.return.statement.text=添加 'return' 語句
add.runtime.exception.to.throws.text=向方法簽名添加執行時異常
add.runtime.exception.to.throws.family=向方法簽名添加執行時異常
add.typecast.family=添加類型轉換
add.typecast.text=轉換到 ''{0}''
add.qualifier.typecast.text=將限定符轉換為 ''{0}''
add.docTag.to.custom.tags=將 {0} 添加到自訂標籤
fix.javadoc.family=修正 Javadoc
adjust.package.family=調整軟體套件名稱
adjust.package.text=將軟體套件名稱設定為 ''{0}''
bring.variable.to.scope.family=將變數引入範圍
bring.variable.to.scope.text=將 ''{0}'' 引入範圍

cast.parameter.text=將{0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個}實參轉換為 ''{1}''
cast.single.parameter.text=將實參轉換為 ''{0}''

add.type.arguments.text=添加顯式類型實參到第{0, choice, 1#1|2#2|3#3|4#{0,number}}個實參
add.type.arguments.single.argument.text=添加顯式類型實參

change.class.signature.text=更改 ''{0}'' 的簽名以符合 ''{1}''
change.class.signature.family=更改類簽名

uidesigner.change.bound.field.type=更改綁定的欄位類型
cannot.change.field.exception=無法更改欄位 ''{0}'' 類型。\n\
原因: {1}

# {0} - original keyword (extends or implements), {1} - proposed keyword (implements or extends), {2} - class name
exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
uidesigner.change.gui.component.type=更改 GUI 組件類型
change.method.signature.from.usage.family=從用法更改方法簽名

# {0} - original method signature including name, {1} - method name, {2} - proposed new parameters list
change.method.signature.from.usage.text=將 ''{0}'' 的簽名更改為 ''{1}({2})''
add.parameter.from.usage.text=將 ''{0}'' 作為第 {1,number,ordinal} 個{2}添加到{3} ''{4}'' 中
remove.parameter.from.usage.text=從{2} ''{3}'' 中移除第 {0,number,ordinal} 個{1}
change.parameter.from.usage.text=將{2} ''{3}'' 的第 {0,number,ordinal} 個{1}從 ''{4}'' 更改為 ''{5}''
searching.for.usages.progress.title=正在搜尋用法…
create.class.from.new.family=從新的運算符創建類
create.class.from.usage.family=從用法創建類
# suppress inspection "UnusedProperty"
create.class.from.usage.text=創建{0} ''{1}''
create.inner.class.from.usage.text=創建內部{0} ''{1}''
create.element.in.class=在 ''{2}'' 中創建{0} ''{1}''
# suppress inspection "UnusedProperty"
create.constant.from.usage.family=從用法創建常數
# suppress inspection "UnusedProperty"
create.constructor.from.new.family=從新的運算符創建構造函數
create.constructor.from.new.text=創建構造函數
# suppress inspection "UnusedProperty"
create.constructor.from.super.call.family=從 super() 調用創建構造函數
# suppress inspection "UnusedProperty"
create.constructor.from.this.call.family=從 this() 調用創建構造函數
create.constructor.family=創建構造函數
create.constructor.text=在 ''{0}'' 中創建構造函數
create.constructor.matching.super=創建符合 super 的構造函數
super.class.constructors.chooser.title=選擇超類構造函數
create.field.from.usage.family=從用法創建欄位
target.class.chooser.title=選擇目標類
new.method.body.template.error.text=請更正“新方法體”模板
new.method.body.template.error.title=檔案模板錯誤
cannot.create.java.file.error.text=無法在{1}中創建 {0}.java: {2}
cannot.create.java.file.error.title=檔案創建失敗
cannot.create.java.package.error.text=無法在{1}中創建 {0}: {2}
cannot.create.java.package.error.title=軟體套件創建失敗
create.accessor.for.unused.field.family=創建未使用欄位的存取器
create.getter.for.field=為 ''{0}'' 創建 getter
create.setter.for.field=為 ''{0}'' 創建 setter
create.getter.and.setter.for.field=為 ''{0}'' 創建 getter 和 setter
create.local.from.usage.family=從用法創建本地
create.local.from.instanceof.usage.family=從 instanceof 用法創建局部變數
create.local.from.instanceof.usage.text=插入 ''({0}){1}'' 宣告
create.member.from.usage.family=從用法創建成員
create.method.from.usage.family=從用法創建方法
create.method.from.usage.text=創建方法 ''{0}''
create.type.parameter.from.usage.family=從用法創建類型參數
create.type.parameter.from.usage.text=創建類型參數 ''{0}''
create.type.parameter.from.usage.chooser.title=用於添加類型參數的位置
create.parameter.from.usage.family=從用法創建參數
create.property.from.usage.family=從用法創建屬性
create.property.from.usage.text=創建屬性 ''{0}''
create.property.from.usage.full.text=在 ''{1}'' 中創建屬性 ''{0}''
create.read.only.property.from.usage.text=創建唯讀屬性 ''{0}''
create.read.only.property.from.usage.full.text=在 ''{1}'' 中創建唯讀屬性 ''{0}''
create.write.only.property.from.usage.text=創建只寫屬性 ''{0}''
create.write.only.property.from.usage.full.text=在 ''{1}'' 中創建只寫屬性 ''{0}''
# suppress inspection "UnusedProperty"
create.getter=創建 Getter
# suppress inspection "UnusedProperty"
create.setter=創建 Setter
create.annotation.family=將註解添加到宣告
create.annotation.text=註解為 @{0}
defer.final.assignment.with.temp.family=使用臨時變數推遲最終賦值
defer.final.assignment.with.temp.text=使用臨時變數推遲 ''{0}'' 賦值
delete.catch.family=刪除 catch
delete.catch.text=刪除 ''{0}'' 的 catch
delete.body.text=刪除方法體
enable.optimize.imports.on.the.fly=啟用 '設定 | 編輯器 | 一般 | 自動匯入 | 動態最佳化 import'
generify.family=泛化檔案
generify.text=嘗試泛化 ''{0}''
implement.methods.fix=實作方法
import.class.fix=匯入類
insert.new.fix=插入 new
insert.super.constructor.call.family=插入基類構造函數調用
insert.super.constructor.call.text=插入 ''{0}''
make.class.an.interface.family=使類成為接口
make.class.an.interface.text=將 ''{0}'' 設為接口
make.interface.an.class.text=使 ''{0}'' 設為類
make.vararg.parameter.last.family=將 vararg 參數設定為最後應參數
make.vararg.parameter.last.text=將 ''{0}'' 移至列表的末尾
make.receiver.parameter.first.family=將接收器參數作為第一項
make.receiver.parameter.first.text=將 'this' 移到列表開頭
fix.parameter.type.family=修正參數類型
fix.parameter.type.text=使 ''{0}'' 在此處獲取類型為 ''{1}'' 的參數
fix.return.type.family=修正返回類型
fix.return.type.or.predecessor.text=使 ''{0}'' 返回 ''{1}'' 或前置符
fix.return.type.text=使 ''{0}'' 返回 ''{1}''
fix.throws.list.family=修正 throws 列表
fix.throws.list.add.exception=將 ''{0}'' 添加到 ''{1}'' throws 列表
fix.throws.list.remove.exception=從 ''{1}'' throws 列表移除 ''{0}''
fix.modifiers.family=修正修飾符

anonymous.class.presentation=派生自 {0} 的匿名類
# {0} owner class name
class.initializer.presentation={0} 類初始設定式
add.modifier.fix=將 ''{0}'' 設為{1}
remove.modifier.fix=將 ''{0}'' 設為非{1}
add.modifier.fix.family=設為 {0}
remove.modifier.fix.family=設為非 {0}

change.inheritors.visibility.warning.text=是否將繼承者的可見性更改為基方法的可見性?
change.inheritors.visibility.warning.title=更改繼承者
move.class.in.extend.list.family=在擴展列表中移動類
move.bound.class.to.front.fix.text=將界限 ''{0}'' 移至類型參數 ''{1}'' 的界限列表的開頭
move.catch.up.family=上移 Catch
move.catch.up.text=將 ''{0}'' 的 catch 移動到 ''{1}'' 之前
move.class.to.separate.file.family=將類移至單獨的檔案
move.class.to.separate.file.text=將類 ''{0}'' 移至 ''{0}.java''
move.class.to.package.family=將類移至軟體套件
move.class.to.package.text=移至軟體套件 ''{0}''

# change if (!a == b) ...  =>  if (!(a == b)) ...
negation.broader.scope.family=否定更寬的範圍
negation.broader.scope.text=更改為 ''!({0})''

optimize.imports.fix=最佳化 import
remove.qualifier.fix=移除限定符
remove.unused.element.family=移除未使用的{0}
rename.wrong.reference.family=重命名錯誤引用
rename.wrong.reference.text=重命名引用
reuse.variable.declaration.family=重用變數宣告
reuse.variable.declaration.text=重用上一個變數 ''{0}'' 宣告
navigate.variable.declaration.family=導航到變數宣告
navigate.variable.declaration.text=導航到上一個變數宣告 ''{0}''
navigate.duplicate.element.text=導航到重複的 {0}
safe.delete.family=安全刪除
safe.delete.text=安全刪除 ''{0}''
setup.jdk.location.family=設定 JDK 位置
setup.jdk.location.text=設定 JDK
side.effects.warning.dialog.title=發現副作用
simplify.boolean.expression.family=簡化布爾表達式
simplify.boolean.expression.text=將 ''{0}'' 簡化為 {1}
fix.super.method.return.type.family=修復 Super 方法返回類型
fix.super.method.return.type.text=使 ''{0}'' 返回 ''{1}''
surround.with.try.catch.fix=使用 try/catch 環繞
make.final.family=設為 final
# suppress inspection "UnusedProperty"
make.final.copy.to.temp=將 ''{0}'' 複製到 {1} 臨時變數
fix.variable.type.family=修正變數類型
fix.variable.type.text=將{0} 的類型由''{1}''更改為 ''{2}''
fix.receiver.parameter.type.family=修正接收器參數類型
fix.receiver.parameter.type.text=更改為封閉類類型

# Sample: Boolean b = "true"; -> Boolean b = Boolean.valueOf("true");
wrap.expression.using.static.accessor.family=包裝表達式
wrap.expression.using.static.accessor.text=使用 ''{0}()'' 包裝

# {0} - qualified class name suggested to be imported.
side.effect.action.remove=移除(&R)
side.effect.action.transform=轉換(&T)
side.effect.action.cancel=取消(&C)
side.effect.message1=<html><body>分配給變數 ''{0}'' 的表達式中可能存在副作用<br>您可以: <ul><li><b>移除</b>涉及的變數用法以及所有表達式</li></body></html>
# {0} - variable name, {1} - variable type, {2} - expression with side effect, {3} - same expression transformed to hold the effect

change.parameter.class.family=更改參數類

change.extends.list.family=擴展類自
add.class.to.extends.list=使 ''{0}'' 擴展 ''{1}''
remove.class.from.extends.list=使 ''{0}'' 不擴展 ''{1}''
add.interface.to.implements.list=使 ''{0}'' 實作 ''{1}''
remove.interface.from.implements.list=使 ''{0}'' 不實現 ''{1}''
convert.method.to.constructor=使方法成為構造函數

create.field.text=創建欄位 {0}
create.property.text=創建屬性 {0}
add.constructor.parameter.name=添加構造函數參數
remove.suppression.action.name=移除 ''{0}'' 禁止
remove.suppression.action.family=移除禁止
remove.qualifier.action.text=移除限定符
fix.argument.family=修正實參
change.new.operator.type.text=將 ''{0}'' 更改為 ''new {1}{2}''
change.new.operator.type.family=更改新運算符類型

fix.unused.symbol.injection.family=添加到依賴項注入註解
fix.unused.symbol.injection.text=如果用 ''{0}'' 註解，則禁止未使用的警告
fix.add.special.annotation.family=添加到特殊註解
fix.add.special.annotation.text=將 ''{0}'' 添加到特殊註解列表

orderEntry.fix.add.dependency.on.module=添加對模組 ''{0}'' 的依賴
orderEntry.fix.add.dependency.on.module.choose=添加對模組的依賴…
orderEntry.fix.choose.module.to.add.dependency.on=選擇要依賴的模組
orderEntry.fix.family.add.module.dependency=添加模組依賴項
orderEntry.fix.add.library.to.classpath=將庫 ''{0}'' 添加到類路徑
orderEntry.fix.family.add.library.to.classpath=將庫添加到類路徑
orderEntry.fix.circular.dependency.warning=添加對模組 ''{0}'' 的依賴將在模組 ''{1}'' 和 ''{2}'' 之間引入迴圈依賴關係。\n\
添加依賴關係?
orderEntry.fix.title.circular.dependency.warning=迴圈依賴關係警告
static.import.method.text=匯入 static 方法
static.import.method.choose.method.to.import=選擇匯入的方法
static.import.constant.text=匯入 static 常數

add.library.title.dialog=將 ''{0}'' 庫添加到專案
add.library.title.choose.folder=選擇目錄
add.library.description.choose.folder=選擇要複製的庫所在的目錄
add.library.error.not.found=庫檔案 ''{0}'' 不存在
add.library.error.cannot.copy=無法將 ''{0}'' 複製到 ''{1}''\n\
({2})
add.library.use.bundled.library.radio.button=使用{1}分發中的''{0}'' (&U)
add.library.copy.files.to.radio.button=將''{0}''庫檔案複製到 (&C)

permute.arguments=重新排列實參
fix.single.character.string.to.char.literal.text=將 {0} 更改為 {1}({2} 文字)
fix.single.character.string.to.char.literal.family=修正文字類型

change.to.append.family=修正 StringBuilder 追加
change.to.append.text=更改為 ''{0}''

convert.to.string.family=修正字符文字
convert.to.string.text=轉換為字串文字

initialize.final.field.in.constructor.name=在構造函數中初始化
initialize.final.field.in.constructor.choose.dialog.title=選擇要添加初始化的構造函數

remove.redundant.arguments.text=移除冗餘實參以調用 ''{0}''
remove.redundant.arguments.family=移除冗餘參數

replace.with.list.access.text=取代為列表存取

add.qualifier=添加限定符
add.qualifier.original.class.chooser.title=原始類

annotations.fix=註解
add.missing.annotation.parameters.fix=添加缺少的註解參數 - {0}
add.missing.annotation.single.parameter.fix=添加缺少的註解參數 ''{0}''

add.method.qualifier.fix.text=將限定符 ''{0}'' 添加到方法
add.method.qualifier.fix.family=添加方法限定符

collection.addall.can.be.replaced.with.constructor.fix.options.column.title=已檢查類
collection.addall.can.be.replaced.with.constructor.fix.options.dialog.title=添加要檢查的類
collection.addall.can.be.replaced.with.constructor.fix.options.label=要檢查的類:
collection.addall.can.be.replaced.with.constructor.fix.description='#ref()' 方法可被取代為參數化構造函數調用
collection.addall.can.be.replaced.with.constructor.fix.family.name=將 'addAll()/putAll()' 調用取代為參數化構造函數調用
collection.addall.can.be.replaced.with.constructor.fix.name=將 ''{0}()'' 調用取代為參數化構造函數調用

add.exception.from.field.initializer.to.constructor.throws.text=添加類{0, choice, 0#預設構造函數|1#構造函數|2#構造函數}簽名的異常
add.exception.from.field.initializer.to.constructor.throws.family.text=向類構造函數簽名添加異常
java.8.map.api.inspection.fix.text=取代為 ''{0}'' 方法調用
java.8.map.api.inspection.description=可被取代為單個 ''Map.{0}'' 方法調用
java.8.map.api.inspection.fix.family.name=取代為單個 Map 方法調用
java.8.collection.removeif.inspection.description=此迴圈可被取代為 'Collection.removeIf'
java.8.collection.removeif.inspection.fix.name=將此迴圈取代為 'Collection.removeIf'
java.8.list.sort.inspection.description=Collections.sort 可被取代為 List.sort
java.8.list.sort.inspection.fix.name=取代為 List.sort

wrap.with.optional.parameter.text=使用 ''java.util.Optional'' 包裝第 {0, choice, 1#1|2#2|3#3|4#{0,number}} 個實參
wrap.with.optional.single.parameter.text=使用 'java.util.Optional' 包裝

move.file.to.source.root.text=將檔案移至源根
delete.return.fix.family=刪除 return
delete.return.fix.text=刪除 return {0}
delete.return.fix.side.effects.text=刪除 return {0} 並提取副作用

delete.reference.fix.text=刪除引用
delete.unreachable.statement.fix.text=刪除不可到達的語句

extract.side.effects.convert.to.if=作為 'if' 語句提取副作用
extract.side.effects=提取副{0, choice, 1#作用|2#作用}
extract.side.effects.family.name=刪除提取副作用的語句

module.info.add.directive.family.name=將指令添加到 module-info.java
module.info.add.requires.name=將 ''requires {0}'' 指令添加到 module-info.java
module.info.add.exports.name=將 ''exports {0}'' 指令添加到 module-info.java
module.info.add.uses.name=將 ''uses {0}'' 指令添加到 module-info.java

collection.to.array.text=套用轉換 ''.toArray({0})''
collection.to.array.family.name=套用轉換 '.toArray()'

insert.sam.method.call.fix.name=插入 ''.{0}'' 以調用函數接口方法
insert.sam.method.call.fix.family.name=插入單一 abstract 方法調用

wrap.with.adapter.call.family.name=使用調用或新物件適應
wrap.with.adapter.text=使用 ''{0}'' 適應
wrap.with.adapter.parameter.single.text=使用 ''{0}'' 適應實參
wrap.with.adapter.parameter.multiple.text=使用 ''{1}'' 適應 {0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個} 實參

java.9.merge.module.statements.fix.family.name=與其他 ''{0}'' 指令合併
java.9.merge.module.statements.fix.name=與其他 ''{0} {1}'' 指令合併


adjust.method.accepting.functional.expression.fix.family.name=調整接受函數表達式的方法
adjust.method.accepting.functional.expression.fix.text=將 ''{0}()'' 取代為 ''{1}()''

add.compiler.option.fix.name=將 ''{0}'' 添加到模組編譯器選項

create.service.implementation.fix.family.name=創建服務實現類
create.service.implementation.fix.name=創建類 ''{0}''

create.service.interface.fix.family.name=創建服務
create.service.interface.fix.name=創建服務 ''{0}''

convert.variable.to.field.in.anonymous.class.fix.name=將 ''{0}'' 移動到匿名物件
change.method.parameters.text=將方法參數更改為 ''{0}''
change.method.parameters.family=更改方法參數

add.default.branch.to.variable.initializing.switch.fix.name=將 ''default'' 分支添加到初始化 ''{0}'' 的 ''switch'' 語句中

insert.empty.parenthesis=插入 '()'
remove.parameter.list=移除參數列表

convert.primitive.to.boxed.type=將基元類型轉換為裝箱類型

choose.class.to.move.popup.title=選擇要移動的類
move.0.in.1=移動 ''{1}'' 中的 ''{0}''…
move.0.from.module.1.to.2=將 ''{0}'' 從模組 ''{1}'' 移動到 ''{2}''

add.0.to.classpath=將 ''{0}'' 添加到類路徑中

iterate.iterable=迭代

choose.fields.to.generate.constructor.parameters.for=選擇要為其生成構造函數參數的欄位
choose.constructors.to.add.parameter.to=選擇要向其添加參數的構造函數
add.constructor.parameters=添加構造函數參數

add.annotation.attribute.name.family.name=添加註解特性名稱
add.annotation.attribute.name=添加 ''{0}=''

replace.with.getter.setter=取代為 getter/setter
replace.with.getter=取代為 getter
replace.with.setter=取代為 setter

wrap.with.block=使用塊包裝
create.block=創建塊

replace.for.each.loop.with.iterator.for.loop=將 'for each' 迴圈取代為迭代器 'for' 迴圈

surround.annotation.parameter.value.with.quotes=使用引號環繞註解參數值
surround.with.array.initialization=通過陣列初始化環繞

create.service.implementation=創建服務實作
create.service=創建服務

choose.default.value.parameters.popup.title=選擇預設值參數
generate.overloaded.method.or.constructor.with.default.parameter.values=使用預設參數值生成多載{0}
generate.overloaded.method.with.default.parameter.values=使用預設參數值生成多載方法

remove.unreachable.branches=移除不可到達的分支
set.inspection.option.fix=設定檢查選項
simplify.boolean.expression.extracting.side.effects=(提取副作用)
intention.move.parenthesis.name=修復右括號位置

extend.sealed.title=擴展密封類並標記為
implement.sealed.title=實作密封接口並標記為

implement.or.extend.fix.family=實作/擴展所需的基類
implement.or.extend.fix.implement.text=實作 ''{0}''
implement.or.extend.fix.extend.text=擴展 ''{0}''

seal.class.from.permits.list.fix=密封繼承者

unwrap.array.initializer.fix=將陣列初始設定式取代為其元素
orderEntry.fix.family.add.library.to.classpath.options=將庫添加到類路徑…
popup.title.choose.library.to.add.dependency.on=選擇要依賴的庫
replace.with.type.pattern.fix=取代為類型模式
merge.duplicate.attributes.family=合併重複特性
move.switch.branch.up.family=將 switch 分支上移
move.switch.branch.up.text=將 switch 分支 ''{0}'' 移動到 ''{1}'' 之前
change.type.family=更改類型
change.type.text=將類型更改為 ''{0}''
make.annotation.applicable.to.0.fix=使註解適用於 {0}
set.inspection.option.description.uncheck=取消選中檢查選項:
set.inspection.option.description.check=選中檢查選項:
java.8.list.replaceall.inspection.description=迴圈可以取代為 'List.replaceAll'
java.8.list.replaceall.inspection.fix.name=將迴圈取代為 'List.replaceAll'
fix.receiver.parameter.name.family=修復接收器參數的名稱
qualify.method.call.fix=使用 ''{0}'' 限定調用
qualify.method.call.family=限定方法調用
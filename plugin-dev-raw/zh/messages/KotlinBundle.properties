group.names.gradle=Gradle
group.names.java.interop.issues=Java 互操作問題
group.names.kotlin=Kotlin
group.names.logging=日誌記錄
group.names.naming.conventions=命名慣例
group.names.maven=Maven
group.names.migration=遷移
group.names.other.problems=其他問題
group.names.probable.bugs=可能的錯誤
group.names.redundant.constructs=冗餘結構
group.names.style.issues=樣式問題
fix.insert.delegation.call=插入 ''{0}()'' 調用
fix.introduce.non.null.assertion=添加非 null 斷言(!!)調用
fix.remove.non.null.assertion=移除不必要的非 null 斷言(!!)
fix.add.annotation.target=添加註解目標
fix.add.const.modifier=添加 'const' 修飾符
fix.add.constructor.parameter=添加構造函數參數 ''{0}''
fix.make.data.class=將 ''{0}'' 設為數據類
fix.add.default.constructor=將預設構造函數添加到 'expect' 類
fix.add.explicit.import=添加顯式匯入
fix.add.function.body=添加函數體
fix.use.fully.qualified.call=使用完全限定的調用
fix.add.is.to.when=在 ''{0}'' 前面添加 ''is''
fix.add.new.line.after.annotations=在註解後面添加新行
fix.make.type.parameter.reified=使 {0} 具體化且使 {1} 內聯
fix.add.return.last.expression=將 'return' 添加到上一個表達式
fix.add.return.before.expression=在表達式前面添加 'return'
fix.add.return.before.lambda.expression=在 lambda 表達式前面添加 'run'
fix.add.semicolon.lambda.expression=使用分號終止前面的調用
fix.add.spread.operator.after.sam=在作為 'vararg' 傳遞的陣列之前添加展開運算符
fix.add.else.branch.when=添加 else 分支
fix.replace.with.assign.function.call=取代為 ''{0}'' 調用
fix.assign.to.property=分配給屬性
fix.change.mutability.change.to.val=將 ''{0}'' 更改為 val
fix.change.type.argument=將類型實參更改為 {0}
fix.change.to.function.invocation=更改為函數調用
fix.change.to.mutable.type=將類型更改為 {0}

fix.change.to.property.access.family.remove=移除調用
fix.change.to.property.access.family.change=更改為屬性存取

fix.change.to.labeled.return.family=更改為帶標籤的返回
fix.change.to.labeled.return.text=更改為 ''{0}''

fix.change.suspend.hierarchy.add=將 'suspend' 修飾符添加到層次結構中的所有函數
fix.change.suspend.hierarchy.remove=從層次結構中的所有函數中移除 'suspend' 修飾符
fix.change.progress.looking.inheritors=正在尋找類 {0} 繼承者…
fix.change.progress.analyzing.class.hierarchy=正在分析類層次結構…

fix.change.return.type.family=更改類型
fix.change.return.type.text.primary.constructor=將類 ''{1}'' 主構造函數的參數 ''{0}'' 類型更改為 ''{2}''
fix.change.return.type.text.function=將函數 ''{1}'' 的參數 ''{0}'' 類型更改為 ''{2}''
fix.change.return.type.command.primary.constructor=將類 ''{1}'' 的主構造函數的參數 ''{0}'' 類型更改為 ''{2}''
fix.change.return.type.command.function=將函數 ''{1}'' 的參數 ''{0}'' 類型更改為 ''{2}''

fix.change.return.type.lambda=將 lambda 表達式返回類型更改為 {0}
fix.change.return.type.remove.explicit.return.type=移除顯式指定的返回類型
fix.change.return.type.remove.explicit.return.type.of=移除 {0} 的顯式指定的返回類型
fix.change.return.type.return.type.text=將返回類型更改為 ''{0}''
fix.change.return.type.return.type.text.of=將 {0} 的返回類型更改為 ''{1}''
fix.change.return.type.type.text=將類型更改為 ''{0}''
fix.change.return.type.type.text.of=將 {0} 的類型更改為 ''{1}''
fix.change.return.type.presentation.property=屬性 {0}
fix.change.return.type.presentation.function=函數 {0}
fix.change.return.type.presentation.enclosing.function=封閉的函數
fix.change.return.type.presentation.enclosing=封閉的 {0}
fix.change.return.type.presentation.called.function=調用的函數
fix.change.return.type.presentation.accessed=存取的{0}
fix.change.return.type.presentation.called=調用的{0}
fix.change.return.type.presentation.base=基{0}

fix.cast.expression.family=轉換表達式
fix.cast.expression.text=將表達式 ''{0}'' 轉換為 ''{1}''

fix.change.accessor.family=更改存取器類型
fix.change.accessor.getter=將 getter 類型更改為 {0}
fix.change.accessor.setter.parameter=將 setter 參數類型更改為 {0}

fix.create.from.usage.dialog.title=根據用法創建

fix.add.remaining.branches=添加剩餘的分支
fix.add.remaining.branches.with.star.import=使用 * 匯入添加剩餘的分支

fix.add.type.annotation.family=添加類型註解
fix.add.type.annotation.text=將類型 ''{0}'' 添加到參數 ''{1}''

fix.add.tostring.call.family=添加 'toString()' 調用
fix.add.tostring.call.text=添加 'toString()' 調用
fix.add.tostring.call.text.safe=添加安全的 '?.toString()' 調用

fix.add.star.projection.family=添加星號投影
fix.add.star.projection.text=添加 ''{0}''

fix.change.to.star.projection.family=更改為星號投影
fix.change.to.star.projection.text=將類型實參更改為 {0}

fix.change.to.use.spread.operator.family=更改為使用展開運算符
fix.change.to.use.spread.operator.text=將 ''{0}'' 更改為 ''{1}''

fix.change.type.family=更改類型
fix.change.type.text=將類型從 ''{0}'' 更改為 ''{1}''

fix.add.suspend.modifier.function=將 {0} 設為suspend
fix.add.suspend.modifier.function.generic=使包含函數掛起
fix.add.suspend.modifier.receiver=使{0}類型掛起
fix.add.suspend.modifier.receiver.generic=使接收器類型掛起


fix.add.function.parameters.change.signature.constructor=更改構造函數 ''{0}'' 的簽名
fix.add.function.parameters.change.signature.function=更改函數 ''{0}'' 的簽名
fix.add.function.parameters.add.parameter.constructor=將第 {0,number,ordinal} 個{1,choice,1#參數|2#參數}添加到構造函數 ''{2}''
fix.add.function.parameters.add.parameter.function=將第 {0,number,ordinal} 個{1,choice,1#參數|2#參數}添加到函數 ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=將{0,choice,1#參數|2#參數}添加到構造函數 ''{1}''
fix.add.function.parameters.add.parameter.generic.function=將{0,choice,1#參數|2#參數}添加到函數 ''{1}''

fix.change.signature.family=更改函數/構造函數的簽名
fix.change.signature.function.family=更改函數簽名
fix.change.signature.function.text=將函數簽名更改為 ''{0}''
fix.change.signature.function.text.generic=更改函數簽名…
fix.change.signature.function.popup.title=選擇簽名
fix.change.signature.lambda=更改 lambda 表達式的簽名
fix.change.signature.lambda.command=更改 Lambda 表達式的簽名
fix.change.signature.remove.parameter=移除參數 ''{0}''
fix.change.signature.remove.parameter.command=移除參數 ''{0}''
fix.change.signature.unavailable=<不可用>
fix.change.signature.error=<錯誤>
fix.change.signature.unnamed.parameter=參數

fix.change.object.to.class=將 'object' 更改為 'class'


fix.add.generic.upperbound.text=作為 {1} 的上限添加 ''{0}''
fix.add.generic.upperbound.family=添加泛型上限

fix.add.modifier.inline.parameter.family=將 ''{0}'' 添加到參數
fix.add.modifier.inline.parameter.text=將 ''{0}'' 添加到參數 ''{1}''

fix.add.modifier.inline.function.family=將 'inline' 添加到函數
fix.add.modifier.inline.function.text=將 ''inline'' 添加到函數 ''{0}''

fix.add.array.of.type.text=添加 {0} 包裝器
fix.add.array.of.type.family=添加 'arrayOf' 包裝器

fix.add.loop.label.text.generic=將標籤添加到迴圈
fix.add.loop.label.text=將 ''{0}'' 添加到 {1}

fix.add.modifier.family=添加修飾符
fix.add.modifier.text=使{0} ''{1}''
fix.add.modifier.text.generic=添加 ''{0}'' 修飾符
fix.potentially.broken.inheritance.title=可能中斷的繼承
fix.potentially.broken.inheritance.message=此變更可能會中斷繼承者。\n要繼續嗎?

fix.add.argument.name.family=將名稱添加到實參
fix.add.argument.name.text.generic=將名稱添加到實參…
fix.add.argument.name.text=將名稱添加到實參: ''{0}''
fix.add.argument.name.step.choose.parameter.title=選擇參數名稱

fix.change.feature.support.family=啟用/禁用{0}支援
fix.change.feature.support.enabled=啟用{0}支援
fix.change.feature.support.enabled.warning=啟用{0}支援 (包含警告)
fix.change.feature.support.disabled=禁用{0}支援

fix.create.expect.actual=創建預期/實際宣告
fix.create.missing.actual.members=添加缺少的實際成員

fix.create.declaration.error=無法生成 {0}: {1}
fix.create.declaration.error.inaccessible.type=無法存取的類型
fix.create.declaration.error.some.types.inaccessible=有些類型無法存取:

fix.add.annotation.family=添加註解
fix.add.annotation.text.self=添加 ''@{0}'' 註解
fix.add.annotation.text.declaration=將 ''@{0}'' 註解添加到 ''{1}''
fix.add.annotation.text.containing.class=將 ''@{0}'' 註解添加到包含類 ''{1}''
fix.add.annotation.text.containing.file=將 ''@{0}'' 註解添加到包含檔案 ''{1}''

fix.import=Import
fix.import.kind.delegate.accessors=委託存取器
fix.import.kind.component.functions=組件函數
fix.import.exclude=從自動匯入中排除 ''{0}''

fix.move.file.to.package.family=將檔案移動到軟體套件符合目錄
fix.move.file.to.package.text=將檔案移動到{0}

fix.change.package.family=更改檔案的軟體套件以符合目錄
fix.change.package.text=將檔案的軟體套件更改為 {0}

fix.move.to.sealed.family=將層次結構成員移至其密封父級的軟體套件/模組
fix.move.to.sealed.text=將 {0} 移至 {1} 的軟體套件/模組

action.add.import.chooser.title=Import

goto.super.chooser.function.title=選擇 super 函數
goto.super.chooser.property.title=選擇 super 屬性
goto.super.chooser.class.title=選擇超類或接口

inspection.unused.receiver.parameter=接收器參數從未使用
fix.unused.receiver.parameter.remove=移除冗餘的接收器參數

inspection.migration.title=程式碼遷移
inspection.migration.profile.name=遷移

fix.create.from.usage.family=從用法創建
fix.create.from.usage.local.variable=創建局部變數 ''{0}''

overridden.marker.implementations.multiple=具有實作
overridden.marker.implementation=在以下位置實作<br/>
overridden.marker.overrides.multiple=在子類中被覆寫
overridden.marker.overrides=在以下位置覆寫<br/>
searching.for.overriding.methods=正在搜尋覆寫方法

overridden.marker.implementations.choose.implementation.title=選擇 {0} 的實作
overridden.marker.implementations.choose.implementation.find.usages={0} 的覆寫屬性
overridden.marker.overrides.choose.implementation.title=選擇 {0} 的 super 實作
overridden.marker.overrides.choose.implementation.find.usages={0} 的 super 實作

remove.expression=移除 ''{0}''
unwrap.expression=解開 ''{0}''
remove.else=移除 ''{0}'' 中的 else
unwrap.else=展開 ''{0}'' 中的 else

override.declaration.x.in.y={0} ({1} 內)
override.declaration.x.implements.y={1} 中的 {0} 實作 {3} 中的 {2}。
override.declaration.x.overrides.y.in.class.list={0} 覆寫以下類/接口中的宣告: {1} 您是否希望{2}基宣告?

override.declaration.unused.overriding.methods.title=未使用的覆寫成員
override.declaration.unused.overriding.methods.description=有未使用的成員重寫了您刪除的方法。
override.declaration.choose.to.delete=選擇要刪除的宣告。
override.declaration.member=成員
override.declaration.delete.multiple.parameters={0} 是層次結構的一部分。您是否希望刪除多個參數?

hierarchy.legend.member.is.defined.in.class=成員在類中定義
hierarchy.legend.member.defined.in.superclass=成員未在類中定義，但在超類中定義
hierarchy.legend.member.should.be.defined=應定義成員，因為類不為 abstract

intention.change.package.text=更改軟體套件

intention.extract.declarations.from.file.text=從當前檔案中提取宣告
intention.extract.declarations.from.file.text.details=從當前檔案中提取 ''{0}'' {1, choice, 0#|1#和子類}
intention.wrap.in.with.context=在 'withContext' 中包裝調用
intention.flow.on.dispatchers.io='Dispatchers.IO' 的 Flow
intention.switch.context.to.dispatchers.io=切換到 'Dispatchers.IO' 上下文

kotlin.compiler.option.generate.no.warnings=報告編譯器警告(&W)
kotlin.compiler.option.additional.command.line.parameters=附加命令行參數(&A):

kotlin.compiler.jvm.option.panel.title=Kotlin 至 JVM

kotlin.compiler.js.option.panel.title=Kotlin 至 JavaScript
kotlin.compiler.js.option.generate.sourcemaps=生成源映射(&S)
kotlin.compiler.js.option.output.prefix=在生成的程式碼前添加檔案(&P)：
kotlin.compiler.js.option.output.postfix=要附加到生成的程式碼的檔案(&O)：
kotlin.compiler.js.option.output.copy.files=複製庫執行時檔案(&C)

kotlin.compiler.lib=庫

# Code insight
dialog.import.on.paste.title3=選擇要移除的匯入
copy.paste.reference.notification=已添加 {0} 個{0, choice, 1#匯入|2#匯入}<p><span><a href=''show''>檢查添加的匯入…</a></span>

plugin.verifier.compatibility.issue.title=兼容性問題
plugin.verifier.compatibility.issue.message=安裝的 Kotlin 延伸模組版本 ({0}) 與 {1} {2} 不相容。\n某些功能可能會中斷。\n\n請重新安裝 Kotlin 延伸模組。

kotlin.external.compiler.updates.notification.group.name=可用的 Kotlin 外部編譯器更新
kotlin.external.compiler.updates.notification.content.0=有可用的 Kotlin 版本 {0}
kotlin.external.compiler.updates.notification.learn.what.is.new.action=了解最新變化

plugin.updater.notification.group=有可用的 Kotlin 延伸模組更新
plugin.updater.notification.title=Kotlin
plugin.updater.notification.message=Kotlin 延伸模組有可用的新版本 {0}
plugin.updater.downloading=正在下載延伸模組
plugin.updater.not.installed=未安裝延伸模組更新
plugin.updater.not.installed.misc=未安裝延伸模組更新: {0}
plugin.updater.error.check.failed=Kotlin 延伸模組更新檢查失敗
plugin.updater.error.unexpected.repository.response=意外延伸模組儲存庫響應
plugin.updater.error.cant.find.plugin.version=在儲存庫響應中找不到延伸模組版本
plugin.updater.error.custom.repository=檢查自訂延伸模組儲存庫 {0} 失敗

quick.doc.text.enum.ordinal=枚舉常數序號: {0}
quick.doc.text.tailrec='tailrec' 將函數標記為<a href="https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions">尾遞歸</a> (允許編譯器將遞歸取代為迭代)
quick.doc.text.lateinit='lateinit' 允許初始化<a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables">構造函數外部的非 null 屬性</a>
quick.doc.no.documentation=無可用文檔
quick.doc.section.deprecated=已棄用:
quick.doc.section.replace.with=取代為:
quick.doc.section.java.declaration=Java 宣告:

action.j2k.name=將 Java 轉換為 Kotlin
action.j2k.task.name=將檔案從 Java 轉換為 Kotlin
action.j2k.correction.investigate=調查錯誤
action.j2k.correction.proceed=繼續轉換
action.j2k.correction.required=您專案其餘部分的一些程式碼在執行此轉換後可能需要更正。要尋找此類程式碼並更正嗎?
action.j2k.correction.errors.single=''{0}'' 包含語法錯誤，轉換結果可能不正確
action.j2k.correction.errors.multiple=''{0}'' 和 {1} 其他 Java 檔案包含語法錯誤，轉換結果可能不正確
action.j2k.error.cant.save.result=無法儲存轉換結果: {0}
action.j2k.error.cant.find.document=無法找到 ''{0}'' 的文檔
action.j2k.error.read.only=檔案 ''{0}'' 為唯讀檔案
action.j2k.errornothing.to.convert=沒有要轉換的內容:<br>未找到可編寫的 Java 檔案

formatter.settings.title=Kotlin 格式化程序設定

action.generate.functions.already.defined=已為類 {1} 定義函數 {0}。要刪除它們並繼續嗎?

action.generate.equals.choose.equals=選擇要包含在 'equals()' 中的屬性
action.generate.equals.choose.hashcode=選擇要包含在 'hashCode()' 中的屬性

action.generate.secondary.constructor.choose.properties=選擇要通過構造函數初始化的屬性
action.generate.secondary.constructor.error.already.exists=構造函數已存在

action.generate.test.support.choose.framework=選擇框架
command.generate.test.support.generate.test.function=生成測試函數
action.generate.test.support.choose.test.name=選擇測試名稱:
action.generate.test.support.edit.template=編輯模板
action.generate.test.support.error.no.template.found=沒有找到 {0} 的模板: {1}
action.generate.test.support.error.cant.convert.java.template=無法將 Java 模板轉換為 Kotlin
action.generate.test.support.error.cant.generate.method=無法生成方法: {0}

action.generate.tostring.name=生成 'toString()'
action.generate.tostring.template.single=單個模板
action.generate.tostring.template.multiple=包含串聯的多個模板
action.generate.tostring.choose.implementation=選擇實作:
action.generate.tostring.generate.super.call=生成對 super.toString() 的調用

action.new.file.text=Kotlin 類/檔案
action.new.file.description=創建新的 Kotlin 類或檔案
action.new.file.dialog.title=新 Kotlin 類/檔案
action.new.file.dialog.file.title=檔案
action.new.file.dialog.class.title=類
action.new.file.dialog.data.class.title=資料類
action.new.file.dialog.sealed.class.title=密封類
action.new.file.dialog.annotation.title=註解
action.new.file.dialog.interface.title=接口
action.new.file.dialog.sealed.interface.title=密封接口
action.new.file.dialog.enum.title=枚舉類
action.new.file.dialog.object.title=物件
action.new.file.error.empty.name=名稱不能為空
action.new.file.error.empty.name.part=名稱不能有空白部分

action.new.script.name=Kotlin 腳本(測試版)
action.new.script.description=創建新的 Kotlin 腳本
action.new.script.dialog.title=新建 Kotlin 腳本

action.new.worksheet.name=Kotlin 工作表(測試版)
action.new.worksheet.description=創建新的 Kotlin 工作表
action.new.worksheet.dialog.title=新建 Kotlin 工作表

breadcrumbs.tooltip.indexing=正在編制索引…

copy.paste.resolve.references=解析貼上的引用

type.provider.anonymous.object=匿名物件
type.provider.unknown.type=類型未知
type.provider.smart.cast.from=(從 {0} 智能轉換)
type.provider.no.expression.found=找不到表達式

optimize.imports.collect.unused.imports=收集未使用的 import
optimize.imports.task.removing.redundant.imports=正在移除冗餘匯入

kdoc.section.title.receiver=接收器
kdoc.section.title.parameters=參數
kdoc.section.title.returns=返回
kdoc.section.title.throws=拋出
kdoc.section.title.author=作者
kdoc.section.title.properties=屬性
kdoc.section.title.constructor=構造函數
kdoc.section.title.since=自
kdoc.section.title.suppress=禁止
kdoc.section.title.samples=範例
kdoc.section.title.see.also=另請參閱
kdoc.comment.unresolved=未解決

livetemplate.description.main=main() 函數
livetemplate.description.soutp=將函數參數名稱和值列印到 System.out
livetemplate.description.iter=迭代 iterable 的元素(for-in loop)
livetemplate.description.ifn=插入 'if null' 表達式
livetemplate.description.inn=插入 'if not null' 表達式
livetemplate.description.void=函數不返回任何內容
livetemplate.description.fun0=無形參函數
livetemplate.description.fun1=單參數函數
livetemplate.description.fun2=雙參數函數
livetemplate.description.interface=接口
livetemplate.description.singleton=單例
livetemplate.description.closure=閉包(沒有名稱的函數)
livetemplate.description.anonymous=匿名類
livetemplate.description.exfun=擴展函數
livetemplate.description.exval=擴展唯讀屬性
livetemplate.description.exvar=擴展讀寫屬性


parameter.hints.old=Kotlin: 顯示參數的嵌入提示
kotlin.references.types.hints=Kotlin: 顯示類型的嵌入提示
kotlin.references.types.hints.hints.type.function.parameter=Kotlin: 顯示函數參數類型的嵌入提示
kotlin.references.types.hints.hints.type.function.return=Kotlin: 顯示函數返回類型的嵌入提示
kotlin.references.types.hints.hints.type.variable=Kotlin: 顯示局部變數類型的嵌入提示
kotlin.references.types.hints.hints.type.property=Kotlin: 顯示屬性類型的嵌入提示
kotlin.lambdas.hints=Kotlin: 顯示 Lambda 的嵌入提示
kotlin.call.chains.hints=Kotlin: 顯示調用鏈的嵌入提示
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin: 顯示隱式接收器和參數的嵌入提示
kotlin.lambdas.hints.hints.lambda.return=Kotlin: 顯示返回表達式的嵌入提示
microservices.url.path.inlay.hints=Kotlin: 顯示 URL 路徑的嵌入提示
vcs.code.author=Kotlin: 顯示程式碼作者的嵌入提示

hints.settings.common.items=顯示以下項的提示:
hints.settings.types=類型
hints.settings.types.property=屬性類型
hints.settings.types.variable=局部變數類型
hints.settings.types.return=函數返回類型
hints.settings.types.parameter=函數參數類型

hints.settings.lambdas=Lambda
hints.settings.lambda.return=返回表達式
hints.settings.lambda.receivers.parameters=隱式接收器和參數

hints.settings.ranges=範圍
hints.ranges.rangeTo.left=≤
hints.ranges.rangeTo.right=≤
hints.ranges.until.left=≤
hints.ranges.until.right=<
hints.ranges.downTo.left=≥
hints.ranges.downTo.right=≥

hints.settings.suspending=正在暫停調用

hints.title.argument.name.enabled=實參名稱

presentation.text.paren=({0})
presentation.text.in.container.paren=({0} 中)
presentation.text.in.container={0} ({1} 內)
presentation.text.for.receiver.in.container.paren=({1}中的{0})
presentation.text.object.in.container={0}中的物件

project.view.class.initializer=類初始設定式
project.view.class.error.name=未提供名稱

copy.text.adding.imports=正在添加 import…
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=剪貼簿內容似乎是 Java 程式碼。要將其轉換為 Kotlin 嗎?
copy.text.convert.java.to.kotlin.title=將 Java 轉換為 Kotlin
copy.text.copied.kotlin.code=複製的 kotlin 程式碼
copy.text.resolving.references=正在解析引用…
copy.title.convert.code.from.java=從 Java 轉換程式碼

editor.checkbox.title.auto.add.val.keyword.to.data.inline.class.constructor.parameters=將 val 關鍵字自動添加到資料/內聯類構造函數參數
editor.checkbox.title.convert.pasted.java.code.to.kotlin=將貼上的 Java 程式碼轉換為 Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=貼上時不顯示 Java 至 Kotlin 轉換對話框
editor.title.kotlin=Kotlin

facet.checkbox.text.use.project.settings=使用專案設定
facet.column.name.options=選項
facet.column.name.plugin=延伸模組
facet.error.text.at.least.one.target.platform.should.be.selected=應至少選擇一個目標平台
facet.label.text.selected.target.platforms=選定的目標平台:
facet.label.text.target.platform=目標平台:
facet.label.text.the.project.is.imported.from.external.build.system.and.could.not.be.edited=專案從外部建置系統匯入，無法編輯
facet.link.text.edit.project.settings=編輯專案設定
facet.name.compiler.plugins=編譯器延伸模組
facet.name.general=一般
facet.text.following.arguments.are.redundant=以下實參冗餘: {0}
facet.text.following.arguments.override.facet.settings=以下實參會覆寫 facet 設定: {0}
facet.text.following.options.are.not.correct=以下選項不正確:
facet.text.multiplatform=多平台

find.usages.progress.text.declaration.superMethods=正在解析 super 方法…

formatter.button.text.use.import.with.when.at.least=至少以下條件下將 import 與 '*' 搭配使用
formatter.button.text.use.import.with=將 import 與 '*' 搭配使用
formatter.button.text.use.single.name.import=使用單個名稱匯入
formatter.checkbox.text.insert.imports.for.nested.classes=為嵌套類插入匯入
formatter.checkbox.text.use.trailing.comma=使用尾隨逗號
formatter.text.names.used=\ 使用的名稱
formatter.text.use.defaults.from=使用以下位置的預設值:
formatter.title.after.colon.before.declaration.type=冒號後，宣告類型前
formatter.title.after.colon.in.new.type.definition=新類型定義中的冒號後
formatter.title.align.when.branches.in.columns=對齊列中的 'when' 分支
formatter.title.around.arrow.in.function.types=函數類型中箭頭周圍
formatter.title.around.arrow.in=“when”子句中箭頭周圍
formatter.title.around.when.branches.with=帶有 {} 的 'when' 分支周圍
formatter.title.before.declaration.with.comment.or.annotation=在帶有註釋或註解的宣告之前
formatter.title.before.colon.after.declaration.name=冒號前，宣告名稱後
formatter.title.before.colon.in.new.type.definition=新類型定義中的冒號前
formatter.title.before.lambda.arrow=lambda 箭頭前
formatter.title.chained.function.calls=鏈式函數調用
formatter.title.elvis.expressions=Elvis 表達式
formatter.title.expression.body.functions=表達式主體函數
formatter.title.function.annotations=函數註解
formatter.title.function.call.arguments=函數調用實參
formatter.title.function.declaration.parameters=函數宣告參數
formatter.title.function.parentheses=函數括號
formatter.title.in.simple.one.line.methods=在簡單的一行方法中
formatter.title.java.statics.and.enum.members=Java static 和枚舉成員
formatter.title.load.save=載入/儲存
formatter.title.other=其他
formatter.title.trailing.comma=尾隨逗號
formatter.title.property.annotations=屬性註解
formatter.title.put.left.brace.on.new.line=將左大括號置於新行中
formatter.title.range.operator=範圍運算符 (..)
formatter.title.top.level.symbols=頂級符號
formatter.title.use.continuation.indent.in.conditions=在條件中使用延續縮排
formatter.title.use.continuation.indent=使用延續縮排
formatter.title.when.parentheses='when' 括號
formatter.title.when.statements='when' 語句

hierarchy.text.anonymous=[匿名]
hierarchy.text.in=\ 在 {0} 中

highlighter.action.text.go.to.actual.declarations=轉到實際宣告
highlighter.action.text.go.to.expected.declaration=轉到預期宣告
highlighter.action.text.go.to.implementations=轉到實作
highlighter.action.text.go.to.overridden.methods=轉到覆寫方法
highlighter.action.text.go.to.overridden.properties=轉到覆寫屬性
highlighter.action.text.go.to.subclasses=轉到子類
highlighter.action.text.go.to.super.method=轉到 super 方法
highlighter.action.text.go.to.super.property=轉到 super 屬性
highlighter.descriptor.text.android.extensions.property=屬性和變數//Android 擴展合成屬性
highlighter.descriptor.text.annotation=註解//註解名稱
highlighter.descriptor.text.annotation.attribute.name=註解//註解特性名稱
highlighter.descriptor.text.arrow=括號和運算符//箭頭
highlighter.descriptor.text.builtin.annotation=關鍵字//修飾符
highlighter.descriptor.text.builtin.keyword.val=關鍵字//'val'
highlighter.descriptor.text.builtin.keyword.var=關鍵字//'var'
highlighter.descriptor.text.builtin.keyword=關鍵字//關鍵字
highlighter.descriptor.text.captured.variable=屬性和變數//閉包中捕獲的變數和值
highlighter.descriptor.text.closure.braces=括號和運算符//lambda 表達式大括號和箭頭
highlighter.descriptor.text.colon=大括號和運算符//冒號
highlighter.descriptor.text.constructor.call=函數//構造函數調用
highlighter.descriptor.text.double.colon=括號和運算符//雙重冒號
highlighter.descriptor.text.dynamic.fun.call=函數//動態函數調用
highlighter.descriptor.text.dynamic.property=屬性和變數//動態屬性
highlighter.descriptor.text.enumEntry=類和接口//枚舉條目
highlighter.descriptor.text.exclexcl=括號和運算符//非 null 斷言
highlighter.descriptor.text.extension.fun.call=函數//擴展函數調用
highlighter.descriptor.text.extension.property=屬性和變數//擴展屬性
highlighter.descriptor.text.field=屬性和變數//支援欄位變數
highlighter.descriptor.text.fun.call=函數//函數調用
highlighter.descriptor.text.fun=函數//函數宣告
highlighter.descriptor.text.instance.property.custom.property.declaration=屬性和變數//包含自訂屬性宣告的實例屬性
highlighter.descriptor.text.instance.property=屬性和變數//實例屬性
highlighter.descriptor.text.it=參數//lambda 表達式預設參數
highlighter.descriptor.text.kdoc.comment=註釋//KDoc//KDoc 註釋
highlighter.descriptor.text.kdoc.tag=註釋//KDoc//KDoc 標記
highlighter.descriptor.text.kdoc.value=註釋//KDoc//KDoc 標記中的鏈接
highlighter.descriptor.text.label=標籤
highlighter.descriptor.text.local.variable=屬性和變數//局部變數或值
highlighter.descriptor.text.named.argument=命名實參
highlighter.descriptor.text.object=類和接口//物件
highlighter.descriptor.text.enum=類和接口//枚舉
highlighter.descriptor.text.package.fun.call=函數//軟體套件級函數調用
highlighter.descriptor.text.package.property.custom.property.declaration=屬性和變數//包含自訂屬性宣告的軟體套件級屬性
highlighter.descriptor.text.package.property=屬性和變數//軟體套件級屬性
highlighter.descriptor.text.quest=括號和運算符//可 null 性類型標記
highlighter.descriptor.text.safe.access=括號和運算符//安全存取的點
highlighter.descriptor.text.smart.cast.receiver=智能轉換//智能轉換隱式接收器
highlighter.descriptor.text.smart.cast=智能轉換//智能轉換值
highlighter.descriptor.text.smart.constant=智能轉換//智能常數
highlighter.descriptor.text.string.escape=字串//字串和模板大括號中的轉義
highlighter.descriptor.text.suspend.fun.call=函數//掛起函數調用
highlighter.descriptor.text.synthetic.extension.property=屬性和變數//合成擴展屬性
highlighter.descriptor.text.typeAlias=類和接口//類型別名
highlighter.descriptor.text.var=屬性和變數//Var (可變變數、參數或屬性)
highlighter.descriptor.text.variable.as.function.call=屬性和變數//變數作為函數調用
highlighter.descriptor.text.variable.as.function.like.call=屬性和變數//變數作為類似函數的調用
highlighter.message.suspend.function.call=掛起函數調用
highlighter.message.suspending.iteration=正在掛起迭代
highlighter.name.dsl.markers=DSL 標記
highlighter.name.dsl=Dsl//
highlighter.name.implemented.declaration=實作的宣告
highlighter.name.implementing.declaration=實作宣告
highlighter.name.kotlin.line.markers=Kotlin 行標記
highlighter.name.multiplatform.actual.declaration=多平台實際宣告
highlighter.name.multiplatform.expect.declaration=多平台預期宣告
highlighter.name.overridden.declaration=覆寫的宣告
highlighter.name.overriding.declaration=覆寫宣告
highlighter.name.style=樣式
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=索引更新時無法導航到覆寫類
highlighter.prefix.text.has.actuals.in=在 {0} 模組中具有實際值
highlighter.text.click.for.navigate=點擊 {0} 以導航
highlighter.text.has.functional.implementations=具有函數實作
highlighter.text.implements=實作
highlighter.text.in=''{1}'' 中的 {0}
highlighter.text.or.press=\ 或按 {0}
highlighter.text.overrides=覆寫
highlighter.title.actuals.for={0} 的實際值
highlighter.title.choose.actual.for=選擇 {0} 的實際值
highlighter.title.choose.expected.for=選擇 {0} 的預期值
highlighter.title.expected.for={0} 的預期值
highlighter.title.overriding.declarations.of={0} 的覆寫宣告
highlighter.title.searching.for.overriding.declarations=正在搜尋覆寫宣告
highlighter.title.searching.for.overriding.methods=正在搜尋覆寫方法
highlighter.tool.tip.marker.annotation.for.dsl=DSL 的標記註解
highlighter.tool.tip.text.function=函數
highlighter.tool.tip.text.property=屬性
highlighter.tool.tip.text.recursive.call=遞歸調用
highlighter.tool.tip.text.run.test=執行測試

import.optimizer.notification.text.unused.imports.not.found=找不到未使用的 import
import.optimizer.progress.indicator.text.collect.imports.for=收集 {0} 的匯入
import.optimizer.text.import={0, choice, 0#匯入|2#匯入}
import.optimizer.text.non.zero=移除的{0} {1}{2, choice, 0#|1#, 添加的{2} {3}}
import.optimizer.text.zero=重新排列的匯入
import.progress.text.resolve.imports=尋找所有 import…

version.message.is.deprecated.since.1.2.0.and.should.be.replaced.with={0} 自 1.2.0 起被棄用，應取代為 {1}

update.name.android.studio=Android Studio
update.reason.text.exception.during.verification=驗證時出現異常: {0}
update.reason.text.no.verified.versions.for.this.build=此建置沒有經過驗證的版本。
update.reason.text.unable.to.connect.to.compatibility.verification.repository=無法連接到兼容性驗證儲存庫
update.reason.text.unable.to.parse.compatibility.verification.metadata=無法解析兼容性驗證元資料
update.reason.text.version.to.be.verified=要驗證的版本。

test.integration.button.text.cancel=取消
test.integration.button.text.rewrite=覆寫
test.integration.message.text.create.test.in.the.same.source.root=在相同的源根中創建測試?
test.integration.message.text.kotlin.class=Kotlin 類 ''{0}'' 已存在。要更新它嗎?
test.integration.title.no.test.roots.found=找不到測試根

slicer.text.in=位置
slicer.text.tracking.enclosing.lambda=\ (跟踪封閉的 lambda)
slicer.text.tracking.lambda.calls=\ (跟踪 lambda 調用)
slicer.text.tracking.lambda.argument=\ (跟踪 lambda 參數)
slicer.text.tracking.lambda.receiver=\ (跟踪 lambda 接收器)
slicer.title.dataflow.from.here=流出此處的數據流
slicer.title.dataflow.to.here=流入此處的數據流
slicer.tool.tip.text.variable.dereferenced=已取消引用變數

script.action.text.ignore=忽略
script.action.text.open.settings=開啟設定
script.action.text.show.all=全部顯示
script.name.kotlin.scripting=Kotlin 腳本
script.text.multiple.script.definitions.are.applicable.for.this.script=多個腳本定義適用於此腳本。已使用 {0}

roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=為 Kotlin 專案中的非 JVM 模組更新源根

reporter.button.text.ignore=忽略
reporter.button.text.update=更新
reporter.message.text.you.re.running.kotlin.plugin.version=您正在執行 Kotlin 延伸模組版本 {0}，最新版本是 {1}
reporter.text.can.t.report.exception.from.patched.plugin=無法從已修補的延伸模組報告異常
reporter.title.update.kotlin.plugin=更新 Kotlin 延伸模組

configuration.description.always=始終
configuration.description.amd=AMD
configuration.description.commonjs=CommonJS
configuration.description.never=從不
configuration.description.plain.put.to.global.scope=普通 (應用於全域)
configuration.description.umd.detect.amd.or.commonjs.if.available.fallback.to.plain=UMD (如果可以，檢測 AMD 或 CommonJS，回退到普通)
configuration.description.when.inlining.a.function.from.other.module.with.embedded.sources=從包含嵌入式源的其他模組內聯函數時
configuration.error.text.shouldn.t.add.null.urls.to.custom.repositories=不應將 null url 添加到自訂庫
configuration.feature.text.new.java.to.kotlin.converter=新 Java 到 Kotlin 轉換器
configuration.message.enter.fully.qualified.method.name=輸入完全限定方法名稱:
configuration.message.text.a.new.version.is.available=有可用的新版本 {0}
configuration.message.text.a.new.version.is.found=已發現新版本 {0}，但未經{1}驗證。
configuration.message.text.update.check.failed=更新檢查失敗: {0}
configuration.message.text.you.have.the.latest.version.of.the.plugin.installed=您已安裝最新版本的延伸模組。
configuration.message.verifier.disabled=(已禁用驗證程序)
configuration.migration.text.api.version=API 版本: {0} 到 {1}
configuration.migration.text.detected.migration=檢測到的遷移:
configuration.migration.text.language.version=語言版本: {0} 到 {1}
configuration.migration.title.kotlin.migration=Kotlin 遷移
configuration.migration.group.name=Kotlin: 可遷移到較新版本
configuration.name.kotlin.compiler=Kotlin 編譯器
configuration.name.kotlin=Kotlin
configuration.name.method=方法
configuration.status.text.installation.failed=安裝失敗
configuration.status.text.installing=正在安裝…
configuration.title.add.exclusion=添加排除
configuration.text.and=和
configuration.text.other.s=其他
configuration.text.patched.original={0} (已修補! 原始: {1})
configuration.title.choose.output.directory=選擇輸出目錄
configuration.title.edit.exclusion=編輯排除
configuration.title.kotlin.compiler.js.option.output.postfix.browse.title=選擇要附加到生成程式碼的檔案
configuration.title.kotlin.compiler.js.option.output.prefix.browse.title=選擇要追加到生成程式碼的檔案
configuration.title.stable=穩定
configuration.warning.text.following.modules.override.project.settings=以下模組會覆寫專案設定:
configuration.warning.text.modules.override.project.settings={0}模組會覆寫專案設定
configuration.warning.text.language.version.unsupported=不再支援語言版本 {0}
configuration.warning.text.api.version.unsupported=不再支援 API 版本 {0}
configuration.kotlin.code.style=Kotlin 程式碼樣式
configuration.kotlin.code.style.group.name=Kotlin 官方程式碼樣式可用
configuration.notification.update.code.style.to.official=要將 Kotlin 程式碼樣式更新為推薦的設定嗎?
configuration.apply.new.code.style=套用程式碼樣式

configuration.is.resolve.module.per.source.set=檢測到傳統 Gradle 匯入模式
configuration.update.is.resolve.module.per.source.set=IDE 當前設定為每個 Gradle 專案創建一個模組。這種模式與 Kotlin Multiplatform 專案不相容，後者要求每個 Gradle 源集都只有一個模組。
configuration.apply.is.resolve.module.per.source.set=修正並重新匯入專案
configuration.do.not.suggest.update.is.resolve.module.per.source.set=不再顯示


#Refactoring
0.1.is.never.used={0} ''{1}'' 從未使用
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} 已在 {2} 中檢測到 {1} 程式碼 {1,choice,1#片段|2#片段}，可以用 {3} 取代。您想要查看並取代 {1,choice,1#它|2#它們}嗎?
0.will.become.invisible.after.extraction={0} 在提取之後將變為不可見
0.will.no.longer.be.accessible.after.extraction={0} 在提取之後將不再可存取
action.text.append=追加
action.text.cancel=取消
action.text.overwrite=覆蓋
button.text.move.nested.class.0.to.upper.level=將嵌套類 {0} 移動到上一級別(&N)
button.text.move.nested.class.0.to.another.class=將嵌套類 {0} 移動到另一個類(&M)
cannot.extract.super.call=不能提取 super-call
cannot.inline.property.with.accessor.s.and.backing.field=無法使用存取器和支援欄位內聯屬性
cannot.introduce.parameter.of.0.type=無法引入類型為 ''{0}'' 的參數
cannot.refactor.expression.has.unit.type=無法引入 unit 類型的表達
cannot.refactor.no.container=無法在此位置重構
cannot.refactor.no.expression=沒有表達無法執行重構
cannot.refactor.no.type=沒有類型無法執行重構
cannot.refactor.not.expression=找不到要引入的表達式
cannot.refactor.package.expression=無法引入軟體套件引用
cannot.refactor.syntax.errors=由於錯誤的程式碼無法重構
cannot.refactor.synthesized.function=無法重構合成函數 ''{0}''
checkbox.text.declare.with.var=使用 var 宣告(&V)
checkbox.text.delete.empty.source.files=刪除空白源文件(&D)
checkbox.text.extension.property=擴展屬性(&X): 
checkbox.text.introduce.default.value=引入預設值(&D)
checkbox.text.open.moved.files.in.editor=在編輯器中開啟移動的成員
checkbox.text.replace.all.occurrences.0=取代所有符合項 ({0})(&R)
checkbox.text.search.references=搜尋引用(&R)
checkbox.text.specify.type.explicitly=顯式指定類型(&T)
checkbox.text.update.package.directive=更新軟體套件指令(Kotlin 檔案)
column.name.receiver=接收器:
column.name.default.parameter=預設參數:
column.name.val.var=Val/Var
declarations.are.used.outside.of.selected.code.fragment=下面的宣告使用於選擇的程式碼段之外：
declarations.will.move.out.of.scope=以下宣告在提取的函數體之外不可用：
description.a.reference.to.extracted.type.parameter=引用提取的類型參數
error.cant.refactor.vararg.functions=不能重構具有可變實參的函數
error.hint.text.cannot.inline.0.from.a.decompiled.file=無法從反編譯檔案內聯 ''{0}''
error.text.can.t.change.signature.of.method=無法更改 {0} 方法的簽名
error.text.can.t.copy.class.to.the.containing.file=無法將類複製到包含檔案
error.text.can.t.generate.0.1=無法生成{0}: {1}
error.text.can.t.introduce.lambda.parameter.for.this.expression=無法為此表達式引入 lambda 參數
error.text.can.t.introduce.property.for.this.expression=無法為此表達式引入屬性
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=無法為非常數表達式引入常數
error.text.can.t.introduce.constant.for.this.expression=無法為此表達式引入常數
error.text.different.name.expected=應為不同名稱
error.text.expression.has.no.type=表達式沒有類型
error.text.extraction.from.expect.class.is.not.yet.supported=尚不支持從預期類提取
error.text.extraction.from.non.jvm.class.is.not.yet.supported=尚不支持從非 JVM 類提取
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=具有多個 return 語句的函數不支持“內聯函數”。
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=return 語句不在主體末尾的函數不支持“內聯函數”。
error.text.interface.cannot.be.extracted.from.an.annotation.class=無法從註解類中提取接口
error.text.introduce.parameter.is.not.available.for.default.value=“引入參數”不適用於預設值
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=“引入參數”不適用於註解條目內部
error.text.invalid.name=名稱無效
error.text.invalid.parameter.name=參數名無效
error.text.invalid.parameter.type=參數類型無效
error.text.invalid.receiver.type=接收器類型無效
error.text.invalid.return.type=返回類型無效
error.text.no.type.to.refactor=沒有要重構的類型
error.text.refactoring.is.not.applicable.in.the.current.context=重構不適用於當前上下文
error.text.superclass.cannot.be.extracted.from.an.annotation.class=無法從註解類中提取超類
error.text.type.reference.is.expected=應為類型引用
error.types.in.generated.function=無法生成返回類型錯誤的函數
error.wrong.caret.position.function.or.constructor.name=文字游標應置於要重構的函數或構造函數的名稱處。
extract.function=提取函數
family.name.update.usages.on.declarations.cut.paste=剪下/貼上宣告時更新用法
function.name.is.invalid=函數名無效
introduce.property=引入屬性
introduce.type.parameter.to.declaration=將類型參數引入宣告
introduce.type.parameter=引入類型參數
introduce.variable=引入變數
introduce.constant=引入常數
label.text.default.receiver.value=預設接收器值(&D):
label.text.destination.directory=目標目錄(&D):
label.text.file.name=文件名(&N):
label.text.introduce.as=引入為(&I):
label.text.name=名稱(&N): 
label.text.package.name=軟體套件名稱(&G):
label.text.receiver.type=接收器類型(&T):
label.text.target.file.name=目標文件名:
label.text.to.file=到檔案(&P):
label.text.to.package=到軟體套件(&A):
label.text.to.class=到類:
label.text.to.object=到物件:
class.name.prompt=類名(&N):
search.for.text.occurrences=搜尋文本符合項(&T)
search.in.comments.and.strings=在註釋和字符中搜尋(&C)
parameter.name.prompt=參數名稱(&M):
pass.outer.class.instance.as.parameter=將外部類實例作為參數傳遞(&O)
label.text.type=類型(&T):
label.text.move.expect.actual.counterparts=移動預期/實際對應項(&M)
label.text.visibility=可見性(&V):
member.info.abstract.0=abstract {0}
member.info.companion.0=伴生{0}
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=“更改簽名”不適用於動態調用的函數
error.hint.the.read.only.declaration.cannot.be.changed=無法更改唯讀宣告
error.hint.cannot.modify.0.declaration.from.1.file=無法修改 ''{1}'' 檔案中的 ''{0}'' 宣告
message.do.not.show.for.local.variables.in.future=以後不為局部變數顯示
message.text.return.type.cannot.be.resolved=無法解析返回類型 ''{0}''。\n是否繼續?
message.text.property.type.cannot.be.resolved=無法解析屬性類型 ''{0}''。\n是否繼續?
message.text.property.receiver.type.cannot.be.resolved=無法解析屬性接收器類型 ''{0}''。\n是否繼續?
message.type.for.cannot.be.resolved=無法解析 {1} 的類型 ''{0}''。\n繼續?
name.extract.interface=提取接口
name.introduce.import.alias=引入匯入別名
name.introduce.lambda.parameter=引入 Lambda 參數
name.introduce.parameter1=引入參數
name.introduce.type.alias=引入類型別名
title.kdoc.for.abstracts=Abstract 的 KDoc
naming.convention.will.be.violated.after.rename=重命名後將違反命名慣例
parameter.name.is.invalid=參數名 ''{0}'' 無效
parameter.type.is.invalid=參數類型 ''{0}'' 無效
parameter.types.are.not.denotable=無法提取方法，因為以下類型在目標作用域中不可表示：
refactoring.move.non.kotlin.file=目標必須是 Kotlin 檔案
return.type.is.invalid=返回類型無效
searching.usages.of.0.parameter=正在搜尋 ''{0}'' 參數的用法
selected.code.fragment.has.multiple.exit.points=選擇的程式碼段具有多個退出點
selected.code.fragment.has.multiple.output.values=選擇的程式碼段具有 3 個以上的輸出值：
selected.code.fragment.has.output.values.and.exit.points=選擇的程式碼段既有輸出值，也有可選的退出點
setter.of.0.will.become.invisible.after.extraction=提取後 {0} 的 Setter 將變為不可見
text.0.already.contains.1={0} 已包含 {1}
text.0.already.contains.nested.class.1={0} 已包含名為 {1} 的嵌套類
text.0.already.declared.in.1={0} 已在 {1} 中宣告
text.0.have.no.inheritors.warning={0} 沒有繼承者\n向下推動成員會導致它們被刪除。要繼續嗎?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={1} 中的 {0} 會在重構後覆寫 {2} 的相應成員
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} 繼承自 {1}。\n它不會受重構影響
text.0.is.invalid.destination.package=''{0}'' 是無效的目標軟體套件名稱
text.0.is.not.allowed.in.the.target.context=目標上下文中不允許出現 ''{0}''
text.0.is.not.valid.package.name={0} 不是有效的軟體套件名稱
text.0.to.inline=要內聯的 {0}
text.0.uses.1.which.is.not.accessible.from.2={0} 使用 {1}，後者無法從 {2} 存取
text.0.uses.1.which.will.be.inaccessible.after.move={0} 使用 {1}，後者在移動後將無法存取
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} 使用 {1}，後者無法從子類存取。
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} 使用 internal {1}，後者在移動後將無法存取
text.0.will.be.shadowed.by.1={0} 將被 {1} 隱藏
text.0.will.clash.with.existing.1.in.2=重命名後的 {0} 會與 {2} 中的現有 {1} 衝突
text.0.will.no.longer.be.accessible.after.signature.change={0} 在簽名更改後將無法存取
text.all.declarations.must.belong.to.the.same.directory.or.class=所有宣告必須屬於同一目錄或類
text.anonymous=[匿名]
text.at.least.one.file.must.be.selected=應至少選擇一個成員
text.callee.text.would.be.shown.here=此處將顯示被調用方文本
text.caller.text.with.highlighted.callee.call.would.be.shown.here=此處將顯示包含\n突出顯示的被調用方調用的調用方文本
text.cannot.create.target.directory.0=無法創建目標目錄 {0}
text.cannot.determine.source.directory=無法確定源目錄
text.cannot.find.package.corresponding.to.0=無法找到 {0} 對應的軟體套件
text.cannot.find.target.package.name=找不到目標軟體套件名稱
text.cannot.move.for.current.project=無法為當前專案移動
text.cannot.move.inner.class.0.into.itself=無法將嵌套的類 {0} 移動到類自身
text.cannot.move.to.original.file=無法移動到原始檔案
text.cannot.move.expect.actual.declaration.to.file=無法將預期/實際宣告移動到檔案
text.change.file.package.to.0=將檔案的軟體套件更改為 ''{0}''
text.choose.containing.file=選擇包含檔案
text.class.0.already.contains.member.1={0} 已包含 {1}
text.class.0.already.exists.in.package.1=類 {0} 在軟體套件 {1} 中已存在
text.class.0.already.exists.in.the.target.scope=類 {0} 在目標範圍中已存在
text.class.0.is.final={0} 為 final
text.constructor=構造函數
text.convert._it_.to.explicit.lambda.parameter=無法將 'it' 轉換為顯式 lambda 參數
text.create.destructuring.declaration=創建析構宣告
text.create.single.variable=創建單個變數
text.declaration=宣告
text.declarations.clash.move.0.destination.1.declared.in.scope.2=以下宣告將衝突: 移動 {0} 和在範圍 {2} 中宣告的目標 {1}
text.default.value=\ // 預設值 = {0}
text.destination.class.should.be.kotlin.class=目標類必須為 Kotlin 類
text.do.you.want.to.rename.0.as.well=同時重命名 {0}() 嗎?
text.do.you.want.to.rename.base.property.from.0=要從 {0} 重命名基本屬性嗎?
text.do.you.want.to.rename.base.property=要重命名基本屬性嗎?
text.duplicating.local.variable=正在複製局部變數 ''{0}''
text.duplicating.parameter=正在複製參數 ''{0}''
text.duplicating.property=正在複製屬性 ''{0}''
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=預設的 Kotlin 調用值可能會導致其他語言的程式碼不正確
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=其他語言可能不支持該預設參數
text.explicit.receiver.is.already.present.in.call.element.0=顯式接收器在調用元素中已存在: {0}
text.extract.superclass=提取超類
text.file.0.already.exists.in.1=檔案 {0} 在 {1} 中已存在
text.file.name.cannot.be.empty=文件名不能為空
text.function.already.exists=函數已存在: ''{0}''
text.function.in.ticks.0=函數 ''{0}''
text.function=函數
text.anonymous.function=匿名函數
text.implicit.companion.object.will.be.inaccessible.0=隱式伴生物件將無法存取: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=目標路徑不正確。目錄 {0} 不屬於當前專案。
text.indirect.outer.instances.will.not.be.extracted.0=將不會提取間接外部實例: {0}
text.inline.0=內聯 {0}
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=內聯所有引用並{0} {1} {2}
text.inline.recursive.function.is.supported.only.on.references=僅在引用上支援內聯遞歸函數
text.inline.this.reference.and.keep.the.0=內聯此引用並保留 {0}
text.inlining.0.1=正在內聯{0} {1}
text.inlined.0.overrides.0.1=已內聯的 {0} 覆寫 {0} {1}
text.inner.class.0.cannot.be.moved.to.intefrace={0} 是內部類。無法移動到接口
text.introduce.default.value=引入預設值(&D)
text.invalid.target.path.0=目標路徑 {0} 無效
text.invalid.target.specified=指定了無效目標
text.keep=保留
text.lambda.parameter=lambda 參數
text.lambda.parameters=Lambda 參數(&P):
text.lambda.return.type=Lambda 返回類型(&T)
text.lazy.property=延遲屬性
text.local.property=屬性
text.local.variable=局部變數
text.looking.for.usages=正在尋找用法…
text.member.0.in.super.class.will.clash.with.existing.member.of.1=超類中的 {0} 將與 {1} 的現有成員衝突
text.member.extension.call.will.not.be.processed.0=不會處理成員擴展調用: {0}
text.move.declaration.no.support.for.companion.objects=伴生物件不支持“移動宣告”
text.move.declaration.no.support.for.enums=枚舉條目不支持“移動宣告”
text.move.declaration.supports.only.top.levels.and.nested.classes=僅頂級宣告和嵌套類支援“移動宣告”
text.move.declaration.proceed.move.without.mpp.counterparts.text=此重構將移動選定的宣告(不包含可能導致編譯錯誤的預期/實際對應項)。\n是否要繼續?
text.move.declaration.proceed.move.without.mpp.counterparts.title=無法執行重構。此重構不支持 MPP 宣告。
text.move.declarations=移動宣告
command.move.declarations=移動宣告
text.no.destination.object.specified=未指定目標物件
title.select.a.name.for.this.parameter=為 ''this@{0}'' 參數選擇一個名稱
text.move.method.is.not.supported.for.non.project.methods=非專案方法不支持 Move 方法
text.move.method.is.not.supported.for.generic.classes=泛型類不支持 Move 方法
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=當方法是繼承層次結構的一部分時，不支持 Move 方法
text.references.to.outer.classes.have.to.be.added.manually=移動後必須手動添加對外部類的引用
action.move.method=移動方法…
text.move.file.0=移動 {0}
text.move.refactoring.not.available.during.indexing=當索引編制正在進行時，無法使用“移動”重構
text.moving.multiple.nested.classes.to.top.level.not.supported=不支持將多個嵌套類移動到頂級
text.Name=名稱
text.nested.classes.to.upper.level=嵌套類到上一級
text.no.elements.to.move.are.selected=未選擇要移動的元素
text.no.files.to.move=沒有要移動的給定檔案
text.no.name.provided.for.type.alias=沒有為類型別名提供名稱
text.no.package.corresponds.to.directory=沒有對應於此目錄的軟體套件
text.non.kotlin.0.will.not.be.affected.by.refactoring=非 Kotlin {0} 將不會受重構影響
text.overload=多載
text.package.directive.dont.match.file.location=軟體套件指令與檔案位置不符合
text.parameter.0=參數 ''{0}''
text.parameter.name=參數名(&N):
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=參數引用無法安全地取代為 {0}，因為 {1} 在此上下文中不明確
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=參數引用無法安全地取代為 {0}，因為在此上下文中無法引用目標函數
text.parameter.type=參數類型(&T):
text.parameter=參數
text.parameters=參數(&P)
text.proceed.with.extraction=繼續提取
text.process.duplicates=處理重複項
text.processing.file.0=正在處理 {0}
text.property.in.ticks.0=屬性 ''{0}''
text.property.with.getter=包含 getter 的屬性
text.property.with.initializer=包含初始設定式的屬性
text.property=屬性
text.pushed.member.will.not.be.available.in.0=推送的成員無法在 ''{0}'' 中使用
text.qualified.call.will.not.be.processed.0=將不會處理限定調用: {0}
text.receiver.can.t.be.safely.transformed.to.value.argument=接收器無法安全地轉換為值實參: {0}
text.receiver=接收器
text.refactoring.can.t.be.performed.on.the.selected.code.element=無法對選定的程式碼元素執行重構
text.refactoring.is.not.applicable.to.this.code.fragment=重構不適用於此程式碼段
text.references.in.code.to.0.1.and.its.declarations=在程式碼中引用{0} {1} 及其宣告
text.remove.0.no.longer.used=移除不再使用的{0}
text.remove.question=移除 '?'
text.remove=移除
text.rename.as.part.of.phrase=重命名
text.rename.is.not.applicable.to.secondary.constructors=“重命名”不適用於輔助構造函數
text.rename.is.not.applicable.to.synthetic.declarations=“重命名”不適用於合成宣告
text.rename.not.applicable.to.backing.field.reference=“重命名”不適用於支援欄位引用
text.rename.not.applicable.to.dynamically.invoked.methods=“重命名”不適用於動態調用的成員
text.rename.overloads.title=重命名多載
title.rename.overloads.to=將重載重命名為:
text.rename.parameters.title=重命名參數
title.rename.warning=重命名警告

text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' 必須隨密封的父類及其全部子類一起移動
text.sealed.class.0.must.be.moved.with.all.its.subclasses=密封類 ''{0}'' 必須隨其所有子類一起移動

text.sealed.broken.hierarchy.none.in.target=''{0}'' 的密封層次結構將被拆分。它的成員都不在模組 ''{2}'' 的軟體套件 ''{1}'' 中: {3}。
text.sealed.broken.hierarchy.still.in.source=''{0}'' 的密封層次結構將被拆分。模組 ''{2}'' 的軟體套件 ''{1}'' 仍將包含其成員: {3}。

text.select.target.code.block.file=選擇目標程式碼塊/檔案
text.select.target.code.block=選擇目標程式碼塊
text.select.target.file=選擇目標檔案
text.there.is.already.a.parameter={1} 中已存在參數 ''{0}''。它會與新參數衝突。
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter={1} 中已存在變數 ''{0}''。它會與新參數衝突。
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=類型別名無法引用在定義範圍中無法存取的類型
text.type.alias.name.must.be.a.valid.identifier.0=類型別名名稱必須為有效的關鍵字: {0}
text.type.alias=類型別名
text.type.already.exists.in.the.target.scope=類型 {0} 在目標範圍中已存在
text.type.parameter.names.must.be.distinct=類型參數名稱必須不同
text.type.parameters=類型參數(&P)
text.type=類型
text.unexpected.element.type.0=意外元素類型: {0}
text.update.usages.to.reflect.declaration.0.move=更新用法以反映{0, choice, 0#宣告n|1#宣告}移動
text.updating.usages.progress=正在更新用法…
text.cannot.inline.reference.from.0.to.1=無法將引用從 {0} 內聯到 {1}
title.inline.function=內聯函數
title.inline.property=內聯屬性
title.inline.type.alias=內聯類型別名
refactoring.cannot.be.applied.no.sources.attached={0} 重構無法套用: 未附加任何源
refactoring.cannot.be.applied.to.abstract.declaration={0} 重構不能應用於 abstract 宣告
refactoring.cannot.be.applied.to.expect.declaration={0} 重構不能應用於 expect 宣告
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} 重構不能在未經調用的情況下應用於匿名函數
refactoring.the.function.not.found=找不到函數
refactoring.the.function.cannot.be.converted.to.anonymous.function=該函數不能轉換為匿名函數
refactoring.the.invocation.cannot.be.resolved=調用無法解析
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} 重構不能在未經調用的情況下應用於 lambda 表達式
text.reference.cannot.be.converted.to.a.lambda=引用無法轉換為 lambda
title.introduce.parameter.to.declaration=將參數引入宣告
title.move.nested.classes.to.upper.level=將嵌套類移動到上一級
title.move.method=Move 方法
title.choose.destination.object=選擇目標物件
title.select.target.code.block=選擇目標程式碼塊
unsupported.usage.0=不支持的用法: {0}
parameter.used.in.declaration.body.warning=''{0}'' 用於宣告體

do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=要在預期宣告和所有相關實際宣告中刪除此參數嗎?
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=要刪除預期宣告和所有相關實際宣告嗎?
delete.with.usage.search=刪除 (通過用法搜尋)

destination.not.found.for.package.0=沒有為軟體套件 ''{0}'' 找到目標
premature.end.of.template=模板過早結束
choose.target.class.or.interface=選擇目標類或接口
text.abstract=抽象
text.secondary.constructor=輔助構造函數
text.create=創建
text.member=成員
text.extension=擴展
text.object=物件
text.interface=接口
text.enum.constant=枚舉常數
text.enum=枚舉
text.annotation=註解
create.0.1=創建 {0} ''{1}''
choose.class.container=選擇類容器
file.0.already.exists.but.does.not.correspond.to.kotlin.file=檔案 {0} 已存在，但與 Kotlin 檔案不對應
create.file=創建檔案
create.0=創建 {0}
create.package.0=創建軟體套件 ''{0}''
text.type.parameter=類型{0, choice, 0#參數|2#參數}
create.0.in.1=在 {1} 中創建 {0}
searching.0=正在搜尋 {0}…
create.property.0.as.constructor.parameter=作為構造函數參數創建屬性 ''{0}''
create.parameter.0=創建參數 ''{0}''
add.property=添加屬性
text.add=添加 '
property.0.to.1='' 屬性 ''{0}'' 到 ''{1}''
add.method=添加方法
add.0.constructor.to.1=將 {0} 構造函數添加到 ''{1}''
text.secondary=輔助
text.primary=主
add.method.0.to.1=將方法 ''{0}'' 添加到 ''{1}''
create.actual.0.for.module.1.2=為模組 {1} 創建實際{0} ({2})
create.expected.0.in.common.module.1=在通用模組 {1} 中創建預期{0}
repair.actual.members=修復實際成員
these.declarations.cannot.be.transformed=無法轉換這些宣告:
unknown.types.title=未知類型
choose.actual.members.title=選擇實際成員
text.annotation.class=註解類
text.enum.class=枚舉類
text.class=類
type.0.1.is.not.accessible.from.target.module=無法從目標模組存取{0, choice, 0#類型|2#類型} {1}
the.function.declaration.shouldn.t.have.a.default.implementation=函數宣告不應具有預設實作
some.types.are.not.accessible.from.0.1=無法從 {0} 存取一些類型:\n{1}
the.declaration.has.0.modifier=宣告包含 ''{0}'' 修飾符
inaccessible.declaration=無法存取的宣告
fix.with.asdynamic=使用 'asDynamic' 修復
migrate.type.parameter.list.syntax=遷移類型參數列表語法
replace.deprecated.symbol.usage=取代棄用的符號用法
replace.with.0=取代為 ''{0}''
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=通過此別名使用的 ''{0}'' 上有自己的 ''ReplaceWith''。請先取代用法。
replace.deprecated.symbol.usage.in.whole.project=取代整個專案中棄用的符號用法
applying.0=正在套用 ''{0}''
replace.usages.of.0.in.whole.project=取代整個專案中的 ''{0}'' 用法
replace.with.publishedapi.bridge.call=取代為 @PublishedApi 橋調用
replace.with.generated.publishedapi.bridge.call.0=取代為生成的 @PublishedApi 橋調用 ''{0}''
convert.sealed.sub.class.to.object.fix.family.name=將密封的子類轉換為物件
generate.identity.equals.fix.family.name=通過標識生成 equals 和 hashCode
change.type.of.0.to.1=將 {0} 的類型更改為 ''{1}''
change.type.to.0=將類型更改為 ''{0}''
base.property.0=基本屬性 {0}
make.0=設為{0}
make.0.1.explicitly=將 ''{0}'' 明確設為{1}
make.0.explicitly=明確生成{0}
use.inherited.visibility=使用繼承的可見性
replace.with.in.when=將 ',' 取代為 '||':
remove.0=移除 ''.{0}''
remove.conversion.from.kclass.to.class=移除從 'KClass' 到 'Class' 的轉換
convert.from.class.to.kclass=將 'KClass' 轉換為 'Class'
convert.to.0=轉換為 {0}
convert.expression.to.0.by.inserting.1=通過插入 ''.{1}'' 將表達式轉換為 ''{0}''
convert.extension.property.initializer.to.getter=將擴展屬性初始設定式轉換為 getter
convert.supertype.to.0=將父類型轉換為 ''{0}''
convert.extension.function.type.to.regular.function.type=將擴展函數類型轉換為一般函數類型
convert.to.notnull.delegate=轉換為非 null 委託
convert.to.anonymous.object=轉換為匿名物件
select.loop.statement.to.label=選擇要標記的迴圈語句
select.lambda.to.label=選擇要標記的 lambda
create.label=創建標籤
create.label.0=創建標籤 {0}@
convert.member.to.extension=將成員轉換為擴展
replace.annotation=取代註解
replace.annotation.with.0=將註解取代為 {0}
add.initializer=添加初始設定式
move.to.constructor.parameters=移動到構造函數參數
initialize.with.constructor.parameter=使用構造函數參數初始化
inline.type.parameter=內聯類型參數
insert.explicit.delegation.call=插入顯式委託調用
kotlin.add.required.module.fix.family.name=將 'requires' 指令添加到 module-info.java
the.anonymous.object=匿名物件
text.implement=實作
text.extend=擴展
let.0.1=使{0} {1}
let.type.implement.interface=使類型實作接口
0.interface.1={0}接口 ''{1}''
lift.assignment.out.of.try.expression=從 'try' 表達式中提取賦值
make.class.an.annotation.class=使類為註解類
make.0.an.annotation.class=將 ''{0}'' 設為註解類
make.constructor.parameter.a.property.0=使構造函數參數為屬性{0}
in.class.0=在類 ''{0}'' 中
add.0.to.module.1.compiler.arguments=將 ''{0}'' 添加到模組 {1} 編譯器實參
add.an.opt.in.requirement.marker.compiler.argument=添加選擇加入要求標記編譯器實參
make.0.in.1.open=使 {1} 中的 ''{0}'' 開啟
add.modifier=添加修飾符
make.private.and.0.1=設為 private 並{0} ''{1}''
text.overrides=覆寫
text.implements=實作
make.type.parameter.reified.and.function.inline=使類型參數具體化且使函數內聯
change.all.usages.of.0.in.this.file.to.1=將此檔案中所有的 ''{0}'' 用法例更改為 ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=將此檔案中所有的 ''{0}'' 用法例更改為 Kotlin 類
change.to.kotlin.class=更改為 Kotlin 類
choose.an.appropriate.kotlin.class=選擇適當的 Kotlin 類
add.empty.brackets.after.primary.constructor=在主構造函數後添加空括號
add.constructor.keyword=添加 'constructor' 關鍵字
move.annotation.to.receiver.type=將註解移動到接收器類型
move.type.parameter.constraint.to.where.clause=將類型參數約束移動到 'where' 子句
move.else.branch.to.the.end=將 else 分支移動到末尾
insert.number.conversion=插入數字轉換
convert.expression.to.0=將表達式轉換為 ''{0}''
remove.from.annotation.argument=從註解實參中移除 @
remove.default.parameter.value=移除預設參數值
remove.final.upper.bound=移除最終上限
remove.function.body=移除函數體
make.0.not.1=將{0}設為非 {1}
remove.0.modifier=移除 ''{0}'' 修飾符
remove.modifier=移除修飾符
remove.identifier.from.anonymous.function=從匿名函數中移除關鍵字
remove.constructor.call=移除構造函數調用
make.not.nullable=設為不可為 null
remove.useless=移除無用的 '?'
remove.redundant=移除冗餘的 '?'
remove.0.from.property=從屬性中移除{0}
remove.parts.from.property=從屬性中移除部分
text.initializer=初始設定式
text.setter=setter
text.getter=getter
remove.element=移除元素
for.0=對於 ''{0}''
remove.conflicting.import.0=移除衝突的匯入 {0}
remove.type.parameters=移除類型參數
remove.type.arguments=移除類型實參
remove.star=移除 '*'
remove.variable.0=移除變數 ''{0}''
remove.redundant.initializer=移除冗餘的初始設定式
remove.redundant.label=移除冗餘標籤
remove.single.lambda.parameter.declaration=移除單個 lambda 參數宣告
remove.supertype=移除父類型
remove.0.variance.from.1=從 ''{1}'' 中移除 ''{0}'' 差異
remove.parameter.0=刪除參數 ''{0}''
remove.redundant.assignment=移除冗餘賦值
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=在分配給變數 ''{0}'' 的表達式中發現可能的副作用<br>您可以:<br>-\\&nbsp;<b>移除</b>整個賦值，或<br>-\\&nbsp;<b>將賦值右側轉換</b>為其自己的語句。<br>
remove.useless.cast=移除無用的轉換
remove.useless.elvis.operator=移除無用的 elvis 運算符
remove.useless.is.check=移除無用的 is 檢查
remove.val.var.from.parameter=從參數中移除 'val/var'
remove.0.from.parameter=從參數中移除 ''{0}''
remove.else.branch=移除 else 分支
remove.branch=移除分支
remove.condition=移除條件
rename.identifier.fix.text=重命名
rename.to.0=重命名為 ''{0}''
rename.parameter.to.match.overridden.method=重命名參數以符合覆寫的方法
rename.to.underscore=重命名為 _
replace.with.safe.this.call=取代為安全的 (this?.) 調用
replace.with.safe.call=取代為安全的 (?.) 調用
replace.scope.function.with.safe.call=將範圍函數取代為 (?.) 調用
replace.with.dot.call=取代為點調用
replace.invalid.positioned.arguments.for.annotation=取代註解的無效定位實參
replace.jvmfield.with.const=將 '@JvmField' 取代為 'const'
replace.modifier=取代修飾符
update.obsolete.label.syntax=更新過時的標籤語法
replace.with.label.0.at=取代為標籤 {0}@
replace.cast.with.call.to.to.0=將轉換取代為對 ''to{0}()'' 的調用
replace.cast.with.primitive.conversion.method=將轉換取代為基元轉換方法
replace.with.array.call=取代為數組調用
remove.expression.target=移除表達式目標
change.existent.retention.to.source=將現有保留更改為源
add.source.retention=添加源保留
round.using.0=使用 {0}() 舍入
simplify.0.to.1=將 {0} 簡化為 ''{1}''
simplify.comparison=簡化對比
specify.override.for.0.explicitly=為 ''{0}'' 顯式指定覆寫
specify.override.explicitly=顯式指定覆寫
specify.return.type.explicitly=顯式指定返回類型
specify.type.explicitly=顯式指定類型
add.constructor.parameters.from.0.1=從 {0}{1} 添加構造函數參數
change.to.constructor.invocation=更改為構造函數調用
add.constructor.parameters.from.superclass=從超類添加構造函數參數
surround.with.star.0=使用 *{0}(...) 環繞
surround.with.lambda=使用 lambda 環繞
surround.with.null.check=使用 null 檢查環繞
convert.too.long.character.literal.to.string=將過長的字符文字轉換為字串
replace.array.of.boxed.with.array.of.primitive=將裝箱陣列取代為基元陣列
migrate.unsupported.yield.syntax=遷移不受支援的 yield 語法
wrap.with=使用 [] 包裝
wrap.with.array.literal=使用陣列文字包裝
wrap.with.collection.literal.call=使用集合文字調用包裝
wrap.element.with.0.call=使用 ''{0}()'' 調用包裝元素
replace.with.0.call=取代為 ''{0}()'' 調用
wrap.with.let.call=使用 ''?.let { ... }'' 調用包裝
change.to.0=更改為 ''{0}''
change.to.correct.long.suffix.l=更改為正確的長後綴 'L'
change.to.correct.primitive.type=更改為正確的基元類型
0.from.1={0} 來自 {1}
checking.data.classes=正在檢查資料類
checking.data.class.0.of.1=正在檢查資料類 {0}/{1}…
difference.found.for.data.class.0.found.1.2=為數據類 {0} 找到差異。找到 {1} 個用法，但應為 {2}
title.error=錯誤
analyzed.0.classes.no.difference.found=已分析 {0} 類。未找到差異。
title.success=成功
can.t.finish.while.indexing.is.in.progress=當索引編制正在進行時，無法完成
enable.tremble.dumb.mode=啟用靜音震動模式
disable.tremble.dumb.mode=禁用靜音震動模式
progress.finding.implicit.nothing.s=正在尋找隱式無內容
scanning.files.0.fo.1.file.2.occurrences.found=正在掃描檔案: 第 {0} 個，共 {1} 個。已找到 {2} 個匹配項
implicit.nothing.s=隱式無內容
not.found.in.0.files=在 {0} 個檔案中未找到
titile.not.found=未找到
search.for.not.property.candidates=搜尋非屬性候選項
enter.package.fqname=輸入軟體套件 FqName
searching.for.not.property.candidates=正在搜尋非屬性候選項
step.1.collecting.0.1.2=第 1 步: 收集 {0}:{1}:{2}
step.2.0.of.1=第 2 步: {0}/{1}
step.3.0.of.1=第 3 步: {0}/{1}
title.done=完成
revert.applied.imports.command=還原已套用的匯入
delete.0=刪除 {0}
replace.if.expression.with.elvis.expression=將 'if' 表達式取代為 elvis 表達式
report.also.on.statement=也在語句上報告
if.then.foldable.to=If-Then 可折疊為 '?:'
replace.if.expression.with.safe.access.expression=將 'if' 表達式取代為安全存取表達式
remove.redundant.if.expression=移除冗餘 'if' 表達式
replace.if.expression.with.safe.cast.expression=將 'if' 表達式取代為安全的轉換表達式
simplify.foldable.if.then=簡化可折疊的 if-then
foldable.if.then=可折疊的 if-then
introduce.when.subject=引入 'when' 主體
when.with.subject.should.be.used=應使用包含主體的 'when'
introduce.0.as.subject.0.when=將 ''{0}'' 作為 ''when'' 的主體引入
convert.call.chain.into.sequence.fix.text=將調用鏈轉換為 'Sequence'
call.chain.length.to.transform=要轉換的調用鏈長度:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=可以將集合上的調用鏈轉換為 'Sequence' 來改善性能
remove.redundant.call.fix.text=移除冗餘調用
rename.useless.call.fix.text=將調用更改為 ''{0}''
call.chain.on.collection.type.may.be.simplified=可以簡化集合類型上的調用鏈
0.call.could.be.simplified.to.1={0} 調用可以簡化為 {1}
simplify.call.fix.text=將 ''{0}'' 調用轉換為 ''{1}''
simplify.call.chain.fix.text=將調用鏈合併為 ''{0}''
call.on.collection.type.may.be.reduced=可以簡化集合類型上的調用
useless.call.on.collection.type=集合類型上存在無用調用
this.call.is.useless.with=此調用對 ?. 無用
useless.call.on.not.null.type=非 null 類型上存在無用調用
call.on.not.null.type.may.be.reduced=可以簡化非 null 類型上的調用
replace.total.order.equality.with.ieee.754.equality=使用 IEEE 754 等式取代總訂單等式
replace.with.binary.operator=取代為二元運算符
call.replaceable.with.binary.operator=調用可被取代為二元運算符
replace.get.or.set.call.with.indexing.operator=將 get 或 set 調用取代為索引運算符
should.be.replaced.with.indexing=應取代為索引
replace.0.call.with.indexing.operator=將 ''{0}'' 調用取代為索引運算符
function.returning.0.with.a.name.that.does.not.end.with.1=返回名稱不以 {1} 結尾的 {0} 的函數
add.call.or.unwrap.type.fix.text=將 ''.{0}()'' 添加到函數結果 (中斷使用站點!)
add.call.or.unwrap.type.fix.text1=解開 ''{0}'' 返回類型(中斷 use-site!)
reports.only.function.calls.from.kotlinx.coroutines=僅報告來自 'kotlinx.coroutines' 的函數調用
deferred.result.is.never.used='Deferred' 結果未被使用
function.0.returning.1.without.the.corresponding=函數 ''{0}'' 返回 ''{1}''，而相應的函數 ''{2}'' 未返回 ''{3}''
redundant.async.call.may.be.reduced.to.0=冗餘 ''async'' 調用可簡化為 ''{0}''
redundant.runcatching.call.may.be.reduced.to.0=冗餘 ''runCatching'' 調用可簡化為 ''{0}''
rename.to.fix.text=重命名為 ''{0}''
wrap.with.coroutine.scope.fix.text=使用 ''coroutineScope { ... }'' 包裝函數體
wrap.with.coroutine.scope.fix.text2=使用 ''coroutineScope { ... }'' 包裝調用
wrap.with.coroutine.scope.fix.text3=移除接收器並使用 ''coroutineScope { ... }'' 包裝
wrap.with.coroutine.scope.fix.family.name=使用 coroutineScope 包裝
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=由於掛起函數的 CoroutineScope 接收器，coroutineContext 不明確
replace.with.kotlin.analog.function.family.name=取代為 Kotlin 模擬
should.be.replaced.with.kotlin.function=應取代為 Kotlin 函數
replace.with.kotlin.analog.function.text=取代為 ''{0}'' 函數
add.documentation.fix.text=添加文檔
missing.documentation=缺少文檔
0.is.missing.documentation={0} 缺少文檔
library.should.be.updated.to.be.compatible.with.kotlin.1.3=應更新庫以與 Kotlin 1.3 相容
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=從 1.3 起，禁止使用 MIN_VALUE 步驟調用 {0}
obsolete.coroutine.usage.in.whole.fix.family.name=修復專案中的實驗性協同程序用法
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=修復專案中的 'kotlin.dom' 和 'kotlin.browser' 軟體套件用法
apply.in.the.project.0=在專案中套用: {0}
obsolete.coroutine.usage.fix.family.name=修復實驗性協同程序用法
obsolete.package.usage.fix.family.name=修正 ''{0}'' 軟體套件用法
0.is.expected.to.be.used.since.kotlin.1.3=從 Kotlin 1.3 起，預期使用 ''{0}''
methods.are.absent.in.coroutines.class.since.1.3=從 1.3 起，協同程序類中不存在方法
experimental.coroutines.usages.are.obsolete.since.1.3=從 1.3 起，實驗性協同程序用法遭到廢棄
package.usages.are.obsolete.since.1.4=''{0}'' 軟體套件用法自 1.4 起已過時
replace.substring.call.with.droplast.call=將 'substring' 調用取代為 'dropLast' 調用
replace.substring.call.with.indexing.operation.call=將 'substring' 調用取代為索引操作調用
replace.substring.call.with.substringbefore.call=將 'substring' 調用取代為 'substringBefore' 調用
replace.substring.call.with.substringafter.call=將 'substring' 調用取代為 'substringAfter' 調用
replace.substring.call.with.take.call=將 'substring' 調用取代為 'take' 調用
add.operator.modifier=添加 'operator' 修飾符
function.should.have.operator.modifier=函數應具有 'operator' 修飾符
type.parameter.can.have.0.variance=類型參數可以具有 ''{0}'' 差異
add.variance.fix.text=添加 ''{0}'' 差異
add.variance.fix.family.name=添加差異
interface.member.dependency.required.by.interfaces={0,choice,1#接口|2#接口}所需
generate.equals.and.hashcode.fix.text=生成 equals() 和 hashCode()
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode='data' 類中存在類型為 'Array' 的屬性: 建議覆寫 'equals()' 和 'hashCode()'
report.also.on.call.with.single.boolean.literal.argument=同時在包含單個布爾文字實參的調用上報告
boolean.literal.argument.without.parameter.name=不包含參數名稱的布爾文字實參
constructor.parameter.is.never.used.as.a.property=構造函數參數從未被用作屬性
property.is.explicitly.assigned.to.parameter.0.can=屬性已明確分配給參數 {0}，因此可以直接在構造函數中宣告
variable.is.never.modified.and.can.be.declared.immutable.using.val=變數從未被修改，因此可以使用 'val' 宣告
sealed.sub.class.has.no.state.and.no.overridden.equals='sealed' 子類沒有狀態，且沒有被覆寫的 'equals()'
cascade.if.should.be.replaced.with.when=級聯 'if' 應取代為 'when'
mark.as.deprecated.level.deprecationlevel.hidden=標記為 '@Deprecated(..., level = DeprecationLevel.HIDDEN)'
searching.for.imports.to.delete.title=正在搜尋要刪除的匯入
delete.redundant.extension.property=刪除冗餘擴展屬性
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=屬性與合成擴展衝突，應移除或重命名，以避免未來版本的 Kotlin 編譯器破壞程式碼
condition.is.always.0=條件始終為 ''{0}''
remove.fix.text=刪除表達式
simplify.fix.text=簡化表達式
0.has.empty.body=''{0}'' 具有空體
convert.na.n.equality.quick.fix.text=取代為 'isNaN()'
equality.check.with.nan.should.be.replaced.with.isnan=包含 NaN 的相等檢查應取代為 'isNaN()'
convert.pair.constructor.to.to.fix.text=取代為中綴 'to'
can.be.converted.to.to=顯式 'Pair' 初始化可被取代為中綴 'to()' 調用
convert.to.a.range.check=轉換為範圍檢查
two.comparisons.should.be.converted.to.a.range.check=兩個比較應轉換為範圍檢查
copy.method.of.data.class.is.called.without.named.arguments=應為 'copy()' 方法調用顯式指定參數名稱
private.data.class.constructor.is.exposed.via.the.generated.copy.method=private 主構造函數通過 'data' 類的生成的 'copy' 方法公開。
remove.var.keyword.text=移除 'var'
delegating.to.var.property.does.not.take.its.changes.into.account=委託給 'var' 屬性不會考慮其更改
add.replacewith.argument.to.specify.replacement.pattern=添加 'replaceWith' 實參以指定取代模式
deprecated.annotation.without.replacewith.argument=不包含 'replaceWith' 實參的 '@Deprecated' 註解
variable.name.0.matches.the.name.of.a.different.component=變數名稱 ''{0}'' 與其他組件的名稱符合
this.range.is.empty.did.you.mean.to.use.0=此範圍為空。是否要使用 ''{0}''?
equals.hashcode.in.object.declaration=物件宣告中的 'equals()'/'hashCode()'
hash.code.text=生成 'hashCode()'
equals.text=生成 'equals()'
delete.equals.and.hash.code.fix.text=刪除 equals()/hashCode()
redundant.explicit.this=冗餘顯式 this
explicit.this.expression.fix.family.name=移除冗餘的 ''{0}''
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=將非常數 Kotlin 屬性用作 Java 常數不正確。將在 1.4 中禁止
replace.if.with.elvis.operator=將 'if' 取代為 elvis 運算符
if.null.return.break.foldable.to=If-Null return/break/... 可折疊為 '?:'
loop.parameter.0.is.unused=未使用迴圈參數 ''{0}''
replace.with.repeat.fix.family.name=取代為 'repeat()'
introduce.anonymous.parameter.fix.family.name=引入匿名參數
wrap.run.fix.text=轉換為執行 { ... }
remove.braces.fix.text=移除大括號
report.for.types.with.platform.arguments=為包含平台實參的類型報告
apply.only.to.public.or.protected.members=僅應用於 public 或 protected 成員
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=宣告已從平台調用推斷出類型，這可能導致未檢查的為 null 性問題。將類型顯式指定為可為 null 或不可為 null。
callable.reference.fix.family.name=添加顯式 ''{0}''
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Java 集合 static 方法調用應取代為 Kotlin stdlib
replace.with.std.lib.fix.text=取代為 {0}.{1}
call.of.java.mutator.0.on.immutable.kotlin.collection.1=在不可變的 Kotlin 集合 ''{1}'' 上調用 Java 轉變器 ''{0}''
replace.with.kotlin.s.foreach=取代為 Kotlin 的 forEach
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Java Map.forEach 方法調用應取代為 Kotlin 的 forEach
remove.deprecated.symbol.import=移除棄用的符號匯入
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=使用了冗餘或棄用的語法或棄用的符號
equals.should.take.any.as.its.argument='equals' 應將 'Any?' 作為其實參
double.negation.fix.text=移除冗餘求反
redundant.double.negation=冗餘雙重求反
equals.between.objects.of.inconvertible.types='equals()' 位於不可轉換類型的物件之間
usage.of.kotlin.internal.declaration.from.different.module=使用了來自不同模組的 Kotlin 內部宣告
inheritance.of.kotlin.sealed=Java {0,choice,0#接口|1#類}不能作為 Kotlin 密封層次結構的一部分
junit.static.methods=JUnit static 方法
redundant.override.fix.text=移除冗餘覆寫方法
redundant.overriding.method=冗餘覆寫方法
throwable.instance.0.is.not.thrown=未引發 Throwable 實例 ''{0}''
result.of.0.call.is.not.thrown=未引發 ''{0}'' 調用的結果
optimize.imports=最佳化匯入
unused.import.directive=未使用的 import 指令
title.lateinit.var.overrides.lateinit.var='lateinit var' 覆寫 super 'lateinit var'
leaking.this.in.constructor.of.non.final.class.0=在非 final 類 {0} 的構造函數中泄漏 ''this''
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=在枚舉類 {0} (具有可覆寫成員) 的構造函數中泄漏 ''this''
accessing.non.final.property.0.in.constructor=正在存取構造函數中的非 final 屬性 {0}
calling.non.final.function.0.in.constructor=正在調用構造函數中的非 final 函數 {0}
text.can=可以
text.should=應當
text.Assignment=賦值
text.Return=返回
text.return=返回
0.1.be.lifted.out.of.2=可從 ''{1}'' 提取出 ''{0}''
lift.assignment.out.fix.text.0=從 ''{0}'' 中提取賦值
lift.return.out.fix.text.0=從 ''{0}'' 中提取返回
change.main.function.return.type.to.unit.fix.text=添加顯式 Unit 返回類型
change.main.function.return.type.to.unit.fix.text2=將返回類型更改為 Unit
0.should.return.unit={0} 應返回 Unit
map.get.with.not.null.assertion.operator=包含非 null 斷言運算符 '(!!)' 的 'map.get()'
replace.with.get.or.else.fix.text=取代為 'getOrElse' 調用
replace.with.get.value.call.fix.text=取代為 'getValue' 調用
replace.with.elvis.error.fix.text=取代為 '?: error("")'
might.be.const=可能為 'const'
const.might.be.used.instead.of.jvmfield=可能使用了 'const'，而不是 '@JvmField'
text.Function=函數
text.Property=屬性
0.1.could.be.private={0} ''{1}'' 可以為 private
diagnostic.name.should.be.replaced.by.the.new.one=診斷名稱應取代為新名稱
replace.diagnostic.name.fix.text={0} 取代為 {1}
replace.diagnostic.name.fix.family.name=取代診斷名稱
lambda.argument.0.be.moved.out=Lambda 實參 {0} 從括號中移出
move.lambda.argument.out.of.parentheses=將 lambda 實參移出圓括號
suspicious.callable.reference.as.the.only.lambda.element=可疑的可調用引用作為唯一的 lambda 元素
inline.variable=內聯變數
move.variable.declaration.into.when=將變數宣告移動到 'when' 中
nothing.to.do=沒有要執行的操作
variable.declaration.could.be.inlined=變數宣告可以內聯
variable.declaration.could.be.moved.into.when=變數宣告可以移動到 'when' 中
may.contain.only.letters.digits.or.underscores=僅可以包含字母、數字或下劃線
may.contain.only.letters.and.digits=僅可以包含字母和數字
should.not.contain.underscores.in.the.middle.or.the.end=中間或結尾不應包含下劃線
should.not.start.with.an.underscore=不應以下劃線開頭
should.not.start.with.an.uppercase.letter=不應以大寫字母開頭
should.not.contain.underscores=不應包含下劃線
should.start.with.a.lowercase.letter=應以小寫字母開頭
should.start.with.an.uppercase.letter=應以大寫字母開頭
doesn.t.match.regex.0=與正則表達式 ''{0}'' 不符合
text.pattern=模式:
package.name=軟體套件名稱
text.part=部分
text.name=名稱
text.Package=軟體套件
add.explicit.parameter.to.outer.lambda.fix.text=將顯式參數名稱添加到外部 lambda
implicit.parameter.it.of.enclosing.lambda.is.shadowed=封閉 lambda 的隱式參數 'it' 已被隱藏
equality.cehck.0.be.used.instead.of.elvis.for.nullable.boolean.check=使用相等檢查 {0} 而不是 elvis 進行可為 null 的布爾檢查
replace.with.equality.check.fix.text=取代為相等檢查
null.checks.to.safe.call.check.fix.text=將鏈式 null 檢查取代為安全的調用
null.checks.replaceable.with.safe.calls=null 檢查可被取代為安全調用
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=可選預期註解在用於平台 {1} 的模組 {0} 中沒有實際註解
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=調用包含可為 null 的接收器的 'inline fun' 在 Kotlin 1.2 及更低版本中可能引起 'NPE'
make.open.fix.text=使類開放
make.private.fix.text=設為 private
protected.visibility.is.effectively.private.in.a.final.class='protected' 可見性在 final 類中實際是 'private'
apply.also.to.private.members=同時應用於 private 成員
apply.also.to.internal.members=同時應用於 internal 成員
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=為確保 API 穩定性，建議顯式指定宣告類型
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=為確保 API 穩定性，建議顯式指定 public 和 protected 宣告類型
recursive.equals.call=遞歸 equals 調用
replace.with.field.fix.text=取代為 'field'
recursive.synthetic.property.accessor=遞歸合成屬性存取器
recursive.property.accessor=遞歸屬性存取器
remove.redundant.companion.reference.fix.text=移除冗餘伴生引用
redundant.companion.reference=冗餘伴生引用
remove.redundant.else.fix.text=移除冗餘的 'else'
redundant.else=冗餘的 'else'
remove.initializer.block.fix.text=移除初始設定式塊
redundant.empty.initializer.block=冗餘空白初始設定式塊
remove.enum.constructor.invocation.fix.text=移除枚舉構造函數調用
redundant.enum.constructor.invocation=冗餘枚舉構造函數調用
explicitly.given.type.is.redundant.here=顯式給定類型在此處冗餘
remove.redundant.getter.fix.text=移除冗餘 getter
redundant.getter=冗餘 getter
remove.redundant.if.text=移除冗餘 'if' 語句
redundant.if.statement=冗餘的 'if' 語句
delete.fix.family.name=移除箭頭
redundant.lambda.arrow=冗餘 lambda 箭頭
remove.let.call=移除 'let' 調用
redundant.let.call.could.be.removed=可以移除冗餘 'let' 調用
redundant.modality.modifier=冗餘形式修飾符
this.type.probably.can.be.changed.to.nullable=此類型或許可以更改為可為 null
redundant.type.checks.for.object=物件的冗餘類型檢查
replace.with.equality.fix.text=將 ''{0}'' 取代為 ''{1}''
redundant.0.call=冗餘的 ''{0}'' 調用
remove.require.not.null.call.fix.text=移除 ''{0}'' 調用
remove.return.label.fix.text=移除冗餘 ''@{0}''
remove.return.label.fix.family=移除冗餘標籤
redundant.0=冗餘 ''@{0}''
remove.redundant.sam.constructors=移除冗餘 SAM 構造函數
remove.redundant.sam.constructor=移除冗餘 SAM 構造函數
redundant.sam.constructors=冗餘 SAM 構造函數
redundant.sam.constructor=冗餘 SAM 構造函數
fix.text=移除冗餘分號
redundant.semicolon=冗餘分號
remove.redundant.setter.fix.text=移除冗餘 setter
redundant.setter=冗餘 setter
redundant.suspend.modifier=冗餘 'suspend' 修飾符
redundant.unit.return.type=冗餘 'Unit' 返回類型
redundant.visibility.modifier=冗餘可見性修飾符
remove.redundant.unit.fix.text=移除冗餘 'Unit'
redundant.unit=冗餘 'Unit'
remove.redundant.with.fix.text=移除冗餘'with' 調用
remove.jvmoverloads.annotation=移除 @JvmOverloads 註解
remove.jvmfield.annotation=移除 @JvmField 註解
report.also.for.a.variables.without.a.whitespace.around=同時為周圍沒有空格的變數報告
remove.curly.braces=移除大括號
redundant.curly.braces.in.string.template=字串模板中的冗餘大括號
remove.empty.parentheses.from.annotation.entry.fix.text=移除不必要的圓括號
parentheses.should.be.removed=應移除括號
remove.redundant.qualifier.name.quick.fix.text=移除冗餘限定符名稱
redundant.qualifier.name=冗餘限定符名稱
remove.redundant.backticks.quick.fix.text=移除冗餘反引號
remove.redundant.spread.operator.quickfix.text=移除冗餘展開運算符
remove.to.string.fix.text=移除 'toString()' 調用
redundant.tostring.call.in.string.template=字串模板中存在冗餘 'toString()' 調用
redundant.setter.parameter.type=冗餘 setter 參數類型
replace.with.contentequals=將 '!=' 取代為 'contentEquals'
replace.with.contentequals2=將 '==' 取代為 'contentEquals'
replace.with.contentequals3=取代為 'contentEquals'
dangerous.array.comparison=危險的陣列比較
replace.with.array.literal.fix.family.name=取代為 [...]
0.call.should.be.replaced.with.array.literal=''{0}'' 調用應取代為數組文字 [...]
replace.assert.boolean.with.assert.equality=將斷言布爾取代為斷言等式
replace.0.with.1=將 ''{0}'' 取代為 ''{1}''
replace.collection.count.with.size.quick.fix.text=將 'count' 取代為 'size'
could.be.replaced.with.size=可被取代為 'size'
replace.with.kotlin.s.function.call=取代為 kotlin 的函數調用
replace.guard.clause.with.kotlin.s.function.call=將臨界子句取代為 Kotlin 的函數調用
replace.index.loop.with.collection.loop.quick.fix.text=取代為元素的迴圈
replace.manual.range.with.indices.call.quick.fix.text=取代為索引
range.could.be.replaced.with.indices.call=範圍可被取代為 '.indices' 調用
for.loop.over.indices.could.be.replaced.with.loop.over.elements=索引的迴圈可被取代為元素的迴圈
replace.negated.0.with.1=將求反的 ''{0}'' 取代為 ''{1}''
replace.with.elvis.return.fix.text=取代為 ''?: return{0}''
replace.with.return=將 '!!' 取代為 '?: return'
convert.put.to.assignment=將 put 轉換為賦值
map.put.should.be.converted.to.assignment=map.put() 應轉換為賦值
replace.int.range.end.inclusive.with.last.quick.fix.text=將 'endInclusive' 取代為 'last'
replace.int.range.start.with.first.quick.fix.text=將 'start' 取代為 'first'
could.be.replaced.with.unboxed.last=可被取代為未裝箱的 'last'
could.be.replaced.with.unboxed.first=可被取代為未裝箱的 'first'
replace.with.until.quick.fix.text=取代為 until
replace.with.string.literal.fix.family.name=取代為字串模板
replace.tostring.with.string.template=將 'toString' 取代為字串模板
replace.to.with.infix.form.quickfix.text=將 'to' 取代為中綴形式
replace.with.enum.map.fix.text=取代為 'EnumMap'
replaceable.with.enummap=可被取代為 'EnumMap'
replace.with.operator.assignment=取代為運算符賦值
replaceable.with.operator.assignment=可被取代為運算符賦值
replace.with.if.fix.text=取代為 'if' 類型檢查
should.be.replaced.with.if.type.check=應取代為 'if' 類型檢查
call.is.replaceable.with.another.scope.function=調用可被取代為另一個範圍函數
convert.scope.function.fix.family.name=轉換為 ''{0}''
variable.0.is.assigned.to.itself=變數 ''{0}'' 已分配給自己
remove.self.assignment.fix.text=移除自我賦值
convert.to.nullable.type.fix.text=轉換為可為 null 類型
constructor.has.non.null.self.reference.parameter=構造函數具有非 null 自引用參數
assign.backing.field.fix.text=分配支援欄位
existing.backing.field.is.not.assigned.by.the.setter=現有支援欄位未由 setter 分配
replace.with.error=取代為 '?: error(...)'
replace.assert.with.operator=將斷言取代為運算符
assert.should.be.replaced.with.operator=斷言應取代為運算符
simplify.negated.operation=簡化求反運算
negated.operation.should.be.simplified=應簡化求反運算
replace.negated.0.operation.with.1=將求反的 ''{0}'' 運算取代為 ''{1}''
simplify.when.fix.text=簡化 'when'
this.when.is.simplifiable=此 'when' 可以簡化
sort.modifiers=對修飾符排序
non.canonical.modifiers.order=非規範修飾符順序
modifiers.should.follow.annotations=修飾符應遵循註解
remove.as.dynamic.call.fix.text=移除 'asDynamic' 調用
suspicious.asdynamic.member.invocation=可疑的 'asDynamic' 成員調用
0.creates.new.1.under.the.hood=''{0}'' 在背景創建新的{1}
replace.with.filter.fix.text=取代為篩選器
change.type.to.mutable.fix.text=將類型更改為可變
replace.with.assignment.fix.text=取代為賦值 (原始為空)
join.with.initializer.fix.text=與初始設定式聯接
suspicious.combination.of.and=可疑的 == 與 === 組合
unlabeled.return.inside.lambda=lambda 中存在未標記的返回
suspicious.var.property.its.setter.does.not.influence.its.getter.result=可疑的 'var' 屬性: 它的 setter 不會影響其 getter 結果
variable.used.only.in.following.return.and.should.be.inlined=變數僅用於以下返回且可以內聯
variable.is.same.as.0.and.should.be.inlined=變數與 ''{0}'' 相同且可以內聯
implicit.unsafe.cast.from.dynamic.to.0=從動態到 {0} 的隱式 (不安全) 轉換
cast.explicitly.fix.text=顯式轉換
unused.equals.expression=未使用的 equals 表達式
since.kotlin.1.3.main.parameter.is.not.necessary=從 Kotlin 1.3 起，主參數不必要
remove.token.from.function.declaration=從函數宣告中移除 '=' 令牌
unused.return.value.of.a.function.with.lambda.expression.body=包含 lambda 表達式主體的函數未使用的返回值
safe.delete.constructor=安全刪除構造函數
remove.unary.operator.fix.text=移除未使用的一元運算符
unused.unary.operator=未使用的一元運算符
one.line.return=一行返回
return.when='返回 when'
block.body=塊主體
use.expression.body.instead.of.0=使用表達式主體，而不是{0}
convert.to.expression.body.fix.text=轉換為表達式主體
when.has.only.else.branch.and.should.be.simplified='when' 僅包含 'else' 分支且應簡化
wrap.unary.operator.quickfix.text=使用 () 包裝一元運算符和值
make.0.1=將 ''{0}'' 設為 {1}
replace.with.0.operator=取代為 ''{0}'' 運算符
do.you.want.to.make.new.extension.an.expected.declaration=要將新擴展設為預期宣告嗎?
loop.to.call.fix.family.name=取代為 stdlib 運算
loop.to.call.fix.family.name2=取代為使用 'asSequence()' 的 stdlib 運算
loop.can.be.replaced.with.stdlib.operations=迴圈可被取代為 stdlib 運算
text.add.setter=添加 setter
text.add.getter=添加 getter
text.add.getter.and.setter=添加 getter 和 setter
text.add.use.site.target.0=添加使用站點目標 ''{0}''
title.choose.use.site.target=選擇 Use-Site 目標
add.use.site.target=添加使用站點目標
add.full.qualifier=添加完全限定符
add.braces.to.0.statement=將大括號添加到 ''{0}'' 語句
add.braces.to.when.entry=將大括號添加到 'when' 條目
add.braces.to.all.branches=向所有分支添加大括號
add.braces.to.if.all.statements=向所有 'if' 語句添加大括號
add.braces.to.when.all.entries=向所有 'when' 條目添加大括號
add.jvmoverloads.annotation.to.0=將 ''@JvmOverloads'' 註解添加到 {0}
text.primary.constructor=主構造函數
function.0=函數 ''{0}''
looking.for.usages.in.java.files=正在 Java 檔案中尋找用法…
add.return.at.0=添加 ''return@{0}''
add.0.to.argument=將 ''{0} ='' 添加到實參
add.val.var.to.parameter.0=將 ''val''/''var'' 添加到參數 ''{0}''
add.val.to.parameter.0=將 ''val'' 添加到參數 ''{0}''
add.val.var.to.primary.constructor.parameter=將 'val'/'var' 添加到主構造函數參數
make.primary.constructor.0=設為主構造函數 {0}
change.visibility.modifier=更改可見性修飾符
0.may.break.code={0}(可能中斷程式碼)
convert.to.vararg.parameter=轉換為 vararg 參數
replace.with=將 '||' 取代為 '\\&\\&'
replace.with2=將 '\\&\\&' 取代為 '||'
can.t.modify.0=無法修改 {0}
0.already.exists={0} 已存在
type.arguments.will.be.lost.after.conversion.0=轉換後類型實參將丟失: {0}
call.with.arguments.will.be.skipped.0=將跳過具有實參的調用: {0}
looking.for.usages.and.conflicts=正在尋找用法和衝突…
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=不會處理下列表達式，因為重構無法保留其語意: {0}
callable.reference.transformation.is.not.supported.0=不支持可調用的引用轉換: {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=無法將非 Kotlin 引用取代為調用表達式: {0}
convert.0.to.1=將 ''{0}'' 轉換為 ''{1}''
convert.lambda.to.reference.before.text=lambda' 可以轉換為引用
convert.lambda.to.reference=將 lambda 轉換為引用
select.target.code.block.file=選擇目標程式碼塊/檔案
select.target.file=選擇目標檔案
replace.expression.with.if.expression=將 '!!' 表達式取代為 'if' 表達式
inline.when.argument=內聯 'when' 實參
replace.elvis.expression.with.if.expression=將 elvis 表達式取代為 'if' 表達式
flatten.when.expression=平展 'when' 表達式
replace.if.expression.with.return=將 'if' 表達式取代為 return
lift.return.out.of.if.expression=從 'if' 表達式中提取 return
replace.if.with.when=將 'if' 取代為 'when'
replace.safe.access.expression.with.if.expression=將安全存取表達式取代為 'if' 表達式
replace.assignment.with.if.expression=將賦值取代為 'if' 表達式
replace.assignment.with.when.expression=將賦值取代為 'when' 表達式
replace.property.initializer.with.if.expression=將屬性初始設定式取代為 'if' 表達式
replace.property.initializer.with.when.expression=將屬性初始設定式取代為 'when' 表達式
replace.return.with.if.expression=將 return 取代為 'if' 表達式
replace.return.with.when.expression=將 return 取代為 'when' 表達式
replace.when.with.if=將 'when' 取代為 'if'
replace.call.with.unary.operator=將調用取代為一元運算符
replace.contains.call.with.in.operator=將 'contains' 調用取代為 'in' 運算符
replace.invoke.with.direct.call=將 'invoke' 取代為直接調用
copy.concatenation.text.to.clipboard=將串聯文本複製到剪貼簿
split.property.declaration=拆分屬性宣告
replace.with.stdlib.operations.with.use.of.assequence=取代為使用 'asSequence()' 的 stdlib 運算
replace.with.stdlib.operations=取代為 stdlib 運算
use.withindex.instead.of.manual.index.increment=使用 withIndex() 代替手動索引增量
add.braces=添加大括號
add.indices.to.for.loop=將索引添加到 'for' 迴圈
add.jvmoverloads.annotation=添加 '@JvmOverloads' 註解
add.jvmstatic.annotation=添加 '@JvmStatic' 註解
add.labeled.return.to.last.expression.in.a.lambda=將帶標籤的 return 添加到 lambda 中的最後一個表達式
add.missing.component=添加缺失的析構組件
add.names.to.call.arguments=將名稱添加到調用實參
add.names.in.comment.to.call.arguments=在註釋中為調用實參添加名稱
add.names.to.this.argument.and.following.arguments=將名稱添加到此實參和所有後續實參
add.name.to.argument=將名稱添加到實參
make.open=設為 'open'
add.throws.annotation=添加 '@Throws' 註解
add.remaining.branches=添加剩餘的分支
convert.anonymous.function.to.lambda.expression=將匿名函數轉換為 lambda 表達式
convert.to.lambda.expression=轉換為 lambda 表達式
put.arguments.on.separate.lines=將實參放在單獨的行中
put.parameters.on.separate.lines=將參數放在單獨的行中
demorgan.law=德摩根定律
replace.with.end.of.line.comment=取代為行尾註釋
convert.collection.constructor.to.function=將集合構造函數轉換為函數
convert.to.sealed.class=轉換為密封類
replace.with.a.for.loop=取代為 'for' 迴圈
convert.function.to.property=將函數轉換為屬性
convert.function.type.parameter.to.receiver=將函數類型參數轉換為接收器
convert.function.type.receiver.to.parameter=將函數類型接收器轉換為參數
convert.to.nullable.var=轉換為可為 null 變數
convert.to.ordinary.property=轉換為普通屬性
replace.with.block.comment=取代為塊註釋
convert.to.lateinit.var=轉換為 lateinit 變數
convert.object.literal.to.class=將物件文字轉換為類
convert.to.lazy.property=轉換為延遲屬性
convert.parameter.to.receiver=將參數轉換為接收器
convert.to.secondary.constructor=轉換為輔助構造函數
convert.property.getter.to.initializer=將屬性 getter 轉換為初始設定式
convert.property.initializer.to.getter=將屬性初始設定式轉換為 getter
convert.property.to.function=將屬性轉換為函數
can.t.replace.foreign.reference.with.call.expression.0=無法將外來引用取代為調用表達式: {0}
unrecognized.reference.will.be.skipped.0=將跳過無法識別的引用: {0}
property.overloaded.in.child.class.constructor=屬性在子類構造函數中多載
property.has.an.actual.declaration.in.the.class.constructor=屬性在類構造函數中具有實際宣告
convert.to.comparisons=轉換為比較
convert.receiver.to.parameter=將接收器轉換為參數
convert.reference.to.lambda.before.text=引用可以轉換為 lambda
convert.reference.to.lambda=將引用轉換為 lambda
following.problems.are.found=發現以下問題:\n
all.expected.and.actual.classes.must.be.sealed.classes=所有預期和實際類必須為密封類。\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=所有繼承者必須為類自己的嵌套物件，且不會從其他類或接口繼承。\n
searching.inheritors=正在搜尋繼承者…
convert.to.enum.class=轉換為枚舉類
convert.to.primary.constructor=轉換為主構造函數
convert.to.primary.constructor.before.text=輔助構造函數應轉換為主構造函數
rename.to.01=重命名為 {0}
replace.0.name.with.spaces=將 {0} 名稱取代為空格
convert.to.block.body=轉換為塊主體
convert.template.to.concatenated.string=將模板轉換為串聯字串
replace.with.a.foreach.function.call=取代為 'forEach' 函數調用
convert.concatenation.to.raw.string=將串聯轉換為原始字串
convert.concatenation.to.template.before.text='String' 串聯可以轉換為模板
convert.concatenation.to.template=將 'String' 串聯轉換為模板
convert.try.finally.to.use.before.text=try-finally 可被取代為 'use()'
convert.try.finally.to.use=將 'try-finally' 取代為 'use()'
convert.to.unsafe.cast=轉換為不安全的轉換
convert.to.0.as.1=轉換為 ''{0} as {1}''
convert.to.0.unsafecast.1=轉換為 ''{0}.unsafeCast<{1}>()''
convert.to.unsafecast.call=轉換為 unsafeCast() 調用
convert.to.array.parameter=轉換為數組參數
convert.to.assignment.expression=將賦值語句轉換為表達式
create.kotlin.subclass=創建 Kotlin 子類
use.destructuring.declaration=使用析構宣告
implement.as.constructor.parameter=作為構造函數參數實作
implement.abstract.member=實作 abstract 成員
import.members.from.0=從 ''{0}'' 匯入成員
import.members.with=匯入帶有 '*' 的成員
add.import.for.0=為 ''{0}'' 添加 import
add.import.for.member=為成員添加匯入
indent.raw.string=縮排原始字串
replace.infix.call.with.ordinary.call=將中綴調用取代為普通調用
insert.curly.braces.around.variable=在變數周圍插入大括號
add.explicit.type.arguments=添加顯式類型實參
introduce.backing.property=引入支援屬性
introduce.import.alias=引入匯入別名
invert.if.condition=反轉 'if' 條件
iterate.over.0=迭代 ''{0}''
iterate.over.collection=迭代集合
join.declaration.and.assignment=聯接宣告和賦值
can.be.joined.with.assignment=可以與賦值聯接
put.arguments.on.one.line=將實參放在同一行中
put.parameters.on.one.line=將參數放在同一行中
convert.lambda.expression.to.anonymous.function=將 lambda 表達式轉換為匿名函數
convert.to.anonymous.function=轉換為匿名函數
merge.else.if=合併 'else if'
merge.if.s=合併 'if'
move.lambda.argument.into.parentheses=將 lambda 實參移入圓括號
class.0.already.contains.1=類 ''{0}'' 已包含 {1}
0.in.1.will.require.class.instance={1} 中的 ''{0}'' 將需要類接口
searching.for.0=正在搜尋 {0}
move.out.of.companion.object=移出伴生物件
calls.with.explicit.extension.receiver.won.t.be.processed.0=不會處理包含隱式擴展接收器的調用: {0}
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=不會處理屬性 ''{0}'' 內外部類實例的用法
companion.object.already.contains.0=伴生物件已包含 {0}
0.references.type.parameters.of.the.containing.class=包含類的 {0} 引用類型參數
0.is.overridden.by.declaration.s.in.a.subclass={0} 已由子類中的宣告覆寫
move.to.companion.object=移動到伴生物件
move.to.companion.object.command=移動到伴生物件
moving.to.companion.object=正在移動到伴生物件…
move.to.top.level=移動到頂層
package.0.already.contains.1=軟體套件 ''{0}'' 已包含 {1}
move.to.class.body=移動到類主體
move.to.constructor=移動到構造函數
convert.boolean.const.to.elvis=將 Boolean? == const 轉換為 elvis
convert.object.literal.to.lambda=將物件文字轉換為 lambda
convert.to.lambda=轉換為 lambda
replace.by.0=由 ''{0}'' 取代
replace.by.reconstructed.type=由重構造類型取代
remove.argument.name=移除實參名稱
remove.all.argument.names=移除所有實參名稱
remove.braces.from.when.entry=從 'when' 條目移除大括號
remove.braces.from.0.statement=從 ''{0}'' 語句中移除大括號
remove.braces=移除大括號
remove.braces.from.all.branches=移除所有分支中的大括號
remove.braces.from.if.all.statements=移除所有 'if' 語句中的大括號
remove.braces.from.when.all.entries=移除所有 'when' 條目中的大括號
remove.constructor.keyword=移除構造函數關鍵字
redundant.empty.class.body=冗餘空類主體
remove.redundant.empty.class.body=移除冗餘的空類主體
remove.unnecessary.parentheses.from.function.call.with.lambda=從帶 lambda 的函數調用中移除不必要的圓括號
remove.empty.primary.constructor=移除空主構造函數
remove.empty.constructor.body=移除空構造函數主體
remove.explicit.lambda.parameter.types.may.break.code=移除顯式 lambda 參數類型(可能中斷程式碼)
remove.explicit.supertype.qualification=移除顯式父類型限定
remove.explicit.type.arguments=移除顯式類型實參
remove.explicit.type.specification=移除顯式類型規範
remove.explicit.type.specification.from.0=移除 ''{0}'' 中的顯式類型規範
remove.indices.in.for.loop=移除 'for' 迴圈中的索引
index.is.not.used.in.the.loop.body=索引未在迴圈體中使用
remove.return.0=移除 return@{0}
remove.labeled.return.from.last.expression.in.a.lambda=從 lambda 中的最後一個表達式移除帶標籤的 return
remove.redundant.calls.of.the.conversion.method=移除轉換方法的冗餘調用
remove.single.expression.string.template=移除單表達式字串模板
redundant.string.template=冗餘字串模板
remove.unnecessary.parentheses=移除不必要的圓括號
rename.class.to.0=將類重命名為 {0}
rename.class.to.containing.file.name=將類重命名為包含文件名稱
rename.file.to.0.1=將檔案重命名為 {0}.{1}
rename.file.to.match.top.level.class.name=重命名檔案以符合頂層類名
replace.0.with=將 ''{0}()'' 取代為 ''+=''
replace.with1=取代為 '+='
replace.explicit.parameter.0.with.it=將顯式參數 ''{0}'' 取代為 ''it''
replace.it.with.explicit.parameter=將 'it' 取代為顯式參數
replace.with.0.1.2=取代為 {0}[{1}] ?: {2}
replace.with.indexing.and.elvis.operator=取代為索引和 elvis 運算符
replace.size.check.with.isnotempty=將大小檢查取代為 'isNotEmpty'
replace.size.zero.check.with.isempty=將大小零檢查取代為 'isEmpty'
replace.with.parameter.name=將 '_' 取代為參數名稱
replace.with.ordinary.assignment=取代為普通賦值
simplify.boolean.expression=簡化布爾表達式
specify.explicit.lambda.signature=指定顯式 lambda 簽名
specify.all.types.explicitly.in.destructuring.declaration=在析構宣告中顯式指定所有類型
cannot.infer.type.for.this.declaration=無法推斷此宣告的類型
split.if.into.two=將 'if' 拆分為兩部分
flip.0=翻轉 ''{0}''
flip.binary.expression=翻轉二元表達式
flip.equals=翻轉 'equals'
replace.with.infix.function.call=取代為中綴函數調用
to.ordinary.string.literal=目標普通字串文字
to.raw.string.literal=目標原始字串文字
remove.underscores=移除下劃線
add.underscores=添加下劃線
excluded.methods=排除的方法
use.of.0.method.instead.of.property.access.syntax=使用 {0} 方法代替屬性存取語法
use.property.access.syntax=使用屬性存取語法
convert.to.object.declaration=轉換為物件宣告
comment=註釋
expression=表達式
statement=語句
class=類
object.declaration=物件宣告
top.level=頂層
rethrow.stored.pce.as.a.new.runtime.exception=將存儲的 PCE 作為新執行時異常再次拋出
internal.toggle.throwing.cached.pce.title=內部: 切換引發快取的 PCE
minimal.line.count=最小行計數
files.to.visit=要存取的檔案
random.seed=隨機種子
number.of.attempts.then.files.in.project.0=嘗試次數 > 專案中隨後的檔案，{0}
text.done=完成
file.lines=檔案行
max.functions.to.visit=要存取的最大函數
move.refactoring.testing=移動重構測試
compiling.project=正在編譯專案…
saving.files=正在儲存檔案…
perform.refactoring=執行重構…
update.indices=更新索引…
reset.files=重置檔案…
cannot.get.or.create.results.file=無法獲取或生成結果檔案
cannot.get.project.root.directory=無法獲取專案根目錄
0.try.1.with.2.fails.and.3.verifications={0} [嘗試 {1}，{2} 次失敗和 {3} 次驗證]
test.result.log.file.will.be.placed.here=測試結果日誌檔案將位於此處
maximum.count.of.applied.refactoring.before.validity.check=驗證檢查前套用重構的最大計數
move.refactoring.test=移動重構測試
resolve.pasted.references=解析貼上的引用
create.kotlin.file=創建 Kotlin 檔案
type.alias.0=類型別名“{0}”
type.parameter.0=類型參數 "{0}"
parameter.0=參數 "{0}"
property.0=屬性“{0}”
function.01=函數“{0}”
object.0=物件“{0}”
interface=接口
constructor=構造函數
move.suspicious.callable.reference.into.parentheses=將可疑的可調用引用移入括號 '()'
local.variable=局部變數
const.property=const 屬性
private.property=private 屬性
object.or.top.level.property=物件或頂層屬性
property=屬性
test.function=測試函數
function=函數
enum.entry=枚舉條目
create.subclass=創建子類
implement.sealed.class=實作密封類
implement.abstract.class=實作 abstract 類
implement.interface=實作接口
implement.abstract.function=實作 abstract 函數
implement.abstract.property=實作 abstract 屬性
replace.explicit.lambda.parameter.with.it=將顯式 lambda 參數取代為 'it'
create.test=創建測試
convert.class.0.to.kotlin=將類 ''{0}'' 轉換為 Kotlin
destination.directory=目標目錄(&D)
language.version=語言版本(&L)
kotlin.compiler.version=Kotlin 編譯器版本(&K)
api.version=API 版本(&I)
embed.source.code.into.source.map=將原始碼嵌入源映射:
enable.incremental.compilation=啟用增量編譯
keep.compiler.process.alive.between.invocations=使編譯器行程在調用之間保持活動
module.kind=模組種類(&K):
target.jvm.version=目標 JVM 版本(&J)
additional.command.line.parameters=附加命令行參數
mnemonic.install=安裝(&I)
status=(狀態)
check.again=再次檢查(&K)
current.kotlin.plugin.version=當前 Kotlin 延伸模組版本:
experimental.features=實驗性功能
action.text.install=安裝
update.channel=更新通道(&C):
version={version}
don.t.show.this.dialog.next.time=下次不顯示此對話框(&D)
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=剪貼簿內容複製自 Java 檔案。要將其轉換為 Kotlin 程式碼嗎?
name=名稱(&N):
return.type=返回類型(&R):
visibility=可見性(&V):
title.parameters=參數
signature.preview=簽名預覽
move.members.from=從以下位置移動成員:
open.moved.members.in.editor=在編輯器中開啟移動的成員
open.moved.method.in.editor=在編輯器中開啟移動的方法
to.fully.qualified.name=到(完全限定名稱):
title.toggle.library.to.source.dependency.support=將庫切換為原始碼依賴項支援
enable.components.for.library.to.source.analysis.in.kotlin=根據 Kotlin 中的專案原始碼檔案啟用組件分析庫
incomplete.destructuring.declaration.text=析構宣告不完整
incomplete.destructuring.fix.family.name=將缺失的變數添加到析構宣告

#Structural Search
category.class=Kotlin/基於類
category.comments=Kotlin/註釋、KDoc 和元資料
category.expressions=Kotlin/表達式
category.functions=Kotlin/函數
category.interesting=Kotlin/關注
category.operators=Kotlin/運算符

context.default=預設
context.property.getter.or.setter=具有顯式 getter/setter 的屬性

error.context.getter.or.setter=此上下文僅適用於具有顯式 getter/setter 的屬性。(將檔案類型設定為 Kotlin)
error.expected.an.expression=應為表達式
error.expected.catch.or.finally=應為 'catch' 或 'finally'
error.param.can.t.be.null.at.index.0.in.1=參數在 {1} 中索引 {0} 處不能為 null。



predefined.configuration.all.methods.of.the.class=類的所有方法
predefined.configuration.all.vars.of.the.class=類的所有 var
predefined.configuration.all.vars.of.the.object=物件的所有 var
predefined.configuration.annotations=註解
predefined.configuration.anonymous.class=匿名類
predefined.configuration.array.access=陣列存取
predefined.configuration.assert.not.null=非 null 斷言運算符
predefined.configuration.assignments=賦值
predefined.configuration.casts=轉換
predefined.configuration.class.annotation=註解類
predefined.configuration.comments.containing.word=包含給定詞的註釋
predefined.configuration.do.while=Do...while 迴圈
predefined.configuration.elvis=Elvis 運算符
predefined.configuration.for=For 迴圈
predefined.configuration.function.annotation=註解函數
predefined.configuration.function.signature=函數簽名
predefined.configuration.ifs=If
predefined.configuration.instance=實例
predefined.configuration.kdoc.tag=KDoc 標記
predefined.configuration.lambda=lambda 表達式
predefined.configuration.method.calls=方法調用
predefined.configuration.properties.getter=具有顯式 getter 的屬性
predefined.configuration.safe.call.operator=安全調用運算符
predefined.configuration.string.literals=字串文字
predefined.configuration.strings=字串
predefined.configuration.strings.with.long.template=包含長模板的字串
predefined.configuration.trys=Try
predefined.configuration.vars.of.given.type=給定類型的 var
predefined.configuration.when=when 表達式
predefined.configuration.while=While 迴圈

#Actions
action.Kotlin.StopScratch.text=停止執行臨時檔案
action.Kotlin.StopScratch.description=停止執行臨時檔案
action.Kotlin.ClearScratch.text=清除 Kotlin 臨時檔案
action.Kotlin.ClearScratch.description=清除 Kotlin 臨時檔案
action.Kotlin.RunScratch.text=執行 Kotlin 臨時檔案
action.Kotlin.RunScratch.description=執行 Kotlin 臨時檔案
action.KotlinGenerateToString.text=toString()
action.KotlinGenerateEqualsAndHashCode.text=equals() 和 hashCode()
action.KotlinGenerateSecondaryConstructor.text=輔助構造函數
action.KotlinGenerateDataMethod.text=參數函數
action.KotlinGenerateTearDownMethod.text=TearDown 函數
action.KotlinGenerateSetUpMethod.text=SetUp 函數
action.KotlinGenerateTestMethod.text=測試函數
action.KotlinShellExecute.text=執行 Kotlin 程式碼
action.KotlinShellExecute.description=在主控台中執行 Kotlin 程式碼
action.IntroduceTypeAlias.text=類型別名(_A)…
action.IntroduceTypeParameter.text=類型參數(_Y)…
action.ExtractFunctionToScope.text=函數到作用域(_S)…
action.KotlinThrowException.text=刪除來自 Kotlin 延伸模組的錯誤
action.KotlinFormattingSettingsStatusAction.text=格式化程序設定資訊
action.CopyAsDiagnosticTest.text=將當前檔案複製為診斷測試
action.StoredExceptionsThrowToggleAction.text=引發快取的 PCE
action.PrintOutNotPropertyMatches.text=搜尋非屬性候選項
action.FindImplicitNothingAction.text=尋找隱式 Nothing 調用
action.CheckComponentsUsageSearchAction.text=檢查組件函數用法搜尋
action.CacheResetOnProcessCanceledToggleAction.text=ProcessCanceledException 時重置快取
action.HighlightingBenchmarkAction.text=基準高亮顯示
action.LocalCompletionBenchmarkAction.text=本地方案
action.TopLevelCompletionBenchmarkAction.text=頂級方案
group.KotlinCompletionBenchmarkGroup.text=基準補全
group.KotlinInternalGroup.text=Kotlin
action.TestMoveRefactiringAction.text=在開啟的專案上測試移動重構
group.KotlinRefactoringTesting.text=Kotlin 重構測試
action.DumbModeTremble.text=靜音震動模式
group.InternalKotlin.text=Kotlin 內部操作
action.IntroduceProperty.text=屬性(_R)…
action.ExtractFunction.text=函數(_F)…
action.KotlinCodeMigrationToggle.text=啟用遷移檢測
action.KotlinCodeMigration.text=執行程式碼遷移
action.CopyKotlinProjectInformation.text=將 Kotlin 專案概覽複製到剪貼簿
action.DecompileKotlinToJava.text=將 Kotlin 反編譯為 Java
action.KotlinConfigureUpdates.text=設定 Kotlin 延伸模組更新
action.KotlinConfigureUpdates.description=為 Kotlin 延伸模組設定自動更新
group.KotlinToolsGroup.text=Kotlin
action.ConvertJavaToKotlin.text=將 Java 檔案轉換為 Kotlin 檔案
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=僅顯示 Kotlin 變數
action.InspectBreakpointApplicability.text=檢查中斷點可用性
action.Kotlin.XDebugger.CoroutinesDump.text=獲取協同程序轉儲
action.ShowKotlinBytecode.text=顯示 Kotlin 字節碼
action.ConfigureKotlinJsInProject.text=在專案中設定 Kotlin (JavaScript)
action.ConfigureKotlinInProject.text=在專案中設定 Kotlin
action.KotlinConsoleREPL.text=Kotlin REPL (實驗性)
action.LibraryToSourceDependencySupportToggleAction.text=將庫切換為原始碼依賴項支援

inspection.unused.unary.operator.display.name=未使用的一元運算符
inspection.incomplete.destructuring.declaration.display.name=析構宣告不完整
inspection.inconsistent.comment.for.java.parameter.display.name=Java 參數的註釋不一致
inspection.replace.guard.clause.with.function.call.display.name=臨界子句可被取代為 Kotlin 的函數調用
inspection.lateinit.var.overrides.lateinit.var.display.name='lateinit var' 屬性覆寫 'lateinit var' 屬性
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
inspection.redundant.empty.initializer.block.display.name=冗餘空白初始設定式塊
inspection.add.operator.modifier.display.name=函數應具有 'operator' 修飾符
inspection.control.flow.with.empty.body.display.name=帶空體的控制流
inspection.replace.java.static.method.with.kotlin.analog.display.name=Java 方法應取代為 Kotlin 模擬
inspection.self.reference.constructor.parameter.display.name=構造函數永遠無法補全
inspection.replace.not.null.assertion.with.elvis.return.display.name=非 null 斷言可被取代為 'return'
inspection.kotlin.covariant.equals.display.name=協變 'equals()'
inspection.replace.associate.function.display.name='associate' 可被取代為 'associateBy' 或 'associateWith'
inspection.java.map.for.each.display.name=Java Map.forEach 方法調用應取代為 Kotlin 的 forEach
inspection.kotlin.throwable.not.thrown.display.name=Throwable 未拋出
inspection.redundant.require.not.null.call.display.name=冗餘 'requireNotNull' 或 'checkNotNull' 調用
inspection.replace.range.start.end.inclusive.with.first.last.display.name=裝箱的屬性應取代為未裝箱的屬性
inspection.redundant.enum.constructor.invocation.display.name=冗餘枚舉構造函數調用
inspection.replace.negated.is.empty.with.is.not.empty.display.name=可以簡化否定調用
inspection.function.with.lambda.expression.body.display.name=具有 ''= { ... }'' 和推斷返回類型的函數
inspection.suspend.function.on.coroutine.scope.display.name=由於掛起函數的 CoroutineScope 接收器，coroutineContext 不明確
inspection.boolean.literal.argument.display.name=不包含參數名稱的布爾文字實參
inspection.suspicious.collection.reassignment.display.name=增強賦值在背景創建新集合
inspection.redundant.else.in.if.display.name='if' 中冗餘的 'else'
inspection.deferred.is.result.display.name=函數直接返回 Deferred
inspection.map.get.with.not.null.assertion.operator.display.name=包含非 null 斷言運算符 (!!) 的 'map.get()'
inspection.delegation.to.var.property.display.name=正在委託給 'var' 屬性
inspection.unused.main.parameter.display.name=主參數不必要
inspection.suspicious.var.property.display.name=可疑的 'var' 屬性: 它的 setter 不會影響其 getter 結果
inspection.setter.backing.field.assignment.display.name=不包含賦值的現有支援欄位
inspection.unlabeled.return.inside.lambda.display.name=lambda 中存在未標記的 return
inspection.optional.expectation.display.name=可選預期註解沒有實際註解
inspection.remove.empty.parentheses.from.annotation.entry.display.name=移除不必要的圓括號
inspection.safe.cast.with.return.display.name=帶有 'return' 的安全轉換應取代為 'if' 類型檢查
inspection.simplifiable.call.display.name=可以簡化庫函數調用
inspection.redundant.run.catching.display.name=冗餘 'runCatching' 調用
inspection.direct.use.of.result.type.display.name=函數直接返回 Result
inspection.redundant.return.label.display.name=冗餘 'return' 標籤
inspection.replace.assert.boolean.with.assert.equality.display.name=斷言布爾可被取代為斷言等式
inspection.suspicious.as.dynamic.display.name=可疑的 'asDynamic' 成員調用
inspection.convert.call.chain.into.sequence.display.name=可以將集合上的調用鏈轉換為 'Sequence' 來改善性能
inspection.redundant.with.display.name=冗餘 'with' 調用
inspection.obsolete.experimental.coroutines.display.name=從 1.3 起，實驗性協同程序用法遭到廢棄
inspection.obsolete.kotlin.js.packages.display.name='kotlin.browser' 和 'kotlin.dom' 軟體套件自 1.4 起已棄用
inspection.warning.on.main.unused.parameter.migration.display.name=從 1.4 起，'main' 上不再使用 'args'
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=未被標記為 '@Repeatable' 的重複註解
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=超類上的無意義註解目標
inspection.redundant.label.migration.display.name=冗餘標籤
inspection.restrict.return.statement.target.migration.display.name=從 1.4 起，目標標籤不表示函數
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=從 1.4 起，'@JvmOverloads' 註解無法用於註解類的構造函數
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=帶類型參數的局部變數
inspection.from.closed.range.migration.display.name=從 1.3 起，fromClosedRange() 中存在 MIN_VALUE 步驟
inspection.replace.to.string.with.string.template.display.name='toString' 的調用可被取代為字串模板
inspection.nested.lambda.shadowed.implicit.parameter.display.name=嵌套 lambda 具有隱藏的隱式參數
inspection.for.each.parameter.not.used.display.name=迭代元素不在 forEach 中使用
inspection.replace.string.format.with.literal.display.name='String.format' 調用可被取代為字串模板
inspection.deferred.result.unused.display.name='@Deferred' 結果未被使用
inspection.redundant.async.display.name=冗餘 'async' 調用
inspection.main.function.return.unit.display.name=main 函數應返回 'Unit'
inspection.move.variable.declaration.into.when.display.name=變數宣告可以在 'when' 中移動
inspection.move.lambda.outside.parentheses.display.name=圓括號內的 lambda 實參
inspection.can.sealed.sub.class.be.object.display.name=密封的子類沒有狀態和覆寫的 equals
inspection.public.api.implicit.type.display.name=具有隱式返回類型的公共 API 宣告
inspection.redundant.companion.reference.display.name=冗餘 'Companion' 引用
inspection.convert.pair.constructor.to.to.function.display.name=將 Pair 構造函數轉換為 'to' 函數
inspection.redundant.not.null.extension.receiver.of.inline.display.name='inline fun' 擴展接收器在 Kotlin 1.2 及更低版本中可以顯式設為可為 null
inspection.platform.extension.receiver.of.inline.display.name=在 Kotlin 1.2 及更低版本中包含可為 null 的接收器的 'inline fun'
inspection.scope.function.conversion.display.name=範圍函數可以轉換為另一個
inspection.redundant.object.type.check.display.name=物件的非慣用 'is' 類型檢查
inspection.fake.jvm.field.constant.display.name=Kotlin 非 const 屬性用作 Java 常數
inspection.may.be.constant.display.name=可能為 'const'
inspection.sort.modifiers.display.name=非規範修飾符順序
inspection.redundant.suspend.modifier.display.name=冗餘 'suspend' 修飾符
inspection.replace.put.with.assignment.display.name='map.put()' 可以轉換為賦值
inspection.replace.to.with.infix.form.display.name='to' 調用應取代為中綴形式
inspection.recursive.equals.call.display.name=遞歸 equals 調用
inspection.java.collections.static.method.on.immutable.list.display.name=在不可變的 Kotlin 集合上調用 Java 轉變器方法
inspection.java.collections.static.method.display.name=Java 集合 static 方法調用可被取代為 Kotlin stdlib
inspection.simplify.when.with.boolean.constant.condition.display.name=可簡化的 'when'
inspection.implicit.nullable.nothing.type.display.name=隱式 'Nothing?' 類型
inspection.self.assignment.display.name=冗餘賦值
inspection.redundant.unit.expression.display.name=冗餘 'Unit'
inspection.implicit.this.display.name=隱式 'this'
inspection.explicit.this.display.name=冗餘顯式 'this'
inspection.migrate.diagnostic.suppression.display.name=應取代診斷名稱
inspection.redundant.setter.display.name=冗餘屬性 setter
inspection.remove.redundant.qualifier.name.display.name=冗餘限定符名稱
inspection.remove.redundant.backticks.display.name=冗餘反引號
inspection.redundant.getter.display.name=冗餘屬性 getter
inspection.suspicious.equals.combination.display.name=可疑的 == 與 === 組合
inspection.kotlin.redundant.override.display.name=冗餘覆寫方法
inspection.package.name.display.name=軟體套件命名慣例
inspection.local.variable.name.display.name=局部變數命名慣例
inspection.const.property.name.display.name=const 屬性命名慣例
inspection.private.property.name.display.name=private 屬性命名慣例
inspection.object.property.name.display.name=object 屬性命名慣例
inspection.property.name.display.name=屬性命名慣例
inspection.test.function.name.display.name=測試函數命名慣例
inspection.function.name.display.name=函數命名慣例
inspection.enum.entry.name.display.name=枚舉條目命名慣例
inspection.class.name.display.name=類命名慣例
inspection.redundant.lambda.arrow.display.name=冗餘 lambda 箭頭
inspection.redundant.lambda.or.anonymous.function.display.name=創建冗餘 lambda 或匿名函數
inspection.redundant.lambda.description=創建冗餘 lambda
inspection.redundant.anonymous.function.description=創建冗餘匿名函數
inspection.redundant.lambda.or.anonymous.function.fix=內聯體
inspection.when.with.only.else.display.name='when' 僅包含 'else' 分支且可以簡化
inspection.kotlin.double.negation.display.name=冗餘雙重求反
inspection.unnecessary.variable.display.name=不必要的局部變數
inspection.constant.condition.if.display.name='if' 表達式的條件為常數
inspection.null.checks.to.safe.call.display.name=null 檢查可被取代為安全調用
inspection.cascade.if.display.name=級聯 if 應取代為 when
inspection.lift.return.or.assignment.display.name=可以提取 return 或賦值
inspection.use.expression.body.display.name=此處更適合表達式主體語法
inspection.simplifiable.call.chain.display.name=可以簡化集合類型上的調用鏈
inspection.useless.call.on.collection.display.name=對集合類型的無用調用
inspection.redundant.explicit.type.display.name=明顯的顯式類型
inspection.useless.call.on.not.null.display.name=對非 null 類型的無用調用
inspection.remove.redundant.spread.operator.display.name=冗餘展開運算符
inspection.empty.range.display.name=start 大於 endInclusive 的範圍為空
inspection.wrap.unary.operator.display.name=模糊一元運算符與數字常數一同使用
inspection.nullable.boolean.elvis.display.name=可以使用相等檢查代替 elvis 進行可空布爾檢查
inspection.member.visibility.can.be.private.display.name=類成員可以具有 'private' 可見性
inspection.replace.range.to.with.until.display.name='rangeTo' 或 '..' 調用應取代為 'until'
inspection.recursive.property.accessor.display.name=遞歸屬性存取器
inspection.replace.array.of.with.literal.display.name='arrayOf' 調用可被取代為數組文字 […]
inspection.copy.without.named.arguments.display.name=資料類的 'copy' 方法在沒有命名實參的情況下調用
inspection.move.suspicious.callable.reference.into.parentheses.display.name=可疑的可調用引用用作 lambda 結果
inspection.kotlin.internal.in.java.display.name=使用來自 Java 的 Kotlin 內部宣告
inspection.kotlin.sealed.in.java.display.name=從 Java 繼承 Kotlin 密封接口/類
inspection.unused.lambda.expression.body.display.name=包含 lambda 表達式主體的函數未使用的返回值
inspection.destructuring.wrong.name.display.name=析構宣告中的變數使用錯誤資料類屬性的名稱
inspection.data.class.private.constructor.display.name=private 資料類構造函數通過 'copy' 方法公開
inspection.replace.with.enum.map.display.name='HashMap' 可被取代為 'EnumMap'
inspection.unused.equals.display.name=未使用的 equals 表達式
inspection.convert.na.n.equality.display.name=將帶 'NaN' 的相等檢查轉換為 'isNaN' 調用
inspection.convert.two.comparisons.to.range.check.display.name=兩個比較應轉換為範圍檢查
inspection.convert.try.finally.to.use.call.display.name=將 try / finally 轉換為 use() 調用
inspection.join.declaration.and.assignment.display.name=聯接宣告和賦值
inspection.remove.empty.secondary.constructor.body.display.name=冗餘構造函數體
inspection.remove.empty.primary.constructor.display.name=冗餘空主構造函數
inspection.remove.redundant.calls.of.conversion.methods.display.name=轉換方法的冗餘調用
inspection.remove.empty.class.body.display.name=取代空類主體
inspection.replace.size.zero.check.with.is.empty.display.name=零大小檢查可被取代為 'isEmpty()'
inspection.replace.size.check.with.is.not.empty.display.name=大小檢查可被取代為 'isNotEmpty()'
inspection.convert.secondary.constructor.to.primary.display.name=轉換為主構造函數
inspection.complex.redundant.let.display.name=基於實參的冗餘 'let' 調用
inspection.simple.redundant.let.display.name=基於接收器的冗餘 'let' 調用
inspection.replace.array.equality.op.with.arrays.equals.display.name=通過 '==' 和 '!=' 進行陣列比較
inspection.remove.empty.parentheses.from.lambda.call.display.name=從帶 lambda 的函數調用中移除不必要的圓括號
inspection.remove.to.string.in.string.template.display.name=字串模板中的冗餘 'toString()' 調用
inspection.remove.single.expression.string.template.display.name=冗餘字串模板
inspection.replace.call.with.binary.operator.display.name=可被取代為二元運算符
inspection.remove.setter.parameter.type.display.name=冗餘 setter 參數類型
inspection.convert.reference.to.lambda.display.name=可被取代為 lambda
inspection.convert.lambda.to.reference.display.name=可被取代為函數引用
inspection.can.be.primary.constructor.property.display.name=屬性已明確分配給構造函數參數
inspection.has.platform.type.display.name=函數或屬性具有平台類型
inspection.leaking.this.display.name=在構造函數中泄漏 'this'
inspection.redundant.if.display.name=冗餘的 'if' 語句
inspection.redundant.unit.return.type.display.name=冗餘 'Unit' 返回類型
inspection.redundant.semicolon.display.name=冗餘分號
inspection.redundant.modality.modifier.display.name=冗餘形式修飾符
inspection.can.be.parameter.display.name=構造函數參數從未被用作屬性
inspection.replace.substring.with.substring.before.display.name='substring' 調用應取代為 'substringBefore'
inspection.replace.substring.with.substring.after.display.name='substring' 調用應取代為 'substringAfter'
inspection.replace.substring.with.indexing.operation.display.name='substring' 調用應取代為索引運算符
inspection.replace.substring.with.take.display.name='substring' 調用應取代為 'take' 調用
inspection.replace.substring.with.drop.last.display.name='substring' 調用應取代為 'dropLast' 調用
inspection.add.variance.modifier.display.name=類型參數可以具有 'in' 或 'out' 差異
inspection.protected.in.final.display.name='protected' 可見性在 final 類中實際是 'private'
inspection.array.in.data.class.display.name=資料類中的陣列屬性
inspection.can.be.val.display.name=本地 'var' 從未被修改，且可以宣告為 'val'
inspection.destructure.display.name=使用析構宣告
inspection.redundant.visibility.modifier.display.name=冗餘可見性修飾符
inspection.equals.or.hash.code.display.name='equals()' 和 'hashCode()' 未配對
inspection.conflicting.extension.property.display.name=擴展屬性與合成屬性衝突
inspection.use.with.index.display.name=手動遞增的索引變數可被取代為使用 'withIndex()'
inspection.loop.to.call.chain.display.name=迴圈可被取代為 stdlib 運算
inspection.remove.for.loop.indices.display.name=未使用的迴圈索引
inspection.kotlin.deprecation.display.name=使用了冗餘或棄用的語法或棄用的符號
inspection.package.directory.mismatch.display.name=軟體套件名稱與包含的目錄不符合
inspection.k.doc.missing.documentation.display.name=public 宣告缺少 KDoc 註釋
inspection.k.doc.unresolved.reference.display.name=KDoc 中存在未解析的引用
inspection.unsafe.cast.from.dynamic.display.name=從動態類型的隱式(不安全)轉換
inspection.redundant.sam.constructor.display.name=冗餘 SAM 構造函數
inspection.kotlin.unused.import.display.name=未使用的 import 指令
inspection.unused.receiver.parameter.display.name=未使用的接收器參數
inspection.unused.symbol.display.name=未使用的符號
inspection.use.property.access.syntax.display.name=可被取代為屬性存取語法的存取器調用
inspection.simplify.boolean.with.constants.display.name=可以簡化布爾表達式
inspection.remove.curly.braces.from.template.display.name=字串模板中的冗餘大括號
inspection.introduce.when.subject.display.name=可以通過引入實參簡化的 'when'
inspection.replace.with.operator.assignment.display.name=賦值可被取代為運算符賦值
inspection.simplify.negated.binary.expression.display.name=可以簡化求反布爾表達式
inspection.remove.explicit.super.qualifier.display.name=不必要的父類型限定
inspection.remove.explicit.type.arguments.display.name=不必要的類型實參
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/… 可折疊為 '?:'
inspection.if.then.to.safe.access.display.name=If-Then 可折疊為 '?.'
inspection.if.then.to.elvis.display.name=If-Then 可折疊為 '?:'
inspection.replace.manual.range.with.indices.calls.display.name=範圍可以轉換為索引或迭代
inspection.replace.get.or.set.display.name=顯式 'get' 或 'set' 調用
inspection.convert.to.string.template.display.name=可以轉換為字串模板的字串串聯
inspection.deprecated.callable.add.replace.with.display.name=不包含 'replaceWith' 實參的 @Deprecated 註解
inspection.replace.collection.count.with.size.display.name=集合計數可以轉換為大小
inspection.simplify.assert.not.null.display.name='assert' 調用可被取代為 '!!' 或 '?:'
inspection.object.literal.to.lambda.display.name=物件文字可以轉換為 lambda
remove.redundant.elvis.return.null.text=移除冗餘 '?: return null'
inspection.redundant.elvis.return.null.descriptor=冗餘 '?: return null'
inspection.redundant.elvis.return.null.display.name=冗餘 '?: return null'
inspection.redundant.inner.class.modifier.descriptor=冗餘 'inner' 修飾符
inspection.redundant.inner.class.modifier.display.name=冗餘 'inner' 修飾符
fix.remove.annotation.text=移除註解
inspection.trailing.comma.display.name=尾隨逗號推薦
inspection.trailing.comma.report.also.a.missing.comma=還報告缺少的逗號或換行
inspection.trailing.comma.add.line.break=添加換行
inspection.trailing.comma.missing.line.break=缺少換行
inspection.trailing.comma.remove.trailing.comma=移除尾隨逗號
inspection.trailing.comma.useless.trailing.comma=無用的尾隨逗號
inspection.trailing.comma.add.trailing.comma=添加尾隨逗號
inspection.trailing.comma.missing.trailing.comma=缺少尾隨逗號
inspection.trailing.comma.fix.comma.position=修復逗號位置
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=逗號在這個位置沒有優勢
inspection.redundant.label.text=冗餘標籤
intention.convert.lambda.line=轉換為{0,choice,0#單|1#多}行 lambda
intention.trailing.comma.custom.text=在格式化程序中預設{0,choice,0#啟用|1#禁用}尾隨逗號
intention.trailing.comma.text=在格式化程序中預設啟用/禁用尾隨逗號
fix.remove.argument.text=移除實參
fix.remove.redundant.star.text=移除冗餘的 *
refactoring.extract.to.separate.file.text=提取到單獨檔案中
action.usage.update.command=用法更新
progress.title.analyze.extraction.data=分析提取資料…
fix.move.file.to.package.dir.name.text=源根
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=無法執行重構，因為以下檔案已存在:
kotlin.script.definitions.title=管理腳本定義
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=如果要在檔案更改時自動載入腳本設定，啟用自動重新載入
kotlin.script.definitions.model.name.autoReloadScriptDependencies=自動重新載入
kotlin.script.definitions.model.name.is.enabled=啟用
kotlin.script.definitions.model.name.pattern.extension=模式/擴展
kotlin.script.definitions.model.name.name=名稱
kotlin.script.lookup.definitions=正在尋找 Kotlin 腳本定義…
codestyle.name.kotlin=Kotlin
add.missing.class.keyword=添加缺少的 'class' 關鍵字
fix.move.typealias.to.top.level=將類型別名移到頂層
fix.change.jvm.name=更改 JVM 名稱
expand.boolean.expression.to.if.else=將布爾表達式擴展為 'if else'
inspection.logger.initialized.with.foreign.class.display.name=使用外類初始化記錄器
logger.initialized.with.foreign.class=使用外類 ''{0}'' 初始化記錄器
inspection.logger.placeholder.count.matches.argument.count.display.name=佔位符數量與日誌調用中的實參數量不符合
placeholder.count.matches.argument.count.more.problem.descriptor=提供的實參數量({0})多於指定的佔位符({1}) #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的實參數量({0})少於指定的佔位符數({1}) #loc
title.logger.factory.method.name=記錄器工廠方法名稱
title.logger.factory.class.name=記錄器工廠類名
title.choose.logger.factory.class=選擇記錄器工廠類
inspection.redundant.assequence.call=冗餘 'asSequence' 調用
remove.assequence.call.fix.text=移除 'asSequence' 調用
codestyle.layout.import.aliases.separately=單獨匯入別名
button.add.package=添加軟體套件
listbox.import.package=軟體套件
listbox.import.with.subpackages=以及子軟體套件
title.import.layout=匯入布局
title.packages.to.use.import.with=將 import 與 '*' 搭配使用的軟體套件
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=不必要的非直接父類限定符
fix.add.exception.to.throws=添加 ''{0}''
fix.add.eq.eq.true=添加 '== true'
inspection.replace.isempty.with.ifempty.display.name='if' 條件可被取代為 lambda 調用
inspection.replace.with.ignore.case.equals.display.name=應取代為 'equals(..., ignoreCase = true)'
inspection.redundant.nullable.return.type.display.name=冗餘可 null 返回類型
0.always.returns.non.null.type=''{0}'' 始終返回非 null 類型
0.is.always.non.null.type=''{0}'' 始終為非 null 類型
inspection.simplifiable.scope.function.display.name=嵌套 forEach 的範圍函數可以簡化
nested.1.call.in.0.could.be.simplified.to.2=''{0}'' 中的嵌套 ''{1}'' 調用可以簡化為 {2}
evaluate.compile.time.expression=評估編譯時表達式

hints.title.codevision=Code Vision

hints.codevision.usages.format={0, choice, 1#1 個用法|2#{0,number} 個用法}
hints.codevision.usages.too_many.format={0,number}+ 個用法
hints.codevision.implementations.format={0, choice, 1#1 個實作|2#{0,number} 個實作}
hints.codevision.implementations.too_many.format={0,number}+ 個實作
hints.codevision.inheritors.format={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
hints.codevision.inheritors.to_many.format={0,number}+ 個繼承者
hints.codevision.overrides.format={0, choice, 1#1 個覆寫|2#{0,number} 個覆寫}
hints.codevision.overrides.to_many.format={0,number}+ 個覆寫
hints.codevision.settings=設定…
convert.string.template.to.build.string=轉換為 'buildString' 調用
convert.concatenation.to.build.string=將串聯轉換為 'buildString' 調用
convert.to.indexed.function.call=轉換為索引函數調用
inspection.kotlin.invalid.bundle.or.property.display.name=無效屬性健
inspection.gradle.kotlinx.coroutines.deprecation.display.name=與 Gradle 中的 Kotlin 1.3+ 一起使用的 kotlinx.coroutines 依賴項不相容
inspection.deprecated.gradle.dependency.display.name=在 Gradle 中使用了棄用的庫
inspection.different.stdlib.gradle.version.display.name=Kotlin 庫和 Gradle 延伸模組版本不同
inspection.different.kotlin.gradle.version.display.name=Kotlin Gradle 和 IDE 延伸模組版本不同
action.Kotlin.Gradle.ShowDslLogs.text=顯示 Kotlin Gradle DSL 日誌
inspection.maven.coroutines.deprecation.display.name=與 Maven 中的 Kotlin 1.3+ 一起使用的 kotlinx.coroutines 依賴項不相容
inspection.deprecated.maven.dependency.display.name=在 Maven 中使用了棄用的庫
inspection.different.kotlin.maven.version.display.name=Maven 和 IDE 延伸模組版本不同
inspection.different.maven.stdlib.version.display.name=庫和 Maven 延伸模組版本不同
inspection.kotlin.test.j.unit.display.name=kotlin-test-junit 可以使用
inspection.kotlin.maven.plugin.phase.display.name=Kotlin Maven 延伸模組設定錯誤
action.KotlinGenerateMavenPluginAction.text=Kotlin 延伸模組
action.KotlinGenerateMavenTestCompileExecutionAction.text=Kotlin 測試編譯執行
action.KotlinGenerateMavenCompileExecutionAction.text=Kotlin 編譯執行
dialog.message.incorrect.target.path.directory.not.specified=目標路徑錯誤。未指定目錄。
dialog.message.none.elements.were.selected=未選擇任何元素
a.field.without.an.initializer.is.not.yet.supported=尚不支持沒有初始設定式的欄位
a.constructor.call.is.not.yet.supported=尚不支持構造函數調用
failed.to.create.a.wrapper.for.inlining.to.kotlin=無法創建內聯到 Kotlin 的包裝器
inspection.unused.result.of.data.class.copy=資料類複製的未使用結果
unclear.precedence.of.binary.expression.inspection.display.name=具有不同優先級的多個運算符
unclear.precedence.of.binary.expression.inspection=表達式應當使用明確的圓括號
unclear.precedence.of.binary.expression.quickfix=添加明確的圓括號
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=即使是明顯的案例也報告
replace.function.call.with.if=將函數調用取代為 'if'
lift.function.call.out.of.if=從 'if' 中解除函數調用

replace.function.call.with.the.opposite=將函數調用取代為相反的函數調用
replace.0.with.1.and.vice.versa=將 ''{0}'' 取代為 ''{1}''，反之亦然

inspection.kotlin.constant.conditions.display.name=恒定條件
inspection.message.value.always.true=''{0}'' 的值始終為 true
inspection.message.value.always.false=''{0}'' 的值始終為 false
inspection.message.condition.always.true=條件 ''{0}'' 始終為 true
inspection.message.condition.always.false=條件 ''{0}'' 始終為 false
inspection.message.condition.always.true.when.reached=條件 ''{0}'' 滿足後始終為 true
inspection.message.condition.always.false.when.reached=條件 ''{0}'' 滿足後始終為 false
inspection.message.value.always.zero=''{0}'' 的值始終為零
inspection.message.value.always.null=''{0}'' 的值始終為 null

inspection.message.when.condition.always.true='when' 分支總是可以到達
inspection.message.when.condition.always.false='when' 分支永遠無法到達
inspection.message.cast.will.always.fail=轉換總是失敗
inspection.message.nonnull.cast.will.always.fail=操作將始終失敗，因為操作數始終為 null
inspection.message.index.out.of.bounds=索引總是超出界限
inspection.message.for.never.visited='for' 範圍始終為空

floating.point.literal.precision.inspection.display.name=浮點文字超出可用精度
floating.point.literal.precision.inspection=浮點文字無法以所需的精度表示

inspection.replace.mapIndexed.with.list.generator.display.name=將 'mapIndexed' 取代為 List 生成器
should.be.replaced.with.list.generator=應取代為 List 生成器
replace.with.list.generator.fix.text=取代為 List 生成器

inspection.replace.with.import.alias.display.name=完全限定名稱可被取代為現有的匯入別名
replace.with.import.alias=取代為匯入別名

inspection.convert.argument.to.set.display.name=實參可以轉換為 'Set' 以提高性能
can.convert.argument.to.set=可將實參轉換為 'Set' 以提高性能
convert.argument.to.set.fix.text=將實參轉換為 'Set'
convert.to.unicode.escape=轉換為 Unicode 轉義
popup.title.expressions=表達式
popup.title.types=類型
popup.title.elements=元素
action.hints.settings.text=提示設定…
start.import.button.text.add=添加
start.import.button.text.remove=移除
import.order.button.text.add.package=添加軟體套件
import.order.button.text.remove=移除
import.order.button.text.up=上
import.order.button.text.down=下
import.text.all.other.imports=所有其他匯入
import.text.import=匯入
import.text.all.alias.imports=所有別名匯入
extract.new.parameter.name.receiver=<接收器>
facets.editor.general.tab.label.depends.on.0=依賴於: {0}。
kotlin.compiler.configurable=Kotlin 編譯器
kotlin.language.configurable=Kotlin
kotlin.scripting.configurable=Kotlin 腳本
hint.text.no.expression.found=找不到表達式
progress.title.calculating.type=正在計算類型…
intention.name.correct.parameter.name=更正參數名稱
intention.add.import.alias.group.name=添加匯入別名
inspection.message.inconsistent.parameter.name.for.0=''{0}'' 的參數名稱不一致
inspection.kotlin.catch.may.ignore.exception.display.name='catch' 塊可能會忽略異常
inspection.message.empty.catch.block=空 catch 塊

project.wizard.new.project.kotlin.comment=要創建複雜的專案，請使用 <a>Kotlin Multiplatform</a> 生成器。

add.empty.argument.list=添加空實參列表

loading.available.versions.from.maven=正在從 Maven 載入可用版本...
failed.fetching.all.available.versions.from.maven=從 Maven 載入所有可用版本失敗
progress.text.detect.test.framework=檢測測試框架

find.declaration.implementing.methods.checkbox=實作函數(&I)
find.declaration.overriding.methods.checkbox=覆寫函數(&R)
find.declaration.implementing.properties.checkbox=實作屬性(&I)
find.declaration.overriding.properties.checkbox=覆寫屬性(&R)
find.declaration.property.readers.checkbox=讀取器
find.declaration.property.writers.checkbox=編寫器
find.declaration.include.overloaded.methods.checkbox=包含多載函數和擴展(&V)
find.declaration.functions.usages.checkbox=函數的用法(&F)
find.declaration.properties.usages.checkbox=屬性的用法(&P)
find.declaration.constructor.usages.checkbox=構造函數的用法(&C)
find.declaration.derived.classes.checkbox=派生類(&D)
find.declaration.derived.interfaces.checkbox=派生接口(&I)
find.usages.class=類
find.usages.companion.object=伴生物件
find.usages.constructor=構造函數
find.usages.facade.class=外觀類
find.usages.for.property=屬性的{0}
find.usages.function=函數
find.usages.getter=getter
find.usages.import.alias=匯入別名
find.usages.interface=接口
find.usages.label=標籤
find.usages.lambda=lambda
find.usages.object=物件
find.usages.parameter=參數
find.usages.property.accessor=屬性存取器
find.usages.property=屬性
find.usages.setter=setter
find.usages.type.alias=類型別名
find.usages.type.parameter=類型參數
find.usages.variable=變數
find.usages.checkbox.name.expected.classes=預期類
find.usages.class.name.anonymous=匿名
find.usages.checkbox.name.expected.functions=預期函數
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>尋找資料類組件和析構宣告的用法<br/>可以<a href="{0}">一次禁用</a>或<a href="{1}">單獨為專案禁用</a>。</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=禁用搜尋資料類組件和析構宣告。(專案範圍設定)
find.usages.checkbox.text.fast.data.class.component.search=快速資料類組件搜尋
find.usages.checkbox.name.expected.properties=預期屬性
find.usages.type.named.argument=命名實參
find.usages.type.type.alias=類型別名
find.usages.type.callable.reference=可調用引用
find.usages.type.type.constraint=類型約束
find.usages.type.value.parameter.type=參數類型
find.usages.type.nonLocal.property.type=類/物件屬性類型
find.usages.type.function.return.type=函數返回類型
find.usages.type.superType=父類型
find.usages.type.is='is' 操作的目標類型
find.usages.type.class.object=嵌套類/物件
find.usages.type.companion.object=伴生物件
find.usages.type.function.call=函數調用
find.usages.type.implicit.get=隱式 'get'
find.usages.type.implicit.set=隱式 'set'
find.usages.type.implicit.invoke=隱式 'invoke'
find.usages.type.implicit.iteration=隱式迭代
find.usages.type.property.delegation=屬性委託
find.usages.type.extension.receiver.type=擴展接收器類型
find.usages.type.super.type.qualifier=super 類型限定符
find.usages.type.receiver=接收器
find.usages.type.delegate=委託
find.usages.type.packageDirective=軟體套件指令
find.usages.type.packageMemberAccess=軟體套件成員存取
and.delete.initializer=並刪除初始設定式
change.to.val=更改為 'val'
change.to.var=更改為 'var'
remove.redundant.0.modifier=移除冗餘 ''{0}'' 修飾符
searching.for.implicit.usages=正在搜尋隱式用法…
usage.provider.text.property.of.0={0}/{1}
usage.provider.text.unnamed=<未命名>
add.jvminline.annotation=添加 '@JvmInline' 註解
fix.import.question=匯入{0}?
fix.add.annotation.text.constructor=將 ''@{0}'' 註解添加到構造函數
fix.opt_in.annotation.family=註解選擇加入功能用法
fix.opt_in.text.use.declaration=在 ''{1}'' 上選擇加入 ''{0}''
fix.opt_in.text.use.constructor=在構造函數上選擇加入 ''{0}''
fix.opt_in.text.use.containing.class=在所包含的類 ''{1}'' 上選擇加入 ''{0}''
fix.opt_in.text.use.containing.file=在所包含的檔案 ''{1}'' 中選擇加入 ''{0}''
fix.opt_in.text.propagate.declaration=將 ''{0}'' 選擇加入要求傳播到 ''{1}''
fix.opt_in.text.propagate.constructor=將 ''{0}'' 選擇加入要求傳播到構造函數
fix.opt_in.text.propagate.containing.class=將 ''{0}'' 選擇加入要求傳播到所包含的類 ''{1}''
fix.opt_in.remove.all.forbidden.targets=移除禁止的選擇加入註解目標
fix.replace.annotation.family=取代註解
fix.replace.annotation.text=將註解取代為 ''@{0}''
inspection.non.exhaustive.when.statement.migration.display.name=將從 1.7 開始禁止非窮舉的 'when' 語句
modifier.match.val=符合 val
modifier.match.var=符合 var
modifier.also.match.val=同時符合 val
modifier.also.match.var=同時符合 var
predefined.configuration.also.match.vals=同時符合 var 和 val
modifier.match.companion.object=符合伴生物件
modifier.also.match.companion.object=同時符合伴生物件
predefined.configuration.object.companion.object=物件和伴生物件
inlay.kotlin.references.types.hints=顯示類型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.function.parameter=顯示函數參數類型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.function.return=顯示函數返回類型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.variable=顯示局部變數類型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.property=顯示屬性類型的嵌入提示
inlay.kotlin.lambdas.hints=顯示 lambda 的嵌入提示
inlay.kotlin.call.chains.hints=顯示調用鏈的嵌入提示
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=顯示隱式接收器和參數的嵌入提示
inlay.kotlin.lambdas.hints.hints.lambda.return=顯示返回表達式的嵌入提示
fix.opt_in.move.requirement.from.value.parameter.to.property=將 ''{0}'' 選擇加入要求從值參數移動到屬性
fix.opt_in.move.requirement.from.getter.to.property=將 ''{0}'' 選擇加入要求從 getter 移動到屬性
fix.opt_in.migrate.experimental.annotation.replace=將已棄用的 '@Experimental' 註解取代為 '@RequiresOptIn'
fix.opt_in.migrate.experimental.annotation.remove=移除已棄用的 '@Experimental' 註解
inspection.unnecessary.opt_in.annotation.display.name=不必要的 '@OptIn' 註解
inspection.unnecessary.opt_in.redundant.marker=選擇加入標記冗餘: 未使用標記為 ''{0}'' 的實驗 API
inspection.unnecessary.opt_in.redundant.annotation=選擇加入註解冗餘: 沒有使用符合的實驗 API
inspection.unnecessary.opt_in.remove.marker.fix.family.name=移除選擇加入標記
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=移除註解
inspection.kotlin.unused.variable.display.name=未使用的變數
surround.with.array.of=使用 arrayOf(...) 環繞
surround.with.0=使用 {0}(...) 環繞
highlighter.tool.tip.has.expect.declaration.in=在 {0} 模組中具有預期值
configuration.title.early.access.preview.version=搶先體驗預覽
fix.add.annotation.with.arguments.text.copy=將 ''@{0}'' 註解從 ''{1}'' 複製到 ''{2}''
fix.make.upperbound.not.nullable.any.text=將 ''Any'' 添加為 {0} 的上限以使其不可為空
fix.make.upperbound.not.nullable.remove.nullability.text=將 {0} 的上限更改為 ''{1}'' 以使 {0} 不可為空
fix.make.upperbound.not.nullable.family=使泛型類型參數不可為空
facet.label.text.project.settings.that.are.used.for.this.facet=用於此 Facet 的專案設定:
script.name.kotlin.script.dependencies=Kotlin 腳本依賴項
replace.size.check.with.0=將大小檢查取代為 ''{0}''
formatter.title.line.break.after.multiline.when.entry=在多行條目後換行
fix.make.field.public=將欄位 ''{0}'' 設為 public
plugin.updater.not.installed.see.log.action=請參閱日誌了解更多資訊
intention.name.specify.supertype=指定父類型
popup.title.choose.supertype=選擇父類型
convert.body.to.expression = 將正文轉換為表達式
inspection.do.not.propagate.method.deprecation.through.overrides=自 1.9 起不得通過覆寫傳播方法描述
inspection.kotlin.jvm.annotation.in.java.display.name=Java 中的 Kotlin JVM 註解
inspection.kotlin.jvm.annotation.in.java.description=Kotlin JVM 註解 ''{0}'' 在 Java 中無效
inspection.verbose.nullability.and.emptiness.display.name=詳細的可空性和空性檢查
inspection.verbose.nullability.and.emptiness.call=將後續檢查取代為 ''{0}()'' 調用
kotlin.script.in.project.sources=不保證對專案原始碼中包含的腳本提供 IDE 支援
kotlin.script.in.project.sources.hide=隱藏
kotlin.script.in.project.sources.link=https://youtrack.jetbrains.com/issue/KTIJ-19432
kotlin.script.in.beta.stage=Kotlin 腳本現在處於測試階段
kotlin.script.in.beta.stage.link=https://kotlinlang.org/docs/components-stability.html#stability-levels-explained
kotlin.script.warning.more.info=更多資訊
rename.only.current.0=僅重命名當前的{0,choice,1#函數|2#屬性}
rename.base.0=重命名基{0,choice,1#函數|2#屬性|3#成員|4#方法|11#函數|12#屬性|13#成員|14#方法}
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1#實作|2#覆寫}{3}的{2}
kotlin.dist.downloading.failed.group.name=Kotlin dist 下載失敗
fix.add.member.supertype.family=將 {0} 添加到父類型
fix.add.member.supertype.text=將 {0} 添加到父類型…
fix.add.member.supertype.progress=將 {0} 添加到類型
fix.add.member.supertype.choose.type=選擇類型
fix.add.member.supertype.add.to=將 ''{0}'' 添加到 ''{1}''
add.return.expression=添加 'return' 表達式
provide.return.value=提供返回值
inspection.add.conversion.call.display.name=自 1.9 起需要從 `Int` 顯式轉換
inspection.ambiguous.expression.when.branch.migration.display.name=自 1.7 起 'when' 分支中不明確的邏輯表達式
wrap.expression.in.parentheses=將表達式括在圓括號中
inspection.this.class.does.not.have.a.constructor=禁止的構造函數調用
kotlin.eap.survey.notification.group.name=Kotlin EAP 調查
kotlin.eap.survey.notification.title=Kotlin 搶先體驗計劃
kotlin.eap.survey.notification.text=我們想更多地了解您，以及我們如何才能使 EAP 體驗更方便!
kotlin.eap.survey.notification.action=進行 EAP 調查
kotlin.eap.survey.notification.link=https://surveys.jetbrains.com/s3/kotlin-eaps-survey
inspection.progression.resolution.change.migration.display.name=自 1.9 起的進度解析度變更
make.member.static.quickfix=將 ''{0}'' 設為 static
inlay.kotlin.values.hints=顯示值的內嵌提示
inlay.kotlin.values.hints.kotlin.values.ranges=顯示範圍的嵌入提示
kotlin.values.hints=顯示值的內嵌提示
kotlin.values.hints.kotlin.values.ranges=Kotlin: 顯示範圍的嵌入提示
hints.settings.values.ranges=範圍
predefined.configuration.function.explicit.inferred.type=顯式和推斷類型
hints.settings.show.types.property=顯示屬性類型提示
hints.settings.dont.show.types.property=不顯示屬性類型提示
hints.settings.show.types.variable=顯示局部變數類型提示
hints.settings.dont.show.types.variable=不顯示局部變數類型提示
hints.settings.show.types.return=顯示函數返回類型提示
hints.title.show.argument.name.enabled=顯示參數名稱提示
hints.title.dont.show.argument.name.enabled=不顯示參數名稱提示
hints.settings.dont.show.types.return=不顯示函數返回類型提示
hints.settings.show.types.parameter=顯示函數參數類型提示
hints.settings.dont.show.types.parameter=不顯示函數參數類型提示
hints.settings.show.lambda.return=顯示返回表達式提示
hints.settings.dont.show.lambda.return=不顯示返回表達式提示
hints.settings.show.lambda.receivers.parameters=顯示隱式接收器和參數提示
hints.settings.dont.show.lambda.receivers.parameters=不顯示隱式接收器和參數提示
hints.settings.show.suspending=顯示掛起調用提示
hints.settings.dont.show.suspending=不顯示掛起調用提示
hints.settings.show.ranges=顯示範圍提示
hints.settings.dont.show.ranges=不顯示範圍提示
hints.types=類型提示
analyzer.version=分析器版本:
inspection.kotlin.redundant.suppression.display.name=冗餘的診斷禁止
configuration.text.bundled.0.jps.version=捆綁的({0})
configuration.text.0.unsupported.jps.version={0} (不支持)
kotlin.jps.plugin.group.name=Kotlin JPS 延伸模組
deprecated.jvm.version=(已棄用)
configuration.maven.group.name=Kotlin Maven 專案匯入
configuration.maven.jvm.target.1.6.title=不支持的 JVM 目標 1.6
configuration.maven.jvm.target.1.6.content=Maven 專案使用已不再支援的 JVM 目標 1.6 進行 Kotlin 編譯。它已作為 JVM 目標 1.8 匯入。請考慮將專案遷移到 JVM 1.8。
livetemplate.description.maina=main(args) 函數
configuration.migration.text.update.your.code.to.replace.deprecated=更新您的程式碼以使用支援的構造取代已棄用的語言和庫功能
configuration.migration.text.scan.for.deprecations=掃描棄用的內容
0.1.be.lifted.out.of.2=可從 ''{1}'' 提取出 ''{0}''
0.1.could.be.private={0} ''{1}'' 可以為 private
0.1.is.never.used={0} ''{1}'' 從未使用
0.already.exists={0} 已存在
0.always.returns.non.null.type=''{0}'' 始終返回非 null 類型
0.call.could.be.simplified.to.1={0} 呼叫可以簡化為 {1}
0.call.should.be.replaced.with.array.literal=''{0}'' 呼叫應被取代為數組字面量 [...]
0.from.1={0} 來自 {1}
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} 已在 {2} 中檢測到 {1} 程式碼 {1,choice,1\#片段|2\#片段}，可以用 {3} 取代。您想要檢視並取代 {1,choice,1\#它|2\#它們}嗎?
0.has.empty.body=''{0}'' 具有空體
0.in.1.will.require.class.instance={1} 中的 ''{0}'' 將需要類別接口
0.interface.1={0}接口 ''{1}''
0.is.always.non.null.type=''{0}'' 始終為非 null 類型
0.is.expected.to.be.used.since.kotlin.1.3=從 Kotlin 1.3 起，預期使用 ''{0}''
0.is.missing.documentation={0} 缺少文檔
0.is.overridden.by.declaration.s.in.a.subclass={0} 已由子類別中的宣告覆寫
0.may.break.code={0}(可能中斷程式碼)
0.on.a.readonly.1.creates.a.new.1.under.the.hood=唯讀{1}上的 ''{0}'' 在背景建立新的{1}
0.references.type.parameters.of.the.containing.class=包含類別的 {0} 參照類型參數
0.should.return.unit={0} 應返回 Unit
0.try.1.with.2.fails.and.3.verifications={0} [嘗試 {1}，{2} 次失敗和 {3} 次驗證]
0.will.become.invisible.after.extraction={0} 在提取之後將變為不可見
0.will.no.longer.be.accessible.after.extraction={0} 在提取之後將不再可存取
a.constructor.call.is.not.yet.supported=尚不支持建構函式呼叫
a.field.without.an.initializer.is.not.yet.supported=尚不支持沒有初始設定式的欄位
accessing.non.final.property.0.in.constructor=正在存取建構函式中的非 final 屬性 {0}
action.CacheResetOnProcessCanceledToggleAction.text=ProcessCanceledException 時重設快取
action.CheckComponentsUsageSearchAction.text=檢查組件函式用法搜尋
action.ConfigureKotlinInProject.text=在專案中組態 Kotlin
action.ConvertJavaToKotlin.text=將 Java 檔案轉換為 Kotlin 檔案
action.CopyAsDiagnosticTest.text=將當前檔案複製為診斷測試
action.CopyKotlinProjectInformation.text=將 Kotlin 專案概覽複製到剪貼簿
action.DecompileKotlinToJava.text=將 Kotlin 反編譯為 Java
action.DumbModeTremble.text=Tremble Dumb 模式
action.ExtractFunction.text=提取函式(_F)…
action.ExtractFunctionToScope.text=將函式提取到作用域(_S)…
action.FindImplicitNothingAction.text=尋找隱式 Nothing 呼叫
action.GotoSuperClass.MainMenu.text=超類別(_U)
action.GotoSuperClass.text=轉到超類別(_U)
action.GotoSuperInterface.MainMenu.text=Super 接口(_U)
action.GotoSuperInterface.text=轉到 super 接口(_U)
action.GotoSuperProperty.MainMenu.text=super 屬性(_U)
action.GotoSuperProperty.description=導覽到當前屬性覆寫或實作的屬性的宣告
action.GotoSuperProperty.text=轉到 super 屬性(_U)
action.HighlightingBenchmarkAction.text=基準醒目提示
action.InspectBreakpointApplicability.text=檢查中斷點可用性
action.IntroduceProperty.text=引入屬性(_R)…
action.IntroduceTypeAlias.text=引入類型別名(_A)…
action.IntroduceTypeParameter.text=引入類型參數(_Y)…
action.Kotlin.ClearScratch.description=清除 Kotlin 臨時檔案
action.Kotlin.ClearScratch.text=清除 Kotlin 臨時檔案
action.Kotlin.NewFile.description=建立新的 Kotlin 類別或檔案
action.Kotlin.NewFile.text=Kotlin 類別/檔案
action.Kotlin.NewScript.description=建立新的 Kotlin 腳本或工作表
action.Kotlin.NewScript.text=Kotlin 腳本
action.Kotlin.RunScratch.description=執行 Kotlin 臨時檔案
action.Kotlin.RunScratch.text=執行 Kotlin 臨時檔案
action.Kotlin.StopScratch.description=停止執行臨時檔案
action.Kotlin.StopScratch.text=停止執行臨時檔案
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=僅顯示 Kotlin 變數
action.KotlinCodeMigration.text=執行程式碼遷移
action.KotlinCodeMigrationToggle.text=啟用遷移檢測
action.KotlinConfigurePlugin.text=組態 Kotlin 延伸模組
action.KotlinConsoleREPL.text=Kotlin REPL (實驗性)
action.KotlinFormattingSettingsStatusAction.text=格式化程序設定資訊
action.KotlinGenerateDataMethod.text=參數函式
action.KotlinGenerateEqualsAndHashCode.text=equals() 和 hashCode()
action.KotlinGenerateMavenCompileExecutionAction.text=Kotlin 編譯執行
action.KotlinGenerateMavenPluginAction.text=Kotlin 延伸模組
action.KotlinGenerateMavenTestCompileExecutionAction.text=Kotlin 測試編譯執行
action.KotlinGenerateSecondaryConstructor.text=輔助建構函式
action.KotlinGenerateSetUpMethod.text=SetUp 函式
action.KotlinGenerateTearDownMethod.text=TearDown 函式
action.KotlinGenerateTestMethod.text=測試函式
action.KotlinGenerateToString.text=toString()
action.KotlinShellExecute.description=在主控台中執行 Kotlin 程式碼
action.KotlinShellExecute.text=執行 Kotlin 程式碼
action.KotlinThrowException.text=刪除來自 Kotlin 延伸模組的錯誤
action.LibraryToSourceDependencySupportToggleAction.text=將庫切換為源相依項支援
action.LocalCompletionBenchmarkAction.text=本地方案
action.PrintOutNotPropertyMatches.text=搜尋非屬性候選項
action.ShowKotlinBytecode.text=顯示 Kotlin 位元組碼
action.StoredExceptionsThrowToggleAction.text=拋出快取的 PCE
action.TestMoveRefactiringAction.text=在開啟的專案上測試移動重構
action.TopLevelCompletionBenchmarkAction.text=頂級方案
action.add.import.chooser.title=Import
action.generate.equals.choose.equals=選擇要包含在 'equals()' 中的屬性
action.generate.equals.choose.hashcode=選擇要包含在 'hashCode()' 中的屬性
action.generate.functions.already.defined=對於類別 {1}，函式 {0} 已經定義。是否要將其刪除並繼續?
action.generate.secondary.constructor.choose.properties=選擇要通過建構函式初始化的屬性
action.generate.secondary.constructor.error.already.exists=建構函式已存在
action.generate.super.type=顯式指定 super 類型
action.generate.test.support.choose.framework=選擇框架
action.generate.test.support.choose.test.name=選擇測試名稱\:
action.generate.test.support.edit.template=編輯模板
action.generate.test.support.error.cant.convert.java.template=無法將 Java 模板轉換為 Kotlin
action.generate.test.support.error.cant.generate.method=無法生成方法\: {0}
action.generate.test.support.error.no.template.found=沒有找到 {0} 的模板\: {1}
action.generate.tostring.choose.implementation=選擇實作\:
action.generate.tostring.choose.implementation.mnemonic=i
action.generate.tostring.generate.super.call=生成對 super.toString() 的呼叫
action.generate.tostring.generate.super.call.mnemonic=秒
action.generate.tostring.name=生成 'toString()'
action.generate.tostring.template.multiple=包含串聯的多個模板
action.generate.tostring.template.multiple.with.super=帶有串聯和 super 呼叫的多個模板
action.generate.tostring.template.single=單個模板
action.generate.tostring.template.single.with.super=帶有 super 呼叫的單個模板
action.hints.settings.text=提示設定…
action.j2k.correction.errors.multiple=''{0}'' 和 {1} 其他 Java 檔案包含語法錯誤，轉換結果可能不正確
action.j2k.correction.errors.single=''{0}'' 包含語法錯誤，轉換結果可能不正確
action.j2k.correction.investigate=調查錯誤
action.j2k.correction.proceed=繼續轉換
action.j2k.correction.required=您專案其餘部分的一些程式碼在執行此轉換後可能需要更正。是否要尋找此類別程式碼並更正?
action.j2k.error.cant.find.document=找不到 ''{0}'' 的文檔
action.j2k.error.cant.save.result=無法儲存轉換結果\: {0}
action.j2k.error.nothing.to.convert=沒有要轉換的內容\:<br>找不到可寫的 Java 檔案
action.j2k.error.read.only=檔案 ''{0}'' 為唯讀檔案
action.j2k.name=將 Java 轉換為 Kotlin
action.j2k.task.name=將檔案從 Java 轉換為 Kotlin
action.move.method=移動方法…
action.new.file.dialog.annotation.title=註解
action.new.file.dialog.class.title=類別
action.new.file.dialog.data.class.title=資料類別
action.new.file.dialog.enum.title=枚舉類別
action.new.file.dialog.file.title=檔案
action.new.file.dialog.interface.title=接口
action.new.file.dialog.object.title=物件
action.new.file.dialog.sealed.class.title=密封類別
action.new.file.dialog.sealed.interface.title=密封接口
action.new.file.dialog.title=新 Kotlin 類別/檔案
action.new.file.error.empty.name=名稱不能為空
action.new.file.error.empty.name.part=名稱不能有空白部分
action.new.script.dialog.script=新增 Kotlin 腳本
action.new.script.dialog.title=新增 Kotlin 腳本檔案
action.new.script.name=Kotlin 腳本
action.text.append=追加
action.text.cancel=取消
action.text.continue=繼續
action.text.install=安裝
action.text.overwrite=覆蓋
action.usage.update.command=用法更新
add.0.constructor.to.1=將 {0} 建構函式新增到 ''{1}''
add.0.library=新增 ''{0}'' 庫
add.0.to.argument=將 ''{0} \='' 新增到實參
add.an.opt.in.requirement.marker.compiler.argument=新增選擇加入要求標記編譯器實參
add.braces=新增大括號
add.braces.to.0.statement=將大括號新增到 ''{0}'' 語句
add.braces.to.all.branches=向所有分支新增大括號
add.braces.to.if.all.statements=向所有 'if' 語句新增大括號
add.braces.to.when.all.entries=向所有 'when' 條目新增大括號
add.braces.to.when.entry=將大括號新增到 'when' 條目
add.call.or.unwrap.type.fix.text=將 ''.{0}()'' 新增到函式結果 (中斷使用站點\!)
add.call.or.unwrap.type.fix.text1=解包 ''{0}'' 返回值類型(中斷 use-site\!)
add.clarifying.braces.to.nested.else.statement=為嵌套的 'else' 語句新增明確的大括號
add.constructor.keyword=新增 'constructor' 關鍵字
add.constructor.parameters.from.0.1=從 {0}{1} 新增建構函式參數
add.constructor.parameters.from.superclass=從超類別新增建構函式參數
add.documentation.fix.text=新增文檔
add.empty.argument.list=新增空實參列表
add.empty.brackets.after.primary.constructor=在主建構函式後新增空括號
add.explicit.parameter.to.outer.lambda.fix.text=將顯式參數名稱新增到外部 lambda
add.explicit.type.arguments=新增顯式類型實參
add.external.keyword=新增 external 關鍵字
add.full.qualifier=新增完全限定符
add.fun.modifier.to.0=將 ''fun'' 修飾符新增到 ''{0}''
add.import.for.0=為 ''{0}'' 新增 import
add.import.for.member=為成員新增匯入
add.indices.to.for.loop=將索引新增到 'for' 迴圈
add.initializer=新增初始設定式
add.interpolation.prefix=新增插值前綴
add.jvminline.annotation=新增 '@JvmInline' 註解
add.jvmoverloads.annotation=新增 '@JvmOverloads' 註解
add.jvmoverloads.annotation.to.0=將 ''@JvmOverloads'' 註解新增到 {0}
add.jvmstatic.annotation=新增 '@JvmStatic' 註解
add.kotlin.coroutines=新增 Kotlin 協程庫
add.kotlin.coroutines.description=新增 Kotlin 協程庫
add.labeled.return.to.last.expression.in.a.lambda=將帶標籤的 return 新增到 lambda 中的最後一個表達式
add.method=新增方法
add.method.0.to.1=將方法 ''{0}'' 新增到 ''{1}''
add.missing.class.keyword=新增缺少的 'class' 關鍵字
add.missing.component=新增缺失的解構組件
add.modifier=新增修飾符
add.name.to.argument=將名稱新增到實參
add.names.in.comment.to.call.arguments=在註釋中為呼叫實參新增名稱
add.names.to.call.arguments=將名稱新增到呼叫實參
add.names.to.this.argument.and.following.arguments=將名稱新增到此實參和所有後續實參
add.operator.modifier=新增 'operator' 修飾符
add.qualifier=新增鏈接限定符
add.qualifier.command=新增鏈接限定符
add.remaining.branches=新增剩餘的分支
add.replacewith.argument.to.specify.replacement.pattern=新增 'replaceWith' 實參以指定取代模式
add.return.at.0=新增 ''return@{0}''
add.return.expression=新增 'return' 表達式
add.source.retention=新增源保留
add.throws.annotation=新增 '@Throws' 註解
add.underscores=新增下劃線
add.use.site.target=新增使用站點目標
add.val.to.parameter.0=將 ''val'' 新增到參數 ''{0}''
add.val.var.to.parameter.0=將 ''val'' 或 ''var'' 新增到參數 ''{0}''
add.val.var.to.primary.constructor.parameter=將 'val' 或 'var' 新增到主建構函式參數
add.variance.fix.family.name=新增差異
add.variance.fix.text=新增 ''{0}'' 差異
advanced.setting.kotlin.mpp.experimental=啟用實驗性多平台 IDE 功能
advanced.setting.kotlin.mpp.experimental.description=需要 IDE 重啟
all.expected.and.actual.classes.must.be.sealed.classes=所有預期和實際類別必須為密封類別。\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=所有繼承者必須為類別自己的嵌套物件，且不會從其他類別或接口繼承。\n
ambiguous.actuals.for.0={0} 在模組 {1} 中具有多個相容的實際宣告
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=由於掛起函式的 CoroutineScope 接收器，coroutineContext 不明確
ambiguous.non.local.break.or.continue.display.name=不明確的非區域 'break' 或 'continue'
ambiguous.non.local.break.or.continue.use.label=不明確的非本地 ''{0}'' (''{1}'' 與 ''{2}'')。使用明確的標籤。
ambiguous.non.local.break.or.continue.use.label.or.contract=不明確的非本地 ''{0}'' (''{1}'' 與 ''{2}'')。使用明確的標籤或將 ''callsInPlace'' 約定新增到 ''{3}''。
analyzed.0.classes.no.difference.found=已分析 {0} 類別。未找到差異。
analyzing.functions=正在分析函式…
analyzing.members=正在分析成員…
and.delete.initializer=並刪除初始設定式
apply.also.to.internal.members=同時應用於 internal 成員
apply.also.to.private.members=同時應用於 private 成員
apply.in.the.project.0=在專案中套用\: {0}
apply.only.to.public.or.protected.members=僅應用於 public 或 protected 成員
applying.0=正在套用 ''{0}''
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode='data' 類別中存在類型為 'Array' 的屬性\: 建議覆寫 'equals()' 和 'hashCode()'
assert.should.be.replaced.with.operator=斷言應取代為運算符
assign.backing.field.fix.text=分配支援欄位
assigned.value.is.never.read=指定的值從未被讀取
base.property.0=基本屬性 {0}
big.decimal.equals=在 'BigDecimal' 上調用了 'equals()'
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>\#ref()</code> 可能應當是 'compareTo()' \#loc
block.body=塊主體
boolean.literal.argument.without.parameter.name=不包含參數名稱的布爾字面量實參
boolean.property.in.external.interface.should.be.nullable=external 接口中的布爾屬性應為可以為 null
breadcrumbs.tooltip.indexing=正在編制索引…
button.add.package=新增軟體套件
button.rename.base=重新命名基
button.rename.current=重新命名當前
button.text.move.nested.class.0.to.another.class=將嵌套類別 {0} 移至另一個類別(&M)
button.text.move.nested.class.0.to.upper.level=將嵌套類別 {0} 移至上一級別(&N)
call.chain.length.to.transform=要轉換的呼叫鏈長度\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=可以將集合上的呼叫鏈轉換為 'Sequence' 來改善性能
call.chain.on.collection.type.may.be.simplified=可以簡化集合類型上的呼叫鏈
call.is.replaceable.with.another.scope.function=呼叫可被取代為另一個作用域函式
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=呼叫包含可為 null 的接收器的 'inline fun' 在 Kotlin 1.2 及更低版本中可能引起 'NPE'
call.of.java.mutator.0.on.immutable.kotlin.collection.1=在不可變的 Kotlin 集合 ''{1}'' 上呼叫 Java 轉變器 ''{0}''
call.on.collection.type.may.be.reduced=可以簡化集合類型上的呼叫
call.on.not.null.type.may.be.reduced=可以簡化非 null 類型上的呼叫
call.replaceable.with.binary.operator=呼叫可被取代為二元運算符
call.with.arguments.will.be.skipped.0=將跳過具有實參的呼叫\: {0}
callable.reference.fix.family.name=新增顯式 ''{0}''
callable.reference.transformation.is.not.supported.0=不支持可呼叫的參照轉換\: {0}
calling.non.final.function.0.in.constructor=正在呼叫建構函式中的非 final 函式 {0}
calls.with.explicit.extension.receiver.won.t.be.processed.0=不會處理包含隱式擴展接收器的呼叫\: {0}
can.be.converted.to.to=顯式 'Pair' 初始化可被取代為中綴 'to()' 呼叫
can.be.joined.with.assignment=可以與賦值聯接
can.convert.argument.to.set=可將實參轉換為 'Set' 以提高性能
can.t.finish.while.indexing.is.in.progress=當索引編制正在進行時，無法完成
can.t.modify.0=無法修改 {0}
can.t.replace.foreign.reference.with.call.expression.0=無法將外來參照取代為呼叫表達式\: {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=無法將非 Kotlin 參照取代為呼叫表達式\: {0}
cannot.extract.super.call=不能提取 super-call
cannot.get.or.create.results.file=無法獲取或生成結果檔案
cannot.get.project.root.directory=無法獲取專案根目錄
cannot.infer.type.for.this.declaration=無法推斷此宣告的類型
cannot.inline.property.with.accessor.s.and.backing.field=無法使用存取器和支援欄位內聯屬性
cannot.introduce.parameter.of.0.type=無法引入類型為 ''{0}'' 的參數
cannot.refactor.expression.has.unit.type=無法引入 unit 類型的表達
cannot.refactor.no.container=無法在此位置重構
cannot.refactor.no.expression=沒有表達無法執行重構
cannot.refactor.no.type=沒有類型無法執行重構
cannot.refactor.not.expression=找不到要引入的表達式
cannot.refactor.package.expression=無法引入軟體套件參照
cannot.refactor.syntax.errors=由於錯誤的程式碼無法重構
cannot.refactor.synthesized.function=無法重構合成函式
cascade.if.should.be.replaced.with.when=級聯 'if' 應取代為 'when'
cast.explicitly.fix.text=顯式轉換
category.class=Kotlin/基於類別
category.comments=Kotlin/註釋、KDoc 和元資料
category.declaration=Kotlin/宣告
category.expressions=Kotlin/表達式
category.interesting=Kotlin/關注
category.operators=Kotlin/運算符
change.all.usages.of.0.in.this.file.to.1=將此檔案中所有的 ''{0}'' 用法例更改為 ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=將此檔案中所有的 ''{0}'' 用法例更改為 Kotlin 類別
change.existent.retention.to.source=將現有保留更改為源
change.main.function.return.type.to.unit.fix.text=新增顯式 Unit 返回值類型
change.main.function.return.type.to.unit.fix.text2=將返回值類型更改為 Unit
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=其他語言可能不支持該預設參數
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=預設的 Kotlin 呼叫值可能會導致其他語言的程式碼不正確
change.to.0=更改為 ''{0}''
change.to.constructor.invocation=更改為建構函式呼叫
change.to.correct.long.suffix.l=更改為正確的長後綴 'L'
change.to.correct.primitive.type=更改為正確的基元類型
change.to.kotlin.class=更改為 Kotlin 類別
change.to.val=更改為 'val'
change.to.var=更改為 'var'
change.type.of.0.to.1=將 {0} 的類型更改為 ''{1}''
change.type.to.0=將類型更改為 ''{0}''
change.type.to.mutable.fix.text=將類型更改為可變
change.visibility=更改可見性
change.visibility.modifier=更改可見性修飾符
change.visibility.popup=更改可見性
checkbox.collapse.to.expression.body=摺疊到表達式主體
checkbox.text.declare.with.var=使用 var 宣告(&V)
checkbox.text.delete.empty.source.files=刪除空白原始檔(&D)
checkbox.text.extension.property=擴展屬性(&X)\:
checkbox.text.introduce.default.value=引入預設值(&D)
checkbox.text.open.moved.files.in.editor=在編輯器中開啟移動的成員
checkbox.text.replace.all.occurrences.0=取代所有符合項 ({0})(&R)
checkbox.text.search.references=搜尋參照(&R)
checkbox.text.specify.type.explicitly=顯式指定類型(&T)
checkbox.text.update.package.directive=更新軟體套件指令(Kotlin 檔案)
checking.data.class.0.of.1=正在檢查資料類別 {0}/{1}…
checking.data.classes=正在檢查資料類別
choose.actual.members.title=選擇實際成員
choose.actual.module=選擇 actual 的模組
choose.an.appropriate.kotlin.class=選擇適當的 Kotlin 類別
choose.class.container=選擇類別容器
choose.target.class.or.interface=選擇目標類別或接口
class=類別
class.0.already.contains.1=類別 ''{0}'' 已包含 {1}
class.name.prompt=類別名(&N)\:
class.should.be.external.interface=類別應為 external 接口
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=剪貼簿內容複製自 Java 檔案。是否要將其轉換為 Kotlin 程式碼?
code.insight.workspace.settings.title=Kotlin
codestyle.layout.import.aliases.separately=單獨匯入別名
codestyle.name.kotlin=Kotlin
column.name.context.parameter=上下文參數\:
column.name.default.parameter=預設參數\:
column.name.receiver=接收器\:
column.name.val.var=Val/Var
command.generate.test.support.generate.test.function=生成測試函式
command.move.declarations=移動宣告
comment=註釋
companion.object.already.contains.0=伴生物件已包含 {0}
compiling.project=正在編譯專案…
condition.is.always.0=條件始終為 ''{0}''
configuration.kotlin.code.style.group.name=Kotlin 官方程式碼樣式可用
configuration.maven.group.name=Kotlin Maven 專案匯入
configuration.message.enter.fully.qualified.method.name=輸入完全限定方法名稱\:
configuration.migration.group.name=Kotlin\: 可遷移到較新版本
configuration.name.method=方法
configuration.status.text.installing=正在安裝…
configuration.title.add.exclusion=新增排除
configuration.title.edit.exclusion=編輯排除
const.might.be.used.instead.of.jvmfield=可能使用了 'const'，而不是 '@JvmField'
const.property=const 屬性
constructor=建構函式
constructor.has.non.null.self.reference.parameter=建構函式具有非 null 自參照參數
constructor.parameter.is.never.used.as.a.property=建構函式參數從未被用作屬性
context.default=預設
context.property.getter.or.setter=具有顯式 getter/setter 的屬性
convert.0.to.1=將 ''{0}'' 轉換為 ''{1}''
convert.anonymous.function.to.lambda.expression=將匿名函式轉換為 lambda 表達式
convert.argument.to.set.fix.text=將實參轉換為 'Set'
convert.body.to.expression=將正文轉換為表達式
convert.boolean.const.to.elvis=將 Boolean? \=\= const 轉換為 elvis
convert.call.chain.into.sequence.fix.text=將呼叫鏈轉換為 'Sequence'
convert.class.0.to.kotlin=將類別 ''{0}'' 轉換為 Kotlin
convert.collection.constructor.to.function=將集合建構函式轉換為函式
convert.comparisons.to.range.check=將比較轉換為 ''{0}''
convert.concatenation.to.build.string=將串聯轉換為 'buildString' 呼叫
convert.concatenation.to.raw.string=將串聯轉換為原始字串
convert.concatenation.to.template=將串聯轉換為模板
convert.concatenation.to.template.before.text='String' 串聯可以轉換為模板
convert.context.parameter.to.receiver.parameter=將上下文參數轉換為接收器
convert.context.parameter.to.regular.parameter=將上下文參數轉換為值參數
convert.context.parameter.to.regular.parameter.progress=正在轉換…
convert.expression.to.0=將表達式轉換為 ''{0}''
convert.expression.to.0.by.inserting.1=通過插入 ''.{1}'' 將表達式轉換為 ''{0}''
convert.extension.function.type.to.regular.function.type=將擴展函式類型轉換為一般函式類型
convert.extension.property.initializer.to.getter=將擴展屬性初始設定式轉換為 getter
convert.from.class.to.kclass=將 'KClass' 轉換為 'Class'
convert.function.to.property=將函式轉換為屬性
convert.function.type.parameter.to.receiver=將函式類型參數轉換為接收器
convert.function.type.receiver.to.parameter=將函式類型接收器轉換為參數
convert.lambda.expression.to.anonymous.function=將 lambda 表達式轉換為匿名函式
convert.lambda.to.reference=將 lambda 轉換為參照
convert.lambda.to.reference.before.text=lambda' 可以轉換為參照
convert.left.hand.side.to.0=將左側轉換為 ''{0}''
convert.member.to.extension=將成員轉換為擴展
convert.na.n.equality.quick.fix.text=取代為 'isNaN()'
convert.object.literal.to.class=將物件字面量轉換為類別
convert.object.literal.to.lambda=將物件字面量轉換為 lambda
convert.pair.constructor.to.to.fix.text=取代為中綴 'to'
convert.parameter.to.receiver=將參數轉換為接收器
convert.path.to.explicit.collection=將 Path 轉換為顯式 Collection
convert.property.getter.to.initializer=將屬性 getter 轉換為初始設定式
convert.property.initializer.to.getter=將屬性初始設定式轉換為 getter
convert.property.to.function=將屬性轉換為函式
convert.put.to.assignment=將 put 轉換為賦值
convert.receiver.parameter.to.context.parameter=將接收器轉換為上下文參數
convert.receiver.to.parameter=將接收器轉換為參數
convert.reference.to.lambda=將參照轉換為 lambda
convert.reference.to.lambda.before.text=參照可以轉換為 lambda
convert.right.hand.side.to.0=將右側轉換為 ''{0}''
convert.scope.function.fix.family.name=轉換為 ''{0}''
convert.sealed.subclass.to.object.fix.family.name=將 sealed 子類別轉換為物件
convert.string.template.to.build.string=轉換為 'buildString' 呼叫
convert.string.to.character.literal=將字串轉換為字元字面量
convert.supertype.to.0=將父類型轉換為 ''{0}''
convert.template.to.concatenated.string=將模板轉換為串聯字串
convert.to.0=轉換為 {0}
convert.to.0.as.1=轉換為 ''{0} as {1}''
convert.to.0.unsafecast.1=轉換為 ''{0}.unsafeCast<{1}>()''
convert.to.a.range.check=轉換為範圍檢查
convert.to.anonymous.function=轉換為匿名函式
convert.to.anonymous.object=轉換為匿名物件
convert.to.array.parameter=轉換為數組參數
convert.to.assignment.expression=將賦值語句轉換為表達式
convert.to.block.body=轉換為塊主體
convert.to.comparisons=轉換為比較
convert.to.data.object=轉換為 'data object'
convert.to.enum.class=轉換為枚舉類別
convert.to.expression.body.fix.text=轉換為表達式主體
convert.to.indexed.function.call=轉換為索引函式呼叫
convert.to.lambda=轉換為 lambda
convert.to.lambda.expression=轉換為 lambda 表達式
convert.to.lateinit.var=轉換為 lateinit 變數
convert.to.lazy.property=轉換為延遲屬性
convert.to.minus.element.call=轉換為 'minusElement' 呼叫(會更改語意)
convert.to.multi.dollar.string=轉換為多美元字串
convert.to.notnull.delegate=轉換為非 null 委託
convert.to.nullable.type=轉換為可為 null 類型
convert.to.nullable.type.fix.text=轉換為可為 null 類型
convert.to.nullable.var=轉換為可為 null 變數
convert.to.object.declaration=轉換為物件宣告
convert.to.ordinary.property=轉換為普通屬性
convert.to.ordinary.string.literal=轉換為普通字串字面量
convert.to.plus.element.call=轉換為 'plusElement' 呼叫(會更改語意)
convert.to.primary.constructor=轉換為主建構函式
convert.to.primary.constructor.before.text=輔助建構函式應轉換為主建構函式
convert.to.raw.string.literal=轉換為原始字串字面量
convert.to.sealed.class=轉換為密封類別
convert.to.secondary.constructor=轉換為輔助建構函式
convert.to.trim.indent=轉換為 'trimIndent()' 呼叫
convert.to.trim.margin=轉換為 'trimMargin()' 呼叫
convert.to.unicode.escape=轉換為 Unicode 轉義
convert.to.unsafe.cast=轉換為不安全的轉換
convert.to.unsafecast.call=轉換為 unsafeCast() 呼叫
convert.to.vararg.parameter=轉換為 vararg 參數
convert.too.long.character.literal.to.string=將過長的字元字面量轉換為字串
convert.try.finally.to.use=將 'try-finally' 取代為 'use()'
convert.try.finally.to.use.before.text=try-finally 可被取代為 'use()'
convert.value.parameter.to.context.parameter=將值參數轉換為上下文參數
copy.concatenation.text.to.clipboard=將串聯文本複製到剪貼簿
copy.method.of.data.class.is.called.without.named.arguments=應為 'copy()' 方法呼叫顯式指定參數名稱
copy.paste.reference.notification=已新增 {0} 個{0, choice, 1\#匯入|2\#匯入}<p><span><a href\=''show''>檢查新增的匯入…</a></span>
copy.paste.resolve.pasted.references=解析貼上的參照
copy.paste.restore.pasted.references=還原貼上的參照
copy.paste.restore.pasted.references.capitalized=還原貼上的參照
copy.paste.select.imports.to.remove.dialog=選擇要移除的 import
copy.paste.select.imports.to.remove.text=<html>您貼上的程式碼段使用了在新上下文中無法存取的元素。已新增必要的 import。<br/>選擇要從檔案中移除哪些已新增的 import。</html>
could.be.replaced.with.size=可被取代為 'size'
could.be.replaced.with.unboxed.first=可被取代為未裝箱的 'first'
could.be.replaced.with.unboxed.last=可被取代為未裝箱的 'last'
create.0=建立 {0}
create.0.1=建立 {0} ''{1}''
create.0.in.1=在 {1} 中建立 {0}
create.actual=建立 actual
create.actual.0.for.module.1.2=為模組 {1} 建立實際{0} ({2})
create.actual.in.0=在 ''{0}'' 中建立 actual
create.actuals=建立缺失的 actual…
create.expected.0.in.common.module.1=在通用模組 {1} 中建立預期{0}
create.kotlin.file=建立 Kotlin 檔案
create.kotlin.subclass=建立 Kotlin 子類別
create.label=建立標籤
create.label.0=建立標籤 {0}@
create.package.0=建立軟體套件 ''{0}''
create.parameter.0=建立參數 ''{0}''
create.property.0.as.constructor.parameter=作為建構函式參數建立屬性 ''{0}''
create.subclass=建立子類別
create.test=建立測試
dangerous.array.comparison=危險的陣列比較
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=宣告已從平台呼叫推斷出類型，這可能導致未檢查的為 null 性問題。將類型顯式指定為可為 null 或不可為 null。
declarations.are.used.outside.of.selected.code.fragment=下面的宣告使用於選擇的程式碼段之外\:
declarations.will.move.out.of.scope=以下宣告在提取的函式體之外不可用\:
deferred.result.is.never.used='Deferred' 結果未被使用
delegating.to.var.property.does.not.take.its.changes.into.account=委託給 'var' 屬性不會考慮其更改
delete.0=刪除 {0}
delete.assignment.completely=完全刪除賦值
delete.equals.and.hash.code.fix.text=刪除 equals()/hashCode()
delete.fix.family.name=移除箭頭
delete.redundant.extension.property=刪除冗餘擴展屬性
delete.with.usage.search=刪除 (通過用法搜尋)
demorgan.law=德摩根定律
deprecated.annotation.without.replacewith.argument=不包含 'replaceWith' 實參的 '@Deprecated' 註解
description.a.reference.to.extracted.type.parameter=參照提取的類型參數
destination.not.found.for.package.0=沒有為軟體套件 ''{0}'' 找到目標
diagnostic.name.should.be.replaced.by.the.new.one=診斷名稱應取代為新名稱
dialog.message.incorrect.target.path.directory.not.specified=目標路徑錯誤。未指定目錄。
dialog.message.none.elements.were.selected=未選擇任何元素
dialog.progress.collect.members.to.generate=收集成員…
dialog.title.build.super.types.hierarchy=為 {0} 建置父類型層次結構
dialog.title.resolving.inheritable.status=正在解析可繼承狀態…
difference.found.for.data.class.0.found.1.2=為數據類別 {0} 找到差異。找到 {1} 個用法，但應為 {2}
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=是否要刪除預期宣告和所有相關實際宣告?
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=是否要在預期宣告和所有相關實際宣告中刪除此參數?
do.you.want.to.make.new.extension.an.expected.declaration=是否要將新擴展設為預期宣告?
doesn.t.match.regex.0=與正則表達式 ''{0}'' 不符合
don.t.show.this.dialog.next.time=下次不顯示此對話框(&D)
double.negation.fix.text=移除冗餘求反
editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=自動將 'val' 關鍵字新增到資料/值類別建構函式參數
editor.checkbox.title.convert.pasted.java.code.to.kotlin=將貼上的 Java 程式碼轉換為 Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=貼上時不顯示 Java 至 Kotlin 轉換對話框
editor.title.kotlin=Kotlin
enter.package.fqname=輸入軟體套件 FqName
enum.entry=枚舉條目
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=使用相等檢查 {0} 而不是 elvis 進行可為 null 布爾檢查
equality.check.with.nan.should.be.replaced.with.isnan=包含 NaN 的相等檢查應取代為 'isNaN()'
equals.between.objects.of.inconvertible.types='equals()' 位於不可轉換類型的物件之間
equals.hashcode.in.object.declaration=物件宣告中的 'equals()'/'hashCode()'
equals.should.take.any.as.its.argument='equals' 應將 'Any?' 作為其實參
equals.text=生成 'equals()'
error.cant.refactor.vararg.functions=不能重構具有可變實參的函式
error.context.getter.or.setter=此上下文僅適用於具有顯式 getter/setter 的屬性。(將檔案類型設定為 Kotlin)
error.expected.an.expression=應為表達式
error.expected.catch.or.finally=應為 'catch' 或 'finally'
error.hint.cannot.modify.0.declaration.from.1.file=無法修改 ''{1}'' 檔案中的 ''{0}'' 宣告
error.hint.library.declarations.cannot.be.changed=庫宣告不能更改
error.hint.text.cannot.inline.0.from.a.decompiled.file=無法從反編譯檔案內聯 ''{0}''
error.param.can.t.be.null.at.index.0.in.1=參數在 {1} 中索引 {0} 處不能為 null。
error.text.can.t.change.signature.of.method=無法更改 {0} 方法的簽名
error.text.can.t.copy.class.to.the.containing.file=無法將類別複製到包含檔案
error.text.can.t.generate.0.1=無法生成{0}\: {1}
error.text.can.t.introduce.constant.for.this.expression=無法為此表達式引入常數
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=無法為非常數表達式引入常數
error.text.can.t.introduce.lambda.parameter.for.this.expression=無法為此表達式引入 lambda 參數
error.text.can.t.introduce.property.for.this.expression=無法為此表達式引入屬性
error.text.different.name.expected=應為不同名稱
error.text.expression.has.no.type=表達式沒有類型
error.text.extraction.from.expect.class.is.not.yet.supported=尚不支持從預期類別提取
error.text.extraction.from.non.jvm.class.is.not.yet.supported=尚不支持從非 JVM 類別提取
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=具有多個 return 語句的函式不支持“內聯函式”。
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=return 語句不在主體末尾的函式不支持“內聯函式”。
error.text.interface.cannot.be.extracted.from.an.annotation.class=無法從註解類別中提取接口
error.text.introduce.parameter.is.not.available.for.default.value=“引入參數”不適用於預設值
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=“引入參數”不適用於註解條目內部
error.text.invalid.name=名稱無效
error.text.invalid.parameter.name=參數名無效
error.text.invalid.parameter.type=參數類型無效
error.text.invalid.receiver.type=接收器類型無效
error.text.invalid.return.type=返回值類型無效
error.text.no.type.to.refactor=沒有要重構的類型
error.text.refactoring.is.not.applicable.in.the.current.context=重構不適用於當前上下文
error.text.superclass.cannot.be.extracted.from.an.annotation.class=無法從註解類別中提取超類別
error.text.type.reference.is.expected=應為類型參照
error.types.in.generated.function=無法生成返回值類型錯誤的函式
error.wrong.caret.position.function.or.constructor.name=文字游標應置於要重構的函式或建構函式的名稱處。
evaluate.compile.time.expression=對編譯時表達式求值
excluded.methods=排除的方法\:
existing.backing.field.is.not.assigned.by.the.setter=現有支援欄位未由 setter 分配
expand.boolean.expression.to.if.else=將布爾表達式擴展為 'if else'
experimental.coroutines.usages.are.obsolete.since.1.3=從 1.3 起，實驗性協程用法遭到廢棄
explicit.0.call=顯式 ''{0}'' 呼叫
explicit.this.expression.fix.family.name=移除冗餘的 ''{0}''
explicit.type.arguments.can.be.inferred=顯式類型實參可以推斷
explicitly.given.type.is.redundant.here=顯式給定類型在此處冗餘
explicitly.ignore.return.value=顯式忽略返回值
expression=表達式
external.interface.contains.non.nullable.property.name=external 接口包含不可為 null 的布爾屬性
external.interface.contains.val.property.name=external 接口包含 val 屬性
extract.function=提取函式
extract.new.parameter.name.receiver=<接收器>
extract.side.effects=提取副作用
failed.to.create.a.wrapper.for.inlining.to.kotlin=無法建立內聯到 Kotlin 的包裝器
family.name.update.usages.on.declarations.cut.paste=剪下/貼上宣告時更新用法
file.entity=檔案
file.lines=檔案行
files.to.visit=要存取的檔案
find.declaration.constructor.usages.checkbox=建構函式的用法(&C)
find.declaration.derived.classes.checkbox=派生類別(&D)
find.declaration.derived.interfaces.checkbox=派生接口(&I)
find.declaration.functions.usages.checkbox=函式的用法(&F)
find.declaration.implementing.methods.checkbox=實作函式(&I)
find.declaration.implementing.properties.checkbox=實作屬性(&I)
find.declaration.include.overloaded.methods.checkbox=包含多載函式和擴展(&V)
find.declaration.overriding.methods.checkbox=覆寫函式(&R)
find.declaration.overriding.properties.checkbox=覆寫屬性(&R)
find.declaration.properties.usages.checkbox=屬性的用法(&P)
find.declaration.property.readers.checkbox=讀取器
find.declaration.property.writers.checkbox=編寫器
find.usages.checkbox.name.expected.classes=預期類別
find.usages.checkbox.name.expected.functions=預期函式
find.usages.checkbox.name.expected.properties=預期屬性
find.usages.checkbox.text.fast.data.class.component.search=快速資料類別組件搜尋
find.usages.class=類別
find.usages.class.name.anonymous=匿名
find.usages.companion.object=伴生物件
find.usages.constructor=建構函式
find.usages.facade.class=外觀類別
find.usages.for.property=屬性的{0}
find.usages.function=函式
find.usages.getter=getter
find.usages.import.alias=匯入別名
find.usages.interface=接口
find.usages.label=標籤
find.usages.lambda=lambda
find.usages.object=物件
find.usages.parameter=參數
find.usages.prepare.dialog.progress=準備對話框
find.usages.progress.text.declaration.superMethods=正在解析 super 方法…
find.usages.property=屬性
find.usages.property.accessor=屬性存取器
find.usages.setter=setter
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>尋找資料類別組件和解構宣告的用法<br/>可以<a href\="{0}">一次停用</a>或<a href\="{1}">單獨為專案停用</a>。</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=停用搜尋資料類別組件和解構宣告。(專案範圍設定)
find.usages.type.alias=類型別名
find.usages.type.callable.reference=可調用參照
find.usages.type.class.object=嵌套類別/物件
find.usages.type.companion.object=伴生物件
find.usages.type.constructor.delegation.reference=建構函式委託參照
find.usages.type.delegate=委託
find.usages.type.extension.receiver.type=擴展接收器類型
find.usages.type.function.call=函式呼叫
find.usages.type.function.return.type=函式返回值類型
find.usages.type.implicit.get=隱式 'get'
find.usages.type.implicit.invoke=隱式 'invoke'
find.usages.type.implicit.iteration=隱式迭代
find.usages.type.implicit.set=隱式 'set'
find.usages.type.is='is' 動作的目標類型
find.usages.type.named.argument=命名實參
find.usages.type.nonLocal.property.type=類別/物件屬性類型
find.usages.type.packageDirective=軟體套件指令
find.usages.type.packageMemberAccess=軟體套件成員存取
find.usages.type.parameter=類型參數
find.usages.type.property.delegation=屬性委託
find.usages.type.receiver=接收器
find.usages.type.super.type.qualifier=super 類型限定符
find.usages.type.superType=父類型
find.usages.type.type.alias=類型別名
find.usages.type.type.constraint=類型約束
find.usages.type.value.parameter.type=參數類型
find.usages.variable=變數
fix.add.annotation.family=新增註解
fix.add.annotation.target=新增註解目標
fix.add.annotation.text.constructor=將 ''@{0}'' 註解新增到建構函式
fix.add.annotation.text.containing.class=將 ''@{0}'' 註解新增到包含類別 ''{1}''
fix.add.annotation.text.containing.file=將 ''@{0}'' 註解新增到包含檔案 ''{1}''
fix.add.annotation.text.declaration=將 ''@{0}'' 註解新增到 ''{1}''
fix.add.annotation.text.self=新增 ''@{0}'' 註解
fix.add.annotation.with.arguments.text.copy=將 ''@{0}'' 註解從 ''{1}'' 複製到 ''{2}''
fix.add.argument.name.family=將名稱新增到實參
fix.add.argument.name.step.choose.parameter.title=選擇參數名稱
fix.add.argument.name.text=將名稱新增到實參\: ''{0}''
fix.add.argument.name.text.generic=將名稱新增到實參…
fix.add.array.of.type.family=新增 'arrayOf' 包裝器
fix.add.array.of.type.text=新增 {0} 包裝器
fix.add.constructor.parameter=新增建構函式參數 ''{0}''
fix.add.default.constructor=將預設建構函式新增到 'expect' 類別
fix.add.else.branch.when=新增 else 分支
fix.add.eq.eq.true=新增 '\=\= true'
fix.add.exception.to.throws=新增 ''{0}''
fix.add.explicit.coroutine.scope.receiver=新增顯式 'this' 接收器
fix.add.explicit.import=新增顯式匯入
fix.add.explicit.receiver.family=新增顯式接收器
fix.add.function.body=新增函式體
fix.add.function.parameters.add.parameter.constructor=將第 {0,number,ordinal} 個{1,choice,1\#參數|2\#參數}新增到建構函式 ''{2}''
fix.add.function.parameters.add.parameter.function=將第 {0,number,ordinal} 個{1,choice,1\#參數|2\#參數}新增到函式 ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=將{0,choice,1\#參數|2\#參數}新增到建構函式 ''{1}''
fix.add.function.parameters.add.parameter.generic.function=將{0,choice,1\#參數|2\#參數}新增到函式 ''{1}''
fix.add.function.parameters.change.signature.constructor=更改建構函式 ''{0}'' 的簽名
fix.add.function.parameters.change.signature.function=更改函式 ''{0}'' 的簽名
fix.add.generic.upperbound.family=新增泛型上限
fix.add.generic.upperbound.text=作為 {1} 的上限新增 ''{0}''
fix.add.is.to.when=在 ''{0}'' 前面新增 ''is''
fix.add.loop.label.text=將 ''{0}'' 新增到 {1}
fix.add.loop.label.text.generic=將標籤新增到迴圈
fix.add.member.supertype.add.to=將 ''{0}'' 新增到 ''{1}''
fix.add.member.supertype.choose.type=選擇類型
fix.add.member.supertype.family=將 {0} 新增到父類型
fix.add.member.supertype.progress=將 {0} 新增到類型
fix.add.member.supertype.text=將 {0} 新增到父類型…
fix.add.modifier.family=新增修飾符
fix.add.modifier.inline.function.family=將 'inline' 新增到函式
fix.add.modifier.inline.function.text=將 ''inline'' 新增到函式 ''{0}''
fix.add.modifier.inline.parameter.family=將 ''{0}'' 新增到參數
fix.add.modifier.inline.parameter.text=將 ''{0}'' 新增到參數 ''{1}''
fix.add.modifier.text=使{0} ''{1}''
fix.add.modifier.text.generic=新增 ''{0}'' 修飾符
fix.add.new.line.after.annotations=在註解後面新增新行
fix.add.remaining.branches=新增剩餘的分支
fix.add.remaining.branches.with.star.import=使用 * 匯入新增剩餘的分支
fix.add.return.before.expression=在表達式前面新增 'return'
fix.add.return.before.lambda.expression=在 lambda 表達式前面新增 'run'
fix.add.return.last.expression=將 'return' 新增到上一個表達式
fix.add.semicolon.lambda.expression=使用分號終止前面的呼叫
fix.add.spread.operator.after.sam=在作為 'vararg' 傳遞的陣列之前新增展開運算符
fix.add.star.projection.family=新增星號投影
fix.add.star.projection.text=新增 ''{0}''
fix.add.suspend.modifier.function=將 {0} 設為suspend
fix.add.suspend.modifier.function.generic=使包含函式掛起
fix.add.suspend.modifier.receiver=使{0}類型掛起
fix.add.suspend.modifier.receiver.generic=使接收器類型掛起
fix.add.tostring.call.family=新增 'toString()' 呼叫
fix.add.tostring.call.text=新增 'toString()' 呼叫
fix.add.tostring.call.text.safe=新增安全的 '?.toString()' 呼叫
fix.add.type.annotation.family=新增類型註解
fix.add.type.annotation.text=將類型 ''{0}'' 新增到參數 ''{1}''
fix.assign.to.property=分配給屬性
fix.cast.expression.family=轉換表達式
fix.cast.expression.text=將表達式 ''{0}'' 轉換為 ''{1}''
fix.change.accessor.family=更改存取器類型
fix.change.accessor.getter=將 getter 類型更改為 {0}
fix.change.accessor.setter.parameter=將 setter 參數類型更改為 {0}
fix.change.jvm.name=更改 JVM 名稱
fix.change.mutability.change.to.val=將 ''{0}'' 更改為 val
fix.change.object.to.class=將 'object' 更改為 'class'
fix.change.package.family=更改檔案的軟體套件以符合目錄
fix.change.package.text=將檔案的軟體套件更改為 {0}
fix.change.progress.analyzing.class.hierarchy=正在分析類別層次結構…
fix.change.progress.looking.inheritors=正在尋找類別 {0} 繼承者…
fix.change.return.type.command.function=將函式 ''{1}'' 的參數 ''{0}'' 類型更改為 ''{2}''
fix.change.return.type.command.primary.constructor=將類別 ''{1}'' 的主建構函式的參數 ''{0}'' 類型更改為 ''{2}''
fix.change.return.type.family=更改類型
fix.change.return.type.lambda=將 lambda 表達式返回值類型更改為 {0}
fix.change.return.type.presentation.accessed=存取的{0}
fix.change.return.type.presentation.base=基{0}
fix.change.return.type.presentation.called=呼叫的{0}
fix.change.return.type.presentation.called.function=呼叫的函式
fix.change.return.type.presentation.enclosing=封閉的 {0}
fix.change.return.type.presentation.enclosing.function=封閉的函式
fix.change.return.type.presentation.function=函式 {0}
fix.change.return.type.presentation.property=屬性 {0}
fix.change.return.type.remove.explicit.return.type=移除顯式指定的返回值類型
fix.change.return.type.remove.explicit.return.type.of=移除 {0} 的顯式指定的返回值類型
fix.change.return.type.return.type.text=將返回值類型更改為 ''{0}''
fix.change.return.type.return.type.text.of=將 {0} 的返回值類型更改為 ''{1}''
fix.change.return.type.text.function=將函式 ''{1}'' 的參數 ''{0}'' 類型更改為 ''{2}''
fix.change.return.type.text.primary.constructor=將類別 ''{1}'' 主建構函式的參數 ''{0}'' 類型更改為 ''{2}''
fix.change.return.type.type.text=將類型更改為 ''{0}''
fix.change.return.type.type.text.of=將 {0} 的類型更改為 ''{1}''
fix.change.signature.error=<錯誤>
fix.change.signature.family=更改函式/建構函式的簽名
fix.change.signature.function.family=更改函式簽名
fix.change.signature.function.popup.title=選擇簽名
fix.change.signature.function.text=將函式簽名更改為 ''{0}''
fix.change.signature.function.text.generic=更改函式簽名…
fix.change.signature.lambda=更改 lambda 表達式的簽名
fix.change.signature.lambda.command=更改 Lambda 表達式的簽名
fix.change.signature.prepare=準備…
fix.change.signature.remove.parameter=移除參數 ''{0}''
fix.change.signature.remove.parameter.command=移除參數 ''{0}''
fix.change.signature.unavailable=<不可用>
fix.change.signature.unnamed.parameter=參數
fix.change.suspend.hierarchy.add=將 'suspend' 修飾符新增到層次結構中的所有函式
fix.change.suspend.hierarchy.remove=從層次結構中的所有函式中移除 'suspend' 修飾符
fix.change.to.function.invocation=更改為函式呼叫
fix.change.to.labeled.return.family=更改為帶標籤的返回
fix.change.to.labeled.return.text=更改為 ''{0}''
fix.change.to.mutable.type.family=將類型更改為可變
fix.change.to.mutable.type.text=將類型更改為 {0}
fix.change.to.property.access.family.change=更改為屬性存取
fix.change.to.property.access.family.remove=移除呼叫
fix.change.to.star.projection.family=更改為星號投影
fix.change.to.star.projection.text=將類型實參更改為 {0}
fix.change.to.use.spread.operator.family=更改為使用展開運算符
fix.change.to.use.spread.operator.text=將 ''{0}'' 更改為 ''{1}''
fix.change.type.argument=將類型實參更改為 {0}
fix.change.type.family=更改類型
fix.change.type.text=將類型從 ''{0}'' 更改為 ''{1}''
fix.convert.to.is.array.of.call=轉換為 'isArrayOf' 呼叫
fix.copy.mismatched.annotation.to.actual.declaration.may.change.semantics=將不符合的註解 ''{0}'' 從 ''expect'' 宣告複製到 ''actual'' 宣告(可能會更改語意)
fix.create.declaration.error=無法生成 {0}\: {1}
fix.create.declaration.error.inaccessible.type=無法存取的類型
fix.create.declaration.error.some.types.inaccessible=有些類型無法存取\:
fix.create.expect.actual=建立預期/實際宣告
fix.create.from.usage.abstract.property=建立抽象屬性 ''{0}''
fix.create.from.usage.dialog.title=根據用法建立
fix.create.from.usage.extension.property=建立擴展屬性 ''{0}''
fix.create.from.usage.family=從用法建立
fix.create.from.usage.local.variable=建立區域變數 ''{0}''
fix.create.from.usage.property=建立屬性 ''{0}''
fix.create.missing.actual.declarations=新增缺少的實際宣告
fix.create.missing.actual.declarations.title=新增缺少的實際宣告
fix.create.missing.actual.members=新增缺少的實際成員
fix.import=Import
fix.import.exclude=從自動匯入中排除 ''{0}''
fix.import.kind.0.name.1.2=匯入{0} ''{1}''{2,choice,0\#|1\# 和其他 {2} 個}
fix.import.kind.0.name.1.and.name.2=匯入{0} ''{1}''、''{2}''
fix.import.kind.component.functions=組件函式
fix.import.kind.delegate.accessors=委託存取器
fix.import.question=匯入{0}?
fix.insert.delegation.call=插入 ''{0}()'' 呼叫
fix.introduce.non.null.assertion.family=新增非 null 斷言呼叫
fix.introduce.non.null.assertion.text=新增非 null 斷言({0}\!\!)呼叫
fix.make.data.class=將 ''{0}'' 設為數據類別
fix.make.field.public.family=將欄位設為 public
fix.make.field.public.text=將欄位 ''{0}'' 設為 public
fix.make.type.parameter.reified=使 {0} 具體化且使 {1} 內聯
fix.make.upperbound.not.nullable.any.text=將 ''Any'' 新增為 {0} 的上限以使其不可為 null
fix.make.upperbound.not.nullable.family=使泛型類型參數不可為 null
fix.make.upperbound.not.nullable.remove.nullability.text=將 {0} 的上限更改為 ''{1}'' 以使 {0} 不可為 null
fix.move.file.to.package.dir.name.text=來源根
fix.move.file.to.package.family=將檔案移至軟體套件符合目錄
fix.move.file.to.package.text=將檔案移至{0}
fix.move.to.sealed.family=將層次結構成員移至其密封父級的軟體套件/模組
fix.move.to.sealed.text=將 {0} 移至 {1} 的軟體套件/模組
fix.move.typealias.to.top.level=將類型別名移到頂層
fix.opt_in.annotation.family=註解選擇加入功能用法
fix.opt_in.migrate.experimental.annotation.remove=移除已棄用的 '@Experimental' 註解
fix.opt_in.migrate.experimental.annotation.replace=將已棄用的 '@Experimental' 註解取代為 '@RequiresOptIn'
fix.opt_in.move.requirement.from.getter.to.property=將 ''{0}'' 選擇加入要求從 getter 移至屬性
fix.opt_in.move.requirement.from.value.parameter.to.property=將 ''{0}'' 選擇加入要求從值參數移至屬性
fix.opt_in.remove.all.forbidden.targets=移除禁止的選擇加入註解目標
fix.opt_in.remove.forbidden.retention=移除禁止的選擇加入註解保留
fix.opt_in.text.propagate.constructor=將 ''{0}'' 選擇加入要求傳播到建構函式
fix.opt_in.text.propagate.containing.class=將 ''{0}'' 選擇加入要求傳播到所包含的類別 ''{1}''
fix.opt_in.text.propagate.containing.object=將 ''{0}'' 選擇加入要求傳播到包含物件 ''{1}''
fix.opt_in.text.propagate.declaration=將 ''{0}'' 選擇加入要求傳播到 ''{1}''
fix.opt_in.text.use.constructor=在建構函式上選擇加入 ''{0}''
fix.opt_in.text.use.containing.anonymous.object=在包含物件上選擇加入 ''{0}''
fix.opt_in.text.use.containing.class=在所包含的類別 ''{1}'' 上選擇加入 ''{0}''
fix.opt_in.text.use.containing.file=在所包含的檔案 ''{1}'' 中選擇加入 ''{0}''
fix.opt_in.text.use.containing.object=在包含物件 ''{1}'' 上選擇加入 ''{0}''
fix.opt_in.text.use.declaration=在 ''{1}'' 上選擇加入 ''{0}''
fix.opt_in.text.use.module=在模組 ''{1}'' 中選擇加入 ''{0}''
fix.opt_in.text.use.statement=在語句上選擇加入 ''{0}''
fix.potentially.broken.inheritance.message=此更改可能會破壞繼承者
fix.remove.annotation.text=移除註解
fix.remove.argument.text=移除實參
fix.remove.mismatched.annotation.from.expect.declaration.may.change.semantics=從 ''expect'' 宣告中移除不符合的註解 ''{0}'' (可能會更改語意)
fix.remove.non.null.assertion=移除不必要的非 null 斷言(\!\!)
fix.remove.redundant.star.text=移除冗餘的 *
fix.replace.annotation.family=取代註解
fix.replace.annotation.text=將註解取代為 ''@{0}''
fix.replace.mismatched.annotation.args.on.actual.declaration.may.change.semantics=取代 ''actual'' 宣告中不符合的註解 ''{0}'' 的實參(可能會更改語意)
fix.replace.mismatched.annotation.args.on.expect.declaration.may.change.semantics=取代 ''expect'' 宣告中不符合的註解 ''{0}'' 的實參(可能會更改語意)
fix.replace.run.blocking.with.inline=用內聯程式碼取代 'runBlocking'
fix.replace.run.blocking.with.run=將 'runBlocking' 取代為 'run'
fix.replace.run.blocking.with.withContext=將 'runBlocking' 取代為 'withContext'
fix.replace.run.family=將 'runBlocking' 取代為內聯執行、'withContext' 或 'run'
fix.replace.with.assign.function.call=取代為 ''{0}'' 呼叫
fix.replace.with.declaring.java.class=取代為 'declaringJavaClass'
fix.unused.receiver.parameter.remove=移除冗餘的接收器參數
fix.use.fully.qualified.call=使用完全限定的呼叫
fix.with.asdynamic=使用 'asDynamic' 修復
flatten.when.expression=平展 'when' 表達式
flip.0=翻轉 ''{0}''
flip.binary.expression=翻轉二元表達式
flip.equals=翻轉 'equals'
floating.point.literal.precision.inspection=浮點字面量無法以所需的精度表示
floating.point.literal.precision.inspection.display.name=浮點字面量超出可用精度
flow.constructed.but.not.used=Flow 已建置但未使用
foldable.if.then=可折疊的 if-then
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=不會處理下列表達式，因為重構無法保留其語意\: {0}
following.problems.are.found=發現以下問題\:\n
for.0=對於 ''{0}''
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=為確保 API 穩定性，建議顯式指定宣告類型
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=為確保 API 穩定性，建議顯式指定 public 和 protected 宣告類型
for.loop.over.indices.could.be.replaced.with.loop.over.elements=索引的迴圈可被取代為元素的迴圈
formatter.button.text.use.import.with=將 import 與 '*' 搭配使用
formatter.button.text.use.import.with.when.at.least=至少以下條件下將 import 與 '*' 搭配使用
formatter.button.text.use.single.name.import=使用單個名稱匯入
formatter.checkbox.text.collection.literal.expression=集合字面量表達式
formatter.checkbox.text.context.receiver.list=上下文接收器列表
formatter.checkbox.text.destructuring.declaration=解構宣告
formatter.checkbox.text.function.literal=函式字面量
formatter.checkbox.text.indices=索引
formatter.checkbox.text.insert.imports.for.nested.classes=為嵌套類別插入匯入
formatter.checkbox.text.type.argument.list=類型實參列表
formatter.checkbox.text.type.parameter.list=類型參數列表
formatter.checkbox.text.use.trailing.comma=使用尾隨逗號
formatter.checkbox.text.value.argument.list=值實參列表
formatter.checkbox.text.value.parameter.list=值參數列表
formatter.checkbox.text.when.entry=進入時
formatter.settings.title=Kotlin 格式化程序設定
formatter.text.names.used=\ 使用的名稱
formatter.text.use.defaults.from=使用以下位置的預設值\:
formatter.title.after.colon.before.declaration.type=冒號後，宣告類型前
formatter.title.after.colon.in.new.type.definition=新類型定義中的冒號後
formatter.title.align.when.branches.in.columns=對齊列中的 'when' 分支
formatter.title.around.arrow.in=“when”子句中箭頭周圍
formatter.title.around.arrow.in.function.types=函式類型中箭頭周圍
formatter.title.around.when.branches.with=帶有 {} 的 'when' 分支周圍
formatter.title.before.colon.after.declaration.name=冒號前，宣告名稱後
formatter.title.before.colon.in.new.type.definition=新類型定義中的冒號前
formatter.title.before.declaration.with.comment.or.annotation=在帶有註釋或註解的宣告之前
formatter.title.before.lambda.arrow=lambda 箭頭前
formatter.title.chained.function.calls=鏈式函式呼叫
formatter.title.elvis.expressions=Elvis 表達式
formatter.title.elvis.operator=Elvis 運算符(?\:)
formatter.title.expression.body.functions=表達式主體函式
formatter.title.function.annotations=函式註解
formatter.title.function.call.arguments=函式呼叫實參
formatter.title.function.context.parameters=函式上下文參數
formatter.title.function.declaration.parameters=函式宣告參數
formatter.title.function.parentheses=函式括號
formatter.title.in.simple.one.line.methods=在簡單的一行方法中
formatter.title.indent.before.arrow.on.new.line=在新行的 '->' 前縮排
formatter.title.java.statics.and.enum.members=Java static 和枚舉成員
formatter.title.line.break.after.multiline.when.entry=在多行條目後換行
formatter.title.load.save=載入/儲存
formatter.title.other=其他
formatter.title.property.annotations=屬性註解
formatter.title.property.context.parameters=屬性上下文參數
formatter.title.put.left.brace.on.new.line=將左大括號置於新行中
formatter.title.range.operator=範圍運算符 (..、..<)
formatter.title.top.level.symbols=頂級符號
formatter.title.trailing.comma=尾隨逗號
formatter.title.use.continuation.indent=使用延續縮排
formatter.title.use.continuation.indent.in.conditions=在條件中使用延續縮排
formatter.title.when.parentheses='when' 括號
formatter.title.when.statements='when' 語句
function=函式
function.0=函式 ''{0}''
function.0.returning.1.without.the.corresponding=函式 ''{0}'' 返回 ''{1}''，而相應的函式 ''{2}'' 未返回 ''{3}''
function.01=函式“{0}”
function.name.is.invalid=函式名無效
function.returning.0.with.a.name.that.does.not.end.with.1=返回名稱不以 {1} 結尾的 {0} 的函式
function.should.have.operator.modifier=函式應具有 'operator' 修飾符
generate.equals.and.hashcode.fix.text=生成 equals() 和 hashCode()
generate.identity.equals.fix.family.name=通過標識生成 equals 和 hashCode
goto.related.provider.in.module.0=(在模組 {0} 中)
goto.super.chooser.class.title=選擇超類別或接口
goto.super.chooser.function.title=選擇 super 函式
goto.super.chooser.property.title=選擇 super 屬性
group.InternalKotlin.text=Kotlin 內部動作
group.KotlinCompletionBenchmarkGroup.text=基準補全
group.KotlinInternalGroup.text=Kotlin
group.KotlinRefactoringTesting.text=Kotlin 重構測試
group.KotlinToolsGroup.text=Kotlin
group.advanced.settings.kotlin=Kotlin
group.names.code.migration=程式碼遷移
group.names.coroutine=協程檢查
group.names.gradle=Gradle
group.names.java.interop.issues=Java 互動作問題
group.names.kotlin=Kotlin
group.names.logging=日誌記錄
group.names.maven=Maven
group.names.migration=遷移
group.names.naming.conventions=命名約定
group.names.numeric.issues=數值問題
group.names.other.problems=其他問題
group.names.probable.bugs=可能的 bug
group.names.redundant.constructs=冗餘結構
group.names.style.issues=樣式問題
group.path.kotlin.migration=Kotlin，遷移
hash.code.text=生成 'hashCode()'
hierarchy.legend.member.defined.in.superclass=成員未在類別中定義，但在超類別中定義
hierarchy.legend.member.is.defined.in.class=成員在類別中定義
hierarchy.legend.member.should.be.defined=應定義成員，因為類別不為 abstract
hierarchy.text.anonymous=[匿名]
hierarchy.text.in=\ 在 {0} 中
highlight.usages.of.receiver=醒目提示接收器的用法
highlighter.action.text.go.to.actual.declarations=轉到實際宣告
highlighter.action.text.go.to.expected.declaration=轉到預期宣告
highlighter.action.text.go.to.implementations=轉到實作
highlighter.action.text.go.to.overridden.methods=轉到覆寫方法
highlighter.action.text.go.to.overridden.properties=轉到覆寫屬性
highlighter.action.text.go.to.subclasses=轉到子類別
highlighter.action.text.go.to.super.method=轉到 super 方法
highlighter.action.text.go.to.super.property=轉到 super 屬性
highlighter.descriptor.text.android.extensions.property=屬性和變數//Android 擴展合成屬性
highlighter.descriptor.text.annotation=註解//註解名稱
highlighter.descriptor.text.annotation.attribute.name=註解//註解特性名稱
highlighter.descriptor.text.arrow=括號和運算符//箭頭
highlighter.descriptor.text.builtin.annotation=關鍵字//修飾符
highlighter.descriptor.text.builtin.keyword=關鍵字//關鍵字
highlighter.descriptor.text.builtin.keyword.val=關鍵字//'val'
highlighter.descriptor.text.builtin.keyword.var=關鍵字//'var'
highlighter.descriptor.text.captured.variable=屬性和變數//閉包中捕獲的變數和值
highlighter.descriptor.text.closure.braces=括號和運算符//lambda 表達式大括號和箭頭
highlighter.descriptor.text.colon=大括號和運算符//冒號
highlighter.descriptor.text.constructor.call=函式//建構函式呼叫
highlighter.descriptor.text.data.class=類別和接口//資料類別
highlighter.descriptor.text.data.object=類別和接口//資料物件
highlighter.descriptor.text.double.colon=括號和運算符//雙重冒號
highlighter.descriptor.text.dynamic.fun.call=函式//動態函式呼叫
highlighter.descriptor.text.dynamic.property=屬性和變數//動態屬性
highlighter.descriptor.text.enum=類別和接口//枚舉
highlighter.descriptor.text.enumEntry=類別和接口//枚舉條目
highlighter.descriptor.text.exclexcl=括號和運算符//非 null 斷言
highlighter.descriptor.text.extension.fun.call=函式//擴展函式呼叫
highlighter.descriptor.text.extension.property=屬性和變數//擴展屬性
highlighter.descriptor.text.field=屬性和變數//支援欄位變數
highlighter.descriptor.text.fun=函式//函式宣告
highlighter.descriptor.text.fun.call=函式//函式呼叫
highlighter.descriptor.text.instance.property=屬性和變數//實例屬性
highlighter.descriptor.text.instance.property.custom.property.declaration=屬性和變數//包含自訂屬性宣告的實例屬性
highlighter.descriptor.text.it=參數//lambda 表達式預設參數
highlighter.descriptor.text.kdoc.comment=註釋//KDoc//KDoc 註釋
highlighter.descriptor.text.kdoc.tag=註釋//KDoc//KDoc 標記
highlighter.descriptor.text.kdoc.value=註釋//KDoc//KDoc 標記中的鏈接
highlighter.descriptor.text.label=標籤
highlighter.descriptor.text.local.variable=屬性和變數//區域變數或值
highlighter.descriptor.text.named.argument=命名實參
highlighter.descriptor.text.object=類別和接口//物件
highlighter.descriptor.text.package.fun.call=函式//軟體套件級函式呼叫
highlighter.descriptor.text.package.property=屬性和變數//軟體套件級屬性
highlighter.descriptor.text.package.property.custom.property.declaration=屬性和變數//包含自訂屬性宣告的軟體套件級屬性
highlighter.descriptor.text.quest=括號和運算符//為 null 性類型標記
highlighter.descriptor.text.safe.access=括號和運算符//安全存取的點
highlighter.descriptor.text.smart.cast=智能轉換//智能轉換值
highlighter.descriptor.text.smart.cast.receiver=智能轉換//智能轉換隱式接收器
highlighter.descriptor.text.smart.constant=智能轉換//智能常數
highlighter.descriptor.text.string.escape=字串//字串和模板大括號中的轉義
highlighter.descriptor.text.suspend.fun.call=函式//掛起函式呼叫
highlighter.descriptor.text.synthetic.extension.property=屬性和變數//合成擴展屬性
highlighter.descriptor.text.typeAlias=類別和接口//類型別名
highlighter.descriptor.text.var=屬性和變數//Var (可變變數、參數或屬性)
highlighter.descriptor.text.variable.as.function.call=屬性和變數//變數作為函式呼叫
highlighter.descriptor.text.variable.as.function.like.call=屬性和變數//變數作為類似函式的呼叫
highlighter.message.suspend.function.call=掛起函式呼叫
highlighter.message.suspending.iteration=正在掛起迭代
highlighter.name.dsl=Dsl//
highlighter.name.dsl.markers=DSL 標記
highlighter.name.expect.actual.line.markers=Kotlin 'expect'//'actual' 行標記
highlighter.name.implemented.declaration=實作的宣告
highlighter.name.implementing.declaration=實作宣告
highlighter.name.kotlin.line.markers=Kotlin 行標記
highlighter.name.multiplatform.actual.declaration=多平台實際宣告
highlighter.name.multiplatform.expect.declaration=多平台預期宣告
highlighter.name.overridden.declaration=覆寫的宣告
highlighter.name.overriding.declaration=覆寫宣告
highlighter.name.style=樣式 {0}
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=索引更新時無法導覽到覆寫類別
highlighter.prefix.text.has.actuals.in=在 {0} {1, choice, 0\#模組|1\#模組}中存在 actual
highlighter.text.click.for.navigate=點擊“{0}”進行導覽
highlighter.text.has.functional.implementations=具有函式實作
highlighter.text.implements=實作
highlighter.text.in=''{1}'' 中的 {0}
highlighter.text.or.press=\ 或按 {0}
highlighter.text.overrides=覆寫
highlighter.title.overriding.declarations.of={0} 的覆寫宣告
highlighter.title.searching.for.overriding.declarations=正在搜尋覆寫宣告
highlighter.title.searching.for.overriding.methods=正在搜尋覆寫方法
highlighter.tool.tip.has.expect.declaration.in=在 {0} {1, choice, 0\#模組|1\#模組}中存在 expect
highlighter.tool.tip.marker.annotation.for.dsl=DSL 的標記註解
highlighter.tool.tip.text.function=函式
highlighter.tool.tip.text.property=屬性
highlighter.tool.tip.text.recursive.call=遞迴呼叫
hint.text.no.expression.found=找不到表達式
hints.codevision.implementations.format={0, choice, 1\#1 個實作|2\#{0,number} 個實作}
hints.codevision.implementations.too_many.format={0,number}+ 實作
hints.codevision.inheritors.format={0, choice, 1\#1 個繼承者|2\#{0,number} 個繼承者}
hints.codevision.inheritors.to_many.format={0,number}+ 繼承者
hints.codevision.overrides.format={0, choice, 1\#1 個覆寫|2\#{0,number} 個覆寫}
hints.codevision.overrides.to_many.format={0,number}+ 覆寫
hints.codevision.settings=設定…
hints.codevision.usages.format={0, choice, 1\#1 個用法|2\#{0,number} 個用法}
hints.codevision.usages.too_many.format={0,number}+ 用法
hints.description.compiler.plugins.declarations=Kotlin 編譯器延伸模組生成的宣告
hints.description.compiler.plugins.modality=提供宣告模態由 Kotlin 編譯器延伸模組更改的提示
hints.description.compiler.plugins.supertypes=提供父類型由 Kotlin 編譯器延伸模組生成的提示
hints.ranges.greaterOrEqual=≥
hints.ranges.less=<
hints.ranges.lessOrEqual=≤
hints.settings.common.items=顯示以下項的提示\:
hints.settings.compiled.parameters=編譯的參數名稱
hints.settings.compiler.plugins.declarations=Kotlin 編譯器延伸模組生成的宣告
hints.settings.compiler.plugins.declarations.show.hidden.description=顯示呼叫站點不可見的宣告
hints.settings.compiler.plugins.declarations.show.hidden.name=顯示隱藏的宣告
hints.settings.compiler.plugins.modality=Kotlin 編譯器延伸模組更改的模態
hints.settings.compiler.plugins.supertypes=Kotlin 編譯器延伸模組新增的父類型
hints.settings.default.parameters=預設參數值
hints.settings.dont.show.lambda.receivers.parameters=不顯示隱式接收器和參數提示
hints.settings.dont.show.lambda.return=不顯示返回表達式提示
hints.settings.dont.show.ranges=不顯示範圍提示
hints.settings.dont.show.suspending=不顯示掛起呼叫提示
hints.settings.dont.show.types.parameter=不顯示函式參數類型提示
hints.settings.dont.show.types.property=不顯示屬性類型提示
hints.settings.dont.show.types.return=不顯示函式返回值類型提示
hints.settings.dont.show.types.variable=不顯示區域變數類型提示
hints.settings.excluded.parameters=排除的參數名稱
hints.settings.lambda.receivers.parameters=隱式接收器和參數
hints.settings.lambda.return=返回表達式
hints.settings.lambdas=Lambda
hints.settings.parameters=參數
hints.settings.ranges=範圍
hints.settings.show.lambda.receivers.parameters=顯示隱式接收器和參數提示
hints.settings.show.lambda.return=顯示返回表達式提示
hints.settings.show.ranges=顯示範圍提示
hints.settings.show.suspending=顯示掛起呼叫提示
hints.settings.show.types.parameter=顯示函式參數類型提示
hints.settings.show.types.property=顯示屬性類型提示
hints.settings.show.types.return=顯示函式返回值類型提示
hints.settings.show.types.variable=顯示區域變數類型提示
hints.settings.suspending=正在暫停呼叫
hints.settings.types=類型
hints.settings.types.parameter=函式參數類型
hints.settings.types.property=屬性類型
hints.settings.types.return=函式返回值類型
hints.settings.types.variable=區域變數類型
hints.settings.value.kotlin.time=kotlin.time 警告
hints.settings.value.ranges=範圍
hints.settings.values.ranges=範圍
hints.title.argument.name.enabled=實參名稱
hints.title.codevision=Code Vision
hints.title.dont.show.argument.name.enabled=不顯示實參名稱提示
hints.title.show.argument.name.enabled=顯示實參名稱提示
hints.tooltip.compiler.plugins.declarations=由 Kotlin 編譯器延伸模組生成
hints.tooltip.compiler.plugins.declarations.expand=由 Kotlin 編譯器延伸模組生成的 Kotlin 宣告。展開類別主體以檢視它們
hints.tooltip.compiler.plugins.modality=Kotlin 編譯器延伸模組將模態從 ''{0}'' 更改為 ''{1}''
hints.tooltip.compiler.plugins.supertypes=Kotlin 編譯器延伸模組新增的父類型
hints.types=類型提示
if.null.return.break.foldable.to=If-Null return/break/... 可折疊為 '?\:'
if.then.foldable.to=If-Then 可折疊為 '?\:'
ignore.imports.and.formatting=忽略匯入和格式設定
implement.abstract.class=實作抽象類別
implement.abstract.function=實作 abstract 函式
implement.abstract.member=實作 abstract 成員
implement.abstract.property=實作 abstract 屬性
implement.as.constructor.parameter=作為建構函式參數實作
implement.interface=實作接口
implement.sealed.class=實作密封類別
implicit.nothing.s=隱式無內容
implicit.parameter.it.of.enclosing.lambda.is.shadowed=封閉 lambda 的隱式參數 'it' 已被隱藏
implicit.unsafe.cast.from.dynamic.to.0=從動態到 {0} 的隱式 (不安全) 轉換
import.members.from.0=從 ''{0}'' 匯入成員
import.members.with=匯入帶有 '*' 的成員
import.optimizer.notification.text.unused.imports.not.found=找不到未使用的 import
import.optimizer.progress.indicator.text.collect.imports.for=收集 {0} 的匯入
import.optimizer.text.import={0, choice, 0\#匯入|2\#匯入}
import.optimizer.text.non.zero=移除的{0} {1}{2, choice, 0\#|1\#, 新增的{2} {3}}
import.optimizer.text.zero=重新排列的匯入
import.order.button.text.add.package=新增軟體套件
import.order.button.text.down=下
import.order.button.text.remove=移除
import.order.button.text.up=上
import.progress.text.resolve.imports=尋找所有 import…
import.text.all.alias.imports=所有別名匯入
import.text.all.other.imports=所有其他匯入
import.text.import=匯入
in.class.0=在類別 ''{0}'' 中
inaccessible.declaration=無法存取的宣告
incomplete.destructuring.declaration.text=解構宣告不完整
incomplete.destructuring.fix.family.name=將缺失的變數新增到解構宣告
indent.raw.string=縮排原始字串
index.is.not.used.in.the.loop.body=索引未在迴圈體中使用
infix.call.may.be.dot.call=中綴呼叫可以是點呼叫
inheritance.of.kotlin.sealed=Java {0,choice,0\#接口|1\#類別}不能作為 Kotlin 密封層次結構的一部分
initialize.with.constructor.parameter=使用建構函式參數初始化
initialize.with.constructor.parameter.analyzing.existing.variables=正在分析現有變量…
initializer.is.redundant=初始設定式冗餘
inlay.kotlin.call.chains.hints=顯示呼叫鏈的嵌入提示
inlay.kotlin.compiler.plugins.declarations.description=Kotlin 編譯器延伸模組生成的宣告
inlay.kotlin.default.parameters.hints=在覆寫的方法中顯示預設參數值
inlay.kotlin.lambdas.hints=顯示 lambda 的嵌入提示
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=顯示隱式接收器和參數的嵌入提示
inlay.kotlin.lambdas.hints.hints.lambda.return=顯示返回表達式的嵌入提示
inlay.kotlin.parameters.hints=在函式呼叫點顯示參數名稱。
inlay.kotlin.parameters.hints.compiled=顯示編譯後的參數名稱
inlay.kotlin.parameters.hints.excluded=顯示排除的參數名稱
inlay.kotlin.references.types.hints=顯示類型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.function.parameter=顯示函式參數類型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.function.return=顯示函式返回值類型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.property=顯示屬性類型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.variable=顯示區域變數類型的嵌入提示
inlay.kotlin.value.kotlin.time=顯示 kotlin.time 軟體套件警告嵌入提示
inlay.kotlin.value.ranges=顯示範圍的嵌入提示
inlay.kotlin.values.hints=顯示值的嵌入提示
inlay.kotlin.values.hints.kotlin.values.ranges=顯示範圍的嵌入提示
inline.type.parameter=內聯類型參數
inline.variable=內聯變數
inline.when.argument=內聯 'when' 實參
insert.curly.braces.around.variable=在變數周圍插入大括號
insert.explicit.delegation.call=插入顯式委託呼叫
insert.number.conversion=插入數字轉換
inspection.add.annotation.target.problem.description=該註解僅適用於參數。建議使用顯式註解使用位置目標。
inspection.add.conversion.call.display.name=自 1.9 起需要從 `Int` 顯式轉換
inspection.add.kotlin.coroutines.display.name=新增 Kotlin 協程庫
inspection.add.operator.modifier.display.name=函式應具有 'operator' 修飾符
inspection.add.variance.modifier.display.name=類型參數可以具有 'in' 或 'out' 差異
inspection.ambiguous.actuals.display.name=不明確的 actual
inspection.ambiguous.expression.when.branch.migration.display.name=自 1.7 起 'when' 分支中不明確的邏輯表達式
inspection.array.in.data.class.display.name=資料類別中的陣列屬性
inspection.assigned.value.is.never.read.display.name=指定的值從未被讀取
inspection.boolean.literal.argument.display.name=不包含參數名稱的布爾字面量實參
inspection.can.be.parameter.display.name=建構函式參數從未被用作屬性
inspection.can.be.primary.constructor.property.display.name=屬性已明確分配給建構函式參數
inspection.can.be.val.display.name=本地 'var' 從未被修改，且可以宣告為 'val'
inspection.can.convert.to.multi.dollar.string.display.name=多美元符號插值可用於字串字面量(自 2.1 起可用)
inspection.can.convert.to.multi.dollar.string.problem.description=插值前綴可以簡化字串
inspection.can.sealed.subclass.be.object.display.name=沒有狀態和覆寫的 equals 的 sealed 子類別
inspection.can.unescape.dollar.literal.inspection.display.name=字串字面量中的冗餘轉義美元字元
inspection.can.unescape.dollar.literal.inspection.problem.description=字串中的轉義美元字元可以簡化
inspection.cascade.if.display.name=級聯 'if' 可被取代為 'when'
inspection.class.name.display.name=類別命名約定
inspection.complex.redundant.let.display.name=基於實參的冗餘 'let' 呼叫
inspection.conflicting.extension.property.display.name=擴展屬性與合成屬性衝突
inspection.const.property.name.display.name=const 屬性命名約定
inspection.constant.condition.if.display.name='if' 表達式的條件為常數
inspection.context.parameters.migration.display.text=使用了過時的上下文接收器
inspection.context.parameters.migration.problem.description=上下文接收器應取代為上下文參數
inspection.context.parameters.migration.quick.fix.text=將上下文接收器取代為上下文參數
inspection.control.flow.with.empty.body.display.name=帶空體的控制流
inspection.convert.argument.to.set.display.name=實參可以轉換為 'Set' 以提高性能
inspection.convert.call.chain.into.sequence.display.name=可以將集合上的呼叫鏈轉換為 'Sequence' 來改善性能
inspection.convert.lambda.to.reference.display.name=可被取代為函式參照
inspection.convert.na.n.equality.display.name=將帶 'NaN' 的相等檢查轉換為 'isNaN' 呼叫
inspection.convert.object.to.data.object.display.name=將 'object' 轉換為 'data object'
inspection.convert.pair.constructor.to.to.function.display.name=將 Pair 建構函式轉換為 'to' 函式
inspection.convert.reference.to.lambda.display.name=可被取代為 lambda
inspection.convert.secondary.constructor.to.primary.display.name=轉換為主建構函式
inspection.convert.to.string.template.display.name=可以轉換為字串模板的字串串聯
inspection.convert.try.finally.to.use.call.display.name=將 try / finally 轉換為 use() 呼叫
inspection.convert.two.comparisons.to.range.check.display.name=兩個比較應轉換為範圍檢查
inspection.copy.without.named.arguments.display.name=資料類別的 'copy' 方法在沒有命名實參的情況下呼叫
inspection.data.class.private.constructor.display.name=private 資料類別建構函式通過 'copy' 方法公開
inspection.deferred.is.result.display.name=函式直接返回 Deferred
inspection.deferred.result.unused.display.name='@Deferred' 結果未被使用
inspection.delegation.to.var.property.display.name=正在委託給 'var' 屬性
inspection.deprecated.callable.add.replace.with.display.name=不包含 'replaceWith' 實參的 @Deprecated 註解
inspection.deprecated.enum.declaring.class.property=已棄用的 'Enum.declaringClass' 屬性
inspection.deprecated.gradle.dependency.display.name=在 Gradle 中使用了棄用的庫
inspection.deprecated.inline.class.text=已棄用的內聯類別
inspection.deprecated.inline.classes.migration.display.name=從 1.5 版本開始，內聯類別已棄用。
inspection.deprecated.maven.dependency.display.name=在 Maven 中使用了棄用的庫
inspection.destructure.display.name=使用解構宣告
inspection.destructuring.wrong.name.display.name=解構宣告中的變數使用錯誤資料類別屬性的名稱
inspection.different.kotlin.gradle.version.display.name=Kotlin Gradle 和 IDE 延伸模組版本不同
inspection.different.kotlin.maven.version.display.name=Maven 和 IDE 延伸模組版本不同
inspection.different.maven.stdlib.version.display.name=庫和 Maven 延伸模組版本不同
inspection.different.stdlib.gradle.version.display.name=Kotlin 庫和 Gradle 延伸模組版本不同
inspection.do.not.propagate.method.deprecation.through.overrides=自 1.9 起不得通過覆寫傳播方法描述
inspection.empty.range.display.name=start 大於 endInclusive 的範圍為空
inspection.enum.entry.name.display.name=枚舉條目命名約定
inspection.enum.values.method.soft.deprecate.in.java.display.name=從 Kotlin 1.9 開始，建議將 'Enum.values()' 取代為 'Enum.getEntries()'
inspection.enum.values.method.soft.deprecate.migration.display.name=從 1.9 開始，建議將 'Enum.values()' 取代為 'Enum.entries'
inspection.equals.or.hash.code.display.name='equals()' 和 'hashCode()' 未配對
inspection.explicit.this.display.name=冗餘顯式 'this'
inspection.fake.jvm.field.constant.display.name=Kotlin 非 const 屬性用作 Java 常數
inspection.filter.is.instance.call.with.class.literal.argument.display.name=帶有類別字面量實參的 'filterIsInstance' 呼叫
inspection.filter.is.instance.call.with.class.literal.argument.quick.fix.text=將類別字面量實參取代為具體化類型參數
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/… 可折疊為 '?\:'
inspection.for.each.parameter.not.used.display.name=迭代元素不在 forEach 中使用
inspection.foreach.join.on.collection.of.job.description=在 'Collection<Job>' 上使用 'forEach { it.join() }'，而不是單個 'joinAll()'
inspection.foreach.join.on.collection.of.job.display.name=在 'Collection<Job>' 上呼叫 'forEach { it.join() }'，而不是單個 'joinAll()'
inspection.foreach.join.on.collection.of.job.replace.with.joinAll=取代為 'joinAll()'
inspection.from.closed.range.migration.display.name=從 1.3 起，fromClosedRange() 中存在 MIN_VALUE 步驟
inspection.function.name.display.name=函式命名約定
inspection.function.with.lambda.expression.body.display.name=具有 '\= { ... }' 和推斷返回值類型的函式
inspection.gradle.kotlinx.coroutines.deprecation.display.name=不相容的 kotlinx.coroutines 相依項在 Gradle 中與 Kotlin 1.3+ 一起使用
inspection.has.platform.type.display.name=函式或屬性具有平台類型
inspection.if.then.to.elvis.display.name=If-Then 可折疊為 '?\:'
inspection.if.then.to.safe.access.display.name=If-Then 可折疊為 '?.'
inspection.implicit.nullable.nothing.type.display.name=隱式 'Nothing?' 類型
inspection.implicit.this.action.name=新增顯式 'this'
inspection.implicit.this.display.name=隱式 'this'
inspection.incomplete.destructuring.declaration.display.name=解構宣告不完整
inspection.inconsistent.comment.for.java.parameter.display.name=Java 參數的註釋不一致
inspection.introduce.when.subject.display.name=可以通過引入實參簡化的 'when'
inspection.java.collections.static.method.display.name=Java 集合 static 方法呼叫可被取代為 Kotlin stdlib
inspection.java.collections.static.method.on.immutable.list.display.name=在不可變的 Kotlin 集合上呼叫 Java 轉變器方法
inspection.java.default.methods.not.overridden.by.delegation.display.name=Java 預設方法未被委託覆寫
inspection.java.default.methods.not.overridden.by.delegation.message=Java 預設方法未被委託覆寫
inspection.java.io.serializable.object.must.have.read.resolve.display.name=Serializable 物件必須實作 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name=實作 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.warning=Serializable 物件必須實作 'readResolve'
inspection.java.map.for.each.display.name=Java Map.forEach 方法呼叫應被取代為 Kotlin 的 forEach
inspection.join.declaration.and.assignment.display.name=聯接宣告和賦值
inspection.join.declaration.and.assignment.option.report.with.complex.initialization.of.member.properties=報告成員屬性的複雜初始化
inspection.k.doc.missing.documentation.display.name=public 宣告缺少 KDoc 註釋
inspection.k.doc.unresolved.reference.display.name=KDoc 中存在未解析的參照
inspection.kotlin.catch.may.ignore.exception.display.name='catch' 塊可能會忽略異常
inspection.kotlin.constant.conditions.display.name=恒定條件
inspection.kotlin.covariant.equals.display.name=協變 'equals()'
inspection.kotlin.deprecation.display.name=使用了冗餘或棄用的語法或棄用的符號
inspection.kotlin.double.negation.action.name=移除冗餘的雙重求反
inspection.kotlin.double.negation.display.name=冗餘雙重求反
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
inspection.kotlin.internal.in.java.display.name=使用來自 Java 的 Kotlin 內部宣告
inspection.kotlin.invalid.bundle.or.property.display.name=無效屬性健
inspection.kotlin.jvm.annotation.in.java.description=Kotlin JVM 註解 ''{0}'' 在 Java 中不起任何作用
inspection.kotlin.jvm.annotation.in.java.display.name=Java 中的 Kotlin JVM 註解
inspection.kotlin.maven.plugin.phase.display.name=Kotlin Maven 延伸模組組態錯誤
inspection.kotlin.options.to.compiler.options.display.name=使用已棄用的 'kotlinOptions' DSL
inspection.kotlin.redundant.override.display.name=冗餘覆寫方法
inspection.kotlin.redundant.suppression.display.name=冗餘的診斷禁止
inspection.kotlin.result.of.filterIsInstance.call.always.empty.collection='filterIsInstance' 呼叫的結果始終為空
inspection.kotlin.sealed.in.java.display.name=從 Java 繼承 Kotlin 密封接口/類別
inspection.kotlin.test.j.unit.display.name=kotlin-test-junit 可以使用
inspection.kotlin.throwable.not.thrown.display.name=Throwable 未拋出
inspection.kotlin.unused.import.display.name=未使用的 import 指令
inspection.kotlin.unused.variable.display.name=未使用的變數
inspection.lateinit.var.overrides.lateinit.var.display.name='lateinit var' 屬性覆寫 'lateinit var' 屬性
inspection.leaking.this.display.name=在建構函式中泄漏 'this'
inspection.lift.return.or.assignment.display.name=可以提取 return 或賦值
inspection.lift.return.or.assignment.option.only.single.statement=僅在每個分支都是單條語句時報告
inspection.local.variable.name.display.name=區域變數命名約定
inspection.logger.initialized.with.foreign.class.display.name=使用外類別初始化記錄器
inspection.logger.placeholder.count.matches.argument.count.display.name=佔位符數量與日誌呼叫中的實參數量不符合
inspection.loop.to.call.chain.display.name=迴圈可被取代為 stdlib 運算
inspection.main.function.return.unit.display.name=main 函式應返回 'Unit'
inspection.map.await.on.collection.of.deferred.description=在 'Collection<Deferred>' 上使用 'map { it.await() }'，而不是單個 'awaitAll()'
inspection.map.await.on.collection.of.deferred.display.name=在 'Collection<Deferred>' 上呼叫 'map { it.await() }'，而不是單個 'awaitAll()'
inspection.map.await.on.collection.of.deferred.replace.with.awaitAll=取代為 'awaitAll()'
inspection.map.get.with.not.null.assertion.operator.display.name=包含非 null 斷言運算符 (\!\!) 的 'map.get()'
inspection.maven.coroutines.deprecation.display.name=不相容的 kotlinx.coroutines 相依項在 Maven 中與 Kotlin 1.3+ 一起使用
inspection.may.be.constant.display.name=可能為 'const'
inspection.member.visibility.can.be.private.display.name=類別成員可以具有 'private' 可見性
inspection.message.cast.will.always.fail=轉換總是失敗
inspection.message.condition.always.false=條件 ''{0}'' 始終為 false
inspection.message.condition.always.false.when.reached=條件 ''{0}'' 滿足後始終為 false
inspection.message.condition.always.true=條件 ''{0}'' 始終為 true
inspection.message.condition.always.true.when.reached=條件 ''{0}'' 滿足後始終為 true
inspection.message.empty.catch.block=空 catch 塊
inspection.message.for.never.visited='for' 範圍始終為空
inspection.message.inconsistent.parameter.name.for.0=''{0}'' 的參數名稱不一致
inspection.message.index.out.of.bounds=索引總是超出界限
inspection.message.nonnull.cast.will.always.fail=動作將始終失敗，因為動作數始終為 null
inspection.message.object.with.manual.tostring.can.be.converted.to.data.object=帶有手動 'toString' 的 'object' 可以轉換為 'data object'
inspection.message.result.of.0.always.empty.collection=''{0}'' 的結果始終為空集合
inspection.message.sealed.object.can.be.converted.to.data.object='sealed' 子物件可以轉換為 'data object'
inspection.message.value.always.false=''{0}'' 的值始終為 false
inspection.message.value.always.null=''{0}'' 的值始終為 null
inspection.message.value.always.true=''{0}'' 的值始終為 true
inspection.message.value.always.zero=''{0}'' 的值始終為零
inspection.message.when.condition.always.false='when' 分支永遠無法到達
inspection.migrate.diagnostic.suppression.display.name=應取代診斷名稱
inspection.move.lambda.outside.parentheses.display.name=圓括號內的 lambda 實參
inspection.move.suspicious.callable.reference.into.parentheses.display.name=可疑的可調用參照用作 lambda 結果
inspection.move.variable.declaration.into.when.display.name=變數宣告可以在 'when' 中移動
inspection.nested.lambda.shadowed.implicit.parameter.display.name=嵌套 lambda 具有隱藏的隱式參數
inspection.no.actual.for.expect.display.name=expect 宣告中沒有 actual
inspection.non.exhaustive.when.statement.migration.display.name=將從 1.7 開始禁止非窮舉的 'when' 語句
inspection.null.checks.to.safe.call.display.name=null 檢查可被取代為安全呼叫
inspection.nullable.boolean.elvis.action.name=使用相等檢查而不是 elvis 進行可以為 null 布爾檢查
inspection.nullable.boolean.elvis.display.name=可以使用相等檢查代替 elvis 進行可以為 null 布爾檢查
inspection.nullable.type.argument.in.java.collection.display.name=Java 集合中不支持 null 的可為 null 的類型實參
inspection.object.exception.to.class.display.name=異常不應為物件
inspection.object.exception.to.class.quick.fix.name=將異常物件更改為類別
inspection.object.exception.to.class.warning=異常不應為物件
inspection.object.literal.to.lambda.display.name=物件字面量可以轉換為 lambda
inspection.object.private.property.name.display.name=物件 private 屬性命名約定
inspection.object.property.name.display.name=object 屬性命名約定
inspection.obsolete.experimental.coroutines.display.name=從 1.3 起，實驗性協程用法遭到廢棄
inspection.obsolete.kotlin.js.packages.display.name='kotlin.browser' 和 'kotlin.dom' 軟體套件自 1.4 起已棄用
inspection.optional.expectation.display.name=可選預期註解沒有實際註解
inspection.package.directory.mismatch.display.name=軟體套件名稱與包含的目錄不符合
inspection.package.name.display.name=軟體套件命名約定
inspection.platform.extension.receiver.of.inline.display.name=在 Kotlin 1.2 及更低版本中包含可為 null 的接收器的 'inline fun'
inspection.prefer.current.coroutine.context.to.coroutine.context.inspection.description='kotlin.coroutine.coroutineContext' 的用法可能存在歧義
inspection.prefer.current.coroutine.context.to.coroutine.context.inspection.display.name=可能存在歧義的 'kotlin.coroutine.coroutineContext' 用法
inspection.prefer.current.coroutine.context.to.coroutine.context.inspection.fix=取代為 'currentCoroutineContext()'
inspection.private.property.name.display.name=private 屬性命名約定
inspection.progression.resolution.change.migration.display.name=自 1.9 起的進度解析度更改
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=從 1.4 起，'@JvmOverloads' 註解無法用於註解類別的建構函式
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=未被標記為 '@Repeatable' 的重複註解
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=帶類型參數的區域變數
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=超類別上的無意義註解目標
inspection.property.name.display.name=屬性命名約定
inspection.protected.in.final.display.name='protected' 可見性在 final 類別中實際是 'private'
inspection.public.api.implicit.type.display.name=具有隱式返回值類型的公共 API 宣告
inspection.recursive.equals.call.display.name=遞迴 equals 呼叫
inspection.recursive.property.accessor.display.name=遞迴屬性存取器
inspection.redundant.anonymous.function.description=建立冗餘匿名函式
inspection.redundant.assequence.call=冗餘 'asSequence' 呼叫
inspection.redundant.async.display.name=冗餘 'async' 呼叫
inspection.redundant.companion.reference.display.name=冗餘 'Companion' 參照
inspection.redundant.else.in.if.display.name='if' 中冗餘的 'else'
inspection.redundant.elvis.return.null.descriptor=冗餘 '?\: return null'
inspection.redundant.elvis.return.null.display.name=冗餘 '?\: return null'
inspection.redundant.empty.initializer.block.display.name=冗餘空白初始設定式塊
inspection.redundant.enum.constructor.invocation.display.name=冗餘枚舉建構函式呼叫
inspection.redundant.explicit.type.display.name=明顯的顯式類型
inspection.redundant.getter.display.name=冗餘屬性 getter
inspection.redundant.if.display.name=冗餘的 'if' 語句
inspection.redundant.inner.class.modifier.descriptor=冗餘 'inner' 修飾符
inspection.redundant.inner.class.modifier.display.name=冗餘 'inner' 修飾符
inspection.redundant.interpolation.prefix.display.name=冗餘的插值前綴
inspection.redundant.interpolation.prefix.problem.description=冗餘的插值前綴
inspection.redundant.interpolation.prefix.quick.fix.text=移除冗餘的插值前綴
inspection.redundant.label.display.name=冗餘標籤
inspection.redundant.label.migration.display.name=冗餘標籤
inspection.redundant.label.problem.description=標籤是冗餘的，因為它不能在 'break、'continue' 或 'return' 表達式中參照
inspection.redundant.label.text=冗餘標籤
inspection.redundant.labeled.return.on.last.expression.in.lambda.display.name=lambda 中最後一個表達式上帶標籤的冗餘 return
inspection.redundant.lambda.arrow.display.name=冗餘 lambda 箭頭
inspection.redundant.lambda.description=建立冗餘 lambda
inspection.redundant.lambda.or.anonymous.function.display.name=建立冗餘 lambda 或匿名函式
inspection.redundant.lambda.or.anonymous.function.fix=內聯主體
inspection.redundant.modality.modifier.display.name=冗餘形式修飾符
inspection.redundant.not.null.extension.receiver.of.inline.display.name='inline fun' 擴展接收器在 Kotlin 1.2 及更低版本中可以顯式設為可為 null
inspection.redundant.nullable.return.type.display.name=冗餘可 null 返回值類型
inspection.redundant.object.type.check.display.name=物件的非慣用 'is' 類型檢查
inspection.redundant.require.not.null.call.display.name=冗餘 'requireNotNull' 或 'checkNotNull' 呼叫
inspection.redundant.return.label.display.name=冗餘 'return' 標籤
inspection.redundant.run.catching.display.name=冗餘 'runCatching' 呼叫
inspection.redundant.sam.constructor.display.name=冗餘 SAM 建構函式
inspection.redundant.semicolon.display.name=冗餘分號
inspection.redundant.setter.display.name=冗餘屬性 setter
inspection.redundant.suspend.modifier.display.name=冗餘 'suspend' 修飾符
inspection.redundant.unit.expression.display.name=冗餘 'Unit'
inspection.redundant.unit.return.type.action.name=移除冗餘的 'Unit' 返回類型
inspection.redundant.unit.return.type.display.name=冗餘 'Unit' 返回值類型
inspection.redundant.upper.bound.fix.text=移除冗餘的上限 'Any?'
inspection.redundant.upper.bound.problem=冗餘的上限 'Any?'
inspection.redundant.value.argument.annotation=值實參與參數 ''{0}'' 的預設值符合
inspection.redundant.value.argument.display.name=冗餘值實參
inspection.redundant.visibility.modifier.display.name=冗餘可見性修飾符
inspection.redundant.with.display.name=冗餘 'with' 呼叫
inspection.remove.curly.braces.from.template.display.name=字串模板中的冗餘大括號
inspection.remove.empty.class.body.display.name=取代空類別主體
inspection.remove.empty.parentheses.from.annotation.entry.display.name=註解中存在多餘的括號
inspection.remove.empty.parentheses.from.lambda.call.action.name=從帶 lambda 的函式呼叫中移除不必要的圓括號
inspection.remove.empty.parentheses.from.lambda.call.display.name=帶 lambda 的函式呼叫中不必要的圓括號
inspection.remove.empty.primary.constructor.display.name=冗餘空主建構函式
inspection.remove.empty.secondary.constructor.body.display.name=冗餘建構函式體
inspection.remove.explicit.super.qualifier.display.name=不必要的父類型限定
inspection.remove.explicit.type.arguments.display.name=不必要的類型實參
inspection.remove.for.loop.indices.display.name=未使用的迴圈索引
inspection.remove.interpolation.prefix.display.name=可移除的多美元符號插值前綴
inspection.remove.interpolation.prefix.problem.description=字串前綴可以移除
inspection.remove.interpolation.prefix.quick.fix.text=移除多美元符號前綴
inspection.remove.redundant.backticks.display.name=冗餘反引號
inspection.remove.redundant.calls.of.conversion.methods.display.name=轉換方法的冗餘呼叫
inspection.remove.redundant.qualifier.name.display.name=冗餘限定符名稱
inspection.remove.redundant.spread.operator.display.name=冗餘展開運算符
inspection.remove.setter.parameter.type.display.name=冗餘 setter 參數類型
inspection.remove.single.expression.string.template.display.name=冗餘字串模板
inspection.remove.to.string.in.string.template.display.name=字串模板中的冗餘 'toString()' 呼叫
inspection.replace.array.equality.op.with.arrays.equals.display.name=通過 '\=\=' 和 '\!\=' 進行陣列比較
inspection.replace.array.of.with.literal.display.name='arrayOf' 呼叫可被取代為數組字面量 […]
inspection.replace.assert.boolean.with.assert.equality.display.name=斷言布爾可被取代為斷言等式
inspection.replace.associate.function.display.name='associate' 可被取代為 'associateBy' 或 'associateWith'
inspection.replace.call.with.binary.operator.display.name=可被取代為二元運算符
inspection.replace.collection.count.with.size.display.name=集合計數可以轉換為大小
inspection.replace.get.or.set.display.name=顯式 'get' 或 'set' 呼叫
inspection.replace.guard.clause.with.function.call.display.name=guard 子句可被取代為 Kotlin 的函式呼叫
inspection.replace.isempty.with.ifempty.display.name='if' 條件可被取代為 lambda 呼叫
inspection.replace.java.static.method.with.kotlin.analog.display.name=Java 方法應取代為 Kotlin 模擬
inspection.replace.manual.range.with.indices.calls.display.name=範圍可以轉換為索引或迭代
inspection.replace.mapIndexed.with.list.generator.display.name=將 'mapIndexed' 取代為 List 生成器
inspection.replace.negated.is.empty.with.is.not.empty.display.name=可以簡化否定呼叫
inspection.replace.not.null.assertion.with.elvis.return.display.name=非 null 斷言可被取代為 'return'
inspection.replace.put.with.assignment.display.name='map.put()' 可以轉換為賦值
inspection.replace.range.start.end.inclusive.with.first.last.display.name=裝箱的屬性應取代為未裝箱的屬性
inspection.replace.range.to.with.rangeUntil.display.name='rangeTo' 或 '..' 呼叫應被取代為 '..<'
inspection.replace.range.to.with.until.display.name='rangeTo' 或 '..' 呼叫應被取代為 'until'
inspection.replace.readline.with.readln.display.name='readLine' 可被取代為 'readln' 或 'readlnOrNull'
inspection.replace.size.check.with.is.not.empty.display.name=大小檢查可被取代為 'isNotEmpty()'
inspection.replace.size.zero.check.with.is.empty.display.name=零大小檢查可被取代為 'isEmpty()'
inspection.replace.string.format.with.literal.display.name='String.format' 呼叫可被取代為字串模板
inspection.replace.substring.with.drop.last.display.name='substring' 呼叫應被取代為 'dropLast' 呼叫
inspection.replace.substring.with.indexing.operation.display.name='substring' 呼叫應被取代為索引運算符
inspection.replace.substring.with.substring.after.display.name='substring' 呼叫應被取代為 'substringAfter'
inspection.replace.substring.with.substring.before.display.name='substring' 呼叫應被取代為 'substringBefore'
inspection.replace.substring.with.take.display.name='substring' 呼叫應被取代為 'take' 呼叫
inspection.replace.to.string.with.string.template.display.name='toString' 的呼叫可被取代為字串模板
inspection.replace.to.with.infix.form.display.name='to' 呼叫應被取代為中綴形式
inspection.replace.until.with.rangeUntil.operator.display.name=將 'until' 取代為 '..<' 運算符
inspection.replace.with.enum.map.display.name='HashMap' 可被取代為 'EnumMap'
inspection.replace.with.ignore.case.equals.display.name=應取代為 'equals(..., ignoreCase \= true)'
inspection.replace.with.import.alias.display.name=完全限定名稱可被取代為現有的匯入別名
inspection.replace.with.operator.assignment.display.name=賦值可被取代為運算符賦值
inspection.replace.with.string.builder.append.range.display.name=JVM 上的 'StringBuilder.append(CharArray, offset, len)' 呼叫
inspection.restrict.return.statement.target.migration.display.name=從 1.4 起，目標標籤不表示函式
inspection.run.blocking.in.suspend.function.description=在 suspend 函式內使用 'runBlocking' 會阻塞呼叫執行緒，從而違背異步編程的目的
inspection.run.blocking.in.suspend.function.display.name=suspend 函式記憶體在 'runBlocking'
inspection.runblocking.analysis.found.runblocking=--> runBlocking
inspection.runblocking.analysis.graphbuilding.progress=正在處理 {0}
inspection.runblocking.presentation.descriptor=正在分析 runBlocking\:
inspection.runblocking.presentation.display.name=協程中的 RunBlocking
inspection.runblocking.presentation.settings.exploration.option.all=是，包括覆寫
inspection.runblocking.presentation.settings.exploration.option.declaration=是，排除覆寫
inspection.runblocking.presentation.settings.exploration.option.strict=否
inspection.runblocking.presentation.settings.exploration.title=瀏覽具有覆寫的函式
inspection.runblocking.presentation.text=從協程呼叫的 RunBlocking 建置器
inspection.safe.cast.with.return.display.name=帶有 'return' 的安全轉換應取代為 'if' 類型檢查
inspection.scope.function.conversion.display.name=作用域函式可以轉換為另一個
inspection.self.assignment.display.name=冗餘賦值
inspection.self.reference.constructor.parameter.display.name=建構函式永遠無法補全
inspection.setter.backing.field.assignment.display.name=不包含賦值的現有支援欄位
inspection.simple.redundant.let.display.name=基於接收器的冗餘 'let' 呼叫
inspection.simplifiable.call.chain.display.name=可以簡化集合類型上的呼叫鏈
inspection.simplifiable.call.display.name=可以簡化庫函數呼叫
inspection.simplifiable.scope.function.display.name=嵌套 forEach 的作用域函式可以簡化
inspection.simplify.assert.not.null.display.name='assert' 呼叫可被取代為 '\!\!' 或 '?\:'
inspection.simplify.boolean.with.constants.display.name=可以簡化布爾表達式
inspection.simplify.negated.binary.expression.display.name=可以簡化求反布爾表達式
inspection.simplify.when.with.boolean.constant.condition.display.name=可簡化的 'when'
inspection.sort.modifiers.display.name=非規範修飾符順序
inspection.suspend.function.on.coroutine.scope.display.name=由於掛起函式的 CoroutineScope 接收器，coroutineContext 不明確
inspection.suspicious.as.dynamic.display.name=可疑的 'asDynamic' 成員呼叫
inspection.suspicious.call.on.collection.to.add.or.remove.path.display.name=在 Collection 上新增或移除 Java NIO Path 的可疑呼叫
inspection.suspicious.cascading.if.display.name=可疑的級聯 'if' 表達式
inspection.suspicious.collection.reassignment.display.name=增強賦值在背景建立新集合
inspection.suspicious.equals.combination.display.name=可疑的 \=\= 與 \=\=\= 組合
inspection.suspicious.implicit.coroutine.scope.receiver.add.explicit.receiver.fix.text=新增顯式帶標籤的接收器(不改變語意)
inspection.suspicious.implicit.coroutine.scope.receiver.description=suspend 上下文中存在可疑的隱式 'CoroutineScope' 接收器存取
inspection.suspicious.implicit.coroutine.scope.receiver.detect.subclasses.option=檢測 'CoroutineScope' 子類型的接收器
inspection.suspicious.implicit.coroutine.scope.receiver.display.name=可疑的隱式 'CoroutineScope' 接收器存取
inspection.suspicious.var.property.display.name=可疑的 'var' 屬性\: 它的 setter 不會影響其 getter 結果
inspection.test.function.name.display.name=測試函式命名約定
inspection.this.class.does.not.have.a.constructor=禁止的建構函式呼叫
inspection.trailing.comma.add.line.break=新增換行
inspection.trailing.comma.add.trailing.comma=新增尾隨逗號
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=逗號在這個位置沒有優勢
inspection.trailing.comma.display.name=尾隨逗號推薦
inspection.trailing.comma.fix.comma.position=修復逗號位置
inspection.trailing.comma.missing.line.break=缺少換行
inspection.trailing.comma.missing.trailing.comma=缺少尾隨逗號
inspection.trailing.comma.remove.trailing.comma=移除尾隨逗號
inspection.trailing.comma.report.also.a.missing.comma=還報告缺少的逗號或換行
inspection.trailing.comma.useless.trailing.comma=無用的尾隨逗號
inspection.unlabeled.return.inside.lambda.display.name=lambda 中存在未標記的 return
inspection.unnecessary.opt_in.annotation.display.name=不必要的 '@OptIn' 註解
inspection.unnecessary.opt_in.redundant.annotation=選擇加入註解冗餘\: 沒有使用符合的實驗 API
inspection.unnecessary.opt_in.redundant.marker=選擇加入標記冗餘\: 未使用標記為 ''{0}'' 的實驗 API
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=移除註解
inspection.unnecessary.opt_in.remove.marker.fix.family.name=移除選擇加入標記
inspection.unnecessary.variable.display.name=不必要的區域變數
inspection.unnecessary.variable.option.report.immediately.returned.variables=報告立即返回的變數
inspection.unreachable.code=不可到達的程式碼
inspection.unreachable.code.remove.unreachable.code=移除不可到達的程式碼
inspection.unsafe.cast.from.dynamic.display.name=從動態類型的隱式(不安全)轉換
inspection.unused.equals.display.name=未使用的 equals 表達式
inspection.unused.expression.display.name=未使用的表達式
inspection.unused.expression.problem.description=表達式未使用
inspection.unused.flow.display.name=未使用的 flow
inspection.unused.lambda.expression.body.display.name=包含 lambda 表達式主體的函式未使用的返回值
inspection.unused.lambda.expression.inspection.display.name=未使用的 lambda 表達式
inspection.unused.lambda.expression.inspection.problem.description=Lambda 表達式從未被呼叫。要建立作用域塊，請使用 'run { ... }'
inspection.unused.main.parameter.display.name=主參數不必要
inspection.unused.receiver.parameter=接收器參數從未使用
inspection.unused.receiver.parameter.display.name=未使用的接收器參數
inspection.unused.result.of.data.class.copy=資料類別複製的未使用結果
inspection.unused.symbol.display.name=未使用的符號
inspection.unused.unary.operator.display.name=未使用的一元運算符
inspection.use.expression.body.display.name=此處更適合表達式主體語法
inspection.use.property.access.syntax.display.name=可被取代為屬性存取語法的存取器呼叫
inspection.use.with.index.display.name=手動遞增的索引變數可被取代為使用 'withIndex()'
inspection.use.with.index.k2.display.name=手動遞增索引變數
inspection.use.with.index.k2.problem.description=手動遞增的索引變數可被取代為使用 'withIndex()'
inspection.useless.call.on.collection.display.name=對集合類型的無用呼叫
inspection.useless.call.on.not.null.display.name=對非 null 類型的無用呼叫
inspection.variable.initializer.is.redundant.display.name=變數初始設定式冗餘
inspection.variable.is.never.read.display.name=變數從未被讀取
inspection.verbose.nullability.and.emptiness.call=將後續檢查取代為 ''{0}()'' 呼叫
inspection.verbose.nullability.and.emptiness.display.name=詳細的為 null 性和空性檢查
inspection.warning.on.main.unused.parameter.migration.display.name=從 1.4 起，'main' 上不再使用 'args'
inspection.when.with.only.else.action.name=僅使用 'else' 分支簡化 'when'
inspection.when.with.only.else.display.name='when' 僅包含 'else' 分支且可以簡化
inspection.wrap.unary.operator.display.name=模糊一元運算符與數字常數一同使用
intention.add.import.alias.group.name=新增匯入別名
intention.change.package.text=更改軟體套件
intention.collection.concatenation.to.build.collection.call.family.name=轉換為集合建置器
intention.convert.lambda.line=轉換為{0,choice,0\#單|1\#多}行 lambda
intention.create.test.dialog.kotlin=Kotlin
intention.error.cannot.create.class.message=無法建立類別''{0}''
intention.error.cannot.create.class.title=建立類別失敗
intention.extract.declarations.from.file.text=從當前檔案中提取宣告
intention.extract.declarations.from.file.text.details=從當前檔案中提取 ''{0}'' {1, choice, 0\#|1\#和子類別}
intention.flow.on.dispatchers.io='Dispatchers.IO' 的 Flow
intention.implement.abstract.method.command.name=實作方法
intention.implement.abstract.method.searching.for.descendants.progress=正在搜尋後代…
intention.name.specify.supertype=指定父類型
intention.name.specify.supertype.title=指定父類型
intention.name.use.correct.parameter.name=請使用正確的參數名稱
intention.switch.context.to.dispatchers.io=切換到 'Dispatchers.IO' 上下文
intention.trailing.comma.custom.text=在格式化程序中預設{0,choice,0\#啟用|1\#停用}尾隨逗號
intention.trailing.comma.text=在格式化程序中預設啟用/停用尾隨逗號
intention.wrap.in.with.context=在 'withContext' 中包裝呼叫
interface=接口
interface.member.dependency.required.by.interfaces={0,choice,1\#接口|2\#接口}所需
interface.should.be.external=接口應為 external
internal.toggle.throwing.cached.pce.title=內部\: 切換拋出快取的 PCE
introduce.0.as.subject.0.when=將 ''{0}'' 作為 ''when'' 的主體引入
introduce.anonymous.parameter.fix.family.name=引入匿名參數
introduce.backing.property=引入支援屬性
introduce.constant=引入常數
introduce.import.alias=引入匯入別名
introduce.property=引入屬性
introduce.type.parameter=引入類型參數
introduce.type.parameter.to.declaration=將類型參數引入宣告
introduce.variable=引入變數
introduce.when.subject=引入 'when' 主體
invert.if.condition=反轉 'if' 條件
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=從 1.3 起，禁止使用 MIN_VALUE 步驟呼叫 {0}
iterate.over.0=迭代 ''{0}''
iterate.over.collection=迭代集合
java.collection.is.parameterized.with.nullable.type=Java 集合 ''{0}'' 使用{1,choice,1\#一個可為 null 類型|2\#可為 null 類型}進行參數化
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Java 集合 static 方法呼叫應被取代為 Kotlin stdlib
java.collections.to.process=要處理的 Java 集合\:
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Java Map.forEach 方法呼叫應被取代為 Kotlin 的 forEach
join.declaration.and.assignment=聯接宣告和賦值
join.with.initializer.fix.text=與初始設定式聯接
junit.static.methods=JUnit static 方法
kdoc.comment.unresolved=未解決
kdoc.section.title.author=作者
kdoc.section.title.constructor=建構函式
kdoc.section.title.parameters=參數
kdoc.section.title.properties=屬性
kdoc.section.title.receiver=接收器
kdoc.section.title.returns=返回
kdoc.section.title.samples=範例
kdoc.section.title.see.also=另請參閱
kdoc.section.title.since=自
kdoc.section.title.suppress=禁止
kdoc.section.title.throws=拋出
kotlin.call.chains.hints=Kotlin\: 顯示呼叫鏈的嵌入提示
kotlin.compiler.configurable=Kotlin 編譯器
kotlin.dist.downloading.failed.group.name=Kotlin dist 下載失敗
kotlin.external.compiler.updates.notification.group.name=可用的 Kotlin 外部編譯器更新
kotlin.jps.plugin.group.name=Kotlin JPS 延伸模組
kotlin.lambdas.hints=Kotlin\: 顯示 Lambda 的嵌入提示
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin\: 顯示隱式接收器和參數的嵌入提示
kotlin.lambdas.hints.hints.lambda.return=Kotlin\: 顯示返回表達式的嵌入提示
kotlin.references.types.hints=Kotlin\: 顯示類型的嵌入提示
kotlin.references.types.hints.hints.type.function.parameter=Kotlin\: 顯示函式參數類型的嵌入提示
kotlin.references.types.hints.hints.type.function.return=Kotlin\: 顯示函式返回值類型的嵌入提示
kotlin.references.types.hints.hints.type.property=Kotlin\: 顯示屬性類型的嵌入提示
kotlin.references.types.hints.hints.type.variable=Kotlin\: 顯示區域變數類型的嵌入提示
kotlin.script.definitions.model.name.autoReloadScriptDependencies=自動重新載入
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=如果要在檔案更改時自動載入腳本組態，啟用自動重新載入
kotlin.script.definitions.model.name.is.enabled=啟用
kotlin.script.definitions.model.name.name=名稱
kotlin.script.definitions.model.name.pattern.extension=模式/擴展
kotlin.script.definitions.title=管理腳本定義\:
kotlin.script.in.beta.stage=Kotlin 腳本現在處於測試階段
kotlin.script.in.beta.stage.link=https\://kotlinlang.org/docs/components-stability.html\#stability-levels-explained
kotlin.script.in.project.sources=<html>此腳本不應位於來源根內。在 Kotlin 1.9 之後，它將在模組編譯期間被忽略。</html>
kotlin.script.in.project.sources.1.9=<html>此腳本不應位於來源根內。自 Kotlin 1.9 起，它將在模組編譯期間被忽略。</html>
kotlin.script.in.project.sources.allow=允許…
kotlin.script.in.project.sources.hide=隱藏
kotlin.script.in.project.sources.later=以後再說
kotlin.script.in.project.sources.link=https\://youtrack.jetbrains.com/issue/KT-52735
kotlin.script.in.project.sources.move=移至…
kotlin.script.lookup.definitions=正在尋找 Kotlin 腳本定義…
kotlin.script.sources.index=索引
kotlin.script.sources.not.yet.indexed=未為原始檔編制索引以減少專案啟動時間
kotlin.script.warning.more.info=更多資訊
kotlin.scripting.configurable=Kotlin 腳本
kotlin.unreachable.code.display.name=不可到達的程式碼
kotlin.values.hints=顯示值的嵌入提示
kotlin.values.hints.kotlin.values.ranges=Kotlin\: 顯示範圍的嵌入提示
label.text.default.receiver.value=預設接收器值(&D)\:
label.text.destination=目標(&D)\:
label.text.destination.directory=目標目錄(&D)\:
label.text.file=檔案(&F)\:
label.text.file.name=檔名(&N)\:
label.text.introduce.as=引入為(&I)\:
label.text.move.expect.actual.counterparts=移動預期/實際對應項(&M)
label.text.name=名稱(&N)\:
label.text.package=軟體套件(&A)\:
label.text.package.name=軟體套件名稱(&G)\:
label.text.receiver.type=接收器類型(&T)\:
label.text.source.sets=源集\:
label.text.target.file.name=目標檔名\:
label.text.to.class=到類別\:
label.text.to.file=到檔案(&P)\:
label.text.to.object=到物件\:
label.text.to.package=到軟體套件(&A)\:
label.text.type=類型(&T)\:
label.text.visibility=可見性(&V)\:
lambda.argument.0.be.moved.out=Lambda 實參{0,choice,0\#可以|1\#應該}從圓括號中移出
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=在枚舉類別 {0} (具有可覆寫成員) 的建構函式中泄漏 ''this''
leaking.this.in.constructor.of.non.final.class.0=在非 final 類別 {0} 的建構函式中泄漏 ''this''
let.0.1=使{0} {1}
let.type.implement.interface=使類型實作接口
lift.assignment.out.fix.text.0=從 ''{0}'' 中提取賦值
lift.assignment.out.of.try.expression=從 'try' 表達式中提取賦值
lift.function.call.out.of.if=從 'if' 中解除函式呼叫
lift.function.call.out.of.when=從 'when' 中解除函式呼叫
lift.return.out.fix.text.0=從 ''{0}'' 中提取返回
lift.return.out.of.if.expression=從 'if' 表達式中提取 return
listbox.import.package=軟體套件
listbox.import.with.subpackages=以及子軟體套件
livetemplate.description.anonymous=匿名類別
livetemplate.description.closure=閉包(沒有名稱的函式)
livetemplate.description.exfun=擴展函式
livetemplate.description.exval=擴展唯讀屬性
livetemplate.description.exvar=擴展讀寫屬性
livetemplate.description.fun0=無形參函式
livetemplate.description.fun1=單參數函式
livetemplate.description.fun2=雙參數函式
livetemplate.description.ifn=插入 'if null' 表達式
livetemplate.description.inn=插入 'if not null' 表達式
livetemplate.description.interface=接口
livetemplate.description.iter=迭代 iterable 的元素(for-in loop)
livetemplate.description.main=main() 函式
livetemplate.description.maina=main(args) 函式
livetemplate.description.serr=將一個字串列印到 System.err
livetemplate.description.singleton=單例
livetemplate.description.sout=將一個字串列印到 System.out
livetemplate.description.soutp=將函式參數名稱和值列印到 System.out
livetemplate.description.soutv=將一個值列印到 System.out
livetemplate.description.void=函式不返回任何內容
local.variable=區域變數
logger.initialized.with.foreign.class=使用外類別 ''{0}'' 初始化記錄器
looking.for.usages.and.conflicts=正在尋找用法和衝突…
looking.for.usages.in.java.files=正在 Java 檔案中尋找用法…
loop.can.be.replaced.with.stdlib.operations=迴圈可被取代為 stdlib 運算
loop.parameter.0.is.unused=未使用迴圈參數 ''{0}''
loop.to.call.fix.family.name=取代為 stdlib 運算
loop.to.call.fix.family.name2=取代為使用 'asSequence()' 的 stdlib 運算
make.0=設為{0}
make.0.1=將 ''{0}'' 設為{1}
make.0.1.explicitly=將 ''{0}'' 明確設為{1}
make.0.an.annotation.class=將 ''{0}'' 設為註解類別
make.0.explicitly=明確生成{0}
make.0.in.1.open=使 {1} 中的 ''{0}'' 開啟
make.0.not.1=將{0}設為非 {1}
make.class.an.annotation.class=使類別為註解類別
make.constructor.parameter.a.property.0=使建構函式參數為屬性{0}
make.member.static.quickfix=將 ''{0}'' 設為 static
make.not.nullable=設為不可為 null
make.open=設為 'open'
make.open.fix.text=使類別開放
make.override.accessor.function.0=將覆寫存取器函式設為 ''{0}''
make.primary.constructor.0=設為主建構函式 {0}
make.private.and.0.1=設為 private 並{0} ''{1}''
make.private.fix.text=設為 private
make.script.executable=將腳本設為可執行
make.type.parameter.reified.and.function.inline=使類型參數具體化且使函式內聯
making.member.static=正在將成員設為 static…
map.get.or.default.can.be.replaced.with.indexing.and.elvis.operator='map.getOrDefault()' 可以取代為索引運算符和 elvis 運算符
map.get.with.not.null.assertion.operator=包含非 null 斷言運算符 '(\!\!)' 的 'map.get()'
map.put.should.be.converted.to.assignment=map.put() 應轉換為賦值
mark.as.deprecated.level.deprecationlevel.hidden=標記為 '@Deprecated(..., level \= DeprecationLevel.HIDDEN)'
max.functions.to.visit=要存取的最大函式
maximum.count.of.applied.refactoring.before.validity.check=驗證檢查前套用重構的最大計數
may.contain.only.letters.and.digits=僅可以包含字母和數字
may.contain.only.letters.digits.or.underscores=僅可以包含字母、數字或下劃線
member.info.abstract.0=abstract {0}
member.info.companion.0=伴生{0}
merge.else.if=合併 'else if'
merge.if.s=合併 'if'
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=“更改簽名”不適用於動態呼叫的函式
message.do.not.show.for.local.variables.in.future=以後不為區域變數顯示
message.text.property.receiver.type.cannot.be.resolved=無法解析屬性接收器類型 ''{0}''。\n是否繼續?
message.text.property.type.cannot.be.resolved=無法解析屬性類型 ''{0}''。\n是否繼續?
message.text.return.type.cannot.be.resolved=無法解析返回值類型 ''{0}''。\n是否繼續?
message.type.for.cannot.be.resolved=無法解析 {1} 的類型 ''{0}''。\n繼續?
methods.are.absent.in.coroutines.class.since.1.3=從 1.3 起，協程類別中不存在方法
microservices.url.path.inlay.hints=Kotlin\: 顯示 URL 路徑的嵌入提示
might.be.const=可能為 'const'
migrate.type.parameter.list.syntax=遷移類型參數列表語法
migrate.unsupported.yield.syntax=遷移不受支援的 yield 語法
minimal.line.count=最小行計數
minus.call.removes.path.elements='minus' 呼叫會移除 Path 元素
missing.documentation=缺少文檔
modifiers.should.follow.annotations=修飾符應遵循註解
move.annotation.to.receiver.type=將註解移至接收器類型
move.else.branch.to.the.end=將 else 分支移至末尾
move.lambda.argument.into.parentheses=將 lambda 實參移入圓括號
move.lambda.argument.out.of.parentheses=將 lambda 實參移出圓括號
move.members.from=從以下位置移動成員\:
move.out.of.companion.object=移出伴生物件
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=無法執行重構，因為以下檔案已存在\:
move.refactoring.test=移動重構測試
move.refactoring.testing=移動重構測試
move.reference.into.parentheses=將參照移到圓括號中
move.to.class.body=移至類別主體
move.to.companion.object=移至伴生物件
move.to.companion.object.command=移至伴生物件
move.to.constructor=移至建構函式
move.to.constructor.parameters=移至建構函式參數
move.to.top.level=移至頂層
move.type.parameter.constraint.to.where.clause=將類型參數約束移至 'where' 子句
move.unary.operator.to.previous.line.fix.text=將一元運算符移至上一行
move.variable.declaration.into.when=將變數宣告移至 'when' 中
moving.to.companion.object=正在移至伴生物件…
name=名稱(&N)\:
name.extract.interface=提取接口
name.introduce.import.alias=引入匯入別名
name.introduce.lambda.parameter=引入 Lambda 參數
name.introduce.parameter1=引入參數
name.introduce.type.alias=引入類型別名
naming.convention.will.be.violated.after.rename=重新命名後將違反命名約定
negated.operation.can.be.simplified=求反運算可以簡化
nested.1.call.in.0.could.be.simplified.to.2=''{0}'' 中的嵌套 ''{1}'' 呼叫可以簡化為 {2}
no.actual.for.expect.declaration=以下模組中的 expect 宣告中沒有 actual\: {0}
non.canonical.modifiers.order=非規範修飾符順序
non.external.classifier.extending.state.or.props.name=擴展 State 或 Props 的非外部分類器
not.found.in.0.files=在 {0} 個檔案中未找到
nothing.to.do=沒有要執行的動作
notification.navigation.to.overriding.classes=索引更新時無法導覽到覆寫類別
notification.text.kotlin.js.compiler.body=使用新的 Kotlin/JS IR 編譯器來縮減應用程式的捆綁包大小並自動生成 TypeScript 定義(d.ts)。
notification.text.kotlin.js.compiler.learn.more=了解詳情
notification.text.kotlin.js.compiler.link=https\://kotl.in/jsirstable
notification.text.kotlin.js.compiler.title=Kotlin/JS IR 在 1.8.0 及更高版本中是穩定的\!
null.checks.replaceable.with.safe.calls=null 檢查可被取代為安全呼叫
null.checks.to.safe.call.check.fix.text=將鏈式 null 檢查取代為安全的呼叫
number.of.attempts.then.files.in.project.0=嘗試次數 > 專案中隨後的檔案，{0}
object.0=物件“{0}”
object.or.top.level.property=物件或頂層屬性
object.private.property=物件 private 屬性
object.should.be.external.interface=物件應為 external 接口
obsolete.coroutine.usage.fix.family.name=修復實驗性協程用法
obsolete.coroutine.usage.in.whole.fix.family.name=修復專案中的實驗性協程用法
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=修復專案中的 'kotlin.dom' 和 'kotlin.browser' 軟體套件用法
obsolete.package.usage.fix.family.name=修正 ''{0}'' 軟體套件用法
one.line.return=一行返回
open.moved.members.in.editor=在編輯器中開啟移動的成員
open.moved.method.in.editor=在編輯器中開啟移動的方法
optimize.imports=最佳化 import
optimize.imports.collect.unused.imports=正在收集未使用的 import
optimize.imports.task.removing.redundant.imports=正在移除冗餘 import
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=可選預期註解在用於平台 {1} 的模組 {0} 中沒有實際註解
overridden.marker.implementation=在以下位置實作\:
overridden.marker.implementations.choose.implementation.find.usages={0} 的覆寫屬性
overridden.marker.implementations.choose.implementation.title=選擇 {0} 的實作
overridden.marker.implementations.multiple=具有實作
overridden.marker.overrides=在以下位置被覆寫\:
overridden.marker.overrides.choose.implementation.find.usages={0} 的 super 實作
overridden.marker.overrides.choose.implementation.title=選擇 {0} 的 super 實作
overridden.marker.overrides.multiple=在子類別中被覆寫
override.accessor.functions.instead=改為覆寫存取器函式
override.declaration.choose.to.delete=<html>有一些未使用的成員覆寫了將被刪除的方法。請選擇您也想要刪除的成員\:</html>
override.declaration.delete.multiple.parameters={0} 是方法層次結構的一部分。是否要刪除多個參數?
override.declaration.member=成員
override.declaration.unused.overriding.methods.title=未使用的覆寫成員
override.declaration.x.implements.y={0}實作{1}。
override.declaration.x.in.y={0} ({1} 內)
override.declaration.x.overrides.y.in.class.list={0} 覆寫以下類別/接口中的宣告\: {1} 是否要{2}基宣告?
override.java.default.methods.delegate.fix.text=通過委託給委託物件來覆寫 Java 預設方法
override.java.default.methods.superclass.fix.text=通過顯式委託給超類別來覆寫 Java 預設方法
package.0.already.contains.1=軟體套件 ''{0}'' 已包含 {1}
package.name=軟體套件名稱
package.usages.are.obsolete.since.1.4=''{0}'' 軟體套件用法自 1.4 起已過時
parameter.0=參數“{0}”
parameter.hints.old=Kotlin\: 顯示參數的嵌入提示
parameter.name.is.invalid=參數名 ''{0}'' 無效
parameter.name.prompt=參數名稱(&M)\:
parameter.type.is.invalid=參數類型 ''{0}'' 無效
parameter.types.are.not.denotable=無法提取方法，因為以下類型在目標作用域中不可表示\:
parameter.used.in.declaration.body.warning=''{0}'' 用於宣告體
parentheses.should.be.removed=應移除括號
pass.outer.class.instance.as.parameter=將外部類別實例作為參數傳遞(&O)
perform.refactoring=執行重構…
placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的實參數量({0})少於指定的佔位符數({1}) \#loc
placeholder.count.matches.argument.count.more.problem.descriptor=提供的實參數量({0})多於指定的佔位符數({1}) \#loc
plus.call.appends.path.elements='plus' 呼叫會附加 Path 元素
popup.title.choose.supertype=選擇父類型
popup.title.elements=元素
popup.title.expressions=表達式
popup.title.types=類型
predefined.configuration.all.methods.of.the.class=類別的所有方法
predefined.configuration.all.vars.of.the.class=類別的所有 var
predefined.configuration.all.vars.of.the.object=物件的所有 var
predefined.configuration.also.match.vals=同時符合 var 和 val
predefined.configuration.annotations=註解
predefined.configuration.anonymous.class=匿名類別
predefined.configuration.array.access=陣列存取
predefined.configuration.assert.not.null=非 null 斷言運算符
predefined.configuration.assignments=賦值
predefined.configuration.casts=轉換
predefined.configuration.class.annotation=註解類別
predefined.configuration.comments.containing.word=包含給定詞的註釋
predefined.configuration.companion.object.method.calls=來自伴生物件的方法呼叫
predefined.configuration.do.while=Do...while 迴圈
predefined.configuration.elvis=Elvis 運算符
predefined.configuration.for=For 迴圈
predefined.configuration.function.annotation=註解函式
predefined.configuration.function.explicit.inferred.type=顯式和推斷類型
predefined.configuration.function.signature=函式簽名
predefined.configuration.ifs=If
predefined.configuration.instance=實例
predefined.configuration.kdoc.tag=KDoc 標記
predefined.configuration.lambda=lambda 表達式
predefined.configuration.method.calls=方法呼叫
predefined.configuration.object.companion.object=物件和伴生物件
predefined.configuration.properties.getter=具有顯式 getter 的屬性
predefined.configuration.safe.call.operator=安全呼叫運算符
predefined.configuration.string.literals=字串字面量
predefined.configuration.strings=字串
predefined.configuration.strings.with.long.template=包含長模板的字串
predefined.configuration.trys=Try
predefined.configuration.vars.of.given.type=給定類型的 var
predefined.configuration.when=when 表達式
predefined.configuration.while=While 迴圈
premature.end.of.template=模板過早結束
preparing.move.descriptor=正在準備 move 檔案描述子
presentation.text.for.receiver.in.container.paren=({1}中的{0})
presentation.text.for.receiver.in.container.paren.no.brackets=物件\: {1}中的{0}
presentation.text.in.container={0} ({1} 內)
presentation.text.in.container.paren=({0} 中)
presentation.text.in.container.paren.no.brackets=({0} 中)
presentation.text.object.in.container={0}中的物件
presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
print.should.be.replaced.with.logging.display.name=對 'print()' 或 'println()' 的呼叫
private.data.class.constructor.is.exposed.via.the.generated.copy.method=private 主建構函式通過 'data' 類別的生成的 'copy' 方法公開。
private.property=private 屬性
progress.finding.implicit.nothing.s=正在尋找隱式無內容
progress.looking.up.add.annotation.usage=正在尋找註解用法…
progress.looking.up.sealed.subclass.usage=正在尋找 sealed 子類別的用法…
progress.title.analyze.extraction.data=分析提取資料…
progress.title.calculate.occurrences=計算符合項…
progress.title.calculating.type=正在計算類型…
progress.title.check.for.conflicts=檢查衝突…
progress.title.collect.hierarchy=收集 ''{0}'' 層次結構…
progress.title.collect.members.to.generate=收集成員…
progress.title.converting.to.if.then.else.expression=正在轉換為 if-then-else 表達式…
progress.title.introducing.value.for.condition=正在引入條件的值…
progress.title.searching.for.expected.actual=正在搜尋預期/實際…
project.view.class.error.name=未提供名稱
project.view.class.initializer=類別初始設定式
project.view.expression=表達式
property=屬性
property.0=屬性“{0}”
property.has.an.actual.declaration.in.the.class.constructor=屬性在類別建構函式中具有實際宣告
property.in.external.interface.should.be.var=external 接口中的屬性應為 var
property.is.explicitly.assigned.to.parameter.0.can=屬性已明確分配給參數 {0}，因此可以直接在建構函式中宣告
property.overloaded.in.child.class.constructor=屬性在子類別建構函式中多載
protected.visibility.is.effectively.private.in.a.final.class='protected' 可見性在 final 類別中實際是 'private'
provide.return.value=提供返回值
put.arguments.on.one.line=將實參放在同一行中
put.arguments.on.separate.lines=將實參放在單獨的行中
put.calls.on.separate.lines=將呼叫放在單獨的行中
put.expressions.on.separate.lines=將表達式放在單獨的行中
put.parameters.on.one.line=將參數放在同一行中
put.parameters.on.separate.lines=將參數放在單獨的行中
quick.doc.no.documentation=無可用文檔
quick.doc.section.deprecated=已棄用\:
quick.doc.section.java.declaration=Java 宣告\:
quick.doc.section.replace.with=取代為\:
quick.doc.text.enum.ordinal=枚舉常數序號\: {0}
quick.doc.text.lateinit='lateinit' 允許初始化<a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables">建構函式外部的非 null 屬性</a>
quick.doc.text.tailrec='tailrec' 將函式標記為<a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions">尾遞迴</a> (允許編譯器將遞迴取代為迭代)
quickFix.add.property.text=將 ''{0}{1}'' 屬性 ''{2}'' 新增到 ''{3}''
quickfix.add.property.familyName=新增屬性
quickfix.text.suffix.may.change.semantics=\ (可能更改語意)
random.seed=隨機種子
range.could.be.replaced.with.indices.call=範圍可被取代為 '.indices' 呼叫
recursive.equals.call=遞迴 equals 呼叫
recursive.property.accessor=遞迴屬性存取器
recursive.synthetic.property.accessor=遞迴合成屬性存取器
redundant.0=冗餘 ''@{0}''
redundant.0.call=冗餘的 ''{0}'' 呼叫
redundant.0.modifier=冗餘的 ''{0}'' 修飾符
redundant.async.call.may.be.reduced.to.0=冗餘 ''async'' 呼叫可簡化為 ''{0}''
redundant.call.of.the.conversion.method=轉換方法的冗餘呼叫
redundant.companion.reference=冗餘伴生參照
redundant.constructor.keyword=冗餘的 'constructor' 關鍵字
redundant.curly.braces.in.string.template=字串模板中的冗餘大括號
redundant.double.negation=冗餘雙重求反
redundant.else=冗餘的 'else'
redundant.empty.class.body=冗餘空類別主體
redundant.empty.initializer.block=冗餘空白初始設定式塊
redundant.enum.constructor.invocation=冗餘枚舉建構函式呼叫
redundant.explicit.this=冗餘顯式 this
redundant.getter=冗餘 getter
redundant.getter.body=冗餘的 getter 主體
redundant.if.option.ignore.chained=忽略鏈式 'if' 語句
redundant.if.statement=冗餘的 'if' 語句
redundant.if.statement.analyzing.type=正在分析條件類型…
redundant.lambda.arrow=冗餘 lambda 箭頭
redundant.let.call.could.be.removed=可以移除冗餘 'let' 呼叫
redundant.modality.modifier=冗餘形式修飾符
redundant.override.fix.text=移除冗餘覆寫方法
redundant.overriding.method=冗餘覆寫方法
redundant.qualifier.name=冗餘限定符名稱
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=不必要的非直接父類別限定符
redundant.runcatching.call.may.be.reduced.to.0=冗餘 ''runCatching'' 呼叫可簡化為 ''{0}''
redundant.sam.constructor=冗餘 SAM 建構函式
redundant.sam.constructors=冗餘 SAM 建構函式
redundant.semicolon=冗餘分號
redundant.semicolon.text=移除冗餘分號
redundant.setter=冗餘 setter
redundant.setter.body=冗餘的 setter 主體
redundant.setter.parameter.type=冗餘 setter 參數類型
redundant.string.template=冗餘字串模板
redundant.suspend.modifier=冗餘 'suspend' 修飾符
redundant.tostring.call.in.string.template=字串模板中存在冗餘 'toString()' 呼叫
redundant.type.checks.for.object=物件的冗餘類型檢查
redundant.unit=冗餘 'Unit'
redundant.unit.return.type=冗餘 'Unit' 返回值類型
redundant.visibility.modifier=冗餘可見性修飾符
refactoring.cannot.be.applied.no.sources.attached=“{0}”重構無法套用\: 未附加任何源
refactoring.cannot.be.applied.to.abstract.declaration={0} 重構不能應用於 abstract 宣告
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} 重構不能在未經呼叫的情況下應用於匿名函式
refactoring.cannot.be.applied.to.expect.declaration={0} 重構不能應用於 expect 宣告
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} 重構不能在未經呼叫的情況下應用於 lambda 表達式
refactoring.cannot.find.target.class=找不到目標類別
refactoring.class.destination=類別目標
refactoring.extract.to.separate.file.text=提取到單獨檔案中
refactoring.file.destination=檔案目標
refactoring.move.non.kotlin.file=目標必須是 Kotlin 檔案
refactoring.the.function.cannot.be.converted.to.anonymous.function=該函式不能轉換為匿名函式
refactoring.the.function.not.found=找不到函式
refactoring.the.invocation.cannot.be.resolved=呼叫無法解析
remove.0=移除 ''.{0}''
remove.0.from.parameter=從參數中移除 ''{0}''
remove.0.from.property=從屬性中移除{0}
remove.0.modifier=移除 ''{0}'' 修飾符
remove.0.variance.from.1=從 ''{1}'' 中移除 ''{0}'' 差異
remove.all.argument.names=移除所有實參名稱
remove.annotation.doesnt.have.any.effect=移除註解，因為它不起任何作用。請參閱 https\://youtrack.jetbrains.com/issue/KT-48141
remove.argument.name=移除實參名稱
remove.as.dynamic.call.fix.text=移除 'asDynamic' 呼叫
remove.assequence.call.fix.text=移除 'asSequence' 呼叫
remove.braces=移除大括號
remove.braces.fix.text=移除大括號
remove.braces.from.0.statement=從 ''{0}'' 語句中移除大括號
remove.braces.from.all.branches=移除所有分支中的大括號
remove.braces.from.if.all.statements=移除所有 'if' 語句中的大括號
remove.braces.from.when.all.entries=移除所有 'when' 條目中的大括號
remove.braces.from.when.entry=從 'when' 條目移除大括號
remove.branch=移除分支
remove.condition=移除條件
remove.conflicting.import.0=移除衝突的匯入 {0}
remove.constructor.call=移除建構函式呼叫
remove.conversion.from.kclass.to.class=移除從 'KClass' 到 'Class' 的轉換
remove.curly.braces=移除大括號
remove.default.parameter.value=移除預設參數值
remove.deprecated.symbol.import=移除棄用的符號匯入
remove.element=移除元素
remove.else=移除 ''{0}'' 中的 else
remove.else.branch=移除 else 分支
remove.empty.constructor.body=移除空建構函式主體
remove.empty.parentheses.from.annotation.entry.fix.text=移除不必要的圓括號
remove.empty.primary.constructor=移除空主建構函式
remove.enum.constructor.invocation.fix.text=移除枚舉建構函式呼叫
remove.explicit.lambda.parameter.types.may.break.code=移除顯式 lambda 參數類型(可能中斷程式碼)
remove.explicit.supertype.qualification=移除顯式父類型限定
remove.explicit.type.arguments=移除顯式類型實參
remove.explicit.type.specification=移除顯式類型規範
remove.explicit.type.specification.from.0=移除 ''{0}'' 中的顯式類型規範
remove.expression=移除 ''{0}''
remove.expression.target=移除表達式目標
remove.extension.function.type.annotation=移除不適用的 @ExtensionFunctionType 註解
remove.final.upper.bound=移除最終上限
remove.fix.text=刪除表達式
remove.from.annotation.argument=從註解實參中移除 @
remove.function.body=移除函式體
remove.identifier.from.anonymous.function=從匿名函式中移除關鍵字
remove.indices.in.for.loop=移除 'for' 迴圈中的索引
remove.initializer.block.fix.text=移除初始設定式塊
remove.jvmfield.annotation=移除 @JvmField 註解
remove.jvmoverloads.annotation=移除 @JvmOverloads 註解
remove.labeled.return.from.last.expression.in.a.lambda=從 lambda 中的最後一個表達式移除帶標籤的 return
remove.let.call=移除 'let' 呼叫
remove.modifier=移除修飾符
remove.modifier.fix=將 ''{0}'' 設為非{1}
remove.modifier.fix.family=設為非 {0}
remove.parameter.0=移除參數 ''{0}''
remove.parameter.name=移除參數名稱
remove.parts.from.property=從屬性中移除部分
remove.redundant=移除冗餘的 '?'
remove.redundant.0.modifier=移除冗餘 ''{0}'' 修飾符
remove.redundant.assignment=移除冗餘賦值
remove.redundant.assignment.title=移除冗餘的賦值
remove.redundant.backticks.quick.fix.text=移除冗餘反引號
remove.redundant.call.fix.text=移除冗餘呼叫
remove.redundant.calls.of.the.conversion.method=移除轉換方法的冗餘呼叫
remove.redundant.companion.reference.fix.text=移除冗餘伴生參照
remove.redundant.constructor.keyword.fix.text=移除冗餘的 'constructor' 關鍵字
remove.redundant.else.fix.text=移除冗餘的 'else'
remove.redundant.elvis.return.null.text=移除冗餘 '?\: return null'
remove.redundant.empty.class.body=移除冗餘的空類別主體
remove.redundant.getter.body.fix.text=移除冗餘的 getter 主體
remove.redundant.getter.fix.text=移除冗餘 getter
remove.redundant.if.expression=移除冗餘 'if' 表達式
remove.redundant.if.may.change.semantics.with.floating.point.types=刪除冗餘 'if' 語句(可能會更改浮點類型的語意)
remove.redundant.if.text=移除冗餘 'if' 語句
remove.redundant.initializer=移除冗餘的初始設定式
remove.redundant.label=移除冗餘標籤
remove.redundant.modality.modifier=移除冗餘的形式修飾符
remove.redundant.qualifier.name.quick.fix.text=移除冗餘限定符名稱
remove.redundant.sam.constructor=移除冗餘 SAM 建構函式
remove.redundant.sam.constructors=移除冗餘 SAM 建構函式
remove.redundant.setter.body.fix.text=移除冗餘的 setter 主體
remove.redundant.setter.fix.text=移除冗餘 setter
remove.redundant.spread.operator.quickfix.text=移除冗餘展開運算符
remove.redundant.unit.fix.text=移除冗餘 'Unit'
remove.redundant.visibility.modifier=移除冗餘的可見性修飾符
remove.redundant.with.fix.text=移除冗餘'with' 呼叫
remove.require.not.null.call.fix.text=移除 ''{0}'' 呼叫
remove.return.0=移除 return@{0}
remove.return.label.fix.family=移除冗餘標籤
remove.return.label.fix.text=移除冗餘 ''@{0}''
remove.self.assignment.fix.text=移除自我賦值
remove.single.expression.string.template=移除單表達式字串模板
remove.single.lambda.parameter.declaration=移除單個 lambda 參數宣告
remove.star=移除 '*'
remove.supertype=移除父類型
remove.to.string.fix.text=移除 'toString()' 呼叫
remove.token.from.function.declaration=從函式宣告中移除 '\=' 令牌
remove.type.arguments=移除類型實參
remove.type.parameters=移除類型參數
remove.unary.operator.fix.text=移除未使用的一元運算符
remove.underscores=移除下劃線
remove.unnecessary.parentheses=移除不必要的圓括號
remove.unnecessary.parentheses.from.function.call.with.lambda=從帶 lambda 的函式呼叫中移除不必要的圓括號
remove.unused.imports.quickfix.text=移除未使用的 import
remove.use.site.get.target=移除 'get\:' 以使註解生效。(會更改語意。請參閱\: https\://youtrack.jetbrains.com/issue/KT-48141)
remove.useless=移除無用的 '?'
remove.useless.cast=移除無用的轉換
remove.useless.elvis.operator=移除無用的 elvis 運算符
remove.useless.is.check=移除無用的 is 檢查
remove.val.or.var.from.parameter=從參數中移除 'val' 或 'var'
remove.var.keyword.text=移除 'var'
remove.variable=移除變數
remove.variable.0=移除變數 ''{0}''
rename.base.0=重新命名基{0,choice,1\#函式|2\#屬性|3\#成員|4\#方法|11\#函式|12\#屬性|13\#成員|14\#方法}
rename.class.to.0=將類別重命名為 {0}
rename.class.to.containing.file.name=將類別重命名為包含檔名
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1\#實作|2\#覆寫}{3}的{2}
rename.file=重新命名檔案
rename.file.0=將檔案重命名為 ''{0}''
rename.file.to.0.1=將檔案重命名為 {0}.{1}
rename.file.to.match.top.level.class.name=重新命名檔案以符合頂層類別名
rename.identifier.fix.text=重新命名
rename.only.current.0=僅重新命名當前的{0,choice,1\#函式|2\#屬性}
rename.parameter.to.match.overridden.method=重新命名參數以符合覆寫的方法
rename.searching.for.all.overrides=正在搜尋所有覆寫
rename.searching.for.super.declaration=正在搜尋最深的 super 宣告
rename.to.0=重命名為 ''{0}''
rename.to.01=重命名為 {0}
rename.to.fix.text=重命名為 ''{0}''
rename.to.underscore=重命名為 _
rename.useless.call.fix.text=將呼叫更改為 ''{0}''
reorder.parameters=對參數重新排序
reorder.parameters.command=對參數重新排序
repair.actual.members=修復實際成員
replace.&&.with.||=將 '\\&\\&' 取代為 '||'
replace.0.call.with.indexing.operator=將 ''{0}'' 呼叫取代為索引運算符
replace.0.name.with.spaces=將 {0} 名稱取代為空格
replace.0.with=將 ''{0}()'' 取代為 ''+\=''
replace.0.with.1=將 ''{0}'' 取代為 ''{1}''
replace.0.with.1.and.vice.versa=將 ''{0}'' 取代為 ''{1}''，反之亦然
replace.and.with.when.guard=將 '\\&\\&' 取代為 'if'
replace.annotation=取代註解
replace.annotation.with.0=將註解取代為 {0}
replace.array.of.boxed.with.array.of.primitive=將裝箱陣列取代為基元陣列
replace.assert.boolean.with.assert.equality=將斷言布爾取代為斷言等式
replace.assert.with.operator=將斷言取代為運算符
replace.assignment.with.if.expression=將賦值取代為 'if' 表達式
replace.assignment.with.when.expression=將賦值取代為 'when' 表達式
replace.by.0=由 ''{0}'' 取代
replace.by.reconstructed.type=由重建構類型取代
replace.call.with.unary.operator=將呼叫取代為一元運算符
replace.cast.with.call.to.to.0=將轉換取代為對 ''to{0}()'' 的呼叫
replace.cast.with.primitive.conversion.method=將轉換取代為基元轉換方法
replace.collection.count.with.size.quick.fix.text=將 'count' 取代為 'size'
replace.contains.call.with.in.operator=將 'contains' 呼叫取代為 'in' 運算符
replace.contains.call.with.in.operator.description=使用了 Java 'contains' 呼叫，而非 Kotlin 慣用的 'in' 運算符
replace.deprecated.symbol.usage=取代棄用的符號用法
replace.deprecated.symbol.usage.in.whole.project=取代整個專案中棄用的符號用法
replace.diagnostic.name.fix.family.name=取代診斷名稱
replace.diagnostic.name.fix.text={0} 取代為 {1}
replace.elvis.expression.with.if.expression=將 elvis 表達式取代為 'if' 表達式
replace.equal.with.content.equals=將 '\=\=' 取代為 'contentEquals'
replace.explicit.lambda.parameter.with.it=將顯式 lambda 參數取代為 'it'
replace.explicit.parameter.0.with.it=將顯式參數 ''{0}'' 取代為 ''it''
replace.expression.with.if.expression=將 '\!\!' 表達式取代為 'if' 表達式
replace.function.call.with.if=將函式呼叫取代為 'if'
replace.function.call.with.the.opposite=將函式呼叫取代為相反的函式呼叫
replace.function.call.with.when=將函式呼叫取代為 'when'
replace.get.or.set.call.with.indexing.operator=將 get 或 set 呼叫取代為索引運算符
replace.guard.clause.with.kotlin.s.function.call=將 guard 子句取代為 Kotlin 函式呼叫
replace.if.expression.with.elvis.expression=將 'if' 表達式取代為 elvis 表達式
replace.if.expression.with.return=將 'if' 表達式取代為 return
replace.if.expression.with.safe.access.expression=將 'if' 表達式取代為安全存取表達式
replace.if.expression.with.safe.cast.expression=將 'if' 表達式取代為安全的轉換表達式
replace.if.with.elvis.operator=將 'if' 取代為 elvis 運算符
replace.if.with.when=將 'if' 取代為 'when'
replace.if.with.when.changes.semantics=將 'if' 取代為 'when' (改變語意)
replace.index.loop.with.collection.loop.quick.fix.text=取代為元素的迴圈
replace.infix.call.with.ordinary.call=將中綴呼叫取代為普通呼叫
replace.int.range.end.inclusive.with.last.quick.fix.text=將 'endInclusive' 取代為 'last'
replace.int.range.start.with.first.quick.fix.text=將 'start' 取代為 'first'
replace.invalid.positioned.arguments.for.annotation=取代註解的無效定位實參
replace.invoke.with.direct.call=將 'invoke' 取代為直接呼叫
replace.it.with.explicit.parameter=將 'it' 取代為顯式參數
replace.jvmfield.with.const=將 '@JvmField' 取代為 'const'
replace.kotlin.options.with.compiler.options=將 'kotlinOptions' 取代為 'compilerOptions'
replace.manual.range.with.indices.call.quick.fix.text=取代為索引
replace.modifier=取代修飾符
replace.negated.0.operation.with.1=將求反的 ''{0}'' 運算取代為 ''{1}''
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=將求反的 ''{0}'' 運算取代為 ''{1}'' (可能會更改浮點類型的語意)
replace.negated.0.with.1=將求反的 ''{0}'' 取代為 ''{1}''
replace.not.equal.with.content.equals=將 '\!\=' 取代為 'contentEquals'
replace.nullable.type.with.non.nullable.family.name=將可為 null 的類型取代為不可為 null 的類型
replace.overloaded.operator.with.function.call=將多載運算符取代為函式呼叫
replace.property.initializer.with.if.expression=將屬性初始設定式取代為 'if' 表達式
replace.property.initializer.with.when.expression=將屬性初始設定式取代為 'when' 表達式
replace.return.with.if.expression=將 return 取代為 'if' 表達式
replace.return.with.when.expression=將 return 取代為 'when' 表達式
replace.safe.access.expression.with.if.expression=將安全存取表達式取代為 'if' 表達式
replace.scope.function.with.safe.call=將作用域函式取代為 (?.) 呼叫
replace.size.check.with.0=將大小檢查取代為 ''{0}''
replace.size.check.with.isnotempty=將大小檢查取代為 'isNotEmpty'
replace.size.zero.check.with.isempty=將大小零檢查取代為 'isEmpty'
replace.substring.call.with.droplast.call=將 'substring' 呼叫取代為 'dropLast' 呼叫
replace.substring.call.with.indexing.operation.call=將 'substring' 呼叫取代為索引動作呼叫
replace.substring.call.with.substringafter.call=將 'substring' 呼叫取代為 'substringAfter' 呼叫
replace.substring.call.with.substringbefore.call=將 'substring' 呼叫取代為 'substringBefore' 呼叫
replace.substring.call.with.take.call=將 'substring' 呼叫取代為 'take' 呼叫
replace.to.with.infix.form.quickfix.text=將 'to' 取代為中綴形式
replace.tostring.with.string.template=將 'toString' 取代為字串模板
replace.total.order.equality.with.ieee.754.equality=使用 IEEE 754 等式取代總訂單等式
replace.usages.of.0.in.whole.project=取代整個專案中的 ''{0}'' 用法
replace.when.with.if=將 'when' 取代為 'if'
replace.with.0=取代為 ''{0}''
replace.with.0.1.2=取代為 {0}[{1}] ?\: {2}
replace.with.0.call=取代為 ''{0}()'' 呼叫
replace.with.0.operator=取代為 ''{0}'' 運算符
replace.with.a.for.loop=取代為 'for' 迴圈
replace.with.a.foreach.function.call=取代為 ''{0}'' 函式呼叫
replace.with.array.call=取代為數組呼叫
replace.with.array.literal.fix.family.name=取代為 [...]
replace.with.arrayof=取代為 'arrayOf'
replace.with.assignment.fix.text=取代為賦值 (原始為空)
replace.with.binary.operator=取代為二元運算符
replace.with.block.comment=取代為塊註釋
replace.with.content.equals=取代為 'contentEquals'
replace.with.dollar.literals=將轉義的美元符號取代為字面量
replace.with.dot.call=取代為點呼叫
replace.with.elvis.error.fix.text=取代為 '?\: error("")'
replace.with.elvis.return.fix.text=取代為 ''?\: return{0}''
replace.with.end.of.line.comment=取代為行尾註釋
replace.with.enum.map.fix.text=取代為 'EnumMap'
replace.with.equality.check.fix.text=取代為相等檢查
replace.with.equality.fix.text=將 ''{0}'' 取代為 ''{1}''
replace.with.error=取代為 '?\: error(...)'
replace.with.explicit.type=將 '_' 取代為顯式類型
replace.with.field.fix.text=取代為 'field'
replace.with.filter.fix.text=取代為篩選器
replace.with.generated.publishedapi.bridge.call.0=取代為生成的 @PublishedApi 橋呼叫 ''{0}''
replace.with.get.or.else.fix.text=取代為 'getOrElse' 呼叫
replace.with.get.value.call.fix.text=取代為 'getValue' 呼叫
replace.with.if.fix.text=取代為 'if' 類型檢查
replace.with.import.alias=取代為匯入別名
replace.with.in.when=將 ',' 取代為 '||'\:
replace.with.indexing.and.elvis.operator=取代為索引和 elvis 運算符
replace.with.infix.function.call=取代為中綴函式呼叫
replace.with.kotlin.analog.function.family.name=取代為 Kotlin 模擬
replace.with.kotlin.analog.function.text=取代為 ''{0}'' 函式
replace.with.kotlin.s.foreach=取代為 Kotlin 的 forEach
replace.with.kotlin.s.function.call=取代為 Kotlin 的函式呼叫
replace.with.label.0.at=取代為標籤 {0}@
replace.with.list.generator.fix.text=取代為 List 生成器
replace.with.operator.assignment=取代為運算符賦值
replace.with.ordinary.assignment=取代為普通賦值
replace.with.parameter.name=將 '_' 取代為參數名稱
replace.with.publishedapi.bridge.call=取代為 @PublishedApi 橋呼叫
replace.with.rangeUntil.quick.fix.text=取代為 '..<'
replace.with.repeat.fix.family.name=取代為 'repeat()'
replace.with.return=將 '\!\!' 取代為 '?\: return'
replace.with.safe.call=取代為安全的 (?.) 呼叫
replace.with.safe.this.call=取代為安全的 (this?.) 呼叫
replace.with.std.lib.fix.text=取代為 {0}.{1}
replace.with.stdlib.operations=取代為 stdlib 運算
replace.with.stdlib.operations.with.use.of.assequence=取代為使用 'asSequence()' 的 stdlib 運算
replace.with.string.literal.fix.family.name=取代為字串模板
replace.with.underscore=將顯式類型取代為 '_'
replace.with.until.quick.fix.text=取代為 'until'
replace.with1=取代為 '+\='
replace.||.with.&&=將 '||' 取代為 '\\&\\&'
replaceable.with.enummap=可被取代為 'EnumMap'
replaceable.with.operator.assignment=可被取代為運算符賦值
report.also.for.a.variables.without.a.whitespace.around=同時為周圍沒有空格的變數報告
report.also.on.call.with.single.boolean.literal.argument=同時在包含單個布爾字面量實參的呼叫上報告
report.also.on.statement=也在語句上報告
report.for.types.with.platform.arguments=為包含平台實參的類型報告
reports.only.function.calls.from.kotlinx.coroutines=僅報告來自 'kotlinx.coroutines' 的函式呼叫
reset.files=重設檔案…
resolve.pasted.references=解析貼上的參照
result.of.0.call.is.not.thrown=未拋出 ''{0}'' 呼叫的結果
retargeting.usages.progress=正在重新定位用法
rethrow.stored.pce.as.a.new.runtime.exception=將存儲的 PCE 作為新執行時異常再次拋出
return.type=返回值類型(&R)\:
return.type.is.invalid=返回值類型無效
return.when='返回 when'
revert.applied.imports.command=還原已套用的匯入
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=為 Kotlin 專案中的非 JVM 模組更新來源根
round.using.0=使用 {0}() 舍入
safe.delete.constructor=安全刪除建構函式
saving.files=正在儲存檔案…
scanning.files.0.fo.1.file.2.occurrences.found=正在掃描檔案\: 第 {0} 個，共 {1} 個。已找到 {2} 個匹配項
script.action.text.ignore=忽略
script.action.text.open.settings=開啟設定
script.action.text.show.all=全部顯示
script.name.kotlin.scripting=Kotlin 腳本
script.not.executable.missing.execute.permission=腳本不可執行。缺少執行權限。
script.text.multiple.script.definitions.are.applicable.for.this.script=多個腳本定義適用於此腳本。已使用 {0}
sealed.sub.class.has.no.state.and.no.overridden.equals='sealed' 子類別沒有狀態，且沒有被覆寫的 'equals()'
search.for.not.property.candidates=搜尋非屬性候選項
search.for.text.occurrences=搜尋文本符合項(&T)
search.in.comments.and.strings=在註釋和字元中搜尋(&C)
searching.0=正在搜尋 {0}…
searching.for.0=正在搜尋 {0}
searching.for.imports.to.delete.title=正在搜尋要刪除的匯入
searching.for.not.property.candidates=正在搜尋非屬性候選項
searching.for.overriding.methods=正在搜尋覆寫方法
searching.inheritors=正在搜尋繼承者…
searching.usages.of.0.parameter=正在搜尋 ''{0}'' 參數的用法
select.lambda.to.label=選擇要標記的 lambda
select.loop.statement.to.label=選擇要標記的迴圈語句
select.target.code.block.file=選擇目標程式碼塊/檔案
select.target.file=選擇目標檔案
selected.code.fragment.has.multiple.exit.points=選擇的程式碼段具有多個離開點
selected.code.fragment.has.multiple.output.values=選擇的程式碼段具有 3 個以上的輸出值\:
selected.code.fragment.has.output.values.and.exit.points=選擇的程式碼段既有輸出值，也有可選的離開點
setter.of.0.will.become.invisible.after.extraction=提取後 {0} 的 Setter 將變為不可見
shortening.usages.progress=正在縮短用法
should.be.replaced.with.if.type.check=應取代為 'if' 類型檢查
should.be.replaced.with.indexing=應取代為索引
should.be.replaced.with.kotlin.function=應取代為 Kotlin 函式
should.be.replaced.with.list.generator=應取代為 List 生成器
should.not.contain.lowercase.letter=不應包含小寫字母
should.not.contain.underscores=不應包含下劃線
should.not.contain.underscores.in.the.middle.or.the.end=中間或結尾不應包含下劃線
should.not.contain.underscores.with.camel.case=使用駝峰式命名法時不應包含下劃線
should.not.start.with.an.underscore=不應以下劃線開頭
should.not.start.with.an.uppercase.letter=不應以大寫字母開頭
should.start.with.a.lowercase.letter=應以小寫字母開頭
should.start.with.an.uppercase.letter=應以大寫字母開頭
signature.preview=簽名預覽
simplify.0.to.1=將 ''{0}'' 簡化為 ''{1}''
simplify.boolean.expression=簡化布爾表達式
simplify.call.chain.fix.text=將呼叫鏈合併為 ''{0}''
simplify.call.fix.text=將 ''{0}'' 呼叫轉換為 ''{1}''
simplify.comparison=簡化對比
simplify.fix.text=簡化表達式
simplify.foldable.if.then=簡化可折疊的 if-then
simplify.negated.operation=簡化求反運算
simplify.when.fix.text=簡化 'when'
since.kotlin.1.3.main.parameter.is.not.necessary=從 Kotlin 1.3 起，主參數不必要
slicer.text.in=位置
slicer.text.tracking.enclosing.lambda=\ (追蹤封閉的 lambda)
slicer.text.tracking.lambda.argument=\ (追蹤 lambda 參數)
slicer.text.tracking.lambda.calls=\ (追蹤 lambda 呼叫)
slicer.text.tracking.lambda.receiver=\ (追蹤 lambda 接收器)
slicer.title.dataflow.from.here=流出此處的數據流
slicer.title.dataflow.to.here=流入此處的數據流
slicer.tool.tip.text.variable.dereferenced=已解參照變數
some.types.are.not.accessible.from.0.1=無法從 {0} 存取一些類型\:\n{1}
sort.modifiers=對修飾符排序
specify.all.remaining.arguments.by.name=按名稱指定所有剩餘實參
specify.all.types.explicitly.in.destructuring.declaration=在解構宣告中顯式指定所有類型
specify.explicit.lambda.signature=指定顯式 lambda 簽名
specify.override.explicitly=顯式指定覆寫
specify.override.for.0.explicitly=為 ''{0}'' 顯式指定覆寫
specify.remaining.required.arguments.by.name=按名稱指定剩餘的必需實參
specify.return.type.explicitly=顯式指定返回值類型
specify.super.type=顯式指定父類型 ''{0}''
specify.type.explicitly=顯式指定類型
split.if.into.two=將 'if' 拆分為兩部分
split.property.declaration=拆分屬性宣告
spring.secured.urls.inlay.hints=Kotlin\: 顯示安全的 Spring URL 的嵌入提示
ssr.modifier.match.call.semantically=在語意上符合呼叫
ssr.modifier.match.companion.object=符合伴生物件
ssr.modifier.match.val=符合 val
ssr.modifier.match.var=符合 var
start.import.button.text.add=新增
start.import.button.text.remove=移除
statement=語句
status=(狀態)
status.text.no.definitions=無定義
step.1.collecting.0.1.2=第 1 步\: 收集 {0}\:{1}\:{2}
step.2.0.of.1=第 2 步\: {0}/{1}
step.3.0.of.1=第 3 步\: {0}/{1}
surround.with.0=使用 {0}(...) 包圍
surround.with.array.of=使用 arrayOf(...) 包圍
surround.with.lambda=使用 lambda 包圍
surround.with.null.check=使用 null 檢查包圍
surround.with.star.0=使用 *{0}(...) 包圍
suspicious.asdynamic.member.invocation=可疑的 'asDynamic' 成員呼叫
suspicious.callable.reference.as.the.only.lambda.element=可疑的可調用參照作為唯一的 lambda 元素
suspicious.combination.of.and=可疑的 \=\= 與 \=\=\= 組合
suspicious.var.property.its.setter.does.not.influence.its.getter.result=可疑的 'var' 屬性\: 它的 setter 不會影響其 getter 結果
test.function=測試函式
test.integration.button.text.cancel=取消
test.integration.button.text.rewrite=覆寫
test.integration.message.text.create.test.in.the.same.source.root=在相同的來源根中建立測試?
test.integration.message.text.kotlin.class=Kotlin 類別 ''{0}'' 已存在。是否要更新它?
test.integration.title.no.test.roots.found=找不到測試根
test.result.log.file.will.be.placed.here=測試結果日誌檔案將位於此處
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' 必須隨 sealed 父類別及其全部子類別一起移動
text.0.already.contains.1={0} 已包含 {1}
text.0.already.contains.nested.class.1={0} 已包含名為 {1} 的嵌套類別
text.0.already.declared.in.1={0} 已在 {1} 中宣告
text.0.have.no.inheritors.warning={0} 沒有繼承者\n向下推動成員會導致它們被刪除。要繼續嗎?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={1} 中的 {0} 會在重構後覆寫 {2} 的相應成員
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} 繼承自 {1}。\n它不會受重構影響
text.0.is.invalid.destination.package=''{0}'' 是無效的目標軟體套件名稱
text.0.is.not.allowed.in.the.target.context=目標上下文中不允許出現 ''{0}''
text.0.is.not.valid.package.name={0} 不是有效的軟體套件名稱
text.0.to.inline=要內聯的 {0}
text.0.uses.1.which.is.not.accessible.from.2={0} 使用 {1}，後者無法從 {2} 存取
text.0.uses.1.which.will.be.inaccessible.after.move={0} 使用 {1}，後者在移動後將無法存取
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} 使用 {1}，後者無法從子類別存取。
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} 使用 internal {1}，後者在移動後將無法存取
text.0.will.be.shadowed.by.1={0} 將被 {1} 隱藏
text.0.will.clash.with.existing.1.in.2=重新命名後的 {0} 會與 {2} 中的現有 {1} 衝突
text.0.will.no.longer.be.accessible.after.signature.change={0} 在簽名更改後將無法存取
text.Assignment=賦值
text.Function=函式
text.Name=名稱
text.Package=軟體套件
text.Property=屬性
text.Return=返回
text.abstract=抽象
text.actual.moved.to.common.modules.target=actual 宣告 ''{0}'' 將被移至通用模組。
text.add.getter=新增 getter
text.add.getter.and.setter=新增 getter 和 setter
text.add.setter=新增 setter
text.add.use.site.target.0=新增使用站點目標 ''{0}''
text.all.declarations.must.belong.to.the.same.directory.or.class=所有宣告必須屬於同一目錄或類別
text.annotation=註解
text.annotation.class=註解類別
text.anonymous=[匿名]
text.anonymous.function=匿名函式
text.at.least.one.file.must.be.selected=應至少選擇一個成員
text.callee.text.would.be.shown.here=此處將顯示被呼叫方文本
text.caller.text.with.highlighted.callee.call.would.be.shown.here=此處將顯示包含\n突出顯示的被呼叫方呼叫的呼叫方文本
text.can=可以
text.cannot.create.target.directory.0=無法建立目標目錄 {0}
text.cannot.determine.source.directory=無法確定源目錄
text.cannot.find.package.corresponding.to.0=找不到 {0} 對應的軟體套件
text.cannot.find.target.package.name=找不到目標軟體套件名稱
text.cannot.inline.reference.from.0.to.1=無法將參照從 {0} 內聯到 {1}
text.cannot.move.expect.actual.declaration.to.file=無法將預期/實際宣告移至檔案
text.cannot.move.for.current.project=無法為當前專案移動
text.cannot.move.inner.class.0.into.itself=無法將嵌套的類別 {0} 移至類別自身
text.cannot.move.to.original.file=無法移至原始檔案
text.change.file.package.to.0=將檔案的軟體套件更改為 ''{0}''
text.change.use.site.target.0=將使用場所目標更改為 ''{0}''
text.choose.containing.file=選擇包含檔案
text.class=類別
text.class.0={0,choice,1\#類別|2\#類別}
text.class.0.already.contains.member.1={0} 已包含 {1}
text.class.0.already.exists.in.package.1=類別 {0} 在軟體套件 {1} 中已存在
text.class.0.already.exists.in.the.target.scope=類別 {0} 在目標作用域中已存在
text.class.0.is.final={0} 為 final
text.constructor=建構函式
text.convert._it_.to.explicit.lambda.parameter=無法將 'it' 轉換為顯式 lambda 參數
text.create=建立
text.create.destructuring.declaration=建立解構宣告
text.create.single.variable=建立單個變數
text.declaration=宣告
text.declarations.clash.move.0.destination.1.declared.in.scope.2=以下宣告將衝突\: 移動 {0} 和在作用域 {2} 中宣告的目標 {1}
text.default.value=\ // 預設值 \= {0}
text.destination.class.should.be.kotlin.class=目標類別必須為 Kotlin 類別
text.do.you.want.to.rename.0.as.well=是否還要重新命名 {0}()?
text.do.you.want.to.rename.base.property=是否要重新命名基本屬性?
text.do.you.want.to.rename.base.property.from.0=是否要從 {0} 重新命名基本屬性?
text.done=完成
text.duplicating.local.variable=正在複製區域變數 ''{0}''
text.duplicating.parameter=正在複製參數 ''{0}''
text.duplicating.property=正在複製屬性 ''{0}''
text.enable.annotation.target.feature=新增編譯器實參\: {0}
text.enum=枚舉
text.enum.class=枚舉類別
text.enum.constant=枚舉常數
text.enum.entry.0={0,choice,1\#枚舉條目|2\#枚舉條目}
text.expected.moved.to.platform.modules.target=預期宣告 ''{0}'' 將被移至平台模組。
text.explicit.receiver.is.already.present.in.call.element.0=顯式接收器在呼叫元素中已存在\: {0}
text.extend=擴展
text.extension=擴展
text.extension.function=擴展函式
text.extension.function.0=擴展{0,choice,1\#函式|2\#函式}
text.extension.property=擴展屬性
text.extension.property.0=擴展{0,choice,1\#屬性|2\#屬性}
text.extract.superclass=提取超類別
text.file.0.already.exists.in.1=檔案 {0} 在 {1} 中已存在
text.file.name.cannot.be.empty=檔名不能為空
text.first.definition.that.matches.script.pattern.extension.applied.starting.from.top=從頂部開始，第一個與腳本模式/擴展符合的定義會被套用
text.function=函式
text.function.0={0,choice,1\#函式|2\#函式}
text.function.already.exists=函式已存在\: ''{0}''
text.function.in.ticks.0=函式 ''{0}''
text.getter=getter
text.implement=實作
text.implements=實作
text.implicit.companion.object.will.be.inaccessible.0=隱式伴生物件將無法存取\: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=目標路徑不正確。目錄 {0} 不屬於當前專案。
text.indirect.outer.instances.will.not.be.extracted.0=將不會提取間接外部實例\: {0}
text.infix.extension.function=中綴擴展函式
text.infix.extension.function.0=中綴擴展{0,choice,1\#函式|2\#函式}
text.infix.function=中綴函式
text.infix.function.0=中綴{0,choice,1\#函式|2\#函式}
text.initializer=初始設定式
text.inline.0=內聯{0}
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=內聯所有參照並{0} {1} {2}
text.inline.function.not.supported=尚不支持內聯函式
text.inline.recursive.function.is.supported.only.on.references=僅在參照上支援內聯遞迴函式
text.inline.this.reference.and.keep.the.0=內聯此參照並保留 {0}
text.inlined.0.overrides.0.1=已內聯的 {0} 覆寫 {0} {1}
text.inlining.0.1=正在內聯{0} {1}
text.inner.class.0.cannot.be.moved.to.interface={0} 是內部類別。無法移至接口
text.interface=接口
text.introduce.default.value=引入預設值(&D)
text.invalid.target.path.0=目標路徑 {0} 無效
text.invalid.target.specified=指定了無效目標
text.keep=保留
text.lambda.parameter=lambda 參數
text.lambda.parameters=Lambda 參數(&P)\:
text.lambda.return.type=Lambda 返回值類型(&T)
text.lazy.property=延遲屬性
text.local.property=屬性
text.local.variable=區域變數
text.looking.for.usages=正在尋找用法…
text.member=成員
text.member.0.in.super.class.will.clash.with.existing.member.of.1=超類別中的 {0} 將與 {1} 的現有成員衝突
text.member.extension.call.will.not.be.processed.0=不會處理成員擴展呼叫\: {0}
text.move.declaration.no.support.for.companion.objects=伴生物件不支持“移動宣告”
text.move.declaration.no.support.for.enums=枚舉條目不支持“移動宣告”
text.move.declaration.no.support.for.multi.file=不支持從不同檔案移動宣告
text.move.declaration.no.support.incorrect.modality=不支持 'abstract'、'open' 和 'override' 成員的移動
text.move.declaration.only.support.for.single.elements=多重嵌套宣告不支持移動宣告
text.move.declaration.only.support.for.some.nested.declarations=除嵌套類別、函式和屬性之外的嵌套宣告不支持移動宣告
text.move.declaration.proceed.move.without.mpp.counterparts.text=此重構將移動所選宣告(不包含可能導致編譯錯誤的 expect/actual 對應項)。\n是否要繼續?
text.move.declaration.proceed.move.without.mpp.counterparts.title=無法執行重構。此重構不支持 MPP 宣告。
text.move.declaration.supports.only.top.levels.and.nested.classes=僅頂級宣告和嵌套類別支援“移動宣告”
text.move.declarations=移動宣告
text.move.file.0=移動 {0}
text.move.file.no.support.for.file.target=非目錄目標不支持移動檔案
text.move.method.is.not.supported.for.generic.classes=泛型類別不支持 Move 方法
text.move.method.is.not.supported.for.non.project.methods=非專案方法不支持 Move 方法
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=當方法是繼承層次結構的一部分時，不支持 Move 方法
text.move.refactoring.not.available.during.indexing=當索引編制正在進行時，無法使用“移動”重構
text.moving.multiple.nested.classes.to.top.level.not.supported=不支持將多個嵌套類別移至頂級
text.name=名稱
text.nested.classes.to.upper.level=嵌套類別到上一級
text.no.destination.object.specified=未指定目標物件
text.no.elements.to.move.are.selected=未選擇要移動的元素
text.no.files.to.move=沒有要移動的給定檔案
text.no.name.provided.for.type.alias=沒有為類型別名提供名稱
text.no.package.corresponds.to.directory=沒有對應於此目錄的軟體套件
text.non.kotlin.0.will.not.be.affected.by.refactoring=非 Kotlin {0} 將不會受重構影響
text.object=物件
text.object.0={0,choice,1\#物件|2\#物件}
text.operator.0={0,choice,1\#運算符|2\#運算符}
text.overload=多載
text.overrides=覆寫
text.package.directive.dont.match.file.location=軟體套件指令與檔案位置不符合
text.parameter=參數
text.parameter.0=參數 ''{0}''
text.parameter.name=參數名(&N)\:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=參數參照無法安全地取代為 {0}，因為 {1} 在此上下文中不明確
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=參數參照無法安全地取代為 {0}，因為在此上下文中無法參照目標函式
text.parameter.type=參數類型(&T)\:
text.parameters=參數(&P)
text.part=部分
text.pattern=模式\:
text.primary=主
text.primary.constructor=主建構函式
text.proceed.with.extraction=仍然繼續提取
text.process.duplicates=處理重複項
text.processing.file.0=正在處理 {0}
text.property=屬性
text.property.0={0,choice,1\#屬性|2\#屬性}
text.property.in.ticks.0=屬性 ''{0}''
text.property.with.getter=包含 getter 的屬性
text.property.with.initializer=包含初始設定式的屬性
text.property.would.conflict.with.superclass.primary.constructor.parameter.0=屬性 ''{0}'' 將與超類別中的主建構函式參數 ''{1}'' 衝突。
text.pushed.member.will.not.be.available.in.0=推送的成員無法在 ''{0}'' 中使用
text.qualified.call.will.not.be.processed.0=將不會處理限定呼叫\: {0}
text.receiver=接收器
text.receiver.can.t.be.safely.transformed.to.value.argument=接收器無法安全地轉換為值實參\: {0}
text.refactoring.can.t.be.performed.on.the.selected.code.element=無法對選定的程式碼元素執行重構
text.refactoring.is.not.applicable.to.this.code.fragment=重構不適用於此程式碼段
text.reference.cannot.be.converted.to.a.lambda=參照無法轉換為 lambda
text.references.in.code.to.0.1.and.its.declarations=在程式碼中參照{0} {1} 及其宣告
text.references.to.outer.classes.have.to.be.added.manually=移動後必須手動新增對外部類的參照
text.remove=移除
text.remove.0.no.longer.used=移除不再使用的{0}
text.remove.question=移除 '?'
text.rename.as.part.of.phrase=重新命名
text.rename.is.not.applicable.to.compiler.plugin.generated.declarations=重新命名不適用於編譯器延伸模組生成的宣告
text.rename.is.not.applicable.to.secondary.constructors=“重新命名”不適用於輔助建構函式
text.rename.is.not.applicable.to.synthetic.declarations=“重新命名”不適用於合成宣告
text.rename.not.applicable.to.backing.field.reference=“重新命名”不適用於支援欄位參照
text.rename.not.applicable.to.dynamically.invoked.methods=“重新命名”不適用於動態呼叫的成員
text.rename.overloads.title=重新命名多載
text.rename.parameters.title=重新命名參數
text.return=返回
text.sealed.broken.hierarchy.none.in.target=''{0}'' 的 sealed 層次結構將被拆分。它的成員都不在模組 ''{2}'' 的軟體套件 ''{1}'' 中\: {3}。
text.sealed.broken.hierarchy.still.in.source=''{0}'' 的 sealed 層次結構將被拆分。模組 ''{2}'' 的軟體套件 ''{1}'' 仍將包含其成員\: {3}。
text.sealed.class.0.must.be.moved.with.all.its.subclasses=密封類別 ''{0}'' 必須隨其所有子類別一起移動
text.secondary=輔助
text.secondary.constructor=輔助建構函式
text.select.target.code.block=選擇目標程式碼塊
text.select.target.code.block.file=選擇目標程式碼塊/檔案
text.select.target.file=選擇目標檔案
text.setter=setter
text.should=應當
text.there.is.already.a.parameter={1} 中已存在參數 ''{0}''。它會與新參數衝突。
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter={1} 中已存在變數 ''{0}''。它會與新參數衝突。
text.type=類型
text.type.alias=類型別名
text.type.alias.0=類型{0,choice,1\#別名|2\#別名}
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=類型別名無法參照在定義作用域中無法存取的類型
text.type.alias.name.must.be.a.valid.identifier.0=類型別名名稱必須為有效的關鍵字\: {0}
text.type.already.exists.in.the.target.scope=類型 {0} 在目標作用域中已存在
text.type.parameter=類型{0, choice, 0\#參數|2\#參數}
text.type.parameter.names.must.be.distinct=類型參數名稱必須不同
text.type.parameters=類型參數(&P)
text.unexpected.element.type.0=意外元素類型\: {0}
text.update.usages.to.reflect.declaration.0.move=更新用法以反映{0, choice, 0\#宣告n|1\#宣告}移動
text.updating.usages.progress=正在更新用法…
the.anonymous.object=匿名物件
the.declaration.has.0.modifier=宣告包含 ''{0}'' 修飾符
the.function.declaration.shouldn.t.have.a.default.implementation=函式宣告不應具有預設實作
the.package.0.does.not.match.the.implicit.prefix.1=所選軟體套件 ''{0}'' 與目標的隱式軟體套件前綴不相容\: ''{1}''。執行重構將破壞隱式軟體套件前綴。
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=在分配給變數 ''{0}'' 的表達式中發現可能的副作用<br>您可以\:<br>-\\&nbsp;<b>移除</b>整個賦值，或<br>-\\&nbsp;<b>將賦值右側轉換</b>為其自己的語句。<br>
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=通過此別名使用的 ''{0}'' 上有自己的 ''ReplaceWith''。請先取代用法。
these.declarations.cannot.be.transformed=無法轉換這些宣告\:
this.call.is.useless.with=此呼叫對 ?. 無用
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=屬性與合成擴展衝突，應移除或重新命名，以避免未來版本的 Kotlin 編譯器破壞程式碼
this.range.is.empty=此範圍為空。
this.range.is.empty.did.you.mean.to.use.0=此範圍為空。是否要使用 ''{0}''?
this.type.probably.can.be.changed.to.nullable=此類型或許可以更改為可為 null
this.when.is.simplifiable=此 'when' 可以簡化
throwable.instance.0.is.not.thrown=未拋出 Throwable 實例 ''{0}''
titile.not.found=未找到
title.choose.destination.object=選擇目標物件
title.choose.logger.factory.class=選擇記錄器工廠類別
title.choose.use.site.target=選擇 Use-Site 目標
title.done=完成
title.error=錯誤
title.import.layout=匯入布局
title.inline.function=內聯函式
title.inline.property=內聯屬性
title.inline.type.alias=內聯類型別名
title.introduce.parameter.to.declaration=將參數引入宣告
title.kdoc.for.abstracts=Abstract 的 KDoc
title.lateinit.var.overrides.lateinit.var='lateinit var' 覆寫 super 'lateinit var'
title.logger.factory.class.name=記錄器工廠類別名
title.logger.factory.method.name=記錄器工廠方法名稱
title.move.method=Move 方法
title.move.nested.classes.to.upper.level=將嵌套類別移至上一級
title.packages.to.use.import.with=將 import 與 '*' 搭配使用的軟體套件
title.parameters=參數
title.rename.file=重新命名檔案
title.rename.file.to=將檔案重命名為\:
title.rename.overloads.to=將重載重命名為\:
title.rename.warning=重新命名警告
title.select.a.name.for.this.parameter=為 ''this@{0}'' 參數選擇一個名稱
title.select.target.code.block=選擇目標程式碼塊
title.success=成功
to.fully.qualified.name=到(完全限定名稱)\:
tooltip.implements.function=在以下位置實作函式\:
tooltip.implements.property=在以下位置實作屬性\:
tooltip.is.implemented.by=實作物件\:
tooltip.is.subclassed.by=被以下類別子類別化
tooltip.overrides.function=在以下位置覆寫函式\:
tooltip.overrides.property=在以下位置覆寫屬性\:
top.level=頂層
two.comparisons.should.be.converted.to.a.range.check=兩個比較應轉換為範圍檢查
type.0.1.is.not.accessible.from.target.module=無法從目標模組存取{0, choice, 0\#類型|2\#類型} {1}
type.alias.0=類型別名“{0}”
type.arguments.will.be.lost.after.conversion.0=轉換後類型實參將丟失\: {0}
type.parameter.0=類型參數“{0}”
type.parameter.can.have.0.variance=類型參數可以具有 ''{0}'' 差異
type.provider.anonymous.object=匿名物件
type.provider.no.expression.found=找不到表達式
type.provider.smart.cast.from=(從 {0} 智能轉換)
type.provider.unknown.type=類型未知
unclear.precedence.of.binary.expression.inspection=表達式應當使用明確的圓括號
unclear.precedence.of.binary.expression.inspection.display.name=具有不同優先級的多個運算符
unclear.precedence.of.binary.expression.quickfix=新增明確的圓括號
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=即使是明顯的案例也報告
unknown.types.title=未知類型
unlabeled.return.inside.lambda=lambda 中存在未標記的返回
unrecognized.reference.will.be.skipped.0=將跳過無法識別的參照\: {0}
unsupported.usage.0=不支持的用法\: {0}
until.can.be.replaced.with.rangeUntil.operator='until' 可被取代為 '..<' 運算符
unused.equals.expression=未使用的 equals 表達式
unused.import.directive=未使用的 import 指令
unused.return.value.of.a.function.with.lambda.expression.body=包含 lambda 表達式主體的函式未使用的返回值
unused.unary.operator=未使用的一元運算符
unwrap.else=展開 ''{0}'' 中的 else
unwrap.expression=解包 ''{0}''
unwrap.parameter=解包 ''{0}'' arg ''{1}''
update.indices=更新索引…
update.obsolete.label.syntax=更新過時的標籤語法
usage.of.kotlin.internal.declaration.from.different.module=使用了來自不同模組的 Kotlin 內部宣告
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=使用了冗餘或棄用的語法或棄用的符號
usage.provider.text.property.of.0={0}/{1}
usage.provider.text.unnamed=<未命名>
usages.of.nested.declarations.from.non.kotlin.code.won.t.be.processed=非 Kotlin 程式碼中的嵌套宣告用法將不會被處理
usages.of.outer.class.instance.inside.declaration.0.won.t.be.processed=宣告 ''{0}'' 內的外部類實例的用法將不會被處理
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=不會處理屬性 ''{0}'' 內外部類實例的用法
use.destructuring.declaration=使用解構宣告
use.expression.body.instead.of.0=使用表達式主體，而不是{0}
use.inherited.visibility=使用繼承的可見性
use.of.getter.method.instead.of.property.access.syntax=使用 getter 方法代替屬性存取語法
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=將非常數 Kotlin 屬性用作 Java 常數不正確。將在 1.4 中禁止
use.of.setter.method.instead.of.property.access.syntax=使用 setter 方法代替屬性存取語法
use.property.access.syntax=使用屬性存取語法
use.property.access.syntax.option.report.non.trivial.accessors=報告非普通的存取器
use.withindex.instead.of.manual.index.increment=使用 withIndex() 代替手動索引增量
useless.call.on.collection.type=集合類型上存在無用呼叫
useless.call.on.not.null.type=非 null 類型上存在無用呼叫
uses.of.should.be.replaced.with.logging=<code>{0}</code> 的使用可能應當被取代為更可靠的日誌呼叫
variable.0.is.assigned.to.itself=變數 ''{0}'' 已分配給自己
variable.declaration.could.be.inlined=變數宣告可以內聯
variable.declaration.could.be.moved.into.when=變數宣告可以移至 'when' 中
variable.is.never.modified.and.can.be.declared.immutable.using.val=變數從未被修改，因此可以使用 'val' 宣告
variable.is.never.read=變數 ''{0}'' 從未被讀取
variable.is.same.as.0.and.should.be.inlined=變數與 ''{0}'' 相同且可以內聯
variable.name.0.matches.the.name.of.a.different.component=變數名稱 ''{0}'' 與其他組件的名稱符合
variable.used.only.in.following.return.and.should.be.inlined=變數僅用於以下返回且可以內聯
vcs.code.author=Kotlin\: 顯示程式碼作者的嵌入提示
version={version}
visibility=可見性(&V)\:
when.has.only.else.branch.and.should.be.simplified='when' 僅包含 'else' 分支且應簡化
when.with.subject.should.be.used=應使用包含主體的 'when'
wrap.argument.with.parentheses=使用圓括號包裝實參
wrap.element.with.0.call=使用 ''{0}()'' 呼叫包裝元素
wrap.expression.in.parentheses=將表達式括在圓括號中
wrap.run.fix.text=轉換為執行 { ... }
wrap.unary.operator.quickfix.text=使用 () 包裝一元運算符和值
wrap.with=使用 [] 包裝
wrap.with.array.literal=使用陣列字面量包裝
wrap.with.collection.literal.call=使用集合字面量呼叫包裝
wrap.with.coroutine.scope.fix.family.name=使用 coroutineScope 包裝
wrap.with.coroutine.scope.fix.text=使用 'coroutineScope { ... }' 包裝函式體
wrap.with.coroutine.scope.fix.text2=使用 'coroutineScope { ... }' 包裝呼叫
wrap.with.coroutine.scope.fix.text3=移除接收器並使用 'coroutineScope { ... }' 包裝
wrap.with.let.call=使用 '?.let { ... }' 呼叫包裝

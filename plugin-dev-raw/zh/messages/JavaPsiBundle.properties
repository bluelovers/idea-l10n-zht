0.is.not.an.identifier=''{0}'' 不是一個標識符.
annotation.name.is.missing=註解特性必須為 'name=value' 形式
anonymous.class.context.display=匿名在{0}
anonymous.class.derived.display=派生自 {0} 的匿名類
aux.context.display=/ {0}
bound.not.expected=意外綁定
catch.without.try='catch' 沒有 'try'
class.context.display={0} ({1} 內)
class.literal.expected=應為 .class
context.type.java.comment=註釋
context.type.string=字符串

default.language.level.description=SDK 默認值

# These constants are used from JavaElementKind
# When localizing you may use the parameter #0 which signals the desired grammatical case:
# 0 = nominative case (subject)
# 1 = accusative case (object)
element.abstract_method=abstract 方法
element.annotation=註解
element.anonymous_class=匿名類
element.class=類
element.type.parameter=類型參數
element.constant=常量字段
element.function Object() { [native code] }=構造函數
element.enum=枚舉
element.enum_constant=枚舉常量
element.expression=表達式
element.field=字段
element.initializer=初始值設定項
element.interface=接口
element.label=標籤
element.local_variable=局部變量
element.method=方法
element.module=模塊
element.package=軟件包
element.parameter=參數
element.pattern_variable=模式變量
element.record=記錄
element.record_component=記錄組件
element.statement=語句
element.unknown=元素
element.variable=變量
element.throws.list=throws 列表
element.extends.list=extends 列表
element.type.arguments=類型實參
element.receiver.parameter=接收器參數
element.method.call=方法調用

else.without.if='else' 沒有 'if'
enum.constant.context=枚舉常數 ''{0}'' 在 ''{1}''
expected.array.initializer=應為數組初始值設定項
expected.boolean.expression=應為布爾表達式
expected.catch.or.finally=應為 'catch' 或 'finally'
expected.class.or.interface=應為 'class' 或 'interface'
expected.class.reference=應為類引用
expected.colon=應為 ':'
expected.comma=應為 ','
expected.comma.or.rparen=應為 ',' 或 ')'
expected.comma.or.semicolon=應為 ',' 或 ';'
expected.dot=應為 '.'
expected.eq=應為 '='
expected.expression=應為表達式
expected.gt=應為 '>'。
expected.gt.or.comma=應為 '>' 或 ','
expected.identifier=應為標識符
expected.identifier.or.type=應為標識符或類型
expected.lbrace=應為 '{'
expected.lbrace.or.semicolon=應為 '{' 或 ';'
expected.lbracket=應為 '['
expected.lparen=應為 '('
expected.lparen.or.lbracket=應為 '(' 或 '['
expected.lt.or.lparen=應為 '<' 或 '('
expected.module.declaration=應為模塊聲明
expected.module.statement=應為模塊指令
expected.package.reference=應為軟件包引用
expected.parameter=應為參數
expected.rbrace=應為 '}'
expected.rbracket=應為 ']'
expected.resource=應為資源定義
expected.rparen=應為 ')'
expected.semicolon=應為 ';'
expected.statement=應為語句
expected.string=應為字符串文字
expected.switch.label=應為 'case'、'default' 或 '}'
expected.switch.rule=應為表達式、塊或 throw 語句
expected.type=應為類型
expected.type.parameter=應為類型參數
expected.value=應為值
expected.while=應為 'while'
expected.with=應為 'with'
filetype.class.description=Java類檔案
filetype.class.display.name=Java類檔案
filetype.java.description=Java
filetype.jshell.description=JShell snippet files
finally.without.try='finally' 沒有 'try'
import.statement.identifier.or.asterisk.expected.=應為標識符或 '*'

java.terms.anonymous.class.base.ref=匿名 {0}
javadoc.exception.tag.class.is.not.throwable=類 {0} 不是 Throwable 的後代
javadoc.exception.tag.exception.is.not.thrown={0} 未被聲明為由方法 {1} 引發
javadoc.exception.tag.wrong.tag.value=標籤值錯誤
javadoc.param.tag.parameter.name.expected=應為參數名稱
javadoc.param.tag.type.parameter.gt.expected=應為 '>'
javadoc.param.tag.type.parameter.name.expected=應為類型參數名稱
javadoc.ref.tag.class.ref.expected=應為類引用
javadoc.value.field.required=@value 標記必須引用字段
javadoc.value.field.with.initializer.required=@value 標記必須引用具有常量初始值設定項的字段
javadoc.value.static.field.required=@value 標記必須引用 static 字段
javadoc.value.tag.jdk15.required=使用 JDK 1.4 或更早版本時，@value 標記可能沒有任何實參
jdk.1.3.language.level.description=1.3 - 普通舊 Java
jdk.1.4.language.level.description=1.4 - 'assert' 關鍵字
jdk.1.5.language.level.description=5.0 - 'enum' keyword, generics, autoboxing etc.
jdk.1.6.language.level.description=6 - 接口中的 @Override
jdk.1.7.language.level.description=7 - 鑽石、ARM、多 catch 等
jdk.1.8.language.level.description=8 - lambda、類型註解等
jdk.1.9.language.level.description=9 - 模塊、接口中的 private 方法等
jdk.10.language.level.description=10 - 局部變量類型推理
jdk.11.language.level.description=11 - lambda 參數的局部變量語法
jdk.12.language.level.description=12 - 無新語言功能
jdk.13.language.level.description=13 - 無新語言功能
jdk.14.language.level.description=14 - switch 表達式
jdk.15.language.level.description=15 - 文本塊
jdk.16.language.level.description=16 - 記錄、模式、本地枚舉和接口
jdk.16.preview.language.level.description=16 (預覽) - 密封類型
jdk.X.language.level.description=X - 實驗性功能

local.class.preposition=本地
method.context.display={0}() 在 {1}
node.abstract.flag.tooltip=abstract
node.annotation.tooltip=註解
node.anonymous.class.tooltip=匿名類
node.class.tooltip=類
node.enum.tooltip=枚舉
node.exception.tooltip=異常
node.field.tooltip=字段
node.final.flag.tooltip=Final
node.interface.tooltip=接口
node.junit.test.tooltip=JUnit測試
node.method.tooltip=方法
node.record.tooltip=記錄
node.runnable.class.tooltip=Runnable類
node.static.flag.tooltip=static
psi.error.attempt.to.edit.class.file=無法修改檔案中的已編譯元素''{0}''

task.background.title.maven=Maven

unexpected.identifier=意外標識符
unexpected.token=意外的標記
unexpected.tokens=意外的標記
error.message.wildcard.not.expected=意外通配符

bad.return.type.in.method.reference=方法引用中存在錯誤返回類型: 無法將 {0} 轉換為 {1}
bad.return.type.in.lambda.expression=lambda 表達式中存在錯誤返回類型: {0} 無法轉換為 {1}
bad.return.type.in.lambda.expression1=lambda 表達式中存在錯誤返回類型: {0} 無法轉換為 void
missing.return.value.lambda=缺少返回值
unexpected.return.value=意外返回值
lambda.body.must.be.a.statement.expression=lambda 體必須是語句表達式
diamond.error.explicit.type.parameters.for.function Object() { [native code] }=無法將 diamond 與顯式類型參數用於構造函數
diamond.error.cannot.infer.arguments=無法推斷實參
diamond.error.cannot.infer.arguments.unable.to.resolve.function Object() { [native code] }=無法推斷實參(無法解析構造函數)
diamond.error.anonymous.inner.classes=無法將 '<>' 用於匿名內部類
diamond.error.anonymous.inner.classes.non.private=由於非 private 方法不會重寫或實現父類型中的方法，因而無法使用 '<>'
diamond.error.cannot.infer.type.arguments=無法推斷 {0} 的類型實參
error.incompatible.type.no.type.variable=變量類型的實例不存在，因此{0}
error.incompatible.type.no.type.variable.0=變量類型 {0} 的實例不存在，因此{1}
type.conforms.to.constraint={0} 符合 {1}
type.can.be.converted={0} 無法轉換為 {1}
conflicting.conjuncts={0} 和 {1}
error.type.parameter.has.incompatible.upper.bounds=類型參數 {0} 的上限不兼容: {1}
error.incompatible.upper.bounds=不兼容的上限: {0}
error.inference.variable.has.incompatible.bounds=推斷變量 {0} 的界限不兼容:\n {1}: {2}\n{3}: {4}
error.incompatible.type={0} 與 {1} 不兼容
error.incompatible.type.not.a.functional.interface={0} 不是函數接口
error.incompatible.type.no.valid.function.type.found=未找到 {0} 的有效函數類型
error.incompatible.type.parameter.type.is.not.yet.inferred=參數類型尚未推斷: {0}
error.incompatible.type.return.type.is.not.yet.inferred=返回類型尚未推斷: {0}
error.incompatible.type.unhandled.exception=未處理的異常: {0}
error.incompatible.type.failed.to.resolve.argument=無法解析實參
error.incompatible.type.incompatible.parameter.types.in.lambda=lambda 表達式中的參數類型不兼容
error.incompatible.type.incompatible.types.expected.void.lambda=不兼容的類型: 應為 void，但 lambda 體既不是語句表達式，也不是與 void 兼容的塊
error.incompatible.type.expected.value.lambda=不兼容的類型: 不應當為 void，但 lambda 體是與值不兼容的塊
error.incompatible.type.bad.lambda.return.type=lambda 表達式中存在錯誤返回類型: {0} 無法轉換為 {1}
error.incompatible.type.incompatible.parameter.types.in.method.reference=方法引用表達式中存在不兼容的參數類型
error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference=不兼容的類型: 不應當為 void，但方法引用的編譯時聲明具有 void 返回類型
error.incompatible.type.declaration.for.the.method.reference.not.found=未找到方法引用的編譯時聲明
error.incompatible.type.expected.non.void.got.void.method.reference=不兼容的類型: 不應當為 void，但方法引用的編譯時聲明具有 void 返回類型
error.incompatible.type.not.convertible=不兼容的類型: {0} 無法轉換為 {1}
error.incompatible.type.incompatible.equality.constraint=不兼容的相等約束: {0} 和 {1}
list.item.no.module=<無模塊>
# {0} = localized element kind ('class', 'field', 'method', etc.); {1} = element name  
element.kind.and.name={0} {1}

expected.case.label.element=應為表達式、模式、'default' 或 'null'
jdk.17.language.level.description=17 - sealed 類型、始終嚴格的浮點語義
jdk.17.preview.language.level.description=17 (預覽) - switch 的模式匹配
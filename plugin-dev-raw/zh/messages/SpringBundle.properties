model.property.error.message=無法解析屬性 ''{0}''
model.create.factory.method.quickfix.message=創建工廠方法 ''{0}''
model.create.factory.method.quickfix.family.name=創建工廠方法
model.add.constructor.args.for.method.quickfix.message=為 ''{0}'' 添加 <constructor-arg>
model.add.constructor.args.for.method.quickfix.message.family.name=添加 <constructor-arg>
model.method.signature.parse.error.message=無法解析簽名 ''{0}''
model.method.resolve.class.error.message=無法解析類 ''{0}''
model.bean.not.found.error.message=找不到名稱為 ''{0}'' 的 Bean
model.method.choose.method=選擇方法

model.bean.quickfix.message=創建新 Bean ''{0}''
model.bean.quickfix.message.family.name=創建新 Bean

model.inspection.display.name=Spring Core(Framework) 基於 XML 的應用程式上下文錯誤
model.inspection.display.bean.name.convention=非建議的 Spring Bean 名稱
model.inspection.bean.property.value=XML 應用程式上下文中不可分配的注入點類型
model.inspection.bean.constructor.arg=XML Spring Bean 中的構造函數注入不正確
model.inspection.bean.autowiring=XML Spring Bean 自動裝配不正確
model.inspection.validator.progress.text=正在驗證 Spring 模型…

model.goto.related.item.group.context=Spring 上下文:“{0}”
model.goto.related.item.group.application.context=Spring 套用程序上下文
model.goto.related.item.group.test.context=Spring 測試上下文


scopes.inspection.display.name=未知 <bean/> 範圍

inspection.group.code=程式碼
inspection.group.setup=設定
inspection.group.xml=XML

model.inspection.invalid.identifier.message=''{0}'' 未遵循 Bean 命名慣例
model.inspection.invalid.lowercase.name.message=''{0}'' 應以小寫字母開頭

model.inspection.bean.factory.method=在 "factory-method" 特性中引用的錯誤定義的方法
model.inspection.bean.public.factory.method=在 "factory-method" 特性中引用的不正確的非 public 方法
method.must.be.static=工廠方法 ''{0}'' 必須為 static
method.must.not.be.static=工廠方法 ''{0}'' 不得為 static
method.must.be.public=工廠方法 ''{0}'' 應為 public
method.cannot.instantiate.bean=工廠方法  ''{0}'' 無法實例化 Bean


bean.autowiring.by.type.none=無法自動裝配。找不到 ''{0}'' 類型的 Bean。
bean.autowiring.by.type.no.beans=無法自動裝配。找不到 ''{0}'' 或 ''{1}'' 類型的 Bean。
bean.autowiring.by.type=無法自動裝配。存在多個 ''{0}'' 類型的 Bean。Bean: {1}。屬性: ''{2}''
bean.class.autowired.by.type=無法自動裝配。存在多個 ''{0}'' 類型的 Bean。
bean.autowiring.by.type.no.parameter.for.autowired.method= 無參數的自動裝配 {0}
bean.class.autowired.incorrect.qualifier.type=無法自動裝配。限定 Bean 必須為 ''{0}'' 類型。
bean.class.unknown.qualifier.bean=找不到具有限定符 ''{0}'' 的 Bean

bean.bad.property.type=''{0}'' 類型的屬性不能由 ''{1}'' 注入
idref.cannot.be.added.in.collection=無法添加到 ''{0}'' 類型的集合中
timeout.parsing.bean=自訂 Bean 解析時間過長
process.unexpectedly.terminated=行程意外終止{0}
try.parsing.custom.beans=嘗試解析自訂 Bean
internal.error.parsing.bean=解析 Bean 時出現內部錯誤;輸出:\n\
{0}

cannot.find.bean.constructor.with.parameters.count=在類 ''{0}'' 中未找到符合的構造函數
cannot.find.factory.method.with.parameters.count=在類中未找到符合的工廠方法

cannot.find.constructor.arg.index=找不到實參索引為 {0} 的構造函數
cannot.find.constructor.arg.index.in.class=在類 {1} 中找不到實參索引為 {0} 的構造函數
cannot.find.factory.method.index=在類 {1} 中找不到參數索引為 {0} 的工廠方法

incorrect.constructor.arg.index.not.unique=索引必須唯一
constructor.arg.incorrect.value.type=注入值類型必須對應於構造函數實參類型

spring.bean=Spring Bean
spring=Spring

config.display.name=設定
config.no.contexts.defined=未定義應用程式上下文

spring.bean.class.tooltip.navigate.declaration=導航到 Spring Bean 宣告
navigate.to.autowired.dependencies=導航到自動裝配的依賴項
navigate.to.by.name.autowired.dependencies=導航到 'byName' 自動裝配的依賴項
autowired.dependencies.goto.related.item.group.name=自動裝配的依賴項

spring.bean.show.beans.candidates.title=Bean 候選項

gutter.navigate.no.matching.beans=未找到符合的 Bean
spring.bean.class.navigate.choose.class.title=選擇 Bean
spring.bean.property.tooltip.navigate.declaration=導航到 Spring Bean 屬性
spring.bean.property.navigate.choose.class.title=選擇包含屬性的 Bean
spring.bean.constructor.tooltip.navigate.declaration=導航到 Spring Bean
spring.bean.constructor.navigate.choose.class.title=選擇包含構造函數的 Bean
spring.bean.methods.tooltip.navigate.declaration=導航到 Spring Bean 方法宣告
spring.bean.method.tooltip.navigate.declaration=導航到 Spring Bean {0} 方法宣告
spring.bean.filter.tooltip=開始輸入以篩選元素

config.file.not.found=找不到檔案
config.files.not.found=未找到檔案
config.file.is.not.spring=該檔案未被識別為 Spring 設定
config.unmapped.configs.popup.title={0} 中未映射的 Spring 設定檔案
spring.bean.lookup.method.inspection=XML Bean 尋找方法設定不正確
spring.bean.lookup.method.incorrect.return.type=不正確的尋找方法返回類型
spring.bean.lookup.method.constructor.not.allowed=此處不允許使用構造函數
spring.bean.lookup.method.return.type.mismatch=Lookup 方法返回類型與 ''{0}'' Bean 類不符合
spring.bean.lookup.method.bean.has.no.class=''{0}'' Bean 沒有類
spring.bean.lookup.method.must.be.public.or.protected=方法必須為 public 或 protected
spring.bean.lookup.method.must.have.no.parameters=方法不得有參數
spring.bean.lookup.method.must.be.not.static=此處不允許使用 static 方法

model.inspection.injection.value.style=XML 應用程式上下文中非建議的注入值樣式
model.inspection.injection.value.style.message=使用了顯式 <value> 元素
model.inspection.injection.value.style.value.fix=將 <value> 元素取代為 "{0}" 特性
model.inspection.injection.value.style.value.fix.family.name=將 <value> 元素取代為特性
model.inspection.injection.value.style.ref.fix=將 <ref> 元素取代為 "{0}" 特性
model.inspection.injection.value.style.ref.fix.family.name=將 <ref> 元素取代為特性
model.inspection.injection.value.style.ref.message=使用了顯式 <ref> 元素

spring.bean.property=屬性
spring.bean.constructor.arg=構造函數實參
spring.bean.map.entry=映射條目

model.inspection.injection.value.consistency=XML 應用程式上下文中的注入值不一致錯誤
model.inspection.injection.value.message={0} 必須指定一個 ref 或 value
spring.bean.property.value.inconsistency.ref.or.value.sub.element.must.defined={0} 只能包含 "ref" 特性或 "value" 特性或子元素
spring.bean.property.value.inconsistency.more.one.sub.element ={0} 不得包含多個子元素
spring.bean.ref.attributes.inconsistency=<ref> 標記只能包含 "bean" 特性或 "local" 特性或 "parent" 特性
spring.bean.ref.attributes.must.specify=<ref> 標記必須指定 Bean
spring.bean.idref.attributes.inconsistency=<idref> 標記只能包含 "bean" 特性或 "local" 特性
spring.bean.idref.attributes.must.specify=<idref> 標記必須指定 Bean
model.inspection.injection.value.entry.key=映射條目必須指定鍵
spring.bean.property.value.inconsistency.key=映射條目只能包含 "key" 特性或 "key-ref" 特性或 <key> 子元素

model.inspection.injection.value.add.ref=添加 "ref" 特性
model.inspection.injection.value.add.list=添加 <list> 標記
model.inspection.injection.value.add.set=添加 <set> 標記
model.inspection.injection.value.add.array=添加 <array> 標記
model.inspection.injection.value.add.map=添加 <map> 標記


spring.bean.abstract.bean.references.inspection=對抽象 Bean 的引用不正確
spring.bean.referenced.by.abstract.bean=此處無法使用 abstract Bean

spring.bean.autowire.escape.inspection.name=在 XML 應用程式上下文中不必要地使用自動裝配的依賴項 
spring.bean.use.autowire=不必要使用自動裝配的依賴項
spring.bean.autowire.escape=將自動裝配的依賴項設為顯式

spring.bean.duplicated.bean.name.inspection=基於 XML 的應用程式上下文中的 Bean 名稱重複
spring.bean.duplicate.bean.name=Bean 名稱重複

spring.bean.instantiation.by.factory=Spring Bean (已由工廠 Bean 實例化)
spring.bean.instantiation.using.factory.method=Spring Bean (由 static 工廠方法實例化)
spring.generate.properties=屬性…
spring.generate.setter.dependencies=Setter 依賴項…
spring.generate.constructor.dependencies=構造函數依賴項…
action.Spring.Beans.Generate.Setter.Dependency.Action.text=Spring Setter 依賴項…
action.Spring.Beans.Generate.Constructor.Dependency.Action.text=Spring 構造函數依賴項…
spring.bean.properties.chooser.title=選擇屬性
spring.bean.dependencies.chooser.title=選擇 Bean
spring.beans.chooser.show.context.files=顯示上下文檔案
spring.beans.chooser.all.context.files=所有 Bean
spring.beans=Bean
util.schema.inspection.name=XML 應用程式上下文中定義的 'util' 架構 Bean 設定不正確
util.required.class.message=類必須為 ''{0}'' 的繼承者

spring.bean.instantiation.inspection=無效的非抽象 Bean 實例化
mark.bean.as.abstract=將 Bean 標記為 abstract
abstract.class.not.allowed=abstract 類不允許用於非 abstract Bean
interface.not.allowed=非抽象 Bean 不允許接口

spring.parent.bean.tooltip=導航到子宣告

spring.patterns=框架/技術
spring.patterns.hibernate=Hibernate
spring.patterns.jdo=JDO
spring.patterns.toplink=Toplink
spring.patterns.ibatis=iBatis
spring.patterns.quartz.scheduler=OpenSymphony 計劃程序
spring.patterns.jdk.timer=JDK 定時器

spring.patterns.aop.group.name=Aop
spring.patterns.data.access.group.name=資料存取
spring.patterns.integration.group.name=整合
spring.patterns.scheduling.group.name=計劃
spring.patterns.common.beans.group.name=通用 Bean
spring.patterns.data.access.hibernate.session.factory=Hibernate 會話工廠
spring.patterns.data.access.hibernate.transaction.manager=Hibernate 事務管理器

spring.patterns.data.access.jdo.persistence.manager=JDO 持久性管理器工廠
spring.patterns.data.access.jdo.jpox.persistence.manager=JPOX 持久性管理器工廠
spring.patterns.data.access.jdo.persistence.manager.proxy=JDO 持久性管理器代理
spring.patterns.data.access.jdo.transaction.manager=JDO 事務管理器

spring.patterns.data.access.toplink.session.factory=Toplink 會話工廠
spring.patterns.data.access.toplink.transaction.aware.session.adapter=Toplink 事務感知會話適配器
spring.patterns.data.access.toplink.transaction.manager=Toplink 事務管理器
spring.patterns.data.access.ibatis.client.factory=iBatis SqlMapClient 工廠

spring.patterns.data.access.data.source=資料來源
spring.patterns.data.access.jndi.data.source=Jndi 資料來源
spring.patterns.data.access.transaction.manager=事務管理器

spring.patterns.aop.auto.proxy.creator=AspectJ 自動代理創建程序
spring.patterns.aop.auto.proxy=Aop: AspectJ 自動代理

spring.patterns.integration.opensymphony.job.detail.bean=OpenSymphony 作業詳細資訊 Bean
spring.patterns.integration.opensymphony.method.invoking.factory.bean=OpenSymphony 方法調用工廠
spring.patterns.integration.opensymphony.simple.trigger=OpenSymphony 簡單觸發器
spring.patterns.integration.opensymphony.cron.trigger=OpenSymphony Cron 觸發器
spring.patterns.integration.opensymphony.scheduler=OpenSymphony 計劃程序工廠 Bean

spring.patterns.integration.jdk.scheduled.timer.task=JDK 計劃的定時器任務
spring.patterns.integration.jdk.timer.factory.bean=JDK 定時器工廠 Bean
spring.patterns.integration.jdk.method.invoking.factory.bean=JDK 方法調用定時器任務工廠

spring.patterns.integration.ejb.local.stateless.session.bean=EJB 本地無狀態會話 Bean
spring.patterns.integration.ejb.remote.stateless.session.bean=EJB 遠端無狀態會話 Bean
spring.patterns.integration.free.marker.factory.bean=Free Marker 設定工廠 Bean

spring.patterns.common.beans.placeholder=屬性佔位符設定器
spring.patterns.common.beans.property.override.configurer=屬性覆寫設定器
spring.patterns.factory.beans.resource=資源工廠 Bean
spring.patterns.factory.beans.commons.log=通用日誌工廠 Bean
spring.patterns.factory.beans.set=設定工廠 Bean
spring.patterns.factory.beans.list=列出工廠 Bean
spring.patterns.factory.beans.map=映射工廠 Bean
spring.patterns.factory.beans.properties=屬性工廠 Bean
spring.patterns.factory.beans.field.retrieving=欄位檢索工廠 Bean

spring.choose.bean.templates.dialog.title=添加 {0} Bean
spring.choose.bean.templates.dialog.beans=Bean

facet.context.default.name=Spring 套用程序上下文

facet.context.xml.files=基於 XML 的設定
facet.context.code.files=基於程式碼的設定
facet.context.properties.files=附加屬性檔案
facet.context.other.files=其他檔案
facet.context.autodetected.suffix= (自動檢測)
facet.context.autoconfigured.suffix= (自動設定)

facet.context.new.title=新建應用程式上下文
facet.context.edit.title=編輯套用程序上下文 ''{0}''
facet.context.edit.name.label=名稱(&N):
facet.context.edit.parent.label=父上下文(&P):
facet.context.edit.parent.none.selected=<none>
facet.context.edit.name.validation.not.empty=名稱不得為空
facet.context.edit.name.validation.already.exists=具有此名稱的上下文已存在。如果已刪除具有此名稱的現有上下文，則必須首先使用“套用”。
facet.context.edit.add.file.choose.type=選擇類型

facet.context.remove.title=移除
facet.context.remove.message=確實要移除應用程式上下文 "{0}" 嗎? (不會刪除任何檔案)

config.new.file=Spring 設定
create.new.spring.configuration.file=創建新的 Spring 設定檔案



framework.title.spring=Spring(&S)

spring.facet.inspection=Spring 構面的 XML 應用程式上下文設定不足
spring.facet.code.inspection=Spring 構面中的 @Configuration 類設定不足
spring.facet.programmatic.inspection=Spring facet 編程設定

spring.facet.inspection.create.facet=創建 Spring facet
spring.facet.inspection.context.choose=選擇應用程式上下文
spring.facet.inspection.context.create=創建新的應用程式上下文…
spring.facet.inspection.context.not.configured.for.file=沒有為此檔案設定應用程式上下文
spring.facet.inspection.configure.context.for.file=設定應用程式上下文
spring.facet.inspection.check.test.files=檢查測試檔案

introduce.bean.intention=引入 Bean

parse.custom.bean.intention=解析自訂 Bean
parsing.custom.bean=正在執行自訂 Spring Bean 處理程序…
parse.custom.bean.error=解析自訂 Bean 時出錯
parse.custom.bean.success=自訂處理程序已成功完成
parse.no.custom.beans=解析器未生成 Bean
parse.only.infrastructure.beans=解析器僅生成架構 Bean
parse.these.beans=自訂命名空間處理程序已生成以下 Bean 定義:\n\
{0}
parse.these.beans.induct=自訂命名空間處理程序生成以下 Bean 定義:\n\
{0}\n\
\n\
要假設名稱空間 ''{1}'' 中 \n\
本地名稱為 ''{2}'' 的所有 Bean 具有\n\
相同的類並且從 ''{3}'' 特性獲得 ID 嗎?
parse.these.beans.induct.only.this=此 Bean
parse.these.beans.induct.all.beans=所有 Bean
parse.no.namespace.handler=找不到命名空間 ''{0}'' 的自訂處理程序
unparsed.custom.bean.inspection=未解析的自訂 Spring Bean
unparsed.custom.bean.message=此自定義 Spring Bean 尚未解析
custom.bean.no.id=IntelliJ IDEA 在設定檔案中找不到此 Bean 的 ID。重命名可能會生成錯誤的程式碼。要繼續嗎?
custom.bean.no.id.title=警告

do.you.want.to.move.bean.to.the.top.level=要將該 Bean 移動到頂層嗎?
move.bean.to.the.top.level=將 Bean 移動到頂層
move.bean=移動 Bean
update.schema.intention=轉換為 Spring XML 架構
use.p.namespace=轉換為 p-namespace
xml.schema.will.be.updated=XML 架構將更新為 spring-beans.xsd。\n\
要繼續嗎?
xml.schema.update.is.required=需要更新 XML 架構

model.qualifiers.in.class.inspection.display.name=Spring Bean 組件中的注入點自動裝配問題
java.class.constructor.autowiring.inspection.display.name=Spring Bean 類構造函數中的自動裝配問題
required.properties.inspection=未注入 Spring Bean @Required 屬性
required.property.not.mapped=未注入必需屬性 ''{0}''
create.missing.mappings=為 ''{0}'' 創建缺少的映射
create.missing.mappings.family.name=創建缺少的映射

spring.required.property.inspection=Spring Xml Bean 宣告中缺少 @Required 屬性注入
required.properties.missed=缺少必需屬性: ''{0}''
create.missing.properties=創建缺少的屬性
cannot.find.bean.qualified.by=找不到使用 {0} 限定的 Bean
cannot.autowire.bean.of.type=無法自動裝配。Bean 必須為 ''{0}'' 類型
required.spring.bean.type.inspection=不正確的注入 Bean 類型
placeholders.inspection.display.name=Spring XML 應用程式上下文中設定的佔位符未解析
bean.property.extract.name=將屬性值提取到設定檔案

spring.incorrect.resource.type.inspection=不正確的資源類型
SpringIncorrectResourceTypeInspection.incorrect.resource.type=不正確的資源類型
SpringIncorrectResourceTypeInspection.expected.resource.types=資源類型不正確。預期類型: {0}
spring.import.resource.inspection.display.name=@ImportResource 位置中的檔案引用未解析
spring.property.source.inspection.display.name=@PropertySource 和 @TestPropertySource 位置的檔案警告未解析
spring.configuration.proxy.methods.display.name=@Configuration proxyMethods 用法警告
spring.context.configuration.inspection.display.name=@ContextConfiguration 設定無效
spring.testing.sql.inspection.display.name=無效的 @Sql 和 @SqlGroup 設定
spring.transaction.inspection.display.name=@Transactional 組件中無效的 'PlatformTransactionManager' 宣告
spring.lookup.inspection.display.name=Spring 組件的 @Lookup 註解中錯誤引用了 Bean
SpringContextConfigurationInspection.cannot.find.default.app.context=找不到預設應用程式上下文檔案 {0}
SpringContextConfigurationInspection.create.nested.configuration.class=創建嵌套 ContextConfiguration 類
action.generate.autowired.dependencies.action.text=@Autowired 依賴項…
SpringAutowiringInspection.add.qualifier.fix=添加限定符
context.schema.inspection.name=基於 XML 的組件掃描中的篩選器定義無效
ContextComponentScanInconsistencyInspection.annotation.is.expected.here=此處應為註解
spring.import.resource.error.message.trailing.space=''{0}'' 中的尾隨空格

spring.profile.expression.inspection=@Profile 表達式設定不正確
spring.profile.expression.empty=設定檔案表達式必須包含文本
spring.profile.expression.malformed=格式不正確的設定檔案表達式
spring.profile.unresolved.message=未知設定檔案

editor.panel.profiles.tooltip=有效設定檔案
editor.panel.profiles.tooltip.action.name=更改設定檔案…

SpringInactiveProfilesHighlightingPass.inactive.profile=停用設定檔案
spring.dom.component.scan.stereotypes=選擇構造型
spring.dom.component.scan.stereotypes.title=導航到組件
ContextJavaBeanUnresolvedMethodsInspection.display.name=@Bean 註解中的 init/destroy 方法未知 
ContextJavaBeanUnresolvedMethodsInspection.cannot.resolve.method=無法解析方法

ActivateSpringProfileIntentionAction.activate.profile=啟用設定檔案 ''{0}''
ActivateSpringProfileIntentionAction.activate.profile.family.name=啟用設定檔案
ActivateSpringProfileIntentionAction.deactivate.profile=停用設定檔案 ''{0}''
ActivateSpringProfileIntentionAction.deactivate.profile.family.name=停用設定檔案

spring.app.context.to.navigate=選擇應用程式上下文
spring.app.context.navigate.tooltip=導航到套用程序上下文

SpringStaticMembersAutowiringInspection.display.name=對 static 類成員的 Spring 組件自動裝配/注入不正確 
static.members.autowiring=不自動裝配 static 成員

gutter.choose.autowired.candidates.title=選擇自動裝配的候選項
gutter.navigate.to.autowired.candidates.title=導航到自動裝配的候選項
gutter.navigate.no.matching.autowired.candidates=未找到符合的自動裝配候選項
process.explicitly.annotated.beans=處理顯式註解的 Bean
configuration.tab.additional.settings=附加設定

gutter.choose.bean.factory.calls.title=選擇 BeanFactory.getBean(...) 用法
gutter.navigate.no.bean.factory.calls=未找到符合的 BeanFactory 用法
gutter.navigate.to.bean.factory.calls.title=導航到 BeanFactory.getBean(...) 用法

multiple.context.tooltip.text=有效上下文
multiple.context.description.in.module.text=<html><body> 在模組 <b>{0}</b> 中。</body></html>
multiple.context.description.label.text=<html><body>檔案包含在 <b>{0} 個上下文</b>中。</body></html>
multiple.context.description.in.modules.label.text=<html><body>檔案包含在 <b>{1}</b> 個模組的 <b>{0} 個上下文</b>中。</body></html>
class.without.matching.constructor.for.autowiring=類不包含用於自動裝配的符合構造函數
multiple.autowiring.constructor=只有一個構造函數可以具有 @Autowired 註解
springAutowiredMembersInspection.inspection=非 Spring 組件中定義的 @Autowired 成員不正確
class.is.not.spring.bean.autowired=必須在有效 Spring Bean 中定義自動裝配成員(@Component|@Service|…)

model.inspection.inactive.profile=停用設定檔案高亮顯示
spring.bean.attributes.inspection.key=Spring Bean 特性衝突 
component.scan.setup.inspection.key=@ComponentScan 或 'component scan meta' 註解中的包無效
custom.namespace.registration.inspection.key=spring.handlers/spring.schemas 檔案中的檔案/類引用未解析


spring.event.publisher.choose.title=選擇事件發佈器
spring.event.publisher.tooltip.text=轉到事件發佈器
spring.event.publisher.empty.tooltip.text=未找到事件發佈器

spring.event.listener.choose.title=選擇事件偵聽器
spring.event.listener.tooltip.text=轉到事件偵聽器
spring.event.listener.empty.tooltip.text=未找到事件偵聽器
spring.cacheable.annotations.inspection.display.name='caching' 註解設定不正確: @Cacheable、@CacheEvict、@CachePut、@CacheConfig
spring.cacheable.names.inspection.display.name=必需的快取名稱定義錯誤
spring.cacheable.and.cache.put.on.the.same.method.display.name=對同一方法不正確地使用 @CachePut 和 @Cacheable

spring.cacheable.annotations.on.interfaces=在接口/接口方法上定義的 Cache* 註解
cacheable.annotations.should.be.defined.on.public.methods=應在 public 方法上定義快取註解
cacheable.no.cache.could.be.resolved.for.cache.operation=應為每個快取操作至少提供一個非空快取名稱。
cacheable.should.be.defined.on.concrete.method=Spring 不建議使用 @Cache* 註解對接口方法進行註解
cacheable.and.cache.put.on.the.same.method=Spring 不建議在同一方法上使用 @CachePut 和 @Cacheable 註解
event.listener.method.parameters.count=方法必須最多只有一個參數
event.listener.method.visibility.public=使用 @EventListener 註解的方法必須為 public
event.listener.method.visibility.nonstatic=使用 @EventListener 註釋的方法必須為非 static

spring.cacheable.element.choose.title=選擇可快取操作
spring.cacheable.element.tooltip.text=轉到同名的可快取操作

SpringAutowiredFieldsWarningInspection.inspection.display.name=非建議的 'field' 注入
field.injection.is.not.recommended=不建議使用欄位注入
field.injection.create.constructor.family.warning=更改欄位注入。創建構造函數
field.injection.add.parameter.family.warning=更改欄位注入。向構造函數添加參數
field.injection.create.constructor.injection=<html>創建構造函數: {0}</html>
field.injection.add.parameters=<html>向構造函數添加參數: {0}</html>
spring.testing.context.dirties.inspection.display.name=@DirtiesContext 'mode' 設定無效
spring.testing.transactional.inspection.display.name=事務生命周期方法宣告無效
spring.testing.model.dirties.method.mode.error.message=在註解的測試類上設定方法模式沒有意義。對於類級別控制，請改用 classMode。
spring.testing.model.dirties.class.mode.error.message=在註解的測試方法上設定類模式沒有意義。 對於方法級別控制，請改用 methodMode。
spring.testing.model.dirties.hierarchy.mode.error.message=當通過 @ContextHierarchy 將上下文設定為層次結構的一部分時，應使用 hierarchyMode
spring.testing.transactional.wrong.number.of.arguments.error.message=參數數量錯誤
spring.testing.transactional.void.method.return.type.error.message=方法返回類型應為 'void'
ScheduledMethodInspection.inspection.display.name=不正確的 @Scheduled 方法簽名
ScheduledMethodInspection.incorrect.signature=使用 @Scheduled 註解的方法應為 void 和無實參
method.parameters.removing.fix.family.name=移除方法參數
method.parameters.removing.fix.text=將 ''{0}'' 更改為無實參
AsyncMethodInspection.inspection.display.name=不正確的 @Async 方法簽名
AsyncMethodInspection.incorrect.signature=使用 @Async 註解的方法應返回 'void' 或 "Future-like" 類型
SpringEventListenerInspection.inspection.display.name=錯誤設定的 @EventListener 方法
# suppress inspection "UnusedProperty"
method.return.type.make.async.family.name=更改方法以返回 "Future-like" 值
method.return.type.make.async.fix.text=更改方法以返回 ''{0}''
ImplicitSubclassInspection.display.forClass.annotated=使用 ''@{0}'' 註解的類可以隱式子類化且不得為 final
ImplicitSubclassInspection.display.forMethod.annotated=使用 ''@{0}'' 註解的方法必須可覆寫
ImplicitSubclassInspection.display.bean.in.configuration=@Configuration 中的 @Bean 方法必須可覆寫
navigate.to.fileset.configuration=導航到套用程序上下文設定

bean.method.called.from.configuration.without.proxy=使用 @Bean 註解的方法直接在 proxyBeanMethods 設定為 false 的 @Configuration 中調用。將 proxyBeanMethods 設定為 true 或使用依賴項注入。
bean.method.called.without.proxy=直接調用使用 @Bean 註解的方法。請改用依賴項注入。

action.DumpSpringConfiguration.text=轉儲 Spring  設定
group.Internal.Spring.text=Spring
action.SpringChangeActiveProfiles.text=更改有效 Spring 設定檔案…
action.Spring.Create.Context.File.text=Spring 設定
action.Add.JdkTimer.text=添加 JDK 定時器
action.Add.OpenSymphonyTimer.text=添加 OpenSymphony 計劃程序
action.Add.Ibatis.Framework.text=添加 iBatis 框架
action.Add.Toplink.Framework.text=添加 Toplink 框架
action.Add.Jdo.Framework.text=添加 JDO 框架
action.Add.Hibernate.Framework.text=添加 Hibernate 框架
group.Spring.Patterns.ActionGroup.text=模式
action.Spring.Beans.Generate.Action.text=Spring Bean

action.JpaPatternAction.text=JPA 模式

spring.settings.common=通用
spring.settings.auto.configure=允許自動設定應用程式上下文
spring.settings.configuration.file.editor=設定檔案編輯器
spring.settings.profiles.panel=顯示設定檔案面板(&P)
spring.settings.profiles.panel.tooltip=允許選擇有效設定檔案
spring.settings.multiple.context.panel=顯示多個上下文面板(&M)
spring.settings.multiple.context.panel.tooltip=如果在多個上下文中使用檔案，則允許選擇有效上下文


framework.support.provider.create.empty.spring.config=創建空 {0}
fileset.editor.help.label=<html>通過 <b>\\&lt;import …/\\&gt;</b> 或 <b>@Import</b> 引用的設定檔案將隱式添加。<br/>用於測試的設定檔案<em>不得</em>添加到上下文。</html>
fileset.circular.dependencies=上下文之間的迴圈依賴關係:<br/>{0}<br/>{1}
fileset.contains.testing.configs.short=用於測試的 {0, choice, 1#設定檔案|1<{0, number} 設定檔案}<em>不得</em>添加到上下文
fileset.contains.testing.configs.full=用於測試的 {0, choice, 1#設定檔案|1<{0, number} 設定檔案}<em>不得</em>添加到上下文:<br/>{1}
spring.facet.validation.help.action=顯示幫助
spring.facet.validation.disable.action=禁用…
spring.facet.detection.will.be.disabled.for.whole.project=將為整個專案禁用檢測。\n\
請注意，如果不執行 Spring facet 設定，將無法使用大多數 Spring 相關功能。\n\
\n\
“專案結構 | Facet | 檢測”\n\
可用於僅排除以及重新啟用特定檔案/資料夾。
spring.facet.config.detection=Spring 設定檢測
spring.facet/detection.disable.detection=禁用檢測
spring.configuration.check=Spring 設定檢查
unmapped.configuration.fix.instruction=請設定 Spring facet 或使用 ''{0}'' 添加一個包括所有未映射檔案的 facet。
unmapped.configuration.configure.facet=請設定 Spring facet。
unmapped.configuration.create.default.context=創建預設上下文
unmapped.configuration.files.count={0, choice, 1#1 檔案|1<{0, number} 檔案}
unmapped.configuration.files.found=找到未映射的 Spring 設定檔案。
unmapped.configuration.programmatic.contexts.found=找到編程上下文:
unmapped.configuration.files.short={0, choice, 1#未映射的 Spring 設定檔案|1<{0, number} 未映射的 Spring 設定檔案}
unmapped.configuration.files.full={0, choice, 1#未映射的 Spring 設定檔案|1<{0, number} 未映射的 Spring 設定檔案}:<br/>{1}
unmapped.configuration.is.not.available.during.index.update= 索引更新期間 ''{0}'' 不可用
unmapped.configuration.open.facet.configuration=開啟 Facet 設定
unmapped.configuration.spring.configuration=Spring 設定
unmapped.configuration.autodetected.context.found.for=已找到 {0} 的自動檢測上下文。\n\
請檢查並設定其他手動上下文(如果需要)。
scanning.for.programmatic.contexts=正在掃描編程上下文…
checking.spring.configuration=檢查模組 ''{0}'' 中的 Spring 設定
searching.for.stereotype.usages=正在搜尋構造型用法…
searching.for.implicit.usages=正在搜尋隱式用法…

spring.core.autowired.annotator.name=自動裝配
spring.core.bean.annotator.name=Bean
spring.core.component.scan.annotator.name=組件掃描
spring.core.dom.annotator.name=設定(XML)
spring.core.properties.annotator.name=屬性
spring.core.test.configuration.annotator.name=測試設定
spring.core.cacheable.annotator.name=同名的可快取操作
spring.core.event.listener.annotator.name=套用程序事件

spring.model.actions.dump.model.gathering.spring.models=正在收集 Spring 模型…
spring.model.actions.dump.model.scanning.spring.models=正在掃描 Spring 模型…
spring.model.actions.dump.model.generating.json=正在生成 JSON…
spring.model.actions.generate.beans=創建 Spring Bean
custom.namespace.quick.fixes.family.name=創建自訂命名空間 Bean
custom.namespace.quick.fixes.create.custom.namespace.bean=創建自訂命名空間 Bean ({0} 個變體)…
custom.namespace.quick.fixes.create.custom.namespace.bean.with.id=創建自訂命名空間 Bean {0}
custom.namespace.quick.fixes.create.name=創建 {0}
custom.namespace.quick.fixes.popup.title=創建自訂命名空間 Bean

use.existing.quick.fixes.use.existing.bean.family.name=使用現有 Bean
use.existing.quick.fixes.use.existing.bean.from.context=使用上下文 ''{0}'' 中的現有 Bean…
use.existing.quick.fixes.choose.fix.for=為 ''{0}'' 選擇修正
use.existing.quick.fixes.add.dependency.to.context=將依賴關係添加到上下文 ''{0}''
use.existing.quick.fixes.add.spring.xml.to.fileset.action=將 ''{0}'' 添加到上下文 ''{1}''
use.existing.quick.fixes.add.import.action=為 ''{0}'' 添加 <import>
use.existing.quick.fixes.open.spring.facet.settings=開啟 Spring facet 設定…

setup.programmatic.context.quick.fix.setup.spring.context=設定 Spring 上下文…
setup.programmatic.context.quick.fix.settings.displayName=Spring
setup.programmatic.context.quick.fix.context.with.name=已創建 ''{0}'' 上下文。\n\
禁止此檢查以禁用高亮顯示。\n\
\n\
要重新創建上下文，請在 Spring facet 中將其刪除並禁用禁止檢查。\n\
\n\
要開啟 Spring facet 嗎?
spring.facet.programmatic.inspection.spring.context=編程 Spring 上下文
duplicated.bean.name.inspection.name.view.duplicates=查看重複項
duplicated.bean.quick.fix.popup.title=查看重複項
UnparsedCustomBeanInspection.unsupported.tag=命名空間 ''{1}'' 不支持標記 ''{0}''，請提交問題(幫助|{2})
change.active.profile.dialog.spring.profiles=更改有效 Spring 設定檔案
change.active.profile.dialog.module=模組 ''{0}''
change.active.profile.dialog.context=上下文 ''{0}''
SpringUpdateSchemaIntention.spring.schema.update=Spring 架構更新
SpringUpdateSchemaIntention.schema.update.failed.for.invalid.file=針對無效檔案 {0} 的架構更新失敗
reference.injector.spring.resource.path=Spring 資源路徑
reference.injector.spring.bean.name=Spring Bean 名稱
reference.injector.spring.placeholder=Spring 佔位符
SpringSpiRegistrationAnnotator.choose.registration=選擇註冊
SpringSpiRegistrationAnnotator.tooltip=導航到 spring.factories 中的註冊
SpringSpiRegistrationAnnotator.spring.factories.registration=spring.factories 註冊
SpringBeansView.show.implicit.beans=顯示隱式 Bean
SpringBeansView.show.infrastructure.beans=顯示架構 Bean
SpringBeansView.show.modules=顯示模組
SpringBeansView.show.application.contexts=顯示應用程式上下文
SpringBeansView.config.no.contexts.defined=未定義應用程式上下文

application.context.configuration=應用程式上下文設定
ChangeActiveProfileDialogUi.radio.button.project=專案
ChangeActiveProfileDialogUi.radio.button.module=模組
ChangeActiveProfileDialogUi.radio.button.context=上下文
ChangeActiveProfileDialogUi.radio.button.comment=逗號分隔的設定檔案列表
ChangeActiveProfileDialogUi.radio.button.profiles=設定檔案:
ChangeActiveProfileDialogUi.radio.button.scope=範圍:

SpringBeanMoveHandler.no.other.files.found=未找到其他 Spring 檔案
SpringBeanMoveHandler.choose.file=選擇檔案

message.navigation.available.during.indexing=索引編制期間導航不可用
dependency.node.in.module.tail=(在模組 {0} 中)

spring.el.inspection.key=Spring Expression Language (SpEl) 錯誤 
spring.el.static.field.inpsection.key=在 static 欄位中不正確地注入 Spring EL
spring.bean.already.exists={1} 中已存在名為 ''{0}'' 的 Spring Bean

spring.bean.pointer.invalid=<無效>
spring.bean.pointer.unknown=<未知>

spring.beans.tab.title=Bean
spring.beans.select.in.target=Spring Bean
spring.intention.category=Spring
spring.factories.file.type=Spring 工廠
spring.aliases=別名
spring.profile=分析
spring.scope=範圍
spring.depends.on.inspection.display.name=@DependsOn 註解中不正確引用的 Bean
config.detecting.contexts=正在檢測應用程式上下文…
spring.scheduled.tasks=計劃的任務
spring.scheduled.method=計劃的方法
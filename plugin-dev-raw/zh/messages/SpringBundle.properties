ActivateSpringProfileIntentionAction.activate.profile=啟用組態檔案 ''{0}''
ActivateSpringProfileIntentionAction.activate.profile.family.name=啟用組態檔案
ActivateSpringProfileIntentionAction.deactivate.profile=停用組態檔案 ''{0}''
ActivateSpringProfileIntentionAction.deactivate.profile.family.name=停用組態檔案
AsyncMethodInspection.incorrect.signature=使用 @Async 註解的方法應返回 'void' 或 "Future-like" 類型
AsyncMethodInspection.inspection.display.name=不正確的 @Async 方法簽名
AutowireBeanGenerateAction.popup.beans.title=自動裝配 Bean
AutowireBeanGenerateAction.search.beans.progress.title=正在搜尋 Bean…
ChangeActiveProfileDialogUi.radio.button.comment=逗號分隔的組態檔案列表
ChangeActiveProfileDialogUi.radio.button.context=上下文
ChangeActiveProfileDialogUi.radio.button.module=模組
ChangeActiveProfileDialogUi.radio.button.profiles=組態檔案\:
ChangeActiveProfileDialogUi.radio.button.project=專案
ChangeActiveProfileDialogUi.radio.button.scope=作用域\:
ContextComponentScanInconsistencyInspection.annotation.is.expected.here=此處應為註解
ContextJavaBeanUnresolvedMethodsInspection.cannot.resolve.method=無法解析方法
ContextJavaBeanUnresolvedMethodsInspection.display.name=@Bean 註解中未知的 init/destroy 方法
GenerateEventListenerMethodAction.command.title=生成事件偵聽器方法
GenerateEventListenerMethodAction.popup.context.events=上下文
GenerateEventListenerMethodAction.popup.lifecycle.events=生存期
GenerateEventListenerMethodAction.popup.other.events=其他
GenerateEventListenerMethodAction.popup.project.events=專案
GenerateEventListenerMethodAction.popup.title=選擇事件
GenerateEventListenerMethodAction.search.events.progress.title=正在搜尋事件…
ImplicitSubclassInspection.display.bean.in.configuration=@Configuration 中的 @Bean 方法必須可覆寫
ImplicitSubclassInspection.display.forClass.annotated=使用 ''@{0}'' 註解的類別可以隱式子類別化且不得為 final
ImplicitSubclassInspection.display.forMethod.annotated=使用 ''@{0}'' 註解的方法必須可覆寫
ScheduledMethodInspection.incorrect.signature=@Scheduled 方法不得包含任何實參，也不應返回任何內容
ScheduledMethodInspection.inspection.display.name=不正確的 @Scheduled 方法簽名
SpringAutowiredFieldsWarningInspection.inspection.display.name=不推薦的欄位注入
SpringAutowiringInspection.add.qualifier.fix=新增限定符
SpringBeanMoveHandler.choose.file=選擇檔案
SpringBeanMoveHandler.no.other.files.found=未找到其他 Spring 檔案
SpringContextConfigurationInspection.cannot.find.default.app.context=找不到預設應用程式上下文檔案 {0}
SpringContextConfigurationInspection.create.nested.configuration.class=建立嵌套 'ContextConfiguration' 類別
SpringEventListenerInspection.inspection.display.name=錯誤組態的 @EventListener 方法
SpringInactiveProfilesHighlightingPass.inactive.profile=停用組態檔案
SpringIncorrectResourceTypeInspection.expected.resource.types=資源類型不正確。預期類型\: {0}
SpringIncorrectResourceTypeInspection.incorrect.resource.type=不正確的資源類型
SpringSpiRegistrationAnnotator.choose.registration=選擇註冊
SpringSpiRegistrationAnnotator.spring.factories.registration=spring.factories 註冊
SpringSpiRegistrationAnnotator.tooltip=導覽到 'spring.factories' 中的註冊
SpringStaticMembersAutowiringInspection.display.name=對 static 類別成員不正確的 Spring 組件自動裝配或注入
SpringUpdateSchemaIntention.schema.update.failed.for.invalid.file=針對無效檔案 {0} 的架構更新失敗
SpringUpdateSchemaIntention.spring.schema.update=Spring 架構更新
UnparsedCustomBeanInspection.unsupported.tag=命名空間 ''{1}'' 不支持標記 ''{0}''，請提交問題(幫助|{2})
abstract.class.not.allowed=抽象類別不允許用於非 abstract Bean
action.DumpSpringConfiguration.text=傾印 Spring  組態
action.Spring.Beans.Generate.Autowiring.Action.text=自動裝配 Bean…
action.Spring.Beans.Generate.Autowiring.Filter.Separator.text=篩選
action.Spring.Beans.Generate.Autowiring.SearchInLibraries.Action.text=顯示庫中的內容
action.Spring.Beans.Generate.Autowiring.ShowBeanImplAction.Action.text=顯示 Bean 實作類別
action.Spring.Beans.Generate.Autowiring.ShowPackagesAction.Action.text=顯示軟體套件
action.Spring.Beans.Generate.Autowiring.ShowProjectBeans.Action.text=顯示專案 Bean
action.Spring.Beans.Generate.Autowiring.ShowRepositoryBeans.Action.text=顯示儲存庫
action.Spring.Beans.Generate.Autowiring.ShowServices.Action.text=顯示服務
action.Spring.Beans.Generate.Autowiring.UseGroupsAction.Action.text=使用組
action.Spring.Beans.Generate.Autowiring.View.Separator.text=檢視
action.Spring.Beans.Generate.Autowiring.ViewSuperClassesAction.Action.text=按基類別分組
action.Spring.Beans.Generate.Constructor.Dependency.Action.text=Spring 建構函式相依項…
action.Spring.Beans.Generate.Setter.Dependency.Action.text=Spring Setter 相依項…
action.Spring.Beans.View.Configuration.Implicit.text=顯示隱式 Bean
action.Spring.Beans.View.Configuration.Infrastructure.text=顯示 XML 架構 Bean
action.Spring.Create.Component.Generate.description=建立一個新的 Spring 組件
action.Spring.Create.Component.Generate.text=Spring 組件…
action.Spring.Create.Component.Java.description=建立一個新的 Java Spring 組件
action.Spring.Create.Component.Java.text=Spring 組件 (Java)
action.Spring.Create.Component.Kotlin.description=建立一個新的 Kotlin Spring 組件
action.Spring.Create.Component.Kotlin.text=Spring 組件 (Kotlin)
action.Spring.Create.Component.dialog.title=新增 Spring 組件
action.Spring.Create.Context.File.text=Spring 組態
action.Spring.Events.Generate.Listener.text=事件偵聽器…
action.SpringChangeActiveProfiles.text=更改有效 Spring 組態檔案…
action.SpringConfigurationCheckAction.text=檢查 Spring 組態
action.generate.autowired.dependencies.action.text=@Autowired 相依項…
application.context.configuration=應用程式上下文組態
autowired.dependencies.goto.related.item.group.name=自動裝配的相依項
bean.autowiring.by.type=無法自動裝配。存在多個 ''{0}'' 類型的 Bean。Bean\: {1}。屬性\: ''{2}''
bean.autowiring.by.type.no.beans=無法自動裝配。找不到 ''{0}'' 或 ''{1}'' 類型的 Bean。
bean.autowiring.by.type.no.parameter.for.autowired.method=無形參的自動裝配 {0}
bean.autowiring.by.type.none=無法自動裝配。找不到 ''{0}'' 類型的 Bean。
bean.bad.property.type=''{0}'' 類型的屬性不能由 ''{1}'' 注入
bean.class.autowired.by.type=無法自動裝配。存在多個 ''{0}'' 類型的 Bean。
bean.class.autowired.incorrect.qualifier.type=無法自動裝配。限定 Bean 必須為 ''{0}'' 類型。
bean.class.unknown.qualifier.bean=找不到具有限定符 ''{0}'' 的 Bean
bean.method.called.from.configuration.without.proxy=使用 @Bean 註解的方法直接在 proxyBeanMethods 設定為 false 的 @Configuration 中呼叫。將 proxyBeanMethods 設定為 true 或使用相依項注入。
bean.method.called.without.proxy=直接呼叫使用 @Bean 註解的方法。請改用相依項注入。
bean.property.extract.name=將屬性值提取到組態檔案
cacheable.and.cache.put.on.the.same.method=Spring 不建議在同一方法上使用 @CachePut 和 @Cacheable 註解
cacheable.annotations.should.be.defined.on.public.methods=應在 public 方法上定義快取註解
cacheable.no.cache.could.be.resolved.for.cache.operation=必須為每個快取動作至少提供一個非空快取名稱。
cacheable.should.be.defined.on.concrete.method=Spring 不建議使用 @Cache* 註解對接口方法進行註解
cannot.autowire.bean.of.type=無法自動裝配。Bean 必須為 ''{0}'' 類型
cannot.find.bean.constructor.with.parameters.count=在類別 ''{0}'' 中未找到符合的建構函式
cannot.find.bean.qualified.by=找不到使用 {0} 限定的 Bean
cannot.find.constructor.arg.index=找不到實參索引為 {0} 的建構函式
cannot.find.constructor.arg.index.in.class=在類別 {1} 中找不到實參索引為 {0} 的建構函式
cannot.find.factory.method.index=在類別 {1} 中找不到實參索引為 {0} 的工廠方法
cannot.find.factory.method.with.parameters.count=在類別中未找到符合的工廠方法
change.active.profile.dialog.context=上下文 ''{0}''
change.active.profile.dialog.module=模組 ''{0}''
change.active.profile.dialog.spring.profiles=更改有效 Spring 組態檔案
checkbox.remember.my.choice=記住我的選擇
checking.spring.configuration=檢查模組 ''{0}'' 中的 Spring 組態
class.is.not.spring.bean.autowired=必須在有效 Spring Bean 中定義自動裝配成員(@Component|@Service|…)
class.without.matching.constructor.for.autowiring=類別不包含用於自動裝配的符合建構函式
component.scan.setup.inspection.key=@ComponentScan 或其元註解中無效的軟體套件
config.detecting.contexts=正在檢測應用程式上下文…
config.display.name=組態
config.file.is.not.spring=該檔案未被識別為 Spring 組態
config.file.not.found=找不到檔案
config.files.not.found=未找到檔案
config.new.file=Spring 組態
config.no.contexts.defined=未定義應用程式上下文
config.unmapped.configs.popup.title={0} 中未映射的 Spring 組態檔案
configuration.tab.additional.settings=附加設定
constructor.arg.incorrect.value.type=注入值類型必須對應於建構函式實參類型
context.schema.inspection.name=基於 XML 的組件掃描中無效的篩選器定義
create.component.action.this.already.exists=檔案 {0} 已存在
create.component.fix.text=建立 ''{0}'' 組件…
create.component.rename.reference=重新命名類別參照
create.missing.mappings=為 ''{0}'' 建立缺少的映射
create.missing.mappings.family.name=建立缺少的映射
create.missing.properties=建立缺少的屬性
create.new.spring.configuration.file=建立新的 Spring 組態檔案
custom.bean.no.id=IntelliJ IDEA 在組態檔案中找不到此 Bean 的 ID。重新命名可能會生成錯誤的程式碼。是否要繼續?
custom.bean.no.id.title=警告
custom.namespace.quick.fixes.create.custom.namespace.bean=建立自訂命名空間 Bean ({0} 個變體)…
custom.namespace.quick.fixes.create.custom.namespace.bean.with.id=建立自訂命名空間 Bean {0}
custom.namespace.quick.fixes.create.name=建立 {0}
custom.namespace.quick.fixes.family.name=建立自訂命名空間 Bean
custom.namespace.quick.fixes.popup.title=建立自訂命名空間 Bean
custom.namespace.registration.inspection.key='spring.handlers' 或 'spring.schemas' 檔案中未解析的檔案或類別參照
dependency.node.in.module.tail=(在模組 {0} 中)
do.you.want.to.move.bean.to.the.top.level=是否要將該 Bean 移至頂層?
duplicated.bean.name.inspection.name.view.duplicates=檢視重複項
duplicated.bean.quick.fix.description=導覽到重複項
duplicated.bean.quick.fix.popup.title=檢視重複項
editor.panel.profiles.tooltip=有效組態檔案
editor.panel.profiles.tooltip.action.name=更改組態檔案…
event.listener.method.parameters.count=方法必須最多只有一個參數
event.listener.method.visibility.nonstatic=使用 @EventListener 註釋的方法必須為非 static
facet.context.autodetected.suffix=(自動檢測)
facet.context.code.files=基於程式碼的組態
facet.context.default.name=Spring 套用程序上下文
facet.context.edit.add.file.choose.type=選擇類型
facet.context.edit.name.label=名稱(&N)\:
facet.context.edit.name.validation.already.exists=具有此名稱的上下文已存在。如果已刪除具有此名稱的現有上下文，則必須首先使用“套用”。
facet.context.edit.name.validation.not.empty=名稱不得為空
facet.context.edit.parent.label=父上下文(&P)\:
facet.context.edit.parent.none.selected=<none>
facet.context.edit.title=編輯套用程序上下文 ''{0}''
facet.context.new.title=新增應用程式上下文
facet.context.other.files=其他檔案
facet.context.properties.files=附加屬性檔案
facet.context.remove.message=確實要移除應用程式上下文“{0}”嗎? (不會刪除任何檔案)
facet.context.remove.title=移除
facet.context.xml.files=基於 XML 的組態
field.injection.add.parameter.family.warning=更改欄位注入。向建構函式新增參數
field.injection.add.parameters=<html>向建構函式新增參數\: {0}</html>
field.injection.create.constructor.family.warning=更改欄位注入。建立建構函式
field.injection.create.constructor.injection=<html>建立建構函式\: {0}</html>
field.injection.is.not.recommended=不建議使用欄位注入
fileset.circular.dependencies=上下文之間的迴圈相依關係\:<br/>{0}<br/>{1}
fileset.contains.testing.configs.full=用於測試的{0, choice, 1\#組態檔案|1< {0, number} 個組態檔案}<em>不得</em>新增到上下文\:<br/>{1}
fileset.contains.testing.configs.short=用於測試的{0, choice, 1\#組態檔案|1< {0, number} 個組態檔案}<em>不得</em>新增到上下文
fileset.editor.help.label=<html>通過 <b>\\&lt;import …/\\&gt;</b> 或 <b>@Import</b> 參照的組態檔案將隱式新增。<br/>用於測試的組態檔案<em>不得</em>新增到上下文。</html>
group.Internal.Spring.text=Spring
group.Spring.Beans.Generate.Action.text=Spring Bean
group.spring.components=組件
group.spring.config=組態
gutter.choose.autowired.candidates.title=選擇自動裝配的候選項
gutter.choose.bean.factory.calls.title=選擇 BeanFactory.getBean(…) 用法
gutter.navigate.no.bean.factory.calls=未找到符合的 BeanFactory 用法
gutter.navigate.no.matching.autowired.candidates=未找到符合的自動裝配候選項
gutter.navigate.no.matching.beans=未找到符合的 Bean
gutter.navigate.to.autowired.candidates.title=導覽到自動裝配的候選項
gutter.navigate.to.bean.factory.calls.title=導覽到 BeanFactory.getBean(…) 用法
idref.cannot.be.added.in.collection=無法新增到 ''{0}'' 類型的集合中
incorrect.constructor.arg.index.not.unique=索引必須唯一
injection.lookup.defaultMethodCommentText=此方法將被 Spring 覆寫並返回 {0} 的新實例
inspection.group.code=程式碼
inspection.group.xml=XML
interface.not.allowed=非抽象 Bean 不允許接口
internal.error.parsing.bean=解析 Bean 時出現內部錯誤;輸出\:\n{0}
introduce.bean.intention=引入 Bean
live.template.bean.description=Spring '@Bean' 模板
live.template.component.description=Spring '@Component' 模板
live.template.configuration.description=Spring '@Configuration' 模板
live.template.service.description=Spring '@Service' 模板
logical.spring.bean.autowired.in=自動裝配到
logical.spring.bean.autowires=自動裝配
logical.spring.bean.implementations=實作
logical.spring.bean.requires=要求
logical.spring.configuration.imports=匯入
logical.spring.event.listeners=偵聽器
logical.spring.event.publishers=發佈程序
logical.spring.scanned.components=已掃描的組件
logical.spring.service.methods=方法
mark.bean.as.abstract=將 Bean 標記為 abstract
message.navigation.available.during.indexing=索引編制期間導覽不可用
method.cannot.instantiate.bean=工廠方法  ''{0}'' 無法實例化 Bean
method.must.be.public=工廠方法 ''{0}'' 應為 public
method.must.be.static=工廠方法 ''{0}'' 必須為 static
method.must.not.be.static=工廠方法 ''{0}'' 不得為 static
method.parameters.removing.fix.family.name=移除方法參數
method.parameters.removing.fix.text=將 ''{0}'' 更改為無實參
method.return.type.make.async.family.name=更改方法以返回 "Future-like" 值
method.return.type.make.async.fix.text=更改方法以返回 ''{0}''
model.add.constructor.args.for.method.quickfix.description=生成缺失的 'constructor-arg' 標記
model.add.constructor.args.for.method.quickfix.message=為 ''{0}'' 新增 <constructor-arg>
model.add.constructor.args.for.method.quickfix.message.family.name=新增 <constructor-arg>
model.bean.not.found.error.message=找不到名稱為 ''{0}'' 的 Bean
model.bean.quickfix.message=建立新 Bean ''{0}''
model.bean.quickfix.message.family.name=建立新 Bean
model.goto.related.item.group.application.context=Spring 套用程序上下文
model.goto.related.item.group.context=Spring 上下文\:“{0}”
model.goto.related.item.group.test.context=Spring 測試上下文
model.inspection.bean.autowiring=不正確的 XML Spring Bean 自動裝配
model.inspection.bean.constructor.arg=XML Spring Bean 中不正確的建構函式注入
model.inspection.bean.factory.method=在 "factory-method" 特性中參照的錯誤定義的方法
model.inspection.bean.property.value=XML 應用程式上下文中不可分配的注入點類型
model.inspection.bean.public.factory.method=在 "factory-method" 特性中參照的不正確的非 public 方法
model.inspection.display.bean.name.convention=Spring Bean 名稱違反約定
model.inspection.display.name=不正確的 Spring Core 基於 XML 的應用程式上下文
model.inspection.inactive.profile=停用組態檔案醒目提示
model.inspection.injection.value.add.array=新增 <array> 標記
model.inspection.injection.value.add.list=新增 <list> 標記
model.inspection.injection.value.add.map=新增 <map> 標記
model.inspection.injection.value.add.ref=新增 "ref" 特性
model.inspection.injection.value.add.set=新增 <set> 標記
model.inspection.injection.value.consistency=XML 應用程式上下文中不一致的注入值
model.inspection.injection.value.entry.key=映射條目必須指定鍵
model.inspection.injection.value.message={0} 必須指定一個 ref 或 value
model.inspection.injection.value.style=XML 應用程式上下文中的注入值違反約定
model.inspection.injection.value.style.message=使用了顯式 <value> 元素
model.inspection.injection.value.style.ref.fix=將 <ref> 元素取代為“{0}”特性
model.inspection.injection.value.style.ref.fix.family.name=將 <ref> 元素取代為特性
model.inspection.injection.value.style.ref.message=使用了顯式 <ref> 元素
model.inspection.injection.value.style.value.fix=將 <value> 元素取代為“{0}”特性
model.inspection.injection.value.style.value.fix.family.name=將 <value> 元素取代為特性
model.inspection.invalid.identifier.message=''{0}'' 未遵循 Bean 命名約定
model.inspection.invalid.lowercase.name.message=''{0}'' 應以小寫字母開頭
model.inspection.validator.progress.text=正在驗證 Spring 模型…
model.method.choose.method=選擇方法
model.method.resolve.class.error.message=無法解析類別 ''{0}''
model.method.signature.parse.error.message=無法解析簽名 ''{0}''
model.property.error.message=無法解析屬性 ''{0}''
model.qualifiers.in.class.inspection.display.name=Spring Bean 組件中不正確的自動裝配
move.bean=移動 Bean
move.bean.to.the.top.level=將 Bean 移至頂層
multiple.autowiring.constructor=只有一個建構函式可以具有 @Autowired 註解
multiple.context.description.in.module.text=<html><body> 在模組 <b>{0}</b> 中。</body></html>
multiple.context.description.in.modules.label.text=<html><body>檔案包含在 <b>{1}</b> 個模組的 <b>{0} 個上下文</b>中。</body></html>
multiple.context.description.label.text=<html><body>檔案包含在 <b>{0} 個上下文</b>中。</body></html>
multiple.context.tooltip.text=有效上下文
navigate.to.autowired.dependencies=導覽到自動裝配的相依項
navigate.to.by.name.autowired.dependencies=導覽到 'byName' 自動裝配的相依項
navigate.to.fileset.configuration=導覽到應用程式上下文組態
notification.group.spring.beans=Spring 自訂 Bean 解析失敗
notification.group.spring.configuration=檢測到 Spring 組態問題
parse.custom.bean.error=解析自訂 Bean 時出錯
parse.custom.bean.intention=解析自訂 Bean
parse.custom.bean.success=自訂處理程序已成功完成
parse.no.custom.beans=解析器未生成 Bean
parse.no.namespace.handler=找不到命名空間 ''{0}'' 的自訂處理程序
parse.only.infrastructure.beans=解析器僅生成架構 Bean
parse.these.beans=自訂命名空間處理程序已生成以下 Bean 定義\:\n{0}
parse.these.beans.induct=自訂命名空間處理程序生成以下 Bean 定義\:\n{0}\n\n是否要假設名稱空間 ''{1}'' 中\n本地名稱為 ''{2}'' 的所有 Bean 具有\n相同的類別並且從 ''{3}'' 特性獲得 ID?
parse.these.beans.induct.all.beans=所有 Bean
parse.these.beans.induct.only.this=此 Bean
parsing.custom.bean=正在執行自訂 Spring Bean 處理程序…
placeholders.inspection.display.name=Spring XML 應用程式上下文中組態的未解析的佔位符
popup.title.select.injection.type=選擇注入類型
popup.title.select.prototypeInjection.type=選擇原型注入類型
process.explicitly.annotated.beans=處理顯式註解的 Bean
process.unexpectedly.terminated=程序意外終止{0}
progress.creating.component=正在建立 Spring 組件 {0}
reference.injector.spring.bean.name=Spring Bean 名稱
reference.injector.spring.placeholder=Spring 佔位符
reference.injector.spring.resource.path=Spring 資源路徑
required.properties.inspection=@Required Spring Bean 屬性未注入
required.properties.missed=缺少必需屬性\: ''{0}''
required.property.not.mapped=未注入必需屬性 ''{0}''
required.spring.bean.type.inspection=不正確的注入 Bean 類型
scopes.inspection.display.name=未知 <bean> 作用域
searching.for.implicit.usages=正在搜尋隱式用法…
searching.for.stereotype.usages=正在搜尋建構型用法…
spring=Spring
spring.add.bean.dependency.fix.family.name=新增對 Bean 的相依關係
spring.add.bean.dependency.fix.text=新增名稱與 ''{0}'' 符合的相依項
spring.aliases=別名
spring.app.context.navigate.tooltip=導覽到應用程式上下文
spring.app.context.to.navigate=選擇應用程式上下文
spring.application.auto.configuration=自動組態
spring.bean=Spring Bean
spring.bean.abstract.bean.references.inspection=對抽象 Bean 不正確的參照
spring.bean.already.exists={1} 中已存在名為 ''{0}'' 的 Spring Bean
spring.bean.attributes.inspection.key=Spring Bean 特性衝突
spring.bean.autowire.escape=將自動裝配的相依項設為顯式
spring.bean.autowire.escape.inspection.name=XML 應用程式上下文中不必要的自動裝配的相依項
spring.bean.class.navigate.choose.class.title=選擇 Bean
spring.bean.class.tooltip.navigate.declaration=導覽到 Spring Bean 宣告
spring.bean.class.tooltip.show.in.description=在 Spring 檢視中選擇
spring.bean.constructor.arg=建構函式實參
spring.bean.constructor.navigate.choose.class.title=選擇包含建構函式的 Bean
spring.bean.constructor.tooltip.navigate.declaration=導覽到 Spring Bean
spring.bean.dependencies.chooser.title=選擇 Bean
spring.bean.duplicate.bean.name=Bean 名稱重複
spring.bean.duplicated.bean.name.inspection=基於 XML 的應用程式上下文中重複的 Bean 名稱
spring.bean.filter.tooltip=開始輸入以篩選元素
spring.bean.idref.attributes.inconsistency=<idref> 標記只能包含 "bean" 特性或 "local" 特性
spring.bean.idref.attributes.must.specify=<idref> 標記必須指定 Bean
spring.bean.instantiation.by.factory=Spring Bean (已由工廠 Bean 實例化)
spring.bean.instantiation.inspection=無效的非抽象 Bean 實例化
spring.bean.instantiation.using.factory.method=Spring Bean (由 static 工廠方法實例化)
spring.bean.lookup.method.bean.has.no.class=''{0}'' Bean 沒有類別
spring.bean.lookup.method.constructor.not.allowed=此處不允許使用建構函式
spring.bean.lookup.method.incorrect.return.type=不正確的尋找方法返回值類型
spring.bean.lookup.method.inspection=不正確的 XML Bean 尋找方法組態
spring.bean.lookup.method.must.be.not.static=此處不允許使用 static 方法
spring.bean.lookup.method.must.be.public.or.protected=方法必須為 public 或 protected
spring.bean.lookup.method.must.have.no.parameters=方法不得有形參
spring.bean.lookup.method.return.type.mismatch=Lookup 方法返回值類型與 ''{0}'' Bean 類別不符合
spring.bean.map.entry=映射條目
spring.bean.method.tooltip.navigate.declaration=導覽到 Spring Bean {0} 方法宣告
spring.bean.methods.tooltip.navigate.declaration=導覽到 Spring Bean 方法宣告
spring.bean.properties.chooser.title=選擇屬性
spring.bean.property=屬性
spring.bean.property.navigate.choose.class.title=選擇包含屬性的 Bean
spring.bean.property.tooltip.navigate.declaration=導覽到 Spring Bean 屬性
spring.bean.property.value.inconsistency.key=映射條目只能包含 "key" 特性或 "key-ref" 特性或 <key> 子元素
spring.bean.property.value.inconsistency.more.one.sub.element={0} 不得包含多個子元素
spring.bean.property.value.inconsistency.ref.or.value.sub.element.must.defined={0} 只能包含 "ref" 特性或 "value" 特性或子元素
spring.bean.ref.attributes.inconsistency=<ref> 標記只能包含 "bean" 特性或 "local" 特性或 "parent" 特性
spring.bean.ref.attributes.must.specify=<ref> 標記必須指定 Bean
spring.bean.referenced.by.abstract.bean=此處無法使用 abstract Bean
spring.bean.show.beans.candidates.title=Bean 候選項
spring.bean.use.autowire=不必要的自動裝配的相依項
spring.beans=已生成的 Bean
spring.beans.chooser.all.context.files=所有 Bean
spring.beans.chooser.show.context.files=顯示上下文檔案
spring.cacheable.and.cache.put.on.the.same.method.display.name=對同一方法不正確地使用 @CachePut 和 @Cacheable
spring.cacheable.annotations.inspection.display.name=組態不正確的 'caching' 註解
spring.cacheable.annotations.on.interfaces=在接口/接口方法上定義的 Cache* 註解
spring.cacheable.element.choose.title=選擇可快取動作
spring.cacheable.element.tooltip.text=轉到同名的可快取動作
spring.cacheable.method.calls.inspection.display.name=@Cacheable 自呼叫方法呼叫
spring.cacheable.names.inspection.display.name=不正確的所需快取名稱定義
spring.cacheable.self.method.calls=@Cacheable 自呼叫(實際上是目標物件內的方法呼叫目標物件的另一個方法)。在執行時會忽略快取註解
spring.choose.bean.templates.dialog.beans=Bean
spring.choose.bean.templates.dialog.title=新增 {0} Bean
spring.component.container.current.file=當前檔案
spring.component.container.custom.package=自訂軟體套件…
spring.component.container.custom.package.dialog.package=包\:
spring.component.container.custom.package.dialog.select.package=選擇軟體套件
spring.component.container.custom.package.dialog.source.root=來源根\:
spring.component.container.custom.package.dialog.title=選擇來源根和軟體套件
spring.component.template.application=應用程式
spring.component.template.bean=Bean
spring.component.template.boot.test=Spring Boot 測試
spring.component.template.component=組件
spring.component.template.configuration=組態
spring.component.template.configuration.properties=組態屬性
spring.component.template.service=服務
spring.configurable.create.bean.tab.title=要接受建議，請按 Tab。
spring.configuration.check=Spring 組態檢查
spring.configuration.proxy.methods.display.name=@Configuration proxyMethods 用法警告
spring.context.configuration.inspection.display.name=無效的 @ContextConfiguration
spring.core.autowired.annotator.name=自動裝配
spring.core.bean.annotator.name=Bean
spring.core.cacheable.annotator.name=同名的可快取動作
spring.core.dom.annotator.name=組態(XML)
spring.core.event.listener.annotator.name=應用程式事件
spring.core.properties.annotator.name=屬性
spring.core.test.configuration.annotator.name=測試組態
spring.core.testing.annotator.navigate.to.overridden=導覽到被覆寫的 Bean
spring.core.testing.inject.annotator.name=測試 Bean
spring.create.bean.command.text=建立並自動裝配新的 {0}
spring.create.bean.dependency.default.name=Spring 組件
spring.create.bean.dependency.fix.family.name=建立新 Bean
spring.create.bean.dependency.fix.text=建立並自動裝配新的 {1} ''{0}''
spring.depends.on.inspection.display.name=@DependsOn 註解中不正確參照的 Bean
spring.dom.component.scan.stereotypes=選擇建構型
spring.dom.component.scan.stereotypes.title=導覽到組件
spring.event.listener.choose.title=選擇事件偵聽器
spring.event.listener.empty.tooltip.text=未找到事件偵聽器
spring.event.listener.tooltip.text=轉到事件偵聽器
spring.event.publisher.choose.title=選擇事件發佈器
spring.event.publisher.empty.tooltip.text=未找到事件發佈器
spring.event.publisher.tooltip.text=轉到事件發佈器
spring.facet.config.detection=Spring 組態檢測
spring.facet.detection.disable.detection=停用檢測
spring.facet.detection.will.be.disabled.for.whole.project=將為整個專案停用檢測。\n請注意，如果不執行 Spring facet 組態，將無法使用大多數 Spring 相關功能。\n\n“專案結構 | Facet | 檢測”\n可用於僅排除以及重新啟用特定檔案/目錄。
spring.facet.validation.disable.action=停用…
spring.facet.validation.help.action=顯示幫助
spring.factories.file.type=Spring 工廠
spring.generate.constructor.dependencies=建構函式相依項…
spring.generate.properties=屬性…
spring.generate.setter.dependencies=Setter 相依項…
spring.import.resource.error.message.trailing.space=''{0}'' 中的尾隨空格
spring.import.resource.inspection.display.name=@ImportResource 位置中未解析的檔案參照
spring.incorrect.resource.type.inspection=不正確的資源類型
spring.injection.autowiring.code.style=自動裝配程式碼樣式
spring.injection.default.beans.inject.strategy=預設 Bean 注入器策略\:
spring.injection.group.libraries=庫
spring.injection.group.project=專案
spring.injection.group.repository=儲存庫
spring.injection.group.service=服務
spring.injection.injectToBeanMethodSignature=對 @Bean 方法使用方法參數注入
spring.injection.variants.collection=集合
spring.injection.variants.default=預設
spring.injection.variants.primary=主要
spring.injection.variants.qualifier={0}
spring.intention.category=Spring
spring.lookup.inspection.display.name=Spring 組件的 @Lookup 註解中不正確參照的 Bean
spring.model.actions.dump.model.gathering.spring.models=正在收集 Spring 模型…
spring.model.actions.dump.model.generating.json=正在生成 JSON…
spring.model.actions.dump.model.scanning.spring.models=正在掃描 Spring 模型…
spring.model.actions.generate.beans=建立 Spring Bean
spring.parent.bean.tooltip=導覽到子宣告
spring.profile=分析
spring.profile.expression.empty=組態檔案表達式必須包含文本
spring.profile.expression.inspection=組態不正確的 @Profile 表達式
spring.profile.expression.malformed=格式不正確的組態檔案表達式
spring.profile.unresolved.message=未知組態檔案
spring.property.source.inspection.display.name=@PropertySource 和 @TestPropertySource 位置中未解析的檔案參照
spring.required.property.inspection=Spring XML Bean 宣告中缺少 @Required 屬性注入
spring.scheduled.inspection.display.name=@Scheduled 註解中不正確參照的 Bean
spring.scheduled.method=觸發 @Scheduled 方法
spring.scheduled.tasks=計劃的任務
spring.scope=作用域
spring.settings.configuration.completion=補全
spring.settings.configuration.file.editor=組態檔案編輯器
spring.settings.multiple.context.panel=顯示多個上下文面板(&M)
spring.settings.multiple.context.panel.tooltip=如果檔案在多個上下文中使用，則允許選擇有效上下文
spring.settings.profiles.panel=顯示組態檔案面板(&P)
spring.settings.profiles.panel.tooltip=允許選擇有效組態檔案
spring.settings.smartCompletionAvailability=智能 Bean 補全
spring.stereotype.bean=Bean
spring.stereotype.component=組件
spring.stereotype.configuration=組態
spring.stereotype.service=服務
spring.template.context.type=Spring
spring.test.override.bean.resolve.inspection.cannot.find.factory.method=找不到 static 工廠方法
spring.test.override.bean.resolve.inspection.display.name=@MockitoBean、@MockitoSpyBean 和 @TestBean 註解中不正確參照的 Bean
spring.testing.context.dirties.inspection.display.name=無效的 @DirtiesContext 'mode' 組態
spring.testing.model.dirties.class.mode.error.message=在帶註解的測試方法上設定類別模式沒有任何意義。對於方法級控制，請改用 methodMode。
spring.testing.model.dirties.hierarchy.mode.error.message=當通過 @ContextHierarchy 將上下文組態為層次結構的一部分時，必須使用 hierarchyMode
spring.testing.model.dirties.method.mode.error.message=在註解的測試類別上設定方法模式沒有意義。對於類別級別控制，請改用 classMode。
spring.testing.sql.inspection.display.name=無效的 @Sql 和 @SqlGroup 組態
spring.testing.transactional.inspection.display.name=無效的事務生存期方法宣告
spring.testing.transactional.void.method.return.type.error.message=方法返回值類型應為 'void'
spring.testing.transactional.wrong.number.of.arguments.error.message=實參數量錯誤
spring.transaction.inspection.display.name=@Transactional 組件中無效的 'PlatformTransactionManager' 宣告
spring.transactional.method.calls.inspection.display.name=@Transactional 自呼叫方法呼叫
spring.transactional.self.method.calls=@Transactional 自呼叫(實際上是目標物件內的方法呼叫目標物件的另一個方法)在執行時不會導致實際的事務
static.members.autowiring=不自動裝配 static 成員
timeout.parsing.bean=自訂 Bean 解析時間過長
try.parsing.custom.beans=嘗試解析自訂 Bean
unmapped.configuration.autodetected.context.found.for=已找到 {0} 的自動檢測上下文。\n請檢查並設定其他手動上下文(如果需要)。
unmapped.configuration.configure.facet=請組態 Spring facet。
unmapped.configuration.create.default.context=建立預設上下文
unmapped.configuration.files.count={0, choice, 1\#1 檔案|1<{0, number} 檔案}
unmapped.configuration.files.found=找到未映射的 Spring 組態檔案。
unmapped.configuration.files.full={0, choice, 1\#未映射的 Spring 組態檔案|1<{0, number} 個未映射的 Spring 組態檔案}\:<br/>{1}
unmapped.configuration.files.not.found=找不到未映射的 Spring 組態檔案。
unmapped.configuration.files.short={0, choice, 1\#未映射的 Spring 組態檔案|1<{0, number} 個未映射的 Spring 組態檔案}
unmapped.configuration.fix.instruction=請組態 Spring facet 或使用 ''{0}'' 新增一個包括所有未映射檔案的 facet。
unmapped.configuration.is.not.available.during.index.update=索引更新期間 ''{0}'' 不可用
unmapped.configuration.open.facet.configuration=開啟 Facet 組態
unmapped.configuration.spring.configuration=Spring 組態
unparsed.custom.bean.inspection=未解析的自訂 Spring Bean
unparsed.custom.bean.message=此自定義 Spring Bean 尚未解析
update.schema.intention=轉換為 Spring XML 架構
use.existing.quick.fixes.add.dependency.to.context=將相依關係新增到上下文 ''{0}''
use.existing.quick.fixes.add.import.action=為 ''{0}'' 新增 <import>
use.existing.quick.fixes.add.spring.xml.to.fileset.action=將 ''{0}'' 新增到上下文 ''{1}''
use.existing.quick.fixes.choose.fix.for=為 ''{0}'' 選擇修正
use.existing.quick.fixes.open.spring.facet.settings=開啟 Spring facet 設定…
use.existing.quick.fixes.use.existing.bean.family.name=使用現有 Bean
use.existing.quick.fixes.use.existing.bean.from.context=使用上下文 ''{0}'' 中的現有 Bean…
use.p.namespace=轉換為 p-namespace
util.required.class.message=類別必須為 ''{0}'' 的繼承者
util.schema.inspection.name=XML 應用程式上下文中定義的組態不正確的 'util' 架構 Bean
xml.schema.update.is.required=需要更新 XML 架構
xml.schema.will.be.updated=XML 架構將更新為 spring-beans.xsd。\n是否要繼續?

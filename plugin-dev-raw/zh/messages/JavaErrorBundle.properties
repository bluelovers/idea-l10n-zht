annotation.annotation.type.expected=應為註解類型
annotation.interface.is.not.used=@interface ''{0}'' 從未使用
annotation.missing.method=找不到 @interface 方法 ''{0}()''
annotation.not.applicable=''@{0}'' 不適用於{1}
annotation.on.static.member.qualifying.type.family.name=移動類型註解
annotation.unknown.method=找不到 @interface 方法 ''{0}()''
assert.identifier.warn=自 Java 1.4 起，不支持使用 'assert' 作為關鍵字
binary.operator.not.applicable=運算符 ''{0}'' 不能應用於 ''{1}''、''{2}''
cannot.resolve.constructor=無法解析建構函式 ''{0}''
cannot.resolve.method=無法解析方法 ''{0}''
cannot.resolve.package=無法解析軟體套件 {0}
cannot.resolve.symbol=無法解析符號 ''{0}''
catch.without.try='catch' 沒有 'try'
class.is.not.used=類別 ''{0}'' 從未使用
class.must.be.abstract=類別“{0}”必須宣告為抽象，或為實作“{2}”中的抽象方法“{1}”
constructor.is.not.used=建構函式 ''{0}'' 從未使用
create.class.action.this.not.valid.java.qualified.name=這不是有效的 Java 限定名稱
deconstruction.pattern.requires.record=解構模式只能應用於記錄，''{0}'' 不是記錄
deprecated.default.constructor=''{0}'' 中的預設建構函式已棄用
deprecated.since.symbol=''{0}'' 自版本 {1} 起已棄用
deprecated.symbol=''{0}'' 已棄用
else.without.if='else' 沒有 'if'
enum.identifier.warn=自 Java 1.5 起，不支持使用 'enum' 作為關鍵字
enum.is.not.used=枚舉 ''{0}'' 從未使用
error.cannot.resolve.class=無法解析類別 ''{0}''
error.cannot.resolve.class.or.package=無法解析類別或軟體套件 ''{0}''
exception.is.never.thrown=此方法中從未拋出異常 ''{0}''
expected.boolean.expression=應為布爾表達式
expected.catch.or.finally=應為 'catch' 或 'finally'
expected.comma=應為 ','
expected.expression=應為表達式
expected.identifier=應為關鍵字
expected.identifier.or.type=應為關鍵字或類型
expected.lbrace=應為 '{'
expected.lparen=應為 '('
expected.lparen.or.lbracket=應為 '(' 或 '['
expected.parameter=應為參數
expected.rbrace=應為 '}'
expected.rbracket=應為 ']'
expected.rparen=應為 ')'
expected.semicolon=應為 ';'
expected.statement=應為語句
expected.switch.label=應為 'case'、'default' 或 '}'
expected.switch.rule=應為表達式、塊或 throw 語句
expected.while=應為 'while'
expression.expected=應為表達式
field.is.not.used=欄位 ''{0}'' 從未使用
field.is.not.used.for.reading={0} 欄位 ''{1}'' 已被分配，從未被存取
finally.without.try='finally' 沒有 'try'
generics.unchecked.assignment=未檢查的賦值\: ''{0}'' 賦值給 ''{1}''
generics.unchecked.call=未檢查的方法 ''{0}'' 呼叫
generics.unchecked.call.to.member.of.raw.type=作為原始類型 ''{1}'' 的成員對 ''{0}'' 的未檢查的呼叫
generics.unchecked.cast=未檢查的轉換\: ''{0}'' 轉換為 ''{1}''
incompatible.types=不相容的類型。實際為 {1}''，需要 ''{0}''
inconvertible.type.cast=不可轉換的類型；無法將 ''{0}'' 轉換為 ''{1}''
interface.is.not.used=接口 ''{0}'' 從未使用
local.class.is.not.used=本地類別 ''{0}'' 從未使用
local.variable.is.never.used=''{0}'' 從未使用變數
local.variable.is.not.assigned=變數 ''{0}'' 從未被賦值
local.variable.is.not.used.for.reading=''{0}'' 已被賦值，從未被存取
marked.for.removal.default.constructor=''{0}'' 中的預設建構函式已棄用並被標記為移除
marked.for.removal.symbol=''{0}'' 已棄用並被標記為移除
marked.for.removal.symbol.since=''{0}'' 自版本 {1} 起已棄用並標記為移除
method.is.not.used=方法 ''{0}'' 從未使用
missing.package.statement=缺少 package 語句\: ''{0}''
missing.package.statement.package.name.invalid=缺少軟體套件語句，但與檔案路徑相對應的軟體套件名稱 ''{0}'' 無效
missing.return.statement=缺少 return 語句
module.open.duplicate.text=轉到重複項
module.unwanted.modifier.warn=自 Java 10 起，禁止對 'requires java.base' 使用修飾符
numeric.overflow.in.expression=表達式中出現數值溢出
overrides.deprecated.method=覆寫 ''{0}'' 中棄用的方法
overrides.marked.for.removal.method=覆寫 ''{0}'' 中棄用並標記為移除的方法
package.name.file.path.mismatch=軟體套件名稱 ''{0}'' 與檔案路徑 ''{1}'' 不對應
parameter.excluding.hierarchy.disable.text=不醒目提示繼承方法的參數
parameter.is.not.used=參數 ''{0}'' 從未使用
pattern.variable.is.not.used=模式變數 ''{0}'' 從未使用
private.constructor.is.not.used=private 建構函式 ''{0}'' 從未使用
private.field.is.not.assigned=private 欄位 ''{0}'' 從未分配
private.field.is.not.used=private 欄位 ''{0}'' 從未使用
private.inner.class.is.not.used=private 內部類別 ''{0}'' 從未使用
private.inner.interface.is.not.used=private 內部接口 ''{0}'' 從未使用
private.method.is.not.used=private 方法 ''{0}'' 從未使用
qualified.enum.constant.in.switch.remove.fix=移除限定符
record.canonical.constructor=規範建構函式
record.compact.constructor=緊湊建構函式
record.is.not.used=記錄 ''{0}'' 從未使用
redundant.semicolon.warn=從 Java 21 開始禁止在 import 語句之間使用冗餘的分號
remove.unused.imports.quickfix.text=移除未使用的 import
restricted.identifier=''{0}'' 是受限關鍵字，不能用於類型宣告
restricted.identifier.warn=自 Java {1} 起的版本中不支持使用 ''{0}'' 作為類別名
static.member.accessed.via.instance.reference=通過實例參照存取 static 成員 ''{0}.{1}''
suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
switch.dominance.of.preceding.label=標籤由先前的 case 標籤 ''{0}'' 支配
switch.expr.empty='switch' 表達式沒有任何 case 子句
switch.expr.incomplete='switch' 表達式未涵蓋所有可能的輸入值
switch.statement.empty='switch' 語句沒有任何 case 子句
switch.statement.incomplete='switch' 語句未涵蓋所有可能的輸入值
text.class.is.not.accessible={0} 在當前上下文中不可存取
type.parameter.is.not.used=類型參數 ''{0}'' 從未使用
unchecked.overriding.incompatible.return.type=未檢查的覆寫\: 返回值類型需要未經檢查的轉換。實際為 ''{0}''，需要 ''{1}''
underscore.identifier.warn=自 Java 9 起，不支持使用 '_' 作為關鍵字
unexpected.token=意外的標記
unhandled.exceptions=未處理 {1, choice, 0\#異常|2\#異常}\: {0}
variable.already.defined=作用域中已定義變數 ''{0}''
yield.unqualified.method.warn=自 Java 14 起的版本中不支持對 'yield' 方法進行非限定呼叫

### Quick fixes ###
QFIX.add.import.add.import=添加 "''{0}''"

#PyImplementMethodsQuickFix
QFIX.NAME.implement.methods=實現 abstract 方法

QFIX.NAME.change.signature=Change signature
QFIX.change.signature.of=更改 {0} 的簽名

QFIX.FAMILY.NAME.rename.element=重命名元素
QFIX.NAME.rename.element=重命名該元素

QFIX.ignore.unresolved.reference=忽略未解析的引用
QFIX.ignore.unresolved.reference.0=忽略未解析的引用 ''{0}''
QFIX.mark.all.unresolved.attributes.of.0.as.ignored=將 ''{0}'' 所有未解析的特性標記為已忽略
QFIX.fill.paragraph=填充段落
QFIX.remove.trailing.blank.lines=移除尾隨的空白行
QFIX.generating.skeletons.for.binary.module=正在為二進制模塊生成框架
QFIX.generate.binary.stubs=生成二進制存根
QFIX.reformat.file=重新格式化該檔案
QFIX.bold.html.text=<b>{0}</b>

# Namespace packages
QFIX.mark.as.namespace.package=將目錄 ''{0}'' 標記為命名空間軟件包
QFIX.change.to.same.directory.import=更改為同一目錄導入

# Intentions: INTN

# Conflict checker
CONFLICT.name.obscured.by.local.definitions=名稱 ''{0}'' 被局部定義掩蓋
CONFLICT.name.obscured.cannot.convert=名稱 ''{0}'' 被掩蓋。無法轉換。
CONFLICT.occurrence.pl=匹配項

##########################################################################################################################
# Unwrap
##########################################################################################################################
unwrap.if=解開 if…
unwrap.while=解開 while…
unwrap.for=解開 for…
unwrap.with=解開 with…
unwrap.try=解開 try…
unwrap.else=解開 else…
unwrap.elif=解開 elif…
remove.else=移除 else…
remove.elif=移除 elif…

INSP.GROUP.python=Python

# Refactoring
refactoring.will.not.be.accessible=您在嘗試移動的成員依賴於在此重構後無法訪問的 ''{0}''
refactoring.error.file.exists=檔案"{0}" 已存在
refactoring.error.directory.exists=目錄 "{0}" 已存在

# introduce
refactoring.introduce.name.error=錯誤的名稱
refactoring.introduce.selection.error=無法使用所選元素執行重構

# introduce variable
refactoring.introduce.variable.dialog.title=提取變數
refactoring.introduce.variable.scope.error=該名稱與現有變量或參數衝突

# introduce constant
refactoring.introduce.constant.dialog.title=提取常量
refactoring.introduce.constant.scope.error=已在範圍中聲明該名稱

# introduce parameter
refactoring.extract.parameter.dialog.title=提取參數
refactoring.introduce.parameter.dialog.title=引入參數

# pull up
refactoring.pull.up.dialog.title=向上拉取成員至
refactoring.pull.up.dialog.move.members.to.class=將成員移至類
refactoring.pull.up.dialog.members.to.be.moved=將移動以下成員
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=無法執行向上拉取成員：不在此類中
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=類 {0} 沒有超類，或者所有超類都不能用於重構

# inline
refactoring.inline.local.multiassignment=使用多個賦值定義

# inline function
refactoring.inline.function.title=內聯函數
refactoring.inline.this.only=僅內聯此調用並保留聲明
refactoring.inline.function=內聯函數 {0}
refactoring.inline.method=內聯方法 {0}
refactoring.inline.all.keep.declaration=內聯所有調用並保留聲明
refactoring.inline.all.remove.declaration=內聯所有調用並移除聲明
refactoring.inline.all.border.title=內聯
refactoring.inline.label.function=函數 {0}
refactoring.inline.label.method=方法 {0}
refactoring.name.label.text={0} 有 {1} 個匹配項{2, choice, 0#|1#}
refactoring.inline.function.command.name=正在內聯 {0}
refactoring.inline.function.function.to.inline=要內聯的函數
refactoring.inline.function.invocations.to.be.inlined=要在 {0} 檔案中內聯的調用
refactoring.inline.function.is.decorator=函數 {0} 用作裝飾器，無法內聯。不會移除函數定義
refactoring.inline.function.is.reference=函數 {0} 用作引用，無法內聯。不會移除函數定義
refactoring.inline.function.uses.unpacking=函數 {0} 使用實參解包，無法內聯。不會移除函數定義
refactoring.inline.function.generator=無法內聯生成器
refactoring.inline.function.async=無法內聯異步函數
refactoring.inline.function.function Object() { [native code] }=無法內聯構造函數調用
refactoring.inline.function.builtin=無法內聯內置函數
refactoring.inline.function.special.method=無法內聯特殊方法
refactoring.inline.function.skeleton.only=無法內聯二進制模塊中的函數
refactoring.inline.function.decorator=無法內聯包含裝飾器的函數
refactoring.inline.function.self.referrent=無法內聯引用自身的函數
refactoring.inline.function.star=無法內聯包含 * 實參的函數
refactoring.inline.function.overrides.method=無法內聯覆蓋其他方法的方法
refactoring.inline.function.is.overridden=無法內聯被覆蓋的方法
refactoring.inline.function.global=無法內聯包含全域變數的函數
refactoring.inline.function.nonlocal=無法內聯包含非局部變數的函數
refactoring.inline.function.nested=無法內聯包含其他函數聲明的函數
refactoring.inline.function.interrupts.flow=無法內聯中斷控制流的函數

# extract method
refactoring.extract.method=提取方法
refactoring.extract.method.error.bad.selection=無法使用所選元素執行提取方法
refactoring.extract.method.error.name.clash=該方法名稱與現有名稱衝突
refactoring.extract.method.error.returns=無法提取程式碼段內包含返回指令的方法
refactoring.extract.method.error.local.variable.modifications=無法從程式碼段內包含局部變數修改的表達式執行重構
refactoring.extract.method.error.local.variable.modifications.and.returns=無法從程式碼段內包含局部變數修改和返回指令的表達式執行重構
refactoring.extract.method.error.empty.fragment=無法從空程式碼段執行重構

refactoring.extract.method.error.class.level=無法在類級別執行重構

# extract superclass
refactoring.extract.super.target.path.outside.roots=該目標目錄在專案外部。必須在內容根內
refactoring.extract.super.target.class.already.exists=此模塊中已存在類 ''{0}''
refactoring.extract.super.name.0.must.be.ident=名稱 ''{0}'' 無效。必須為有效的 Python 關鍵字
refactoring.extract.super.class.no.members.allowed=無法提取任何成員

# move
refactoring.move.choose.destination.file.title=選擇目標檔案
refactoring.move.error.destination.file.contains.class=目標檔案已包含名稱為 ''{0}'' 的類
refactoring.move.error.destination.file.contains.function=目標檔案已包含名稱為 ''{0}'' 的函數
refactoring.move.error.destination.file.contains.global.variable=目標檔案已包含名稱為 ''{0}'' 的全域變數
refactoring.move.error.cannot.use.module.name=不能在導入中使用模塊名稱 ''{0}''


# move module members (top-level)
refactoring.move.module.members=移動模塊成員
refactoring.move.module.members.dialog.title=移動模塊成員
refactoring.move.module.members.dialog.table.title=批量移動(&M)
refactoring.move.module.members.dialog.description.class=移動類 {0}
refactoring.move.module.members.dialog.description.function=移動函數 {0}
refactoring.move.module.members.dialog.description.variable=移動全域變數 {0}
refactoring.move.module.members.dialog.description.selection=移動所選元素
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=無法將元素放入非 Python 檔案中
refactoring.move.module.members.error.selection=無法使用所選元素執行重構

# Make function top-level
refactoring.make.method.top.level.dialog.title=使之為頂層方法
refactoring.make.method.top.level.dialog.description=將方法 {0} 移至頂層

refactoring.make.local.function.top.level.dialog.title=使之為頂層局部函數
refactoring.make.local.function.top.level.dialog.description=將局部函數 {0} 移至頂層

refactoring.make.function.top.level.error.nonlocal.writes=無法移動包含非局部寫入的函數
refactoring.make.function.top.level.error.self.reads=無法移動外部範圍中包含 "self" 參數用法的函數
refactoring.make.function.top.level.error.outer.scope.reads=無法移動引用外部範圍中的名稱的方法
refactoring.make.function.top.level.error.private.attributes=無法移動引用私有實例特性的方法
refactoring.make.function.top.level.error.attribute.writes=無法移動寫入實例特性的方法
refactoring.make.function.top.level.error.method.calls=無法移動調用該類其他方法的方法
refactoring.make.function.top.level.error.special.usage.of.self=無法移動包含 "self" 參數特殊用法的方法



#change signature
refactoring.change.signature.usage.view.declarations.header=要重構的函數
refactoring.change.signature.dialog.validation.name.defined=名稱已在範圍中定義
refactoring.change.signature.dialog.validation.function.name=函數名稱不正確
refactoring.change.signature.dialog.validation.parameter.name=參數名稱不正確
refactoring.change.signature.dialog.validation.multiple.star=不允許多個 * 實參
refactoring.change.signature.dialog.validation.multiple.double.star=不允許多個 ** 實參
refactoring.change.signature.dialog.validation.default.missing=缺少預設值
refactoring.change.signature.dialog.validation.parameter.missing=缺少參數名稱
refactoring.change.signature.dialog.default.value.checkbox=在簽名中使用預設值：
refactoring.change.signature.dialog.name.label=名稱:
refactoring.change.signature.find.usages.of.base.class=類 {1} 的方法 {0}\n\
重寫類 {2} 的方法。\n\
要重構基方法嗎?
refactoring.change.signature.error.wrong.caret.position.method.name=文本游標應置於要重構的方法的名稱處
refactoring.change.signature.error.lambda.call=文本游標位於 lambda 調用上
refactoring.change.signature.error.tuple.parameters=該函數包含元組參數
refactoring.change.signature.error.not.under.source.root=該函數不在源根下
refactoring.change.signature.suggested.callSite.value=調用點的值
refactoring.change.signature.suggested.callSite.value.optional=調用點的可選值

refactoring.convert.package.to.module.error.not.empty.package=軟件包 "{0}" 不為空

refactoring.occurrences.count={0}（{1} 個匹配項）
refactoring.introduce.field.setup.method=setUp() 方法
refactoring.introduce.field.cannot.be.used.in.static.methods=static 方法中不能使用引入字段重構
refactoring.introduce.field.not.in.class=無法引入該字段: 不在類中
refactoring.rename.containing.file.with.the.following.name.to=將具有以下名稱的包含檔案重命名為:
refactoring.rename.containing.file.title=重命名包含檔案
refactoring.rename.containing.file=重命名包含檔案
refactoring.rename.containing.file.entity.name=包含檔案
refactoring.rename.parameter.in.hierarchy.to=將層次結構中的參數重命名為:
refactoring.rename.parameter.entity.name=參數
refactoring.rename.parameters.title=重命名參數
refactoring.rename.parameters.in.hierarchy=重命名層次結構中的參數
refactoring.rename=重命名
refactoring.rename.not.valid.identifier=名稱 ''{0}'' 不是有效的 Python 關鍵字。無法更新 ''{1}'' 中的 import 語句
refactoring.rename.inheritor.classes.with.the.following.names.to=將具有以下名稱的繼承者類重命名為：
refactoring.rename.inheritors.title=重命名繼承者
refactoring.rename.inheritors=重命名繼承者
refactoring.rename.inheritor.class.entity.name=繼承者類

python.run.select.script=選擇腳本
python.run.configuration=Python 執行配置
python.run.python=Python

python.testing.target.not.provided=未提供該目標
python.testing.provide.qualified.name=提供函數、類或模塊的限定名稱
python.testing.pattern.can.only.be.used=模式只能用於匹配一個資料夾中的多個檔案。無法對一個檔案使用模式。
python.testing.cant.resolve=無法解析 {0}。嘗試移除配置並再次生成
python.testing.cant.find.where.declared=在聲明 {0} 的位置找不到檔案。確保它存在於專案根中
python.testing.cant.get.importable.name=無法獲得 {0} 的可導入名稱。它是專案中的 Python 檔案嗎?

runcfg.tests.cant_rerun=無法重新執行測試，因為無法解析測試 ID。嘗試刪除執行配置，然後點擊右鍵以創建新配置。
runcfg.tests.empty_suite=空套件

### doctest run conf
runcfg.doctest.display_name=Doctest
runcfg.python_tests.config.additionalArguments=其他實參
runcfg.python_tests.config.target=目標
runcfg.python_tests.config.targetType=目標類型

### nosetests run conf
runcfg.nosetests.display_name=Nosetest
runcfg.nosetests.config.regexPattern=正則表達式模式

### pytest run conf
runcfg.pytest.display_name=pytest

# deprecated start
# deprecated end

runcfg.pytest.config.keywords=關鍵字
runcfg.pytest.config.parameters=參數


### trial run conf
runcfg.trial.display_name=Twisted Trial

### test run configuration
runcfg.test.display_name=Python 測試
runcfg.test.description=PyCharm 支援 Python 框架
runcfg.test.suggest.name.in.path={0} ({1} 內)
runcfg.test.suggest.name.in.python={1} 的 {0}


### tox
runcfg.tox.runner=tox 執行程序
runcfg.tox=tox

### unittest run configuration
runcfg.unittest.config.pattern=模式

runcfg.unittest.display_name=Unittest
runcfg.unittest.no_script_name=請指定腳本名稱
runcfg.unittest.no_module_name=請指定模塊的限定名稱
runcfg.unittest.no_class_name=請指定類名
runcfg.unittest.no_method_name=請指定方法名稱
runcfg.unittest.no_folder_name=請指定包含測試的資料夾
runcfg.unittest.dlg.test_script_label=腳本:
runcfg.unittest.dlg.class_label=類:
runcfg.unittest.dlg.method_label=方法:
runcfg.unittest.dlg.function_label=函數:
runcfg.unittest.dlg.folder_path=資料夾：
runcfg.unittest.dlg.test_type_title=測試:
runcfg.unittest.dlg.all_in_folder_title=資料夾中的所有
runcfg.unittest.dlg.all_in_script_title=腳本
runcfg.unittest.dlg.test_class_title=類
runcfg.unittest.dlg.test_method_title=方法
runcfg.unittest.no_valid_sdk=請選擇有效的 Python 解釋器
runcfg.unittest.no_module_sdk=請選擇包含有效 Python SDK 的模塊
runcfg.unittest.no_sdk=請指定 Python SDK
runcfg.unittest.dlg.select.folder.path=選擇資料夾路徑：
runcfg.unittest.dlg.select.script.path=選擇腳本路徑：
runcfg.unittest.dlg.interpreter_options_title=解釋器選項：
runcfg.unittest.suggest.name.in.class={0} ({1} 內)
runcfg.unittest.suggest.name.in.script={0} ({1} 內)
runcfg.unittest.suggest.name.in.folder={0} ({1} 內)
runcfg.labels.script_parameters=參數(&P):
runcfg.labels.environment_variables=環境變數(&E)：
runcfg.labels.interpreter=使用指定的解釋器(&U)：
runcfg.labels.use.sdk.of.module=使用模塊 SDK：
runcfg.labels.interpreter_options=解釋器選項(&O)：
runcfg.labels.working_directory=工作目錄(&W):
runcfg.captions.script_parameters_dialog=輸入腳本參數
runcfg.captions.interpreter_options_dialog=輸入解釋器選項
runcfg.labels.python.interpreter=Python 解釋器(&P)：
runcfg.labels.add.content.roots.to.pythonpath=將內容根添加到 PYTHONPATH
runcfg.labels.add.source.roots.to.pythonpath=將源根添加到 PYTHONPATH
runcfg.labels.path.mappings=路徑映射
runcfg.labels.project=專案(&J):
runcfg.labels.script.path=腳本路徑
runcfg.labels.module.name=模塊名稱
runcfg.labels.custom.name=自定義
runcfg.labels.execution=執行
python.sdk.error.invalid.interpreter.name=Python 解釋器名稱 ''{0}'' 無效!
sdk.select.path=選擇 Python 解釋器
runcfg.unittest.dlg.pattern=模式:

runcfg.testing.no.test.framework=在所選解釋器中未找到 {0} 執行程序

runcfg.error.message.failed.to.find.free.socket.port=找不到可用的套接字端口
runcfg.error.message.cannot.find.python.interpreter=找不到此執行配置的 Python 解釋器

# Consoles messages
python.console=Python 控制台
python.console.history.root=Python 控制台
python.console.run.anything.provider=執行 Python 控制台
python.console.not.supported=不支持 {0} 解釋器的 Python 控制台

#Buildout
runcfg.unittest.dlg.test_function_title=函數
run.configuration.remote.debug.name=Python 遠端調試
run.configuration.remote.debug.visible.name=Python 調試伺服器
run.configuration.type.description=啟動伺服器進行遠端調試
run.configuration.show.command.line.action.name=顯示調試控制台

unable.to.stop=無法停止當前正在執行的進程。先手動終止此進程。

#Debug

debug.popup.title.step.into.function=單步進入函數

debug.notification.group=Python 調試器
debug.notification.title.connection.failed=連接 Python 調試器失敗

remote.debug.server.hint=啟動此調試配置以啟動調試伺服器。
remote.debug.server.hint1.5=更新腳本：
remote.debug.server.hint2=1. 將 pydevd-pycharm.egg 從 PyCharm 安裝目錄添加到 Python 路徑或執行：
remote.debug.server.hint3=pip 安裝 pydevd-pycharm
remote.debug.server.hint4=2. 添加以下命令以連接至調試伺服器：
remote.debug.port=端口:
remote.debug.local.host=IDE 主機名：
remote.debug.redirect.output=將輸出重定向到控制台
remote.debug.suspend.on.connect=連接後掛起

# Debug VFS

python.debug.remote.name=PyRemoteDebug
filetype.python.debug.remote.description=遠端調試

python.sdk.getting.remote.interpreter.version=正在獲取遠端解釋器版本
python.sdk.directory.macro.description=此目錄包含為專案選擇的 Python 解釋器
python.sdk.scanning.installed.packages=正在掃描已安裝的軟件包…
python.sdk.updater.notifications.group.title=Python SDK 更新程序
python.sdk.updating.skeletons=正在更新框架…
python.sdk.unpacking.pre.generated.skeletons=正在解壓縮預生成的框架…
python.sdk.popup.interpreter.settings=解釋器設定…
python.sdk.popup.add.interpreter=添加解釋器…
python.sdk.switch.to=切換到 {0}
python.sdk.installing=正在安裝 {0}
python.sdk.downloading=下載中{0}
python.sdk.running=正在執行 {0}
python.sdk.installing.windows.warning=Windows 可能需要您批准後才能安裝 Python。請檢查任務欄。
python.sdk.select.conda.path.title=選擇 Conda 可執行檔案路徑
python.sdk.conda.path=Conda 可執行檔案：
python.sdk.select.location.for.conda.title=選擇 Conda 環境的位置
python.sdk.environment.yml.chooser=選擇 environment.yml
python.sdk.environment.yml.label=environment.yml
python.sdk.creating.conda.environment.sentence=創建 Conda 環境
python.sdk.creating.conda.environment.title=正在創建 Conda 環境
python.sdk.add.python.interpreter.title=添加 Python 解釋器
python.sdk.python.interpreter.title.0=Python 解釋器: {0}
python.sdk.new.environment.kind=新 {0} 環境
python.sdk.next=下一個
python.sdk.previous=上一個
python.sdk.finish=完成
python.sdk.setting.up.pipenv.sentence=正在設定 pipenv 環境
python.sdk.setting.up.pipenv.title=正在設定 Pipenv 環境
python.sdk.install.requirements.from.pipenv.lock=Pipfile.lock 中的安裝要求
python.sdk.pipenv.executable.not.found=找不到 Pipenv 可執行檔案
python.sdk.pipenv.executable=Pipenv 可執行檔案：
python.sdk.pipenv.select.executable.title=選擇 Pipenv 可執行檔案的路徑
python.sdk.pipenv.associated.project=關聯專案:
python.sdk.pipenv.associated.module=關聯模塊:
python.sdk.pipenv.execution.exception.no.project.message=無法找到與此 Pipenv 環境關聯的專案
python.sdk.pipenv.execution.exception.no.pipenv.message=無法找到 Pipenv
python.sdk.pipenv.execution.exception.error.running.pipenv.message=執行 Pipenv 時出錯
python.sdk.pipenv.quickfix.fix.pipenv.name=修復 Pipenv 解釋器
python.sdk.pipenv.quickfix.use.pipenv.name=使用 Pipenv 解釋器
python.sdk.pipenv.pip.file.lock.not.found=找不到 Pipfile.lock
python.sdk.pipenv.pip.file.lock.out.of.date=Pipfile.lock 過期
python.sdk.pipenv.pip.file.notification.content=執行 <a href='#lock'>pipenv lock</a> 或 <a href='#update'>pipenv update</a>
python.sdk.pipenv.pip.file.notification.locking=正在鎖定 Pipfile
python.sdk.pipenv.pip.file.notification.updating=正在更新 Pipenv 環境
python.sdk.pipenv.pip.file.watcher=Pipfile 觀察程序

python.sdk.file.not.found=找不到檔案 {0}
python.sdk.cannot.execute=無法執行 {0}
python.sdk.pipenv.has.been.selected=已添加 Pipenv 解釋器，選擇解釋器列表中的 ''{0}''
python.sdk.there.is.no.interpreter=無解釋器
python.sdk.no.interpreter.configured.warning=未為此專案配置 Python 解釋器
python.sdk.no.interpreter.selection=未選擇 Python 解釋器
python.sdk.choose.valid.interpreter=選擇有效的 Python 解釋器
python.sdk.common.options.environment=環境
python.sdk.rendering.project.default=專案預設設定
python.sdk.rendering.project.default.0=專案預設值 ({0})
python.sdk.failed.to.install.title=無法安裝 {0}
python.sdk.installation.has.been.cancelled.title={0} 安裝已被取消
python.sdk.directory.not.found=找不到目錄 {0}
python.sdk.failed.to.create.interpreter.title=無法創建解釋器
python.sdk.can.t.obtain.python.version=無法獲取 Python 版本
python.sdk.executable.not.found.header=找不到 Python 可執行檔案。選擇以下選項之一:
python.sdk.executable.not.found.option.specify.path=點擊 {0} 以指定 python.exe 在檔案系統中的路徑
python.sdk.executable.not.found.option.download.and.install=點擊 {0} 從 python.org 下載並安裝 Python ({1})
python.sdk.admin.permissions.needed.consider.creating.venv=<html><strong>注</strong>: 您需要具備管理員權限才能為此解釋器安裝軟件包。不妨改為按專案創建虛擬環境。</html>
python.sdk.try.to.install.python.manually=嘗試從 https://www.python.org 手動安裝 Python。
python.sdk.consider.installing.python.manually=不妨從 https://www.python.org 手動安裝 Python。
python.sdk.some.installed.python.components.might.get.inconsistent.after.cancellation=取消後，某些已安裝的 Python 組件可能會變得不一致。
python.sdk.failed.to.install.timed.out=已超時
python.sdk.failed.to.install.exit.code=退出程式碼 {0}
python.sdk.invalid.python.sdk=無效的 Python SDK
python.sdk.cannot.setup.sdk=無法\n\
在 {0} 設定 python SDK。\n\
此 SDK 似乎無效。

# SDK / skeletons
sdk.some.skeletons.failed=無法生成某些框架
sdk.gen.cleaning.up=正在清理框架…
sdk.gen.launching.generator=正在啟動框架生成器…
sdk.gen.reloading=正在重新載入生成的框架…
sdk.gen.unpacking.prebuilt=正在解壓縮預構建框架…
sdk.gen.updating.interpreter=正在更新 Python 解釋器
sdk.scanning.installed.packages=正在掃描已安裝的軟件包
sdk.gen.stubs.for.binary.modules=生成二進制模塊 {0} 的存根
sdk.gen.failed.notification.title=無法刷新遠端解釋器的框架
sdk.gen.cannot.create.skeleton.dir=無法創建框架目錄 {0}
sdk.updating.interpreter.paths=正在更新解釋器路徑…
sdk.updating.interpreter.version=正在更新解釋器版本…

# Active SDK configurable and related dialogs
active.sdk.dialog.show.all.item=全部顯示…
active.sdk.dialog.project.interpreter=Python 解釋器：
active.sdk.dialog.project.interpreter.path.mappings=路徑映射：
active.sdk.dialog.project.interpreter.path.mappings.default.project.error=打開或創建專案以配置映射

sdk.details.step.add=添加…
sdk.details.step.show.all=全部顯示…

sdk.details.dialog.title=Python 解釋器
sdk.details.dialog.hide.all.virtual.envs=隱藏與其他專案關聯的虛擬環境
sdk.details.dialog.show.interpreter.paths=顯示所選解釋器的路徑
sdk.details.dialog.error.duplicate.name=為解釋器指定唯一名稱

sdk.edit.dialog.title=編輯 Python 解釋器
sdk.edit.dialog.associate.virtual.env.with.path=關聯此虛擬環境與 {0}
sdk.edit.dialog.associate.virtual.env.current.project=關聯此環境與當前專案
sdk.edit.dialog.specify.interpreter.path=指定解釋器路徑

sdk.paths.dialog.title=解釋器路徑
sdk.paths.dialog.reload.paths=重新載入路徑列表
sdk.paths.dialog.added.by.user.suffix=（使用者已添加）
sdk.paths.dialog.removed.by.user.suffix=（使用者已移除）

sdk.create.venv.dependencies.label=依賴項:
sdk.create.venv.dependencies.chooser=選擇 requirements.txt 或 setup.py

sdk.create.venv.dialog.label.inherit.global.site.packages=繼承全域站點軟件包
sdk.create.venv.conda.dialog.label.location=位置:
sdk.create.venv.conda.dialog.label.python.version=Python 版本:

# remote interpreters
remote.interpreter.configure.title=配置遠端 Python 解釋器
remote.interpreter.configure.path.title=選擇 Python 解釋器
remote.interpreter.configure.temp.files.path.title=為 PyCharm 幫助程序選擇資料夾
remote.interpreter.default.interpreter.path=/usr/bin/python
remote.interpreter.wsl.default.interpreter.path=/usr/bin/python
remote.interpreter.docker.default.interpreter.path=python
remote.interpreter.unspecified.interpreter.path=指定 Python 解釋器路徑
remote.interpreter.unspecified.temp.files.path=為 PyCharm 幫助程序指定路徑
remote.interpreter.configure.path.label=Python 解釋器路徑：
remote.interpreter.configure.temp.files.path.label=PyCharm 幫助程序路徑：
remote.interpreter.configure.ssh.run_as_root_via_sudo.checkbox=使用此解釋器通過 sudo 以根權限執行程式碼
remote.interpreter.configure.ssh.run_as_root_via_sudo.help=僅在通過 SSH 連接啟動遠端解釋器時才調用 Sudo。這些檔案將通過使用者權限被複製到遠端伺服器。
remote.interpreter.unsupported.python.sdk.type=不受支援的 Python SDK 類型
remote.interpreter.support.is.not.available={0} 支援不可用。\n\
請檢查相應套件。
remote.interpreter.remote.server.permissions=無法瀏覽遠端伺服器。確保您具備權限。
remote.interpreter.accessing.remote.interpreter.progress.title=正在訪問遠端解釋器

# CommandLine
commandLine.inspection.name=不正確的 CLI 語法
commandLine.inspection.badCommand=命令錯誤或未知。確保存在此命令。
commandLine.inspection.badOption=選項錯誤或未知。確保存在此選項。
commandLine.inspection.badArgument=實參不能具有此值。使用自動補全檢查可能的值的列表。
commandLine.inspection.excessArgument=實參過多或此處無法使用實參
# What to display of user entered junk
commandLine.commandNotFound={0}：找不到命令

# Window with actions
# "X" button title
windowWithActions.closeWindow=關閉視窗
# "Stop" button title
windowWithActions.stopProcess=停止當前執行的進程

formatter.imports.panel.title=導入
formatter.imports.panel.optimize.imports=優化 import
formatter.imports.panel.sort.imports=對 import 語句排序
formatter.imports.panel.sort.names.in.from.imports=對 "from" 導入中的導入名稱排序
formatter.imports.panel.from.imports.structure.title="from" 導入結構
formatter.imports.panel.from.imports.leave.as.is=保持原樣
formatter.imports.panel.from.imports.join.with.same.source=使用相同的源聯接導入
formatter.imports.panel.from.imports.always.split=始終拆分導入
formatter.imports.panel.sort.by.type=在組中分別對 plain 導入和 "from" 導入進行排序
formatter.imports.panel.sort.case.insensitively=不區分大小寫排序

formatter.panel.dict.alignment.label=字典對齊：
formatter.panel.add.trailing.line.feed=在檔案末尾添加換行

formatter.panel.use.continuation.indent.for.title=為此內容使用繼續縮進
formatter.panel.use.continuation.indent.for.parameters=方法聲明參數
formatter.panel.use.continuation.indent.for.arguments=方法調用實參
formatter.panel.use.continuation.indent.for.collection.literals=集合和推導

formatter.left.bracket = 左中括號
formatter.around.eq.in.named.parameter = 在命名參數中的 = 周圍
formatter.around.eq.in.keyword.argument = 在關鍵字實參中的 = 周圍
formatter.braces = 大括號
formatter.before.backslash = '\' 之前
formatter.before.hash = '#' 之前
formatter.after.hash = '#' 之後
formatter.around.top.level.imports = 在頂層導入後：
formatter.after.local.imports=在本地導入後面：
formatter.before.first.method=在第一個方法前面：
formatter.around.top.level.classes.and.function=圍繞頂層類和函數：
formatter.around.multiplicative.operators=乘法運算符 (*, @, /, %)
formatter.around.power.operator=冪運算符 (**)
formatter.single.clause.statements=單子句語句
formatter.multi.clause.statements=多子句語句
formatter.force.new.line.after.colon=在冒號後強制換行
formatter.align.when.multiline=多行時對齊
formatter.collections.and.comprehensions=集合和推導
formatter.from.import.statements="From" Import 語句
formatter.from.import.statements.force.parentheses.if.multiline=如有多行，強制使用括號
formatter.from.import.statements.force.comma.if.multline=如有多行，強制使用尾隨逗號
formatter.dictionary.literals=字典文字
formatter.hang.closing.brackets=掛起右中括號

smartKeys.insert.backslash.in.statement.on.enter=在語句內按 Enter 時插入反斜杠
smartKeys.insert.self.in.method=定義方法時插入 'self'
smartKeys.insert.type.placeholder.in.docstring.stub=在文檔註釋存根中插入類型佔位符

show.expression.type.no.expression.found=找不到表達式
remote.interpreter.failed.to.obtain.credentials=無法獲取 Python SDK {0} 的連接憑據

action.SetNextStatement.text=跳轉到游標(&J)
action.SetNextStatement.description=跳轉到文本游標所在的行
action.StepIntoMyCode.text=單步執行我的程式碼
action.StepIntoMyCode.description=跳到已執行的下一行，並忽略庫
action.PyConvertPackageToModuleAction.text=轉換為 Python 模塊
action.PyConvertPackageToModuleAction.description=創建同名模塊，並將 __init__.py 的內容移至該模塊
action.PyConvertModuleToPackage.text=轉換為 Python 軟件包
action.PyConvertModuleToPackage.description=創建同名的軟件包，並將模塊內容移至其 __init__.py
action.PyDebugger.ViewAsGroup.text=作為...查看
action.PyDebugger.ViewArray.text=作為數組查看
action.PythonGenerateDictionaries.text=生成 Python 拼寫檢查器字典
group.PyPackagingMenu.text=打包
action.CleanPyc.text=清除 Python 編譯檔案
action.CleanPyc.description=刪除所選目錄及其子目錄中已編譯的字節碼檔案
action.CleanPyc.status.bar.text.deleted.bytecode.files=已刪除 {0} 個字節碼{0, choice, 0#檔案|1#檔案|2#檔案}
action.CleanPyc.progress.title.cleaning.up.pyc.files=正在清理 .pyc 檔案…
action.PySyncPythonRequirements.text=同步 Python 要求…
action.PySyncPythonRequirements.description=同步 Python 要求檔案與專案中使用的軟件包
action.CompuleQrc.text=編譯 .qrc 檔案
action.NewPythonPackage.text=Python 軟件包
action.NewPythonPackage.description=在其中創建新目錄和 __init__.py
action.PyConsoleRenameAction.text=重命名控制台
action.ExecuteInPyConsoleAction.text=在控制台中執行所選內容
action.ExecuteInPyConsoleAction.description=在 Python/Django 控制台中執行選定的程式碼段
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.text=Python 或調試控制台
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.description=允許在執行調試會話時快速執行 Python 控制台或調試控制台
action.ForceStepInto.text=強制單步執行 (_R)
action.ForceStepInto.description=步入，忽略庫、構造函數等步進篩選器。
configurable.PyConsoleOptionsConfigurable.display.name=控制台
configurable.PyConsoleOptionsConfigurable.child.display.name=Python 控制台
configurable.PySmartKeysOptions.display.name=Python
configurable.PyContentEntriesModuleConfigurable.display.name=專案結構
configurable.PythonContentEntriesConfigurable.display.name=專案結構
configurable.PyDependenciesConfigurable.display.name=專案依賴項
configurable.PyIntegratedToolsConfigurable.display.name=Python 集成工具
configurable.PyIntegratedToolsModulesConfigurable.display.name=Python 集成工具
configurable.PythonSdkEditorTab.display.name=Python SDK
configurable.PyDebuggerConfigurable.display.name=Python 調試器
configurable.PyActiveSdkModuleConfigurable.python.interpreter.display.name=Python 解釋器
configurable.PyLanguageCodeStyleSettingsProvider.display.name=Python
flask.name=Flask
settings.default.remote.interpreter=預設 Python 遠端解釋器
action.DumbAware.PydevConsoleRunnerImpl.text.stop.console=停止控制台
action.DumbAware.PydevConsoleRunnerImpl.description.stop.python.console=停止 Python 控制台
action.DumbAware.ConcurrencyToolWindowPanel.text.stop.process=停止進程
action.DumbAware.ConcurrencyToolWindowPanel.description.stop.process=停止進程
action.AnActionButton.text.use.conda.package.manager=使用 Conda 軟件包管理器
action.AnActionButton.text.show.early.releases=顯示早期版本
action.PyManagePackages.text=管理 Python 軟件包…
action.RunPythonToolwindowAction.text=Python 控制台

# qt actions
qt.error.failed.run.qt.designer=無法執行 Qt 設計器：{0}
qt.qrc.compiler.select.output.path=選擇輸出目錄:
qt.qrc.compile.files=編譯 {0} .qrc 檔案
qt.qrc.compile=編譯 {0}
qt.compile.qrc.file=編譯 .qrc 檔案
qt.run.tab.title.compile.qrc=編譯 .qrc
qt.run.error=執行 {0} 出錯：{1}
qt.cannot.find.pyrcc4.or.pysidercc=找不到所選 Python 解釋器的 pyrcc4 或 pyside-rcc
qt.run.designer.error=錯誤
qt.ui.designer.form.filetype.description=Qt UI Designer 窗體
qt.ui.designer.form.filetype.display.name=Qt UI Designer 窗體

python.module.name=Python 模塊
python.module.description=Python 模塊用於開發 <b>Python</b> 應用程序。
python.module.description.extended=支援的技術包括 <b>Django、Google App Engine、Jinja2</b> 等。

action.create.python.file.title=Python 檔案
action.create.python.file.description=從指定的模板創建 Python 檔案
acton.run.file.in.python.console.title=執行 Python 控制台中的檔案
action.run.file.in.python.console.description=執行 Python 控制台中的當前檔案


code.insight.goto.superclass.attribute.chooser.title=選擇超類特性

code.insight.select.methods.to.override=選擇要重寫的方法
code.insight.select.methods.to.implement=選擇實現的方法
code.insight.stub.package.advertiser.notifications.group.title=Python 存根軟件包廣播程序
code.insight.create.test=創建測試
code.insight.select.target.directory=選擇目標目錄
code.insight.encoding.comment.format=編碼註釋格式：
code.insight.select.default.encoding=選擇預設編碼： 
code.insight.stub.forced.packages.are.not.installed.message=存根{0,choice,1#軟件包|2#軟件包} {1} {0,choice,1#未|2#未}安裝。{0,choice,1#它|2#它們}{0,choice,1#包含|2#包含}提升程式碼洞察所需的類型提示。
code.insight.stub.checked.packages.are.not.installed.message=存根{0,choice,1#軟件包|2#軟件包} {1} {0,choice,1#未|2#未}安裝。
code.insight.stub.packages.ignored.notification.content=建議的 {0} {1,choice,1#與|2#與}您的當前環境不相容。\n\
{1,choice,1#此|2#這些}存根{1,choice,1#軟件包|2#軟件包}將被移除和忽略，直到新版本發佈。
code.insight.stub.packages.install.requirements.fix.name=安裝存根{0,choice,1#軟件包|2#軟件包}
code.insight.type.hints.are.not.installed=未安裝類型提示
code.insight.install.type.hints.content=它們可以使程式碼洞察更出色。
code.insight.install.type.hints.action=安裝存根軟件包
code.insight.ignore.type.hints=忽略
code.insight.ignore.packages.qfix=忽略 {0,choice, 1#軟件包|2#軟件包}
configurable.pipenv.auto.detected=已自動檢測：{0}
configurable.choose.path.to.the.package.requirements.file=選擇軟件包要求檔案的路徑:
configurable.choose.working.directory=選擇工作目錄:
configurable.select.working.directory=選擇工作目錄

console.waiting.execution.result=正在等待執行結果
console.getting.from.runtime=正在從 Python 執行時獲取{0}
console.getting.completion=補全
console.getting.documentation=文檔
console.getting.frame.variables=框架變數
console.getting.variable.value=變量值
console.getting.array=數組
console.getting.table.data=表資料
console.evaluating.expression.in.console=正在控制台中評估表達式
console.connecting.to.debugger=正在連接到調試器
console.changing.variable=正在更改變數
console.interrupting.execution=正在中斷執行
console.close.console.communication=關閉控制台通信
console.executing.code.in.console=正在控制台中執行程式碼…
console.new.console.description=創建新的 python 控制台
console.new.console=新建控制台
console.error.connecting.debugger=連接調試器出錯
console.cannot.connect.to.debugger=無法連接到調試器
console.attach.debugger.description=對控制台中執行的程式碼啟用追踪
console.attach.debugger=附加調試器
console.restarting.console=正在重啟控制台
console.stopping.console=正在停止控制台
connecting.to.console.progress=正在連接到控制台…
connecting.to.console.title=連接控制台
console.show.variables.title=顯示變數
console.show.variables.description=顯示活動控制台變數
console.executing.dataviewer.command="正在執行 DataViewer 命令"
console.table.failed.to.load=無法載入:

form.debugger.save.call.signatures=保存調用簽名

compile.cython.extensions.title=編譯 Cython 擴展
compile.cython.extensions.help=運作方式
compile.cython.extensions.install=安裝
compile.cython.extensions.notification=Python 調試器擴展可用
compile.cython.extensions.error=編譯 Cython 擴展錯誤

create.python.file.action.new.python.file=新建 Python 檔案
create.python.file.action.python.file=Python 檔案
create.python.file.action.python.unit.test=Python 單元測試
create.python.file.action.python.stub=Python 存根
create.python.file.script.action=創建 Python 腳本 {0}

debugger.attach.to.process.filter.names=<html>為<b>附加到進程</b>顯示名稱中包含這些內容的進程：</html>
debugger.attach.to.process.failed.to.find.free.socket.port=找不到可用的套接字端口
debugger.watch.return.values.description=啟用監視，以查看所執行函數返回的值
debugger.exception.breakpoint.ignore.library.files=忽略庫檔案
debugger.exception.breakpoint.on.raise=引發時
debugger.exception.breakpoint.on.termination=終止時
debugger.exception.breakpoint.type=Python 異常斷點
debugger.exception.breakpoint.activation.policy=啟用策略
debugger.exception.breakpoint.any.exception=任何異常
debugger.line.breakpoint.type=Python 行斷點
debugger.delete.signature.cache=刪除緩存
debugger.simplified.view.description=禁用監視類、函數和模塊對象
debugger.simplified.view.text=簡化變數視圖
debugger.data.view.colored=已著色
debugger.data.view.close.selected.viewer=關閉所選查看器
debugger.data.view.close.viewer=關閉查看器
debugger.data.view.open.new.container.viewer=打開新容器查看器
debugger.data.view.view.new.container=查看新容器
debugger.data.view.data=資料
debugger.data.view.close=關閉
debugger.data.view.resize.automatically=自動調整大小
debugger.data.view.colored.cells=已著色單元
debugger.data.view.failed.to.evaluate.expression=無法評估表達式 {0}
debugger.data.view.type.is.not.supported=不支持 {0}
debugger.data.view.empty.tab=空
debugger.numeric.view.as.dataframe=作為 DataFrame 查看
debugger.numeric.view.as.array=作為數組查看
debugger.numeric.view.as.series=作為系列查看
debugger.stepping.filter=步進篩選器
debugger.stepping.filter.specify.pattern=指定 glob 模式（允許使用 '*'、'?' 和 '[seq]'，分號 ';' 用作名稱分隔符）：
debugger.stepping.no.script.filters=未配置腳本篩選器
debugger.sending.close.message=正在向 Python 控制台發送關閉消息…
debugger.waiting.to.finish=正在等待 Python 控制台進程結束…
debugger.variables.loading.policy=變數載入策略
debugger.variables.loading.synchronously.text=同步
debugger.variables.loading.synchronously.description=同步載入變量值
debugger.variables.loading.asynchronously.text=異步
debugger.variables.loading.asynchronously.description=異步載入變量值
debugger.variables.loading.on.demand.text=按需
debugger.variables.loading.on.demand.description=按需載入變量值
debugger.variables.view.loading.timed.out=載入超時
debugger.variables.view.switch.to.loading.on.demand=切換為按需載入
debugger.variables.view.warning.message=無法載入多個變數的值  
debugger.exception.breakpoint.select.exception.class=選擇異常類
debugger.watch.show.return.values=顯示返回值
debugger.data.view.connected.to.python.console=已連接到 Python 控制台
debugger.data.view.connected.to.debug.session=已連接到調試會話 ''{0}''
debugger.data.view.empty.text=執行 Python 控制台或調試器以查看可用資料
debugger.stack.frame.special.variables=特殊變數
debugger.stack.frame.return.values=返回值
debugger.stack.frame.frame.not.available=<框架不可用>
debugger.stack.frame.unable.to.display.frame.variables=無法顯示框架變數
debugger.stack.frames.not.available.in.non.suspended.state=框架在未掛起的狀態下不可用
debugger.test.failed.caption=測試失敗
debugger.error.in.test.setup.or.teardown.caption=設定或刪除測試時出錯
debugger.remote.port.out.of.boundaries=端口號超出界限

debugger.dataviewer.action.export.name=導出…
debugger.dataviewer.action.export.dialog.description=保存到
debugger.dataviewer.export.error.title=表導出失敗
debugger.dataviewer.export.error.invalid.filepath=無效檔案路徑
debugger.dataviewer.export.error.invalid.filepath.content=檔案路徑 ''{0}'' 無效
debugger.dataviewer.export.error.unhandled=未處理的錯誤
debugger.dataviewer.export.error.unhandled.content=無法導出到 ''{0}'':\n\
{1}
debugger.dataviewer.notification.group.title=資料查看器錯誤
debugger.dataviewer.action.copy.name=複製
debugger.dataviewer.action.set.filter.name=設定篩選器…
debugger.dataviewer.action.set.filter.description=篩選列 ''{0}''
debugger.dataviewer.action.set.filter.use.regex=使用正則表達式
debugger.dataviewer.action.set.filter.button.set=設定
debugger.dataviewer.action.set.filter.item.expression=表達式
debugger.dataviewer.action.set.filter.item.substring=子字串
debugger.dataviewer.action.set.filter.help.expression=<html>使用 <b>{0}</b> 作為 lambda 函數的變數</html>
debugger.dataviewer.action.set.filter.ad.controls=按 Enter 鍵應用
debugger.dataviewer.action.goto.dialog.title=轉到
debugger.dataviewer.action.goto.dialog.label=行:列
debugger.dataviewer.action.copy.properties.name=複製到剪貼簿設定
debugger.dataviewer.action.copy.properties.dialog.title=複製到剪貼簿設定
debugger.dataviewer.action.copy.properties.include.header=包含標頭
debugger.dataviewer.action.copy.properties.include.indices=包含索引
debugger.dataviewer.action.copy.properties.separator=分隔符:
debugger.dataviewer.action.copy.update.message=複製到剪貼簿
debugger.dataviewer.action.remove.filter.name=移除篩選器
debugger.dataviewer.action.open.in.editor.name=在編輯器頁籤中打開
debugger.dataviewer.modifier.error=修飾符錯誤: {0}
debugger.dataviewer.header.filter.hint={0}: {1}
debugger.dataviewer.header.filter.hint.mode.expression=表達式
debugger.dataviewer.header.filter.hint.mode.regex=正則表達式
debugger.dataviewer.header.filter.hint.mode.substring=子字串

debugger.remote.waiting.for.process.connection=正在等待進程連接…
debugger.remote.waiting.for.connection=正在等待連接
debugger.cython.python.run.configuration.should.be.selected=應選擇 Python 執行配置
debugger.cython.extension.speeds.up.python.debugging=Cython 擴展加速 Python 調試
debugger.cython.extension.permission.denied=權限被拒絕
debugger.cython.extension.non.zero.exit.code=非零退出程式碼 ({0}):\n\
{1}
debugger.cython.please.enter.your.password.to.compile.cython.extensions=請輸入密碼以編譯 cython 擴展:
debugger.warning.message=此選項可能會減慢調試器的速度
debugger.connected.to.pydev.debugger.build=已連接到 pydev 調試器(內部版本號 {0})
debugger.warning.wrong.debugger.version=警告: 調試器版本錯誤。使用 PyCharm 安裝資料夾中的 pycharm-debugger.egg\n\
或執行: ''pip install pydevd-pycharm~=%{0}''
debugger.pydev.console.pause.the.process.to.use.command.line=暫停進程以使用命令行。
debugger.debug.process.running=進程正在執行
debugger.remote.starting.debug.server.at.port=正在端口 {0} 上啟動調試伺服器
debugger.use.the.following.code.to.connect.to.the.debugger=使用以下程式碼連接到調試器: 

python.local.attach.group.name=Python

pydev.console.runner.settings=設定
pydev.console.runner.error.running.console=執行控制台出錯
pydev.console.runner.python.console.debugger=Python 控制台調試器
pydev.console.runner.unknown.error=未知錯誤
pydev.console.console.process.terminated.with.error=控制台進程因錯誤而終止：\n\
{0}{1}
pydev.console.console.process.terminated.with.exit.code=控制台進程終止，退出程式碼為 {0}，輸出：{1}
pydev.console.couldnt.connect.to.console.process=無法連接到控制台進程。
pydev.console.debugger.connected=\n\
調試器已連接。\n\

pydev.console.couldnt.read.integer.value.from.stream=無法讀取流中的整數值
pydev.console.python.interpreter.is.not.selected=未選擇 Python 解釋器。請先安裝 Python 解釋器。

external.documentation.python.plugin=Python 外部文檔
external.documentation.pycharm=外部文檔
external.documentation.edit.documentation.url=編輯文檔 URL
external.documentation.title=Python 外部文檔
external.documentation.configure.description=模塊 {0} 未配置外部文檔 URL。\n\
要立即配置嗎?
external.documentation.column.name.module=模塊名稱
external.documentation.column.name.url.path.pattern=URL/路徑模式


python.colors.python=Python
python.colors.type.annotation=類型註解
python.colors.class.definition=類定義
python.colors.decorator=裝飾器
python.colors.built.in.name=內置名稱
python.colors.special.names.usage=特殊名稱//用法
python.colors.special.names.definition=特殊名稱//定義
python.colors.keyword.argument=關鍵字實參
python.colors.parameters.self.parameter=參數//'self' 參數
python.colors.parameters.parameter=參數//參數
python.colors.functions.method.call=函數//方法調用
python.colors.functions.nested.function.definition=函數//嵌套函數定義
python.colors.functions.function.call=函數//函數調用
python.colors.functions.function.definition=函數//函數定義
python.colors.braces.and.operators.dot=大括號和運算符//點
python.colors.braces.and.operators.comma=大括號和運算符//逗號
python.colors.braces.and.operators.braces=大括號和運算符//大括號
python.colors.braces.and.operators.brackets=大括號和運算符//中括號
python.colors.braces.and.operators.parentheses=大括號和運算符//圓括號
python.colors.braces.and.operators.operation.sign=大括號和運算符//運算符號
python.colors.docstring.tag=Docstring//標籤
python.colors.docstring.text=Docstring//文本
python.colors.string.f.string.format.specifier.start=字串//格式化字串//格式說明符開始
python.colors.string.f.string.type.conversion=字串//格式化字串///類型轉換
python.colors.string.f.string.expression.braces=字串//格式化字串///表達式大括號
python.colors.string.escape.sequence.invalid=字串//轉義序列//無效
python.colors.string.escape.sequence.valid=字串//轉義序列//有效
python.colors.string.text.unicode=字串//文本 (unicode)
python.colors.string.binary.bytes=字串//二進制（字節）
python.colors.line.comment=行註釋
python.colors.keyword=關鍵字
python.colors.number=數字

python.new.project.synchronization.not.configured.dialog.title=未配置同步
python.new.project.synchronization.not.configured.dialog.message=本地/遠端同步配置不正確。\n\
{0}\n\
您可能需要手動同步本地專案和遠端專案。\n\
\n\
是否繼續?\n\
\n\
選擇 ''是'' 將保留配置不當的映射，選擇 ''否'' 將開始手動配置過程。

python.new.project.remote.path.not.provided=未提供遠端路徑
python.new.project.more.settings=更多設定(&E)
python.new.project.install.failed.title=安裝 {0} 失敗
python.new.project.error.solution.another.sdk=選擇另一個 SDK

python.project.view.remote.libraries=遠端庫
python.project.view.py.skeletons=二進制框架
python.project.view.typeshed.stubs=Typeshed 存根
python.project.view.user.skeletons.node=擴展定義

python.packaging.installing.packaging.tools=正在安裝打包工具…
python.packaging.installing.packages=正在安裝軟件包…
python.packaging.warning=警告
python.packaging.create.setup.py=創建 setup.py
python.packaging.failed.to.run.task=無法執行任務：{0}
python.packaging.run.setup.py.task=執行 setup.py 任務…
python.packaging.expand.options=展開選項 >>
python.packaging.collapse.options=<< 收起選項
python.packaging.run.setup.task.0=執行安裝任務 {0}
python.packaging.enter.setup.py.task=輸入 setup.py 任務名稱
python.packaging.no.tasks.found=找不到任務
python.packaging.command.line=命令行
python.packaging.install=安裝
python.packaging.choose.packages.to.install=選擇要安裝的軟件包
python.packaging.removing.conda.channel=移除 Conda 通道
python.packaging.adding.conda.channel=添加 Conda 通道
python.packaging.failed.to.install.packaging.tools.title=無法安裝 Python 打包工具
python.packaging.install.packaging.tools=安裝打包工具

# Example of produced message:
#    You are attempting to uninstall MarkupSafe package which is required for Jinja2 package
#
#    Do you want to proceed?
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package.single.package.description={1} 需要 {0} 軟件包
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package=您將要移除 {0} {1, choice, 1#軟件包|2#軟件包}\n\
\n\
是否繼續?

# Example of produced message:
#    You are attempting to uninstall packages which are required for another packages.
#
#    Jinja2 -> Flask
#    muffin -> muffin-jinja2
#
#    Do you want to proceed?
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages.single.package.description={0} -> {1}
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages=您將要移除其他軟件包所需的軟件包。\n\
\n\
{0}\n\
\n\
是否繼續?

python.packaging.notification.description.details.link=詳細資訊…
python.packaging.notification.description.installed.all.requirements=已安裝所有要求
python.packaging.notification.description.installed.packages=已安裝軟件包: {0}
python.packaging.notification.description.installed.python.packaging.tools=已安裝 Python 打包工具
python.packaging.notification.description.uninstalled.packages=已移除軟件包: {0}
python.packaging.notification.title.error.occurred={0}: 發生錯誤。
python.packaging.notification.title.install.packages.failed=安裝軟件包失敗
python.packaging.notification.title.packages.installed.successfully=已成功安裝軟件包
python.packaging.notification.title.packages.uninstalled.successfully=已成功移除軟件包
python.packaging.notification.title.uninstall.packages.failed=移除軟件包失敗
python.packaging.progress.text.installing.specific.package=正在安裝軟件包 ''{0}''…
python.packaging.progress.title.installing.packages=正在安裝軟件包
python.packaging.progress.title.uninstalling.packages=正在移除軟件包
python.packaging.failed.to.install.packages.title=無法安裝軟件包

python.unresolved.reference.inspection.install.package=安裝軟件包 {0}

# UI forms

form.qt.compile.qrc.output.file=輸出檔案：
form.auto.import.from.module.import.name=從 <module> 導入 <name>
form.auto.import.import.module.name=導入 <module>.<name>
form.auto.import.preferred.import.style=首選的導入樣式：
form.auto.import.python=Python
form.auto.import.auto.import.show.popup=顯示自動導入工具提示
form.create.test.target.directory=目標目錄
form.create.test.test.class.name=測試類名
form.create.test.test.file.name=測試文件名
form.edit.sdk.associate.this.virtual.environment.with.current.project=將此虛擬環境與當前專案關聯(&A)
form.edit.sdk.interpreter.path=解釋器路徑(&I):
form.edit.sdk.label.create.connection.pool.options.name=名稱(&N):
form.edit.sdk.html.href.remove.association=<html><a href=\"#\">移除關聯</a>
form.edit.smart.indent.pasted.lines=智能縮進貼上行
form.integrated.tools.analyze.python.code.in.docstrings=分析 docstring 中的 Python 程式碼
form.integrated.tools.default.test.runner=預設測試執行程序：
form.integrated.tools.docstring.format=Docstring 格式：
form.integrated.tools.package.requirements.file=軟件包要求檔案：
form.integrated.tools.path.to.pipenv.executable=Pipenv 可執行檔案路徑：
form.integrated.tools.render.external.documentation.for.stdlib=渲染 stdlib 的外部文檔
form.integrated.tools.sphinx.working.directory=Sphinx 工作目錄：
form.integrated.tools.treat.txt.files.as.restructuredtext=將 *.txt 檔案視為 reStructuredText
form.console.options.always.show.debug.console=始終顯示調試控制台
form.console.options.settings.title.system.settings=常規設定
form.console.options.show.console.variables.by.default=預設顯示控制台變數
form.console.options.use.existing.console.for.run.with.python.console=為“通過 Python 控制台執行”使用現有控制台
form.console.options.use.ipython.if.available=使用 IPython（如有）
form.console.specific.options.starting.script=正在啟動腳本
form.debugger.for.attach.to.process.show.processes.with.names.containing=為“附加到進程”顯示名稱中包含這些內容的進程：
form.debugger.attach.to.subprocess.automatically.while.debugging=調試時自動附加到子進程
form.debugger.clear.caches=清除緩存
form.debugger.clear.caches.action=清除緩存
form.debugger.collect.run.time.types.information.for.code.insight=收集執行時類型資訊以獲取程式碼洞察
form.debugger.gevent.compatible=Gevent 相容
form.debugger.drop.into.debugger.on.failed.tests=在失敗的測試中放入調試器
form.debugger.pyqt.compatible=PyQt 相容
form.debugger.remote.interpreter.docker.default.interpreter.path=python
form.data.viewer.current.slice=當前切片
form.data.viewer.dialog.show.svn.map.table.header.column.format.title=格式
form.data.viewer.format=格式:
form.debugger.stepping.checkbox.text.do.not.step.into.library.scripts=不要單步執行庫腳本
form.debugger.stepping.do.not.step.into.scripts=不單步執行腳本:
form.debugger.stepping.always.do.smart.step.into=始終進行智能單步執行
form.documentation.entry.insert=插入(&I)
form.documentation.entry.module.name=模塊名稱 (&M)：
form.documentation.entry.url.path.pattern=URL/路徑模式 (U)：
form.documentation.entry.available.macros=可用的巨集
form.remote.path.remote.project.location=遠端專案位置：
form.introduce.name=名稱(&N):
form.introduce.field.initialize.in=初始化在(&I)
form.move.module.members.from=從:
form.move.module.members.to=到:
form.python.run.configuration.emulate.terminal.in.output.console=模擬輸出控制台中的終端
form.python.run.configuration.redirect.input.from=重定向輸入自:
form.python.run.configuration.run.with.python.console=使用 Python 控制台執行
form.test.shared.target=目標:
form.test.shared.test=測試
form.test.run.configuration.params=參數:
form.test.run.configuration.specify.nosetests.command.line.options=指定 nosetest 命令行選項
form.test.run.configuration.unittest=Unittest
form.tox.configuration.arguments=實參:
form.tox.configuration.runcfg.tox=tox
py.module.dependencies.configurable.list.title=專案取決於這些專案：
py.sdk.editor.python.interpreter.label.text=Python 解釋器：
# Python reStructuredText forms
rest.configuration.editor.open.output.file.in.browser.label.text=在瀏覽器中打開輸出檔案
sphinx.ask.for.working.directory.label.text=Sphinx 工作目錄



pure.python.project=純 Python
project.cannot.be.generated=無法生成專案
error.in.project.generation=專案生成出錯

sdk.has.been.configured.as.the.project.interpreter={0} 已被配置為專案解釋器
sdk.has.been.configured.notification.name=已配置的 Python 解釋器
configuring.interpreters.link=<html><a href="#">配置解釋器
looking.for.previous.interpreter=正在尋找以前用過的解釋器
looking.for.related.venv=正在尋找與專案相關的虛擬環境
install.packages.from.pipfile=從 Pipfile 安裝軟件包
looking.for.default.interpreter=正在尋找新項目的預設解釋器設定
looking.for.previous.system.interpreter=正在尋找以前用過的系統級解釋器
looking.for.system.interpreter=正在尋找系統級解釋器
looking.for.shared.conda.environment=正在尋找共享的 Conda 環境
current.interpreter=當前解釋器：{0}
switch.python.interpreter=切換 Python 解釋器
python.facet.name=Python
choose.packages.to.install=選擇要安裝的軟件包：
manage.python.packages=管理 Python 軟件包
available.to.all.projects=可用於所有專案


framework.support.python.sdk.combobox.label=Python SDK:
integrated.tools.configurable.docstrings=Docstring
integrated.tools.configurable.restructuredtext=reStructuredText
integrated.tools.configurable.packaging=打包
integrated.tools.configurable.testing=測試
integrated.tools.configurable.pipenv=Pipenv
command.line.parser.error.message=實參與其值之間不應有空格

python.package.installation.notification.message={0} 將安裝在選定的解釋器上
python.package.and.packaging.tools.installation.notification.message=Python 打包工具和 {0} 將安裝在所選解釋器上

python.execute.selection.action.execute.selection.in.console=執行 Python 控制台中的選定內容
python.execute.selection.action.execute.line.in.console=執行 Python 控制台中的程式碼行

python.add.sdk.panel.name.conda.environment=Conda 環境
python.add.sdk.panel.name.existing.environment=現有環境
python.add.sdk.panel.name.previously.configured.interpreter=先前配置的解釋器
python.add.sdk.panel.name.new.environment.using=使用此工具新建環境
python.add.sdk.panel.name.new.environment=新環境
python.add.sdk.panel.name.new.project.interpreter=新項目解釋器
python.add.sdk.panel.name.pipenv.environment=Pipenv 環境
python.add.sdk.panel.name.system.interpreter=系統解釋器
python.add.sdk.panel.name.virtualenv.environment=Virtualenv 環境

python.add.sdk.conda.executable.path.is.empty=Conda 可執行檔案路徑為空
python.add.sdk.conda.executable.not.found=找不到 Conda 可執行檔案
python.add.sdk.conda.executable.path.is.not.executable=Conda 可執行檔案路徑不是可執行檔案

python.requirements.version.label=需求版本:
python.requirements.version.separator.no.version=不指定版本
python.requirements.version.separator.strong.eq=強相等
python.requirements.version.separator.gte=大於或等於
python.requirements.version.separator.compatible=相容版本
python.requirements.remove.unused=移除未使用的需求
python.requirements.modify.base.files=修改基本檔案（使用 -r 或 --requirement 定義的檔案）
python.requirements.keep.matching.specifier=如果現有版本與當前版本相匹配，則保留現有版本說明符
python.requirements.analyzing.imports.title=正在分析專案中的導入
python.requirements.action.name=同步 Python 需求
python.requirements.error.ends.with.slash=解析需求出錯：檔案以 '/' 符號結尾。
python.requirements.error.no.interpreter=已配置同步需求所需的解釋器。
python.requirements.warning.unhandled.lines=無法分析需求檔案中的條目：{0}
python.requirements.info.file.ref.dropped=基本檔案中的某些需求未更新：{0}
python.requirements.balloon=同步 Python 需求

toolwindow.stripe.SciView=SciView
toolwindow.stripe.Python_Console=Python 控制台
python.folding.options.title=Python
python.long.string.literals=長字串文字
python.long.collection.literals=長集合文字
python.sequential.comments=順序註釋
python.provide.a.qualified.name.of.a.module=提供模塊的限定名稱
python.input.file.doesn.t.exist=輸入檔案不存在
python.call.graph=調用圖
python.debugger.collection.signatures.deleted=收集的簽名已被刪除
python.debugger.nothing.to.delete=沒有要刪除的內容
python.debugger.qt.backend.auto=自動
python.debugger.settings.waiting.for.connection=正在等待連接…
python.debugger.settings.connecting.to.debugger=正在連接到調試器
python.debugger.attaching.to.process.with.pid=正在附加到 PID={0} 的進程
python.debugger.attaching=正在附加調試器
python.rename.processor.override.message=類 {1} 的方法 {0}\n\
重寫了類 {2} 的方法。\n\
要重命名基方法嗎?
python.rename.processor.property=是否要重命名屬性 ''{0}'' 而不是其訪問器函數 ''{1}''?
python.configuration.choose.target.to.run=選擇要執行的目標
python.vagrant.refresh.skeletons=啟動 vagrant 並刷新框架
python.concurrency.visualizer.scroll.end=滾動到結尾
python.execute.cell.in.console=在控制台中執行單元
python.template.select.file.type=選擇檔案類型
python.execution.is.still.running=上一個執行仍在執行

INSP.settings.pep8.ignore.errors=忽略錯誤
INSP.settings.pep8.ignore.errors.label=已忽略的錯誤:
INSP.settings.bdd.behave.specific=特定於 BDD 行為的定義不正確
INSP.settings.bdd.step.definition.arguments=步驟定義函數中的實參不正確
python.compatibility.inspection.advertiser.notifications.group.title=Python 兼容性檢查廣播程序
python.compatibility.inspection.advertiser.notifications.title=Python 版本相容性

python.compatibility.inspection.advertiser.using.future.imports.warning.message=您的原始碼包含 __future__ 導入。<br/>要啟用程式碼兼容性檢查嗎?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>

python.compatibility.inspection.advertiser.using.six.warning.message=您的原始碼導入了 'six' 軟件包。<br/>要啟用程式碼兼容性檢查嗎?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>

# Both placeholders are Python versions like 2.7, 3.7, etc.
python.compatibility.inspection.advertiser.version.stale.python3.version.warning.message=已為最高 {0} 的 Python 版本配置了程式碼兼容性檢查。<br/>要為 Python {1} 啟用嗎?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>

python.install.framework.ensure.installed=正在確保 {0} 已安裝
python.install.framework.checking.is.installed=正在檢查是否已安裝 {0}…
python.install.framework.installing=正在安裝 {0}…
py.commandline.configure=為專案配置 Python SDK

python.task.cannot.find.python.interpreter.for.selected.module=找不到所選模塊的 Python 解釋器
python.unknown.project.synchronizer.this.interpreter.type.does.not.support.remote.project.creation=此解釋器類型不支持創建遠端專案
progress.text.connecting.to.console=正在連接到控制台…
progress.title.debugger.connection=調試器連接
python.sdk.configuration.tab.title=類
python.console.rename.message=輸入新控制台名稱:
python.introduce.variable.refactoring.name=引入變數

settings.completion.ml.python.display.name=Python
QFIX.pep8.edit.inspection.profile.setting=編輯檢查配置檔案設定

python.remote.process.starter.can.t.run.remote.interpreter=無法執行遠端 Python 解釋器: {0}
python.remote.interpreter.can.t.create.project.this.type=無法在遠端解釋器上創建此類型的專案。選擇本地解釋器。
dialog.message.error.on.python.side.exit.code.stderr.stdout=Python 端錯誤。退出程式碼: {0}，錯誤: {1}，輸出: {2}
live.template.context.class=類
live.template.context.top.level=頂層

line.markers.popup.title.choose.super.method=選擇 {0} 的 super 方法
line.markers.popup.title.choose.super.attribute=選擇 {0} 的 super 特性
line.markers.popup.title.choose.subclass=選擇 {0} 的子類
line.markers.popup.title.choose.overriding.method=選擇 {0} 的重寫方法
line.markers.tooltip.header.is.subclassed.by=被以下對象子類化:
line.markers.tooltip.has.subclasses=具有子類
line.markers.tooltip.header.is.overridden.in=在以下位置被重寫:
line.markers.tooltip.has.overridden.methods=具有被重寫的方法
line.markers.tooltip.overrides.method.in.class=重寫 {0} 中的方法
line.markers.tooltip.overrides.attribute.in.class=重寫 {0} 中的特性
python.find.module.usages.dialog.label.prefix.package=軟件包
python.find.module.usages.dialog.label.prefix.module=模塊
goto.superclass.choose=選擇超類
python.symbol.chooser.dialog.title=選擇符號
button.install.to.user.site.packages.directory=安裝到使用者的站點軟件包目錄
framework.not.supported.for.the.selected.interpreter=所選解釋器不支持 {0}

action.MarkNamespacePackageDirectory.text=命名空間軟件包
python.unmark.as.namespace.package=取消標記為命名空間軟件包
python.unmark.as.python.namespace.package=取消標記為 Python 命名空間軟件包
python.namespace.package.folder=命名空間軟件包
python.python.namespace.package.folder=Python 命名空間軟件包
python.namespace.packages.name=命名空間軟件包
python.namespace.packages.description=命名空間軟件包資料夾
dialog.title.can.t.create.package=創建軟件包錯誤
command.name.create.new.package=創建新軟件包 {0}
dialog.title.new.python.package=新建 Python 軟件包
new.package.list.item.ordinary.package=軟件包
new.package.list.item.namespace.package=命名空間軟件包

# Python Packages toolwindow
python.toolwindow.packages.installed.label=已安裝
python.toolwindow.packages.pypi.repo.label=PyPI 倉庫
python.toolwindow.packages.documentation.link=文檔
python.toolwindow.packages.no.interpreter.text=選擇解釋器以查看所安裝的軟件包
python.toolwindow.packages.latest.version.label=最新
python.toolwindow.packages.install.button=安裝
python.toolwindow.packages.delete.package=刪除軟件包
python.toolwindow.packages.search.text.placeholder=搜尋更多軟件包
python.toolwindow.packages.description.panel.placeholder=選擇軟件包以查看文檔
python.toolwindow.packages.request.failed=<html><head></head><body><p class="empty_description">請求失敗。</p></body></html>
python.toolwindow.packages.no.description.placeholder=<html><head></head><body><p class="empty_description">軟件包作者未提供描述。</p></body></html>
python.toolwindow.packages.remote.interpreter.placeholder=<html><head></head><body><p class="empty_description">需要本地解釋器才能查看軟件包文檔。</p></body></html>
python.toolwindow.packages.collecting.packages.task.title=正在收集軟件包
python.toolwindow.packages.rst.parsing.failed=無法解析描述

vcs.activate.virtualenv.checkbox.text=為掛鈎啟用 Virtualenv

notification.action.edit.settings=編輯設定

group.advanced.settings.python=Python
advanced.setting.python.pytest.swapdiff=Pytest: 在差異中交換實際/預期值
advanced.setting.python.pytest.show_summary=Pytest: 不添加 "--no-header --no-summary -q"
python.toolwindow.packages.custom.repo.searched={0} (找到 {1} 個)
python.toolwindow.packages.no.documentation=在當前倉庫中找不到文檔
python.toolwindow.packages.manage.repositories.action=管理倉庫
python.toolwindow.packages.reload.repositories.action=重新載入所有倉庫
python.toolwindow.packages.add.package.action=添加軟件包
python.toolwindow.packages.add.package.from.vcs=從版本控制
python.toolwindow.packages.add.package.from.disc=從磁碟
python.toolwindow.packages.add.package.as.editable=作為 editable (-e)安裝
python.toolwindow.packages.add.package.vcs.git=Git
python.toolwindow.packages.add.package.vcs.svn=Subversion
python.toolwindow.packages.add.package.vcs.hg=Mercurial
python.toolwindow.packages.add.package.vcs.bzr=Bazaar
python.toolwindow.packages.add.package.path=路徑
python.toolwindow.packages.add.package.path.selector=選擇檔案或目錄
python.toolwindow.packages.add.package.dialog.title=安裝軟件包
python.toolwindow.packages.load.more=… 其他 {0} 個條目。雙擊以顯示更多。
python.toolwindow.packages.load.more.start=…
runcfg.autodetect.display_name=自動檢測
python.template.language.none=無
form.tox.configuration.environments.to.run=執行環境:
enter.path.dialog.title=輸入路徑
path.label=路徑:
path.must.not.be.empty.error.message=路徑不能為空
path.must.be.absolute.error.message=路徑必須是絕對路徑
path.ends.with.whitespace.warning.message=路徑以空格結尾
python.console.toolbar.action.available.non.interactive=此操作不可用於非交互式 shell 
toolwindow.stripe.Jupyter_Variables=Jupyter 變數
python.sdk.interpreter.executable.path.title=Python 解釋器可執行檔案路徑
python.sdk.action.add.new.interpreter.text=添加新的解釋器
sdk.create.venv.dialog.interpreter.label=解釋器：
sdk.create.venv.dialog.location.label=位置:
sdk.create.venv.dialog.base.interpreter.label=基本解釋器：
sdk.create.venv.conda.dialog.label.interpreter=解釋器：
python.language.configure.label=Python 配置
python.language.run.label=執行 Python 應用程序
configurable.name.python.language=Python 語言
python.console.command.queue.add.title={0} 命令隊列
python.console.command.queue.show.action.text=顯示命令隊列
python.console.command.queue.show.action.description=顯示帶有命令隊列的視窗
python.console.command.queue.got.it.tooltip.id=python.console.command.queue.show
python.console.command.queue.got.it.tooltip.title=控制台命令隊列
python.console.command.queue.got.it.tooltip.text=命令隊列彈出視窗中列出了排隊等待執行的命令
python.sdk.action.add.local.interpreter.text=添加本地解釋器…
python.sdk.action.add.interpreter.based.on.target.text=在 {0} 上...
active.sdk.dialog.link.add.interpreter.text=添加解釋器
python.sdk.new.project.environment=環境：
python.sdk.new.project.environment.type=環境類型:
refactoring.introduce.constant.cannot.extract.selected.expression=所選表達式無法提取為常量
python.packages.dictionary.name=Python 軟件包字典
python.sdk.poetry.executable.not.found=找不到 Poetry 可執行檔案
python.sdk.poetry.executable=Poetry 可執行檔案:
python.sdk.poetry.select.executable.title=選擇 Poetry 可執行檔案的路徑
python.sdk.poetry.associated.project=關聯專案:
python.sdk.poetry.associated.module=關聯模塊:
python.sdk.poetry.execution.exception.no.project.message=找不到與此 Poetry 環境關聯的專案
python.sdk.poetry.execution.exception.no.poetry.message=找不到 Poetry
python.sdk.poetry.execution.exception.error.running.poetry.message=執行 Poetry 時出錯
python.sdk.poetry.quickfix.fix.pipenv.name=修正 Poetry 解釋器
python.sdk.poetry.quickfix.use.pipenv.name=使用 Poetry 解釋器
python.sdk.poetry.pip.file.lock.not.found=找不到 poetry.lock
python.sdk.poetry.pip.file.lock.out.of.date=poetry.lock 已過期
python.sdk.poetry.pip.file.notification.content=執行 <a href='#lock'>poetry lock</a> 或 <a href='#update'>poetry update</a>
python.sdk.poetry.pip.file.notification.content.without.updating=執行 <a href='#lock'>poetry lock</a>、<a href='#noupdate'>poetry lock --no-update</a> 或 <a href='#update'>poetry update</a>
python.sdk.poetry.pip.file.notification.locking=正在鎖定 poetry.lock
python.sdk.poetry.pip.file.notification.locking.without.updating=正在鎖定 poetry.lock 而不更新
python.sdk.poetry.pip.file.notification.updating=正在更新 Poetry 環境
python.sdk.poetry.pip.file.watcher=pyproject.toml 觀察程序
looking.for.inner.venvs=正在尋找內部虛擬環境
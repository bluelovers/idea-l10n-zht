action.ChangePHPInterpreter.text=更改 PHP 解釋器
action.ChangePHPInterpreter.description=更改專案 PHP 解釋器
action.MessDetectorAddToIgnored.text=添加到 PHPMD 忽略列表
action.MessDetectorAddToIgnored.description=添加到 PHP Mess Detector 忽略列表
action.PhpCSFixerAddToIgnored.text=添加到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.description=添加到 PHP CS Fixer 忽略列表
action.PhpCSAddToIgnored.text=添加到 PHPCS 忽略列表
action.PhpCSAddToIgnored.description=添加到 PHP_CodeSniffer 忽略列表
group.PHPQualityToolsAddToIgnoredList.text=添加到忽略列表…
action.ComposerShowLogAction.text=顯示日誌
action.ComposerShowLogAction.description=顯示包含此 composer.json 的 Composer 操作日誌
action.ComposerClearCacheAction.text=清除快取
action.ComposerClearCacheAction.description=刪除 Composer 快取目錄中的所有內容
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerSelfUpdateAction.description=將 Composer 本身更新到最新版本
group.ComposerToolsGroup.text=Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
group.ComposerGroup.text=Composer
action.ComposerDiagnoseAction.text=診斷
action.ComposerDiagnoseAction.description=檢查常見的 Composer 問題
action.ComposerLicensesAction.text=列出授權
action.ComposerLicensesAction.description=列出安裝的每個軟體套件的名稱、版本和授權
action.ComposerStatusAction.text=檢查依賴項中的變更
action.ComposerStatusAction.description=檢查任何依賴項中有無本地變更
action.ComposerDryRunUpdate.text=模擬更新
action.ComposerDryRunUpdate.description=模擬更新，但不實際更新
action.ComposerDumpAutoloadAction.text=轉儲自動載入器…
action.ComposerDumpAutoloadAction.description=重新生成自動載入類的列表
action.ComposerValidateAction.text=驗證…
action.ComposerValidateAction.description=檢查 composer.json 是否有效
action.ComposerAddDependencyAction.text=管理依賴項…
action.ComposerAddDependencyAction.description=管理 Composer 依賴項
action.ComposerUpdateAction.text=更新
action.ComposerUpdateAction.description=從 Composer.json 安裝最新適當版本的軟體套件
action.ComposerInstallAction.text=安裝
action.ComposerInstallAction.description=考慮到 composer.lock，安裝 composer.json 中的軟體套件
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=當前檔案的 PHP 控制流
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=顯示 PHP FQN
action.ProfilerJumpToSource.text=跳轉到原始碼
action.ProfilerJumpToSource.description=跳轉到原始碼
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
group.DBGPProxyGroup.text=DBGp 代理
action.PhpDebuggerCopyType.text=複製類型
action.XDebugger.CopyPath.text=複製路徑
action.PhpDetectPsroRoots.text=檢測 PSR-0 命名空間根
action.PhpDetectPsroRoots.description=將檢測原始碼命名空間根
action.PhpListenDebugAction.text=偵聽偵錯連接
action.PhpListenDebugAction.description=偵聽偵錯連接
action.PhpMakeStaticAction.text=設為 static
action.PhpMakeStaticAction.description=將類方法設為 static
action.PhpExtractClassAction.text=提取類…
action.PhpExtractClassAction.description=將元素提取到單獨的類

action.PhpNewTest.text=PHP 測試
action.PhpNewTest.description=創建新的 PHP 測試
group.PhpNewTestGroup.text=PHP 測試
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTearDownMethod.description=創建 PHPUnit tearDown 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateSetUpMethod.description=創建 PHPUnit setUp 方法
action.PhpUnitGenerateTestMethod.text=測試方法
action.PhpUnitGenerateTestMethod.description=創建 PHPUnit 測試方法
action.PhpGeneratePhpDocBlocks.text=PHPDoc 塊…
action.PhpGeneratePhpDocBlocks.description=為函數、類和欄位添加 PHPDoc 塊。
action.PhpGenerateSetters.text=setter…
action.PhpGenerateSetters.description=為 private 類欄位創建 setter。
action.PhpGenerateGettersAndSetters.text=getter 和 setter…
action.PhpGenerateGettersAndSetters.description=為 private 類欄位創建 getter 和 setter。
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGetters.description=為 private 類欄位創建 getter。
action.PhpGenerateConstructor.text=構造函數…
action.PhpGenerateConstructor.description=創建構造函數。

# php colors page elements
color.settings.name=PHP
color.settings.php.scripting=PHP 程式碼//背景
color.settings.php.tags=PHP 程式碼//標記
color.settings.keyword=關鍵字
color.settings.comment=註釋
color.settings.number=數字
color.settings.string=字串//字符
color.settings.escape_sequence=字串//轉義序列
color.settings.operation=大括號和運算符//運算符
color.settings.brackets=大括號和運算符//中括號
color.settings.parentheses=大括號和運算符//圓括號
color.settings.braces=大括號和運算符//大括號
color.settings.bad_character=未知字符
color.settings.comma=大括號和運算符//逗號
color.settings.semicolon=大括號和運算符//分號
color.settings.heredoc_id=Heredoc//Heredoc ID
color.settings.heredoc_content=Heredoc//Heredoc 內容
color.settings.var=關鍵字//變數
color.settings.var_var=關鍵字//可變變數
color.settings.this.var=關鍵字//'$this' 變數
color.settings.identifier=關鍵字//預設
color.settings.constant=關鍵字//常數
color.settings.function=函數和方法//宣告
color.settings.parameter=函數和方法//參數
color.settings.function.call=函數和方法//函數調用
color.settings.instance.method=函數和方法//實例方法調用
color.settings.instance.protected.method=函數和方法//protected 實例方法調用
color.settings.instance.private.method=函數和方法//private 實例方法調用
color.settings.static.method=函數和方法//static 方法調用
color.settings.magic.member=關鍵字//魔幻成員存取
color.settings.class=類和屬性//類
color.settings.interface=類和屬性//接口
color.settings.static.field=類和屬性//static 屬性
color.settings.instance.field=類和屬性//實例屬性
color.settings.instance.protected.field=類和屬性//protected 實例屬性
color.settings.instance.private.field=類和屬性//private 實例屬性
color.settings.doccomment=PHPDoc//文本
color.settings.doctag=PHPDoc//標記
color.settings.docmarkup=PHPDoc//標記
color.settings.doc.identifier=PHPDoc//關鍵字
color.settings.doc.parameter=PHPDoc//參數
color.settings.doc.var=PHPDoc//變數
color.settings.doc.method.identifier=PHPDoc//方法宣告
color.settings.doc.property.identifier=PHPDoc//屬性
color.settings.exec_command=Shell 指令
color.settings.concatenation=字串//串聯
color.settings.predefined.symbols=關鍵字//預定義符號
color.settings.goto.label=關鍵字//轉到標籤
color.settings.alias.reference=關鍵字//別名引用
color.settings.alias.primitive.type.hint=關鍵字//基元類型提示
color.settings.named.arguments=命名實參
color.settings.attributes=特性

# annotations
annotation.variable.variable=可變變數
annotation.new.expression.interface=無法實例化接口 ''{0}''
annotation.new.expression.trait=無法實例化特徵 ''{0}''
annotation.new.expression.abstract=無法實例化 abstract 類 ''{0}''
annotation.new.expression.enum=無法實例化枚舉 ''{0}''
annotation.expression.is.not.allowed.as.class.constant.value=表達式不允許為類常量值

#folding
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法體
folding.checkbox.collapse.function.body=函數體
folding.checkbox.collapse.php.tags=標記
folding.checkbox.collapse.heredocs.and.nowdocs=HEREDOC\\NOWDOC
folding.checkbox.collapse.classes=類主體

#gutter
gutter.overriding.select.title=選擇要導航的父方法
gutter.overriden.select.subclass.title=選擇 {0} 的子類
gutter.overriden.select.implementation.title=選擇 {0} 的實作
#gutter-pinned
gutter.pin.overriding.select.title={0} 的父項
gutter.pin.overriden.select.subclass.title={0} 的實作
gutter.pin.overriden.select.implementation.title={0} 的實作

# inspections
inspection.group=PHP
inspection.group.general=一般
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素: ''{0}''
inspection.group.undefined=未定義
inspection.group.control.flow=控制流
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的錯誤
inspection.group.type.compatibility=類型相容性
inspection.group.code.style=程式碼樣式
inspection.group.code.smell=程式碼異味
inspection.group.naming.convention=命名慣例


inspection.dead.code.problem.empty.constant.synopsis=常數從未使用。
inspection.dead.code.problem.single.constant.synopsis=常數有一個用法，但無法到達。
inspection.dead.code.problem.multiple.constant.synopsis=常數有 {0, choice, 1#1 個用法|2#{0,number} 個用法}，但無法從入口點到達。
inspection.dead.code.problem.empty.function.synopsis=函數從未使用。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函數用法均屬於不存在可從入口點到達的成員的調用鏈。
inspection.dead.code.problem.suspicious.function.synopsis=函數無法從入口點到達。
inspection.dead.code.problem.trait.synopsis=特徵從未使用。
inspection.dead.code.problem.class.nousages.synopsis=類從未使用。
inspection.dead.code.problem.trait.additional.unreachable=特徵沒有可到達用法。
inspection.dead.code.problem.trait.additional.reachable=特徵具有可到達用法。
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1#直接或間接實作|2# {1,number} 個直接或間接實作}，但<ul><li>其從未實例化或</li><li>不存在可從入口點到達的實例化。</li></ul>

inspection.hierarchyChecks=類層次結構檢查
inspection.hierarchyChecks.descr=類必須被宣告為 abstract 或實作 {0}
inspection.hierarchyChecks.should.implement=類必須實作 {0}
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=類型不得定義(如基類 ''{0}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=類型必須為 ''{0}''(如基類 ''{1}'' 中)
inspection.wrong_param_type=應為 ''{1}'' 類型的參數，提供的是 ''{0}''
inspection.missing_param=缺少所需參數 ''{0}''
inspection.optional.before.required=可選參數在需要前提供
#inspection -> Super class incompatible with interface
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的宣告必須與 ''{1}'' 相容

#inspection -> Wrong Exception order
inspection.wrong.exception.order.problem.batch=已捕獲異常 '#ref'
inspection.wrong.exception.order.problem.same=已捕獲異常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕獲異常類 ''{1}'' 的超類 ''{0}''

inspection.wrong.exception.order.fix.move.display.name=將 ''catch'' 子句移動到 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移動 'catch' 子句
#inspection -> Wrong Exception class
inspection.wrong.exception.type.problem.throw = 已拋出物件必須為 'Exception' 或 'Throwable' 的實例
inspection.wrong.exception.type.problem.catch = 無法捕獲非派生自 'Exception' 或 'Throwable' 基類的物件

#inspection -> Assigned value never used
#inspection -> Wrong foreach argument
inspection.wrong.foreach.argument.type.problem.batch=提供給 'foreach' 的無效實參
inspection.wrong.foreach.argument.type.problem=提供給 ''foreach'' 的實參無效。預期類型: ''array'' 或 ''object''，提供的是 ''{0}''。

#inspection -> Redundant PHPDoc
inspection.redundant.phpdoc=冗餘 PHPDoc 註釋

#inspection -> Unused local variable
inspection.unused.local.variable.problem=未使用的局部變數 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=局部變數 '#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=變數的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=變數的值被立即覆蓋。
inspection.unused.local.variable.problem.case3=變數中存儲的引用未在任何位置使用。
inspection.unused.local.variable.problem.case4=變數中存儲的引用被立即覆蓋。
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 鍵時忽略 foreach 值
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的變數
inspection.unused.local.variable.option.description.file.scope=在全域空間中啟用檢查
inspection.unused.local.variable.option.description.null=忽略 'null' 的賦值
inspection.unused.local.variable.option.indirect.access=忽略通過 'get_defined_vars()' 存取的變數
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=發現副作用
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配給 ''{0}'' 的表達式可能含有副作用。\n\
您可以:\n\
- 完全<b>移除</b>變數賦值\n\
- 將分配的表達式<b>轉換</b>成單獨的語句

#inspection -> Unused parameter
inspection.unused.parameter.problem=未使用的參數 ''{0}''。{1}
inspection.unused.parameter.problem.case1=參數值未在任何位置使用。
inspection.unused.parameter.problem.case2=參數值被立即覆蓋。
inspection.unused.parameter.problem.case3=參數中存儲的引用未在任何位置使用。
inspection.unused.parameter.problem.case4=參數中存儲的引用被立即覆蓋。
inspection.unused.parameter.option.description.empty.body=忽略帶有空體的方法/函數的參數
inspection.unused.parameter.option.description.empty.abstract=忽略 abstract 類方法的參數
inspection.unused.parameter.option.description.empty.override=忽略覆寫方法的參數
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函數的參數
inspection.unused.parameter.option.description.parameter.count=不報告通過 'func_num_args()' 存取的參數

#inspection -> Unused private method
inspection.unused.private.method.problem.batch=未使用的 private 方法 '#ref'
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法

#inspection -> Undefined callback
inspection.undefined.callback.method=在類 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.callback.field=在類 ''{1}'' 中未找到屬性 ''{0}''
inspection.undefined.callback.class=未定義的類 ''{0}''
inspection.undefined.callback.function=未定義的函數 ''{0}''
inspection.undefined.callback.dont.report.exist.checkbox=忽略來自 '*_exists' 和 'is_callable' 函數的回調
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明確時不報告

#inspection -> Missing parent call
inspection.missing.parent.call.message=缺少父方法調用

#inspection -> Missing parent constructor call
inspection.missing.parent.constructor.call.message=缺少父構造函數調用

#inspection - > Undefined variable
inspection.undefined.variable.problem1=未定義的變數 '#ref'
inspection.undefined.variable.problem2=變數 '#ref' 可能未定義
inspection.undefined.variable.option.description.enable.in.file.scope=在全域空間中啟用檢查
inspection.undefined.variable.option.description.report.can.be.undefined=報告變數可能未定義
inspection.undefined.variable.option.description.ignore.include=在當前檔案外搜尋變數定義

#inspection -> Wrong String concatenation operator
inspection.wrong.string.concatenation.operator.problem=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.problem.batch=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通過魔術方法存取的屬性

#inspection -> Dynamic method called as static
inspection.dynamic.method.called.as.static.problem=非 static 方法 '#ref' 不應被靜態調用
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '#ref' 不應被靜態調用，但類具有 '__magic' 方法。

#inspection -> Static method called as dynamic
inspection.static.method.called.as.dynamic.problem=static 方法 '#ref' 不應被動態調用
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '#ref' 不應被動態調用，但類具有 '__magic' 方法。

#inspection -> Assignment in condition
inspection.assignment.in.condition=條件中的賦值
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=從條件中移出賦值

#inspection -> Division by zero
inspection.division.by.zero=除以零

#inspection -> Dynamic namepsace
#inspection -> Unreachable Statement
inspection.unreachable.statement=不可到達的語句
inspection.unreachable.statement.problem=不可到達的語句

#inspection -> Missing doc comment
inspection.missing.doc.comment.problem=缺少 PHPDoc 註釋
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 註釋
inspection.missing.doc.comment.options.panel.constant=常數(&O)
inspection.missing.doc.comment.options.panel.function=函數(&F)
inspection.missing.doc.comment.options.panel.class=類(&C)
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.options.panel.field=屬性(&P)
inspection.missing.doc.comment.options.panel.class.constant=類常數(&A)

#inspection -> Silly assignment
inspection.silly.assignment.problem=賦值左右兩側相等

#inspection -> Illegal array key type
inspection.illegal.array.key.type.problem=非法陣列鍵類型

#inspection -> Illegal string offset
inspection.illegal.string.offset.problem=非法字串偏移 {0}

#inspection -> Missing @return tag
inspection.doc.missing.return.tag.problem=函數/方法 PHPDoc 註釋中缺少 @return 標記

#inspection -> Missing @throws tag
inspection.doc.throws.problem=PHPDoc 註釋不包含所有必需的 @throws 標記
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略沒有 @param/@return 的 PHPDoc

#inspection -> Inconsistent return points
inspection.inconsistent.return.points.problem1=缺少 'return' 語句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 語句
inspection.inconsistent.return.points.problem2=缺少返回實參
inspection.inconsistent.return.points.option.treat.return=在 'void' 函數/方法中以相同方式對待 'return null' 和 'return'

#inspection -> Redundant closing tag
inspection.redundant.closing.tag.problem=冗餘結束標記
inspection.redundant.closing.tag.fix.remove=移除結束標記

#inspection -> Void function result used
inspection.void.function.result.used.problem1=使用了 ''void'' 函數 ''{0}'' 結果
inspection.void.function.result.used.problem2=使用了 ''void'' 方法 ''{0}'' 結果

#inspection -> Expression result unused
inspection.expression.result.unused.problem=表達式結果未在任何位置使用

#inspection -> Missing 'break' statement
inspection.missing.break.statement.problem=缺少 'break' 語句

#inspection -> Nested vs outer 'foreach' variables conflict
inspection.nested.vs.outer.foreach.variables.conflict.problem1=變數 ''{0}'' 作為鍵用於內部和外部 ''foreach'' 迴圈
inspection.nested.vs.outer.foreach.variables.conflict.problem2=變數 ''{0}'' 作為值用於內部和外部 ''foreach'' 迴圈

#inspection -> Foreach array is used as value
inspection.foreach.array.is.used.as.value.problem=變數 ''{0}'' 已用作 ''array expression''

#inspection -> Usage of a silence operator
inspection.usage.of.silence.operator.problem=使用了沉默運算符

#inspection -> Language level
#switch language level quick fix
inspection.language.level.quick.fix.switch.language.level.name.0=切換到 PHP {0} 語言級別

#switch language level in composer file manually quick fix
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手動切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切換到 composer.json 中的 PHP {0} 語言級別


inspection.disabled.quality.tool.inspection.fix=啟用檢查
inspection.disabled.quality.tool.inspection.open.fix=開啟檢查設定

inspection.disabled.quality.tool.inspection= {0} 檢查已禁用

inspection.json.not.installed.packages=未安裝軟體套件
inspection.json.all.not.installed.packages=未安裝軟體套件
inspection.json.not.installed.packages.update.fix=更新所有軟體套件
inspection.json.not.installed.package.update.fix=更新軟體套件
inspection.json.not.installed.packages.install.fix=安裝軟體套件
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重複的 ''{0}'' 條目
inspection.json.duplicated.packages.fix=從 require-dev 中移除重複項

#inspection -> Duplicate array keys
inspection.duplicate.array.keys.display.name=重複的陣列鍵
inspection.duplicate.array.keys.problem=重複的陣列鍵
inspection.duplicate.array.keys.problem.0=值為 ''{0}'' 的重複陣列鍵

#inspection -> Duplicate PhpDoc type
inspection.duplicate.phpdoc.type.problem=重複的類型 ''{0}''
inspection.duplicate.phpdoc.type.fix=從標記中移除重複類型

#inspection -> Undefined constant
inspection.undefined.constant.problem1=未定義的常數 '#ref'
inspection.undefined.constant.problem2=常數 '#ref' 可能未定義

#inspection -> Undefined function
inspection.undefined.function.problem1=未定義的函數 '#ref'
inspection.undefined.function.problem2=函數 '#ref' 可能未定義

#inspection -> Undefined property
inspection.undefined.field.problem1=通過魔術方法存取的屬性
inspection.undefined.field.problem2=屬性動態宣告
inspection.undefined.field.notify.access.magic.method=通過魔術方法存取屬性的通知
inspection.undefined.field.notify.dynamic.declaration=動態屬性宣告的通知

#inspection -> Undefined provider
inspection.undefined.phpunit.provider=未定義的 PHPUnit 資料提供程序 ''{0}''

#inspection -> PHPUnit missing target for test
inspection.phpunit.missing.target.element.ref=未找到 '#ref' 的測試目標元素

#inspection -> Covered function reference is provided without '::'
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆蓋{0}引用沒有 ''::''

#inspection -> Deprecated assertEquals/assertNotEquals usage
inspection.phpunit.asserts.assertEquals.parameters.many=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.single=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.empty=帶有此類參數的調用已棄用

#inspection -> Usage assertCount/assertSameSize methods instead of assertEquals
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}

#inspection -> Misordered assertEquals/assertNotEquals arguments
inspection.phpunit.asserts.assertEquals.misordered.arguments=順序錯誤的 {0} 實參

#inspection -> Method assertArrayHasKey/assertArrayNotHasKey can be used instead
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 {0}

#inspection -> Deprecated expectException usage
inspection.phpunit.expectException=對將 expectException() 用於 {0} 的支援已棄用，將在 PHPUnit 10 中移除。請改用 {1}()。

#inspection -> Unnecessary fully qualified name
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在檔案範圍內啟用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全域命名空間

#inspection -> Fully qualified name usage
inspection.fully.qualified.name.usage=限定符可以取代為匯入
inspection.fully.qualified.name.usage.option.enable.file.scope=在檔案範圍內啟用
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全域命名空間

#inspection -> Multiple classes declaration in one file
inspection.multiple.classes.declarations.in.one.file=在此檔案中宣告了另一個類
#inspection -> Namespace name is not matched with project structure
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空間名稱與 PSR-0/PSR-4 專案結構不符合
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名稱與包含文件名不符合

#inspection -> Traditional Syntax Array Declaration Inspection
inspection.traditional.syntax.array.literal.detected=使用了傳統語法陣列文字

#inspection -> Too Many Parameters
inspection.too.many.parameters=參數數量超出指定限值
inspection.too.many.parameters.max.number.of.parameters=最大參數數量
inspection.too.many.parameters.ignore.constructors=忽略構造函數

#inspection -> Parameters count mismatch
inspection.method.parameters.count.mismatch=為方法調用提供了 {0} 個參數，但方法簽名使用了 {1} 個參數
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最後一個參數為 $_ 的函數/方法
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略帶有 func_get_arg/func_get_args 調用的函數/方法

#inspection -> Method __toString is not implemented
inspection.method.to.string.is.not.implemented.strict.mode=檢查每種表達式類型是否存在 __toString
inspection.method.to.string.is.not.implemented=沒有為類 ''{0}'' 實作方法 ''__toString''

#inspection -> Method or class is not case sensitive
inspection.codeSmell.function.call.is.not.casesensitive=函數/方法調用中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.class.call.is.not.casesensitive=類用法中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空間引用中的大小寫與宣告中的大小寫不符合

#inspection -> Method visibility shouldn't be overridden
inspection.codeSmell.overriding.method.visibility.description=方法可見性不應被覆寫

#inspection -> Usage of a variable variable
inspection.variable.variable=使用了可變變數

#inspection -> Strict type checking rules violation
inspection.strict.type.checking.parameter=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=參數 '#ref' 類型與宣告不相容
inspection.strict.type.checking.return=返回值必須為 ''{0}'' 類型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值類型與宣告不相容
inspection.strict.type.checking.option=為所有檔案啟用
inspection.strict.type.checking.field.assignment=屬性必須為 ''{0}'' 類型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容

#inspection -> Incompatible return type
inspection.incompatible.return.type=返回值應為 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值類型與宣告不相容
inspection.incompatible.return.type.strict.type.checking=嚴格類型檢查
#inspection -> Missing strict types declaration
inspection.missing.strict.types.declaration=缺少嚴格類型宣告
inspection.missing.strict.types.declaration.add.declaration=添加嚴格類型宣告

#inspection -> Magic method visibility
inspection.magic.method.visibility.must.be.public=魔術方法 ''{0}'' 必須為 public
inspection.magic.method.visibility.must.be.static=魔術方法 ''{0}'' 必須為 static
inspection.magic.method.visibility.cannot.be.static=魔術方法 ''{0}'' 不能為 static

#inspection -> Naming convention
inspection.naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
inspection.naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
inspection.naming.convention.element.descriptor.regexp={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
inspection.naming.convention.element.description.class=類
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=屬性
inspection.naming.convention.element.description.variable=變數
inspection.naming.convention.element.description.function=函數
inspection.naming.convention.element.description.constant=常數

#inspection -> Replaceable assignment
inspection.assignment.replaceable.with=<code>#ref</code> 可以取代為 ''{0}'' #loc

#inspection -> Constructor style
inspection.constructor.style=舊式構造函數

#inspection -> Statement has empty body
inspection.statement.has.empty.body.comments.count.as.content=註釋計為內容
inspection.statement.has.empty.body.ignore.empty.while=忽略無主體的 'while' 迴圈
inspection.statement.has.empty.body.ignore.empty.for=忽略無主體的 'for' 迴圈

#inspection -> Convert loop to array_map
inspection.loop.can.be.converted.to.arraymap=迴圈可以轉換為 'array_map' 調用

#inspection -> Convert loop to array_filter
inspection.loop.can.be.converted.to.arrayfilter=迴圈可以轉換為 'array_filter' 調用

#inspection -> Convert loop to array_fill
inspection.loop.can.be.converted.to.arrayfill=迴圈可以轉換為 'array_fill' 調用

#inspection -> Convert str_pos to str_contains
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos' 調用可以轉換為 'str_contains'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr' 調用可以轉換為 'str_starts_with'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos' 調用可以轉換為 'str_starts_with'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr' 調用可以轉換為 'str_ends_with'
#inspection -> Convert array_map to loop
inspection.arraymap.can.be.converted.to.loop='array_map' 調用可以轉換為迴圈

#inspection -> Convert array_filter to loop
inspection.arrayfilter.can.be.converted.to.loop='array_filter' 調用可以轉換為迴圈

#inspection -> Convert array_fill to loop
inspection.arrayfill.can.be.converted.to.loop='array_fill' 調用可以轉換為迴圈

#inspection -> Ignored class alias declaration
inspection.ignored.class.alias.declaration=忽略了類別名聲明

#inspection -> Format function parameters mismatch
inspection.format.function.parameters.mismatch.parameter=參數未映射到任何轉換規範
inspection.format.function.parameters.mismatch.conversion.specification=轉換規範未映射到任何參數

inspection.export.results.const=常數
inspection.export.results.back.traces=反向跟踪

inspection.unused.symbol.check.fields=屬性
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.check.classes=類
inspection.unused.symbol.check.constants=常數
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.functions=函數
inspection.unused.symbol.check.magic_method=魔術方法
inspection.unused.symbol.export.calls=調用
inspection.unused.symbol.export.call=調用
inspection.unused.symbol.export.label=標籤
inspection.unused.symbol.export.reachable_element=可到達
inspection.unused.symbol.export.entry=入口點
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.closure=結束
inspection.unused.symbol.export.test_method=測試

inspection.composer.file.reference.problem=路徑 ''{0}'' 未找到

#inspection -> Method may be static
inspection.method.may.be.static=方法可能為 'static'

#inspection -> Missing field type
inspection.missing.field.type=缺少屬性的類型宣告

inspection.unpacked.argument.type.mismatch=僅可解包陣列和 Traversable，獲得的是{0}

inspection.closure.can.be.converted.to.arrow.function=閉包可以轉換為箭頭函數

inspection.field.assignment.type.mismatch=類型不相容: 應為 ''{0}'' 類型的屬性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容

inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重複項

inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重複項

inspection.switch.without.default.case='Switch' 沒有預設分支

inspection.doc.field.type.mismatch=屬性類型不符合

inspection.nested.ternary.expression=嵌套三元表達式自 PHP 7.4 已棄用

inspection.statement.without.braces=控制語句主體無大括號
inspection.statement.without.braces.fix.name=將大括號添加到 ''{0}'' 語句

inspection.single.statement.with.braces=單語句主體帶大括號
inspection.single.statement.with.braces.fix.name=從 ''{0}'' 語句中移除大括號

inspection.curly.braces.access.syntax.usage=大括號存取語法自 PHP 7.4 已棄用

inspection.expression.have.same.operands=表達式有相同操作數

inspection.deprecated.cast={0} 轉換自 PHP {1} 已棄用
inspection.deprecated.implode.usage=帶實參(陣列，字串)調用的 {0} 自 PHP 7.4 已棄用

quickfix.replace.curly.braces.with.brackets=將大括號取代為中括號

#quickfix
quickfix.is.not.available.in.dump.mode=在索引更新期間，''{0}'' 快速修復不可用
quickfix.cannot.find.class.reference=無法找到要解析的類引用
quickfix.cannot.find.target.class=無法從引用 ''{0}'' 解析類
quickfix.multiple.target.class.resolve=類 ''{0}'' 有多個宣告
quickfix.import.base.no.candidates=無法找到要匯入的候選項

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.overriding.method.visibility=移除可見性覆寫

#quickfix -> PhpMoveClassToCorrespondingDirectoryQuickFix
quickfix.move.class.to.corresponding.directory=移至目錄 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=檔案 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=無法創建缺少的目錄: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=無法將檔案移動到目錄 ''{0}''

#quick fix for:
quickfix.create.class=創建類
quickfix.failed.to.create.class=無法創建類 ''{0}''

#quic fix for:{PhpConstructorStyleInspection} -> Convert constructor to new style
quickfix.convert.to.new.style.constructor=將構造函數轉換為新樣式

#quick fix for: {PhpUnderfinedVariableInspection} -> Create parameter
quickfix.create.parameter=創建參數
#quick fix for: {PhpUnderfinedVariableInspection} -> Add to use
quickfix.add.to.use=添加到閉包 'use' 結構

#quickfix -> PhpImportClassQuickFix
quickfix.import.class.name=匯入類
quickfix.import.class.popup.title=要匯入的類

#quickfix -> PhpImportConstantQuickFix
quickfix.import.constant.name=匯入常數
quickfix.import.constant.popup.title=要匯入的常數

#quickfix -> PhpImportFunctionQuickFix
quickfix.import.function.name=匯入函數
quickfix.import.function.popup.title=要匯入的函數

#quickfix -> PhpAddFieldDeclarationQuickFix
#quickfix -> PhpAddMethodDeclarationQuickFix
#quickfix -> MakeCallDynamicQuickFix
quickfix.can.not.find.static.method.reference=無法找到 static 方法引用

#quickfix -> MakeCallStaticQuickFix
quickfix.make.call.static.name=將調用設為 static
quickfix.can.not.find.dynamic.method.reference=無法找到動態方法引用

#quickfix -> PhpAddFunctionFromCallback/PhpAddMethodFromCallback/PhpAddFieldFromCallback
quickfix.create.field.from.callback.name=從回調創建屬性
quickfix.create.field.from.callback.invalid.element=無法從回調提取屬性名稱
quickfix.create.field.from.callback.unresolved.class.ref=無法從回調創建屬性。無法解析目標類引用。
quickfix.create.field.from.callback.ambiguity.class.ref=無法從回調創建屬性。解析的類引用不明確。
quickfix.create.method.from.callback.name=從回調創建方法
quickfix.create.method.from.callback.invalid.element=無法從回調提取方法名稱
quickfix.create.method.from.callback.unresolved.class.ref=無法從回調創建方法。無法解析目標類引用。
quickfix.create.method.from.callback.ambiguity.class.ref=無法從回調創建方法。解析的類引用不明確。
quickfix.create.function.from.callback.family.name=從回調創建函數
quickfix.create.function.from.callback.name=添加函數
quickfix.create.function.from.callback.invalid.element=無法從函數回調提取 FQN
quickfix.create.function.from.callback.another.namespace=無法在 ''{0}'' 命名空間中創建函數

#quickfix -> PhpChangeParameterTypeQuickFix/PhpChangeReturnTypeQuickFix/PhpExtendReturnTypeQuickFix
quickfix.strict.type.checking.change.parameter.type.name=將{0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個}參數的類型從 ''{1}'' 更改為 ''{2}''
quickfix.strict.type.checking.change.parameter.type.family=更改參數類型
quickfix.strict.type.checking.change.return.type.name=將返回類型從 ''{0}'' 更改為 ''{1}''
quickfix.strict.type.checking.change.return.type.family=更改返回類型
quickfix.strict.type.checking.extend.return.type.name=將返回類型從 ''{0}'' 擴展為 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=擴展返回類型

#quickfix -> PhpChangeTypeDeclarationQuickFix
quickfix.change.type=更改為 ''{0}''
quickfix.remove.type=移除類型 ''{0}''
quickfix.change.type.declaration.family=更改類型

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.case.sensitive.name=更改 {0} 的大小寫以符合其宣告

#quickfix -> Replace assignment with operator assignment
quickfix.replace.assignment.with.operator.assignment.family.name=將賦值取代為運算符賦值
quickfix.replace.assignment.with.operator.assignment.name=將 ''='' 取代為 ''{0}=''

#quickfix -> Replace assignment with prefix expression
quickfix.replace.assignment.with.prefix.expression.family.name=將賦值取代為前綴表達式
quickfix.replace.assignment.operator.with.prefix.expression.family.name=將賦值運算符取代為前綴表達式

quickfix.replace.one.operator.with.another=將 ''{0}'' 取代為 ''{1}''

#quickfix -> Convert loop to array_map
quickfix.convert.loop.to.arraymap=將迴圈轉換為 'array_map' 調用

#quickfix -> Convert loop to array_filter
quickfix.convert.loop.to.arrayfilter=將迴圈轉換為 'array_filter' 調用

#quickfix -> Convert loop to array_fill
quickfix.convert.loop.to.arrayfilll=將迴圈轉換為 'array_fill' 調用

#quickfix -> Convert array_map to loop
quickfix.convert.arraymap.to.loop=將 'array_map' 調用轉換為迴圈

#quickfix -> Convert array_filter to loop
quickfix.convert.arrayfilter.to.loop=將 'array_filter' 調用轉換為迴圈

#quickfix -> Convert array_fill to loop
quickfix.convert.arrayfill.to.loop=將 'array_fill' 調用轉換為迴圈

#quickfix -> PHPUnit create missing target class
quickfix.phpunit.create.target.class.error.filename.exists=存在檔案 {0}

#quickfix -> Replace current method with alternative 
quickfix.phpunit.replace.current.method.with.alternative=取代為 ''{0}''

#quickfix -> Drop redundant optional parameters
quickfix.phpunit.drop.redundant.optional.parameters=刪除冗餘的可選參數

#quickfix -> Flip misordered assertEquals/assertNotEquals arguments
quickfix.phpunit.assert.equals.flip.compared.arguments=翻轉比較實參

#quickfix -> Unnecessary qualifier
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=簡化 FQN

#quickfix -> Disable for global namespace
quickfix.disable.inspection.for.global.namespace=為全域命名空間禁用檢查

#quickfix -> Make method static
quickfix.make.method.static=設為 'static'

#quickfix -> Change field type
quickfix.change.field.type.to.match.super=更改類型以符合 super
quickfix.change.field.type.add.inferred.type.family.name=作為屬性的類型添加推斷的類型
quickfix.change.field.type.add.inferred.type.name=作為屬性的類型添加 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=無法修改唯讀檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.error.non.project=無法修改非專案檔案 ''{0}''

#quickfix -> Remove redundant PHPDoc
quickfix.remove.phpdoc=移除冗餘 PHPDoc 註釋

quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 標記
quickfix.remove.phpdoc.param.tag=移除 @param 標記
quickfix.remove.phpdoc.return.tag=移除 @return 標記

quickfix.phpdoc.update.type=更新 PHPDoc 類型
quickfix.phpdoc.update.field.type=將屬性類型更改為 ''{0}'' 以匹配 PHPDoc 註釋

quickfix.replace.nested.ternary.expression=將三元表達式取代為 {0} 關聯版本

quickfix.set.inheritance.between.classes=使{0} {1} {2}

quickfix.navigate.to.duplicate.array.key=導航到重複鍵
quickfix.navigate.to.duplicate.condition=導航到重複條件

#quickfix -> Delete return argument
quickfix.delete.return.argument=刪除返回實參

quickfix.remove.default.arm=移除重複的 'default' match 分支
#intentions

#intentions Replace ?: expression with If
intention.replace.ternary.expression.with.if=將 '?:' 取代為 if

#intentions Replace If with ?: expression
intention.replace.if.with.ternaryExpression=簡化 'if'

#intentions -> Convert To Short Syntax
intention.convert.to.short.syntax=將陣列轉換為短語法
intention.convert.to.traditional.syntax=將陣列轉換為傳統語法

#intentions -> Convert To Short Syntax (list)
intention.convert.to.short.syntax.list=將列表轉換為短語法
intention.convert.to.traditional.syntax.list=將列表轉換為傳統語法

#intentions -> Declare Field
intention.declare.missing.field=宣告屬性

#intentions -> Declare Property
intention.declare.missing.property=添加 @property

#intentions -> Flip Binary Expression
intention.flip.binary.expression.family.name=翻轉二進制表達式
intention.flip.binary.expression.text1=翻轉 ''{0}''
intention.flip.binary.expression.text2=翻轉 ''{0}'' (可能更改語意)
intention.flip.binary.expression.text3=翻轉 ''{0}'' (更改語意)

#intentions -> Namespace Bracing
intention.namespace.bracing=將命名空間轉換為帶大括號

#intentions -> Smart Line Split
intention.line.split=在兩個字串和串聯中拆分字串

#intentions -> Split comma-separated values
intention.split.comma.separated.values=將逗號分隔的值拆分為多行
intention.join.comma.separated.values=將逗號分隔的值合併為一行

#intentions -> Swap Call Arguments
intention.swap.call.arguments.family.name=交換調用實參
intention.swap.call.arguments.text1=交換 ''{0}'' 和 ''{1}''

#intention -> Add variable PHPDoc comment
intention.variable.add.phpdoc.comment.family.name=添加 PHPDoc 註釋

#intention -> Import class
intention.import.class=作為別名匯入類
intention.import.class.alias.name=別名:
intention.import.class.alias.already.exists=已匯入具有相同別名的類

#intention -> Simplify FQN
#intention -> Generate PHPDoc
intention.generate.phpdoc=生成 PHPDoc

#intention -> Surround With Call
intention.can.not.find.statement.to.surround=無法找到要環繞的目標語句。
intention.statement.to.surround.failed.message=無法用 ''{0}'' 環繞語句。

#intention -> Replace quotes
intention.replace.quotes=無法取代引號 - 轉義符號無效且\\r 不受支援

#intention -> Replace with alias
intention.replace.class.with.alias=取代為別名

#intention -> Inline alias
intention.inline.alias=內聯別名

#intention -> Add constructor parameters
intention.add.constructor.parameters=添加構造函數參數
intention.add.constructor.parameters.fields.chooser.dialog.title=選擇要在構造函數中初始化的屬性

#intention -> Implement the interface
intention.implement.interface=實作接口

intention.merge.condition.with.outer=與外部條件合併

#navigation -> Goto Super Method
navigation.goto.super.method.is.not.available=索引更新期間無法在此處導航

#run and debug
#dbgp debugging protocol
dbgp.invalid.packet=無效數據包

#annotator
annotator.duplicate.use.statement=無法使用 ''{0}''，因為該名稱已被使用
annotator.duplicate.default.match.condition=match 表達式只能包含一個 'default' 分支
annotator.unhandled.match.argument=未處理的 'match' 實參
annotator.reserved.class.name=無法使用 ''{0}'' 作為類名，因為該名稱已被保留
annotator.invalid.class.name=''{0}'' 是無效的類名
annotator.special.class.name=無法將 {0} 用作 {1}，因為 ''{1}'' 是一個特殊的類名
annotator.cannot.break.continue=無法中斷/繼續{0}級別
annotator.jump.out.of.finally=不允許跳出 finally 塊
php.annotator.expecting.interface=應為接口引用
php.annotator.expecting.class=應為類引用
php.annotator.exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
php.annotator.strict.types.first.statement='strict_types' 宣告必須是腳本中的第一條語句
php.annotator.strict.types.block.mode='strict_types' 宣告不能使用塊模式
php.annotator.heredoc.indent.validation.mixed.space.and.tab.characters=結束關鍵字縮排中混用了空格和制表符字符
php.annotator.heredoc.indent.validation.wrong.content.indent=縮排錯誤:應與結束標記縮排相同
php.annotator.typed.property.illegal.value=''{0}'' 類型的屬性可能沒有預設值
php.annotator.typed.property.type.mismatch=預設值只能是 ''{0}'' 類型
php.annotator.typed.property.type.mismatch.fix.nullable=使屬性類型可為 null
php.annotator.typed.parameter.type.mismatch.fix.nullable=使參數類型可為 null
php.annotator.typed.property.type.mismatch.fix.change=將屬性類型更改為 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.change=將參數類型更改為 ''{0}''
php.annotator.typed.property.type.mismatch.fix.family=更改屬性類型以符合預設值的類型
php.annotator.typed.parameter.type.mismatch.fix.family=更改參數類型以符合預設值的類型
php.annotator.typed.property.callable.is.illegal=屬性不能有 'callable' 類型
php.annotator.return.type.non.nullable.null.returned=無法返回 'null': 返回類型不可為 null
php.annotator.return.type.make.nullable.fix=使返回類型可為 null
php.annotator.void.function.must.not.return.value=void 函數不得返回值
php.surround.with.if=if

#quality tool
quality.tool.configuration.tool.path.is.empty=所選設定的 {0} 路徑為空
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 無法找到 {0} 設定: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=預設選擇 {0} 設定解釋器，但未指定解釋器
quality.tool.configuration.for.interpreter.is.not.found=找不到解釋器的 {0} 設定: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 設定的解釋器未指定或無效
quality.tool.phpcs.custom.rules.warning=選擇 'Custom' 編碼標準類型以選擇自訂規則集。
quality.tool.phpcs.custom.rules.validation.not.xml=所選規則集不是 XML
guality.tool.configuration.show.ignored.files=顯示忽略的檔案
quality.tool.phpcs.installed.paths=已安裝的標準路徑
quality.tool.empty.path.phpcs={0} 的路徑為空
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=選擇有效的 phpcbf 啟動器
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 設定
quality.tool.phpcbf.path=phpcbf 路徑:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer: 修復整個檔案
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.selected.file.is.not.phpcbf=所選檔案不是 phpcbf 可執行檔案
quality.tool.cs.fixer.custom.rules.warning=選擇 'Custom' 類型以選擇您的設定。
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持選定的規則集
quality.tool.php_cs.dir.does.not.contain.custom=此目錄不包含任何受支援的檔案: {0}
quality.tool.php.dir.does.not.contain=該目錄不包含{0}
quality.tool.can.not.determine.version=無法確定工具版本，得到 ‘{0}’
quality.tool.file.not.found=找不到檔案。
quality.tool.path.must.not.be.empty=路徑不能為空。
quality.tool.can.not.retrieve.standards=無法檢索可用規則集，請檢查 PHP CS Fixer 工具設定。
quality.tool.phpcs.can.not.retrieve.standards=無法檢索可用標準，請檢查 PHP_CodeSniffer 工具設定。
quality.tool.stardards.has.been.updated=已安裝的規則集列表已更新。
quality.tool.coding.stardards.has.been.updated=已安裝的編碼標準列表已更新。
quality.tool.cs.fixer.allow.risky.rules=允許為內建規則集設定有風險的規則
quality.tool.cs.fixer.reformat.action=PHP CS Fixer: 修復整個檔案
quality.tool.cs.fixer.ruleset=規則集:

quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本為 1.5.0 或更高，找到的是 {0}
quality.tool.php.cs.fixer.required.phpcs.version=支援的 PHP CS Fixer 版本為 2.8.0 或更高，找到的是 {0}

quality.tool.label.check.files.with.extensions=檢查帶副檔名的檔案:
quality.tool.label.coding.standard=編碼標準:
quality.tool.checkbox.installed.standard.paths=已安裝的標準路徑:
quality.tool.checkbox.show.sniff.name=顯示 sniff 名稱
quality.tool.checkbox.show.warning.as=將警告顯示為:
quality.tool.label.tool.path=工具路徑:
quality.tool.label.tool.process.timeout=工具處理超時，[1...60] 秒:
quality.tool.button.validate=驗證
quality.tool.label.validation.label=驗證標籤
quality.tool.label.custom.rulesets=自訂規則集:
quality.tool.phpcs.label.path.to.ruleset=規則集路徑:
quality.tool.label.label=標籤
quality.tool.label.configuration=設定:

#phpunit messages
php.unit.local.run.display.name=PHPUnit
php.unit.local.run.description=PHPUnit
php.not.test.method=類 ''{1}'' 中的方法 ''{0}'' 不是測試方法
php.method.not.found=在類 ''{1}'' 中未找到方法 ''{0}''
php.method.name.empty=未指定測試方法
php.unit.radio.button.composite=複合
php.unit.test.runner.options=測試執行程序選項
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路徑:
php.unit.optional=可選
php.unit.label.test.file.template=測試檔案模板(&T):

choose.php.home=選擇 PHP 可執行檔案
cleaning.up=正在清理…
this.reassignment.is.not.allowed=不能重新分配 $this
cant.use.temporary.expression.in.write.context=在寫上下文中不能使用臨時表達式
parsing.error.statement.expected=應為語句
smarty.configurable.title=Smarty
analyzing.php.sdk=正在檢查 PHP 安裝…
include.path.column.info=路徑
working.directory.invalid=找不到工作資料夾 ''{0}''
#control flow
#validation common
validation.file.already.exists.in.dir=名稱為“{0}”的檔案已存在於“{1}”中
validation.file.already.exists=檔案 "{0}" 已存在
validation.file.not.valid.name=“{0}”不是有效的文件名
validation.class.not.valid.name="{0}" 不是有效的類名
validation.namespace.not.valid.name=“{0}”不是有效的命名空間名稱
validation.invalid.identifier=“{0}”不是有效的關鍵字
validation.invalid.identifier.with.no.identifier=插入的關鍵字無效
validation.invalid.alias=“{0}”不是有效的別名
validation.value.is.not.specified.or.invalid={0} 未指定或無效。
validation.value.path.to.value.should.be.specified={0} 的路徑應在 {1} 中指定
validation.value.path.to.value.is.invalid=無法通過 {1} 中提供的路徑找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=無法通過 {1} 中提供的路徑找到 {0}。按“修復”以編輯 {2} 設定。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或無效。按“修復”編輯您的專案設定。
validation.value.is.not.specified.press.fix.project.configuration={1} 設定中未指定 {0}。按“修復”以編輯 {1} 設定。
validation.press.fix.to.edit.project.configuration=按“修復”編輯您的專案設定。
validation.value.is.invalid={0} 無效
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.0.is.not.a.directory=''{0}'' 不是目錄
validation.0.extension.is.not.installed=未安裝 ''{0}'' 擴展
validation.debug.extension.is.updated=偵錯擴展設定已更新。請重新執行當前設定以使用新值。
validation.0.extension.is.installed.check.configuration.options=已安裝 ''{0}'' 擴展。檢查設定選項。
validation.no.debug.extension.is.installed=未安裝偵錯擴展。
validation.cannot.parse.value.of.0=無法解析 ''{0}'' 的值
validation.connection.was.not.established=未建立連接。
validation.connection.was.not.established.0=無法使用 ''{0}'' 啟動偵錯器會話
validation.connection.was.not.established.no.debug=未安裝偵錯擴展
validation.connection.was.not.established.update.info=更新解釋器資訊
validation.connection.was.not.established.validate.installation=驗證安裝
validation.function.already.exists = 當前命名空間中已定義具有相同名稱的函數
validation.namespace.already.exists = {1}中已定義名稱為 ''{0}'' 的命名空間
validation.class.already.exists = {0}中已經存在具有相同名稱的類
validation.class.cannot.be.overridden = 類“{0}”不能被覆寫
validation.interface.cannot.be.overridden = 無法實作接口“{0}”
validation.test.no.test.patterns = 未添加任何模式

validation.ssh.remote.debug.support=''{0}'' 擴展不支持通過 ssh 進行遠端偵錯。
validation.ssh.remote.code.coverage.support={0} 擴展不支持通過 ssh 進行程式碼覆蓋
remote.interpreter.path.mappings.validation.title=沒有為所選解釋器設定路徑映射。
remote.interpreter.path.mappings.validation.message=請檢查映射是否在 {0} 下正確設定。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href="php_mappings">設定|PHP</a></i></b>
docker.compose.coverage.file.is.not.found=找不到覆蓋率檔案
docker.compose.coverage.file.failed.to.copy=無法從 Docker 容器複製覆蓋率結果
docker.compose.coverage.file.failed.to.extract=無法提取覆蓋率結果
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始終啟動一個新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=連接到現有容器('Docker-compose exec')
docker.compose.failed.to.start.container=啟動 docker-compose 服務失敗，請在命令行中啟動並重試

#errors common
error.template.unable.parse.internal.template=無法解析內部模板 {0}
error.template.unable.create.from.internal.template=無法從內部模板 {0} 創建檔案
error.file.unable.create.selected.directory=無法在所選目錄中創建檔案 {0}
error.cannot.connect.to.0.1=無法連接到 ''{0}'': {1}
error.cannot.connect.to.0=無法連接到 ''{0}''

#messages common
0.completion.shortcut=使用{1}進行{0}補全

#completion
completion.press.again.to.see.more.variants=再次按 {0} 以查看更多變體
completion.press.again.to.see.global.variants=再次按 {0} 以查看全域變體
completion.press.again.to.see.all.classes=再次按 {0} 以查看所有類

#unwrap
unwrap.if=解開 if…
unwrap.while=解開 while...
unwrap.for=解開 for...
unwrap.try=解開 try...
unwrap.else=解開 else...
unwrap.elseif=解開 elseif…
unwrap.dowhile=解開 do-while…
unwrap.foreach=解開 foreach…
unwrap.method=解開 ''{0}''
remove.else=移除 else...


#refactoring
refactoring.common.not.supported.expression.in.scope=當前範圍不支持此類表達式的{0}
refactoring.common.not.supported.context=當前上下文不支持{0}
refactoring.common.not.extractable.expression=不支持此類表達式
refactoring.common.fail.to.extract.expression=無法從所選程式碼段中提取表達式

refactoring.common.ui.target.namespace.label=命名空間(&N):
refactoring.common.ui.target.directory.label=目標目錄(&D):
refactoring.common.ui.target.directory.edit = 按 F2 編輯目標目錄

refactoring.common.validation.namespace.name=“{0}”不是有效的命名空間名稱
refactoring.common.validation.class.psi=無法執行重構: 目標類“{0}”無效
refactoring.common.validation.target.directory.is.not.valid=目錄“{0}”的路徑無效
refactoring.common.validation.target.directory.not.inside.project=目錄“{0}”不在專案內部

refactoring.parameter.reserved.name = 參數名稱“{0}”已保留
refactoring.parameter.validation = 參數 {0} 無效
refactoring.parameter.validation.duplicate.parameter=重複的參數名稱: {0}
refactoring.parameter.validation.initializer.last=必選參數不能位於可選參數後
refactoring.parameter.validation.variadic.last=只有最後一個參數可以是可變形參
refactoring.parameter.validation.variadic.can.have.default.value=可變形參不能具有預設值
refactoring.parameter.validation.initializer.type=具有類類型提示的參數的預設值只能為 NULL
refactoring.parameter.validation.pass.by.reference=僅變數可通過引用傳遞
refactoring.parameter.validation.type=參數類型 ''{0}'' 無效
refactoring.parameter.validation.default.value=預設值表達式 ''{0}'' 無效
refactoring.parameter.validation.initializer=初始設定式 ''{0}'' 無效
refactoring.parameter.validation.no.default.value=應該為參數 ''{0}'' 提供初始設定式或預設值
refactoring.parameter.validation.name.collision.with.use.list=參數名稱 ''{0}'' 無效。''{0}'' 已匯入 use 列表
refactoring.returnType.validation.type=返回類型 ''{0}'' 無效

#refactoring - > extract base
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 關鍵字。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 關鍵字。
refactoring.extract.base.handler.no.expression.selected=選擇不構成正確的表達式
refactoring.extract.base.handler.not.supported.expression=此類表達式不支持{0}
refactoring.extract.base.handler.not.supported.scope=當前範圍不支持{0}
refactoring.extract.base.dialog.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
#refactoring -> extract class
refactoring.extract.class.extract.to.class=提取到類
refactoring.extract.class.extracting.from.file=正在從檔案提取:
refactoring.extract.class.extracting.from.class=正在從類提取:
refactoring.extract.class.dialog.class=類名:
refactoring.extract.class.dialog.generate.accessors=生成存取器
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成員
refactoring.extract.class.error.failed.to.create.file=無法創建檔案
refactoring.extract.class.preview=已提取的類預覽
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=動態宣告屬性用法不支持“提取類”重構
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法 "{0}" 依賴於屬性 "${1}"，需要 "{2}" 中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法 "{0}" 依賴於屬性 "${1}"，需要 "{2}" 中的 setter
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法 "{0}" 依賴於 {1} 方法 "{2}"
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法 "{0}" 依賴於 {1} 常數 "{2}"
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=無法將委託屬性初始化添加到類構造函數
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=無法將委託屬性初始化添加到類構造函數: 特徵構造函數將被覆寫
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取類”重構不支持將寫入權限用於陣列析構表達式中的非 public 屬性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取類”重構不支持將寫入權限用於多個賦值表達式中的非 public 屬性
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所選函數必須屬於專案源
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函數不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名類不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通過 PHPDoc 定義的魔術方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通過 PHPDoc 定義的魔術屬性不支持 Extract Class 重構
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名稱為 "{0}" 的屬性

#refactoring -> extract variable
refactoring.extract.variable.name=提取變數
refactoring.extract.variable.conflict.already.exists=範圍中已經存在名稱為“{0}”的變數。
#refactoring -> extract constant
refactoring.extract.constant.name=提取常數
refactoring.extract.constant.conflict.already.exists=範圍中已經存在名稱為“{0}”的常數。
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的存取級別必須為“{1}”(如在類“{2}”中)或更弱
refactoring.extract.constant.conflict.exists.in.subclass=“{0}::{1}”將被此常數覆寫
refactoring.extract.constant.conflict.cannot.override.interface.constant=無法覆寫接口“{1}”的常數“{0}”
refactoring.extract.constant.unable.to.add.constant.declaration="無法添加常數宣告"

#refactoring -> extract field
refactoring.extract.field.name=提取屬性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的屬性名稱
refactoring.extract.field.conflict.already.exists=該類中已經存在名稱為“{0}”的屬性。
refactoring.extract.field.visibility=可見性
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.private=private(&I)

#refactoring -> extract parameter
refactoring.extract.parameter.name=提取參數

#refactoring -> rename - > element processor
conflict.method.with.same.name.already.exists=此類中已經定義了具有相同名稱的方法
conflict.field.with.same.name.already.exists=此類中已經定義了具有相同名稱的屬性
conflict.class.constant.with.same.name.already.exists=此類中已經定義了具有相同名稱的常數
conflict.variable.with.same.name.already.exists=已經定義了具有相同名稱的變數
conflict.parameter.with.same.name.already.exists=已經定義了具有相同名稱的參數
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.use.with.same.name.already.exists=已經定義名稱相同的 'Use' 語句
conflict.class.with.same.name.already.exists=已經定義了具有相同名稱的類
conflict.function.with.same.name.already.exists=已經定義了具有相同名稱的函數
conflict.constant.with.same.name.already.exists=已經定義了具有相同名稱的常數
refactoring.rename.search.in.global.scope=在全域範圍中搜尋

#refactoring -> rename - > automatic renamers
refactoring.rename.automatic.renamer.accessors.name=重命名存取器(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重命名存取器
refactoring.rename.automatic.renamer.field.accessors.dialog.description=將具有以下名稱的屬性存取器重命名為:
refactoring.rename.automatic.renamer.field.accessors.entity.name=存取器


refactoring.rename.automatic.renamer.class.name=重命名類(&C)
refactoring.rename.automatic.renamer.class.dialog.title=重命名類
refactoring.rename.automatic.renamer.class.dialog.description=將具有以下名稱的類重命名為:
refactoring.rename.automatic.renamer.class.entity.name=類

refactoring.rename.entity.name.inheritor=繼承者/檔案
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=將具有以下名稱的繼承者和相關檔案重命名為:


#refactoring->inline variable
refactoring.inline.variable.cannot.extract.value=無法提取變數 ''${0}'' 的值
refactoring.inline.cannot.find.variable.to.inline=無法找到要內聯的變數
refactoring.inline.variable.no.occurrences=沒有符合項可以被安全地內聯

#refactoring->inline function
refactoring.inline.function.title=內聯{0}重構
refactoring.inline.function.all.invocations.and.remove.the.method=全部內聯並移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部內聯並保留{0}(&E)
refactoring.inline.function.this.invocation.only.and.keep.the.method=僅內聯此調用並保留{0}(&K)
refactoring.inline.function.command=正在內聯{0}
refactoring.inline.function.cannot.inline.function.with.global.usage=無法內聯{0}和 <code>global</code> 用法
refactoring.inline.function.not.accessible.from.caller.site=無法從調用者站點存取成員引用 <code>{0}</code>
refactoring.inline.function.cannot.parse.function.body=無法解析函數體
refactoring.inline.function.cannot.inline.library.function=無法內聯庫函數
refactoring.inline.function.cannot.inline.magic.method=無法內聯魔術方法
refactoring.inline.function.cannot.inline.constructor=無法內聯構造函數
refactoring.inline.function.reference.is.ambiguous=函數引用不明確
refactoring.inline.function.only.static.method.is.supported=僅支援 static 方法
refactoring.inline.function.reference.is.recursive=不支持遞歸調用
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流程時，不支持內聯函數重構
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 類引用在 {0} 中未解析
refactoring.inline.function.yield.found.in.function.body=在函數體中找到 <code>yield</code> 用法

#refactoring->inline constant
refactoring.inline.constant.name=內聯常數
refactoring.inline.constant.command=內聯常數
refactoring.inline.constant.this.reference.only=僅內聯此引用並保留常數
refactoring.inline.constant.all.references.and.remove=全部內聯並移除常數
refactoring.inline.constant.all.references.and.keep=全部內聯並保留常數
refactoring.inline.constant.cannot.extract.value=無法提取常數的值
refactoring.inline.constant.is.never.used=常數 {0} 從未使用
refactoring.inline.constant.multiple.declarations=還有其他具有相同名稱的常數宣告。

#refactoring -> extact method/function
refactoring.extract.method.name=提取函數/方法
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所選塊應代表一組語句或表達式。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一組語句應來自同一程式碼塊。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在會中斷執行的 break/continue 運算符。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所選程式碼段中的返回點不一致。
refactoring.extract.method.tooltip=輸入 $name = 'init'
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.extract.function=提取函數
PhpExtractMethodDialog.visibility=可見性:
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.method=方法:
PhpExtractMethodDialog.function=函數:
PhpExtractMethodDialog.name=名稱(&A):
PhpExtractMethodDialog.declare.static=宣告 static(&S)
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.parameters=參數
PhpExtractMethodDialog.signature.preview=簽名預覽
PhpExtractMethodDialog.replace.tail.break.continue.with.return=將尾“break/continue”語句取代為“return”語句(&T)
PhpExtractMethodDialog.return.output.through=通過以下方式返回輸出變數:
PhpExtractMethodDialog.return.output.through.return=return 語句(&E)
PhpExtractMethodDialog.return.output.through.ref.parameters=通過引用傳遞的參數(&P)
PhpExtractMethodDialog.transformation.options=轉換選項
PhpExtractMethodDialog.output.variables=輸出變數
PhpExtractMethodDialog.duplicates.count=檢查並取代重複項(找到 {0} 個)
PhpExtractMethodDialog.duplicates.pending=正在搜尋重複項…
refactoring.extract.method.from.duplicate.code=從重複的程式碼中提取方法

#find usages
find.options.include.child.methods.checkbox=包括覆寫/實作方法(&V)
find.field.accessors.title=搜尋存取器
find.field.accessors.text=要搜尋 ''{0}'' 的存取器嗎?
usages.show.this.self.references=顯示 $this/自引用

#refactoring -> change signature
change.signature.find.usages.of.base.interface=類 {1} 的方法 {0}\n\
實作了接口 {2} 的方法。\n\
要{3}基方法嗎?
change.signature.find.usages.of.base.class=類 {1} 的方法 {0}\n\
重寫了類 {2} 的方法。\n\
要{3}基方法嗎?
change.signature.tooltip.parameter=$name = 'init' 或 &...$array = 'init'
change.signature.tooltip.default.value=要在此方法的所有現有調用中使用的值
change.signature.error.wrong.caret.position=文字游標應置於要重構的函數的名稱處。
change.signature.usage.view.declarations.header=要重構的函數
change.signature.column.name.parameter=參數:
change.signature.column.type.parameter=類型:
change.signature.initialize.new.parameters=創建並初始化類屬性(&I)
change.signature.parameter.may.have.side.effect=用作參數“{1}”的表達式“{0}”可能會有副作用
change.signature.arg.type.miss.argument=應為 ''{0}'' 類型的參數
change.signature.arg.type.incompatible=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
change.signature.visibility.not.accessible=可見性為 {1} 的{0}將無法從{2}存取

#refactoring -> pull up/push down
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在專案檔案中沒有基類/接口
refactoring.pull.up.implement.method = 在實作接口的類中創建方法存根(&S)
refactoring.pull.up.validation.field.into.interface = 無法將屬性拉入接口
refactoring.pull.up.validation.static.method.into.interface = {0} 為 static，不能為 abstract。
refactoring.pull.up.private.access = {0} 存取權限將更改為 {1}
refactoring.pull.up.abstract.method = 類 {0} 將被標記為 abstract
refactoring.pull.up.conflict.duplicate.constant = {0} 將與 {1} 中的常數衝突。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目標類中將無法存取。
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不應在外部類中靜態調用
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目標類中可能無法存取。
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 為 private，在目標類中將無法存取。
refactoring.push.down.method.implemented.in.interface={0} 必須被宣告為 abstract 或實作 {1}
refactoring.push.down.validation.magic.method=移動魔術方法會產生副作用

#refactoring -> move class
refactoring.move.class.name = 移動類
refactoring.move.class.action.name = 移動類…
refactoring.move.class.title = 將類 {0} 移至命名空間(&C):
refactoring.move.class.new.file = 將類提取到單獨的檔案(&E)
refactoring.move.class.in.non.code.message=註釋和字串中的類引用
refactoring.move.class.cannot.move.anonymous.class=無法移動匿名類

#refactoring -> move namespace
refactoring.move.namespace.name=移動命名空間
refactoring.move.namespace.action.name=移動命名空間…
refactoring.move.namespace.title=移動命名空間 {0}
refactoring.move.namespace.new.namespace=新命名空間名稱(&N):
refactoring.move.related.namespace.description=將具有相關命名空間的檔案移至新目錄:
refactoring.move.related.namespace.title=移動具有相關命名空間的檔案
refactoring.move.related.namespace.name.column=新命名空間名稱
refactoring.move.related.namespace.directory.column=新建目錄
refactoring.move.related.namespace.collect.title=收集子命名空間
refactoring.move.namespace.header.message=移動命名空間
refactoring.move.namespace.message=要移動的命名空間
refactoring.move.namespace.in.non.code.message=註釋和字串中的命名空間引用

#refactoring -> move member
refactoring.move.method.label.text.field=將成員移至類(&C)
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子類 {1} 中被覆寫
refactoring.move.members.there.are.several.classes.with.specified.name=存在多個具有指定名稱 {0} 的類
refactoring.move.members.is.not.a.valid.class.name="{0}" 不是有效的類名
refactoring.move.member.title=移動 static 成員
refactoring.move.member.action.name=移動成員…
refactoring.move.members.to.be.moved=要移至另一個類的成員(&B)
refactoring.move.members.preview.header=要移至另一個類的成員
refactoring.move.members.unable.to.resolve.usage.callback.found=無法解析用法: 發現回調: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=無法解析用法: 檢測到延遲 static 綁定: {0}
refactoring.move.members.late.static.binding.detected=檢測到延遲 static 綁定: {0}
refactoring.move.members.self.from.anonymous.class=無法處理對匿名類的自引用
refactoring.move.members.late.static.binding.detected.in.doc=在文檔中檢測到延遲 static 綁定
refactoring.move.members.is.not.accessible={0} 在 {1} 中無法存取
refactoring.move.members.cannot.find.target.class=找不到類 {0}
refactoring.move.members.member.will.change.visibility.to.public=成員 {0} 會將可見性更改為 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中實作 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中實作方法
refactoring.move.members.0.will.be.hidden.in.1=成員 {0} 將在 {1} 中被隱藏
refactoring.move.members.only.constants.can.be.moved.to.interface = 只有常數可以移至接口

#refactoring -> move file constant
refactoring.move.constant.title=移動常數
refactoring.move.constant.action.name=移動常數…
refactoring.move.constant.label.text.field=將常數 {0} 移至類(&C)
refactoring.move.multiple.constant.label.text.field=將 {0} 個常數移至類(&C)
refactoring.move.constant.unable.to.resolve=無法解析 {0}
refactoring.move.constant.class.already.contains.constant=類 {0} 已包含常數 {1}

#refactoring -> move function
refactoring.move.function.title=移動函數
refactoring.move.function.action.name=移動函數…
refactoring.move.function.label.text.field=將函數 {0} 移至類(&C)
refactoring.move.multiple.functions.label.text.field=將 {0} 個函數移至類(&C)
refactoring.move.constant.class.already.contains.method=類 {0} 已包含方法 {1}
refactoring.move.function.interface.cant.contain.method=接口中不允許帶有主體的方法

#refactoring -> move instance
refactoring.move.method.cannot.move.constructor=無法移動構造函數
refactoring.move.method.cannot.move.magic.method=無法移動魔術方法
refactoring.move.instance.method=移動實例方法
refactoring.move.instance.method.action.name=移動實例方法…
refactoring.move.instance.method.preview.header=要移至另一個類的方法
refactoring.move.instance.method.this.parameter.label=將取代類 {0} 的 $this 引用的參數名稱
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 將無法存取。應提高方法可見性

#refactoring -> make static then move method
refactoring.make.static.then.move.method.select=將方法 ''{0}'' 移至類
refactoring.make.static.then.move.method.message=方法 ''{0}'' 將被設為 ''public static''

#refactoring -> extract interface
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.title=從類 ''{0}'' 提取接口
refactoring.extract.interface.invalid.caret.location=文字游標應置於要重構的類名處。
refactoring.extract.interface.invalide.extract.from.trait=無法從特徵提取接口。
refactoring.extract.interface.no.methods=沒有要提取到接口的方法。
refactoring.extract.interface.field=接口名稱(&I):
refactoring.extract.replace.class.reference=盡可能將類引用取代為接口(&F)
refactoring.extract.interface.members.title=要構成接口的成員(&B)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.phpdoc.do.nothing=保留原樣(&A)
refactoring.extract.interface.phpdoc.copy=複製(&C)
refactoring.extract.interface.phpdoc.move=移動(&M)
refactoring.extract.interface.validation.members.modifier=對於每個提取的方法，修飾符將更改為 public。
refactoring.extract.interface.fail.to.create.file=無法創建檔案 ''{0}''。

#refactoring -> make method static
refactoring.make.method.static=將方法設為 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法調用
refactoring.make.method.static.method.converts.method.to.static=將方法轉換為 static
refactoring.make.method.static.dynamic.method.call.found=實例物件應作為參數傳遞，找到動態方法調用: {0}
refactoring.make.method.static.this.found=實例物件應作為參數傳遞，找到 $this
refactoring.make.method.static.references.to.be.changed=待變更引用 {0}
refactoring.make.method.static.doc.method.is.not.supported=不支持文檔方法
refactoring.make.method.static.method.is.overridden=方法 {0} 被覆寫
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作為參數傳遞的屬性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 屬性 {0} 無法從類外部存取
refactoring.make.method.static.protected.field.is.not.accessible=protected 屬性 {0} 無法從類及其繼承者外部存取
refactoring.make.method.static.writeAccess=檢測到 {0} 寫入存取，實例物件應作為參數傳遞。
refactoring.make.method.static.magic.method=魔術方法不能設為 static
refactoring.make.method.static.add.parameters.for.fields=添加屬性參數(&P):

#actions
#action -> detect namespace roots
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空間根檢測
actions.detect.namespace.roots.notification.title=檢測 PSR-0 命名空間根
actions.detect.namespace.roots.title=正在檢測 PSR-0 命名空間根…
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空間根檢測。
actions.detect.namespace.roots.no.new.roots.detected=未檢測到新的 PSR-0 命名空間根。
actions.detect.namespace.roots.view.configuration=檢視設定
actions.detect.namespace.roots.manual.configuration=手動設定
actions.detect.namespace.roots.idea.view.configuration=您可以在 '專案結構 | 模組' 中修改設定。
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.from.composer.idea.title=源根

#action -> detect language level
actions.detect.language.level.loaded.from.composer.title=PHP 語言級別
actions.detect.language.level.loaded.from.composer.idea.title=語言級別

#action --> common settings
actions.detect.common.setting.from.composer.suggest.title=將設定與 Composer 同步?
actions.detect.common.setting.from.composer.enable=啟用同步
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.settings.updated.from.composer.title={0} 設定已更新
actions.detect.common.settings.composer.sync.state.title=與 composer.json 的同步{0}
actions.detect.common.setting.from.composer.show.settings=顯示設定

action.detect.user.settings.state.overwritten=如果開啟同步，IDE 設定(PHP 語言級別，PSR-0/PSR-4 根)可能會被覆蓋
action.detect.user.settings.state.supported=支援 PSR-0/PSR-4 根和 PHP 語言級別的同步
action.detect.user.settings.state.overwritten.short=設定可能會被覆蓋: PSR-0/PSR-4 根和 PHP 語言級別。
action.detect.settings.sync.turned.on.title=已與 composer.json 同步
action.detect.settings.sync.turned.on=PHP 語言級別已與 composer.json 同步
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.not.found=在路徑 {0} 下找不到 composer.json
action.detect.composer.json.open=在編輯器中開啟

#action -> mark directory as namespace root
actions.mark.directory.as.psr.0.root.title=要將資料夾標記為 {0} 根嗎?
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>為前綴“{1}”?
actions.mark.directory.as.psr.0.root.mark.psr=標記為 {0} 根

#action - > new php base
actions.new.php.base.dialog.label.file.name=文件名:
actions.new.php.base.dialog.label.extension=檔案副檔名:
actions.new.php.base.arrows.extension.tooltip=在編輯器中按向上或向下箭頭可更改檔案副檔名
actions.new.php.base.arrows.template.tooltip=在編輯器中按向上或向下箭頭可更改模板

#action -> new php file
actions.new.php.file.action.name=PHP 檔案
actions.new.php.file.action.description=創建新的 PHP 檔案
actions.new.php.file.dialog.title=創建新的 PHP 檔案

#action -> new php class
actions.new.php.class.action.name=PHP 類
actions.new.php.class.action.description=創建新的 PHP 類
actions.new.php.class.dialog.title=創建新的 PHP 類
actions.new.php.class.dialog.label.class.name=名稱:
actions.new.php.class.dialog.label.namespace=命名空間:
actions.new.php.class.dialog.label.directory=目錄:
actions.new.php.class.dialog.label.template=模板:
actions.new.php.class.dialog.label.superclasses.container=父類
actions.new.php.class.dialog.label.superclasses.super.fqn=擴展:
actions.new.php.class.dialog.label.superinterfaces.add.interface=添加接口…
actions.new.php.class.dialog.label.superinterfaces.to.implement=實作:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=選擇要實作的接口
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=選擇要擴展的接口
actions.new.php.class.dialog.border.title.class=類

#action -> new php test
actions.new.test.class.action.name=新建 PHP 測試
actions.new.test.class.action.description=創建新的 PHP 測試
actions.new.test.class.dialog.title=創建新的 PHP 測試
actions.new.test.class.dialog.title.named=為 {0} 創建新的 PHP 測試
actions.new.test.class.dialog.label.name=名稱:
actions.new.test.class.dialog.label.namespace=命名空間:
actions.new.test.class.dialog.label.directory=目錄:
actions.new.test.class.dialog.label.fqn=完全限定名稱:
actions.new.test.class.dialog.border.title.class.to.test=要測試的類(可選)
actions.new.test.class.dialog.border.title.test.class=測試類
actions.new.test.class.dialog.border.title.target.class.file.path=檔案路徑:
actions.new.test.class.dialog.arrows.libraries.hint=在編輯器中按向上或向下箭頭可更改測試庫
actions.new.test.class.dialog.select.methods.show.inherited.methods=顯示繼承的方法(&I)

#action -> new PHPUnit test
actions.new.phpunit.class.action.name=PHPUnit 測試
actions.new.phpunit.class.action.description=創建新的 PHPUnit 測試

#action -> generate php doc
actions.generate.php.doc.is.not.available=PHPDoc 生成在索引更新期間不可用

unnamed.variable=(未命名)
server=伺服器
#Connection -> Server Connection
connection.port.is.busy=連接埠 {0} 繁忙

#Server configuration
debug.server.import.configuration.dialog.title=從部署設定匯入
debug.server.import.configuration.preview.border.title=預覽
debug.server.import.configuration.path.to.remote.root=部署根的絕對路徑(&R):
debug.server.import.configuration.path.to.remote.root.sftp=絕對遠端根: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=遠端檔案的絕對路徑:<br>"遠端根的絕對路徑" . "根路徑" (來自部署設定) . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.path.to.remote.root.mounted=本地: ''{0}'' -> 遠端: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已掛載資料夾的遠端路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=遠端檔案的絕對路徑:<br>"已掛載資料夾的遠端路徑" . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.deployment=部署(&D):
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.mounted=已掛載(&M)

debug.server.import.configuration.local.file.path=本地檔案路徑:
debug.server.import.configuration.project=專案(&P):
debug.server.import.from.deployment.deployment.configurations.message=找到具有相關路徑映射的部署設定。
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合適的部署設定
debug.server.import.from.deployment.no.deployment.configurations.tooltip=設定部署根(如果不為空)
debug.server.import.from.deployment.deployment.root.label=部署根(&R):
debug.server.import.from.deployment.radio=從部署匯入映射(&I)
debug.server.manually.select.file.or.project=手動選擇本地檔案或專案(&M)
debug.server.manually.select.file.message=選擇一個專案或檔案進行偵錯
debug.server.select.file.mapping=設定本地檔案路徑
debug.server.detect.path.mappings.from.deployment.progress=正在為 ''{0}'' 專案分析路徑映射
debug.server.detect.path.mappings.from.deployment=正在檢測現有路徑映射…
debug.server.can.not.detect.path.mappings.from.deployment=無法評估路徑映射: 未選擇目標部署伺服器

#Debug
debug.accept.connection=接受
debug.ignore.connection=忽略
debug.incoming.connection.title.0=來自 {0} 的傳入連接
debug.path.on.server=伺服器上的絕對路徑
debug.error.cannot.modify.value=無法修改值
debug.error.cannot.evaluate.variables=無法評估變數
debug.error.cannot.evaluate.expression0=無法評估表達式 ''{0}''
debug.error.cannot.evaluate.expression=無法評估表達式
debug.process.cannot.find.file.in.project=在專案中找不到路徑為 ''{0}'' 的檔案
debug.process.cannot.find.server.name=找不到源位置。名稱為 ''{0}'' 的伺服器不存在。
debug.process.status.disconnected=已斷開連接
debug.process.status.wait=正在等待與{0} ''{1}'' 的傳入連接
debug.process.status.connected=已連接
debug.process.console.error.format={0}: {1}，{2} 中的第 {3} 行\n\

debug.mapping.resolve.dialog.stop.debugger=停止偵錯器
debug.zend.error.title.cannot.accept.external.xdebug.connection=無法接受外部 Xdebug 連接
debug.zend.required.protocol.version.0.or.higher=所需協議版本為 ''{0}'' 或更高版本
debug.error.title.cannot.accept.external.0.connection=無法接受外部 {0} 連接
debug.zend.cannot.accept.incoming.connection=無法接受來自 Zend Debugger 的傳入連接
debug.zend.debugger.settings.broadcasting=Zend Debugger 設定廣播
debug.zend.debugger=Zend 偵錯器
debug.xdebug=Xdebug
debug.not.installed=<未安裝>
debug.process.cannot.find.file.link=更多資訊
debug.process.cannot.find.file=在本地找不到檔案 ''{0}''。\n\
要修復，請通過環境變數 PHP_IDE_CONFIG 設定伺服器名稱，然後重新啟動偵錯會話。
debug.process.cannot.find.local.file=在伺服器 {0} 上找不到檔案的本地副本\n\
本地路徑為 {1}
debug.process.cannot.find.path.mapping=遠端檔案路徑 ''{0}'' 未映射到專案中的任何檔案路徑
debug.process.script.outside.project=腳本 ''{0}'' 在專案外部。
debug.process.cant.compute.source.position=無法計算源位置。腳本 ''{0}'' 未與任何文本檔案類型關聯。
debug.edit.path.mappings=點擊以設定路徑映射
debug.configure.servers=設定伺服器
debug.settings.broadcasting.port=設定廣播連接埠:
debug.settings.auto.detect.ide.host=自動檢測 IDE IP:
debug.debug.port=偵錯連接埠:
debug.error=錯誤
debug.process.cannot.find.remote.copy.local.file=專案 ''{0}'' 中的檔案路徑未映射到伺服器上的任何檔案路徑
debug.cannot.map.local.file=檔案路徑未映射到伺服器上的任何檔案路徑。編輯路徑映射以解決此問題。
debug.resolve.mapping.problem=解決路徑映射問題
debug.cannot.start.listening.for.connections.from.0=無法開始偵聽來自 ''{0}'' 的連接
debug.cannot.start=無法啟動 ''{0}''
debug.stop.listen.debug.connections=停止偵聽 PHP 偵錯連接
debug.start.listen.debug.connections=開始偵聽 PHP 偵錯連接
debug.breakpoint.was.resolved=此處的偵錯會話已暫停，因為 ''{0}'' 處的中斷點已被解析到此位置。<br/>您可以<a href="disable">禁用</a>中斷點解析或<a href="more">了解詳情</a>。<a href="dontshow">不再顯示</a>
debug.breakpoint.resolved.disabled=中斷點解析已被禁用，從下一個偵錯會話開始將不會解析中斷點。 您可以稍後在 <a href="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.notify.disabled=中斷點解析通知已被禁用。您可以在 <a href="open">PHP|偵錯|進階設定</a>下將其啟用。
debug.log.invalid.xdebug.message=由於 Xdebug 訊息無效，無法在中斷點處停止。\n\
要解決此問題，請切換到穩定版本的 Xdebug 或使用 'xdebug.remote_log' 選項收集日誌並創建錯誤報告。 
debug.log.stop=停止於 (''{0}'':{1})
debug.log.path.mapping.remote.local=遠端: ''{0}'' <-> 本地: ''{1}''
debug.log.path.mapping.remote.extracted=遠端: ''{0}'' <-> 提取: ''{1}''
debug.log.stack.frame=框架: {0}:{1}，{2}
debug.log.connection.was.terminated=偵錯連接在 ''{0}'':''{1}'' 上意外終止
debug.log.cant.register.breakpoint.no.remote=無法註冊中斷點。沒有本地路徑 ''{0}'' 的路徑映射
debug.log.cant.register.breakpoint.no.template.mapping=無法註冊中斷點。沒有到 PHP 行 ''{0}'' 的映射
debug.log.exception.break=異常中斷: {0} ({1})
debug.file.is.ignored=檔案 ''{0}'' 被跳過。
debug.edit.ignored.paths.list=<a href="#a">編輯</a>跳過的路徑。
debug.composite.value.presentation=[{0}]
debug.error.unknown.debugger.id=未檢測到偵錯器擴展
debug.error.wrong.debugger.id=不支持 {0}
debug.type.array=陣列
debug.type.resource=資源
debug.type.int=int
debug.type.float=浮點
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 協議版本
debug.php.line.breakpoint.title=PHP 行中斷點
debug.php.exception.breakpoint.title=PHP 異常中斷點
debug.php.exception.breakpoint.not.supported=載入的偵錯擴展不支持異常中斷點
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持異常中斷點
debug.php.exception.breakpoint.dialog.title=添加異常中斷點
debug.php.exception.breakpoint.exception.name=異常名稱:
debug.php.method.breakpoint.title=PHP 方法中斷點
debug.php.method.breakpoint.dialog.title=添加方法中斷點
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法中斷點
debug.php.breakpoint.failed.to.register=無法註冊中斷點，請嘗試將其禁用並重新啟用。
debug.error.cannot.parse.ssh.connection=無法從 $_SERVER[''SSH_CONNECTION''] 解析連接埠: ''{0}''
debug.error.cannot.parse.server.name.for.external.connection=無法為外部 {0} 連接解析伺服器名稱。
debug.error.cannot.parse.server.name=要修復，請在遠端伺服器上創建環境變數 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows:</i> 設定 PHP_IDE_CONFIG="serverName=SomeName"<br/> <i>Linux / Mac OS X:</i> 匯出 PHP_IDE_CONFIG="serverName=SomeName"。
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b> 為空，這可能是 Web 伺服器設定錯誤所致。<br/><br/><i>Nginx:</i> 將 fastcgi 參數添加至 nginx 設定，<a href="http://wiki.nginx.org/PHPFcgiExample">更多</a><br/><i>Apache:</i> 為當前 VirtualHost 設定 ServerName，<a href="https://httpd.apache.org/docs/2.4/vhosts/name-based.html">更多</a>

debug.php.external.connection.finished.warning.title=偵錯會話已完成且未暫停
debug.php.external.connection.finished.warning=這可能是由於路徑映射設定錯誤或本地和遠端專案未同步。<br/><br/>要找出問題，請在 <b><i><a href="servers">PHP|伺服器</a></i></b>下檢查 ''{0}'' 伺服器的路徑映射設定，或啟用 <b><i><a href="break">''在 PHP 腳本中的第一行中斷''</a></i></b> 選項(位於<i>執行</i>選單下)。<br/><a href="ignore">不再顯示</a>
debug.php.external.connection.finished.break.at.first.line.title=PHP 偵錯設定
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中斷'</i></b> 選項已啟用

debug.process.smart.step.into.popup=單步進入函數
debug.process.smart.step.into.function.evaluation.error =無法評估目標函數。將執行“單步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未調用所選函數。

#rest client
debug.rest.client.error.cannot.evaluate.server.name.title=無法通過伺服器名稱找到對應的“PHP|伺服器”
debug.rest.client.error.cannot.evaluate.server.name=無法評估 '$_SERVER['SERVER_NAME']'。請確保為您的 Web 伺服器設定了正確的伺服器名稱。<br>點擊此<a href="help">鏈接</a>獲取更多資訊。

# custom actions
debug.function.was.added.to.skip.list=''{0}'' 已添加到跳過列表。
debug.action.copy.as.title=將變數複製為 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=無法將變數複製為 ''{0}''，無法評估完整的變數名
debug.action.copy.value.as.text=將值複製為…

debug.label.select.a.project.or.a.file.to.debug=選擇一個專案或檔案進行偵錯
debug.label.select.a.project.to.debug=選擇一個專案進行偵錯
debug.label.file.path.on.server=伺服器上的檔案路徑:
debug.label.file.path.in.project=專案中的檔案路徑:
debug.checkbox.can.accept.external.connections=可以接受外部連接
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系統請求
debug.label.max.simultaneous.connections=最大同時連接數:

# templates
template.debug.path.to.output.folder.descr=指定快取目錄路徑
template.debug.path.to.output.folder=快取目錄路徑
template.debug.cache.path=快取路徑:
template.debug.cache.dir.is.incorrect=模板偵錯: 在設定中指定的快取目錄路徑無效
template.debug.cache.dir.is.not.specified=模板偵錯: 未在設定中指定快取目錄路徑
template.debug.php.file.not.found=模板偵錯: 未找到 {0} 的相應 PHP 檔案

postfix.template.provider.display.name=PHP

template.smart.completion.function.parameters.description=智能函數參數補全

debug.expression.evaluation.fail=由於返回值未知，無法評估表達式

dbgp.proxy=Xdebug 代理
dbgp.proxy.port=代理連接埠
dbgp.proxy.host=代理主機
dbgp.proxy.ide.key=IDE 鍵
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 鍵 ''{0}'' 註冊
dbgp.proxy.ide.unregister.success=IDE 已成功註銷
dbgp.proxy.ide.register.error=無法使用 IDE 鍵 ''{0}'' 註冊 IDE
dbgp.proxy.cannot.connect.to.host=無法連接到主機 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=無法連接到 ''{0}:{1}'' 上的 Xdebug 代理
dbgp.proxy.sending.request.to.xdebug.proxy=正在將請求发送到 Xdebug 代理…

profiler.xdebug.task.title=分析 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.file.chooser.title=選擇 Xdebug 分析器快照

profiler.view.execution.statistics.title=執行統計
profiler.view.call.tree.title=調用樹
profiler.view.callees.title=被調用方
profiler.view.callers.title=調用方
profiler.column.time.title=時間
profiler.column.memory.title=內存(B)
profiler.column.own.memory.title=自身記憶體(B)
profiler.column.own.time.title=自用時間
profiler.column.invocation.count.title=調用
profiler.column.invocation.callable=可調用
profiler.column.script=腳本

profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.button.refresh=重新整理
profiler.label.time=時間:

#phpunit
php.uml.provider.presentable.name=PHP 類圖

#coverage
coverage.is.not.supported.for.selected.run.profile=程式碼覆蓋率與所選執行設定檔案不相容

#UI

#run configurations -> components -> command line
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解釋器選項
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.interpreter.options=解釋器選項:
PhpCommandLineConfigurationEditor.field.custom.working.directory=自訂工作目錄:
PhpCommandLineConfigurationEditor.field.environment.variables=環境變數:

#run configurations -> components -> test runner
PhpUnitTestRunnerConfigurationEditor.test.runner=測試執行程序
PhpUnitTestRunnerConfigurationEditor.scope=測試範圍:
PhpUnitTestRunnerConfigurationEditor.scope.directory=目錄
PhpUnitTestRunnerConfigurationEditor.scope.class=類
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在設定檔案中定義
PhpUnitTestRunnerConfigurationEditor.field.directory=目錄:
PhpUnitTestRunnerConfigurationEditor.field.method=方法:
PhpUnitTestRunnerConfigurationEditor.field.class=類:
PhpUnitTestRunnerConfigurationEditor.field.file=檔案:
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代設定檔案(&U):
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代啟動檔案(&U):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=測試執行程序選項(&O):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首選覆蓋率引擎:
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=測試執行程序選項

# run configurations
PhpScripRunConfigurationEditor.configuration.display.name=PHP 腳本
PhpScripRunConfigurationEditor.configuration.description=PHP 腳本設定
PhpScripRunConfigurationEditor.file=檔案:
PhpScripRunConfigurationEditor.arguments=實參:
PhpScripRunConfigurationEditor.arguments.caption=實參

PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 請求
PhpHttpRequestRunConfiguration.configuration.description=HTTP 請求設定
PhpHttpRequestRunConfiguration.error.fetch.result=響應正文不可用
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名稱為 ''{0}'' 的遠端伺服器
PhpHttpRequestRunConfiguration.error.host.is.not.specified=伺服器 ''{0}'' 的主機未指定或無效
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或無效: ''{0}''。
PhpHttpRequestRunConfiguration.error.server.configuration=無法執行 HTTP 請求: ''{0}''。請在“PHP|伺服器”下檢查伺服器設定。

RunConfigurationEditor.configuration=設定
RunConfigurationEditor.server=伺服器(&S):
RunConfigurationEditor.error.server.is.not.selected=未選擇伺服器
RunConfigurationEditor.error.server.is.not.exist=名稱為 ''{0}'' 的伺服器不存在

PhpWebAppRunConfigurationEditor.configuration.display.name=PHP Web 頁面
PhpWebAppRunConfigurationEditor.configuration.description=PHP Web 頁面設定
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U):
PhpWebAppRunConfigurationEditor.browser=瀏覽器(&B):
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式錯誤 - {0}

PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 遠端偵錯
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 偵錯設定
PhpRemoteDebugRunConfigurationEditor.server.label=伺服器(&E)：
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 鍵(會話 ID)(&K):
PhpRemoteDebugRunConfigurationEditor.auto.config=通過 IDE 鍵篩選偵錯連接
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 鍵(會話 ID)不能為空
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已開始偵聽傳入 PHP 偵錯連接
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=進階選項
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=適用於複雜伺服器設定，例如同一主機連接埠上有多個應用程式。<p/>保持未選中狀態以自動檢測設定，或使用<i>“偵聽偵錯連接”</i>操作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=閱讀更多資訊
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=沒有為 <i>''{0}''</i> 執行設定指定<i>伺服器</i>，因此 PhpStorm 將偵聽所有傳入偵錯連接。<br/>查看<a href="zero_config">零設定偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連接，請使用<a href="stop">執行|停止偵聽 PHP 偵錯連接</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“偵聽傳入偵錯連接”已啟用，不會發生任何變化。<br/>查看<a href="zero_config">零設定偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連接，請使用<a href="stop">執行|停止偵聽 PHP 偵錯連接</a>。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止偵聽傳入 PHP 偵錯連接
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止偵聽傳入偵錯連接。

PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 內建 Web 伺服器
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 內建 Web 伺服器設定
PhpBuiltInWebServerRunConfigurationEditor.title=伺服器設定
PhpBuiltInWebServerRunConfigurationEditor.host=主機:
PhpBuiltInWebServerRunConfigurationEditor.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.document.root=文檔根:
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 腳本:

PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通過未註冊的伺服器設定忽略外部連接
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果中斷點在當前行不可用，則解析中斷點(Xdebug 2.8+)
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路徑映射時，在第一行強制中斷
PhpDebugConfigurable.xdebug.force.break.when.outside.project=當腳本在專案外部時，在第一行強制中斷
PhpDebugConfigurable.xdebug.debug.port=Xdebug 偵錯連接埠
PhpDebugConfigurable.zend.debug.port=Zend Debugger 偵錯連接埠
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 設定廣播連接埠
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主機
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在檢測…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在檢測 Zend Debugger 的 IP…
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.zend.debugger=Zend 偵錯器
PhpDebugConfigurable.safe.evaluation.mode=值提示和監視框架下的安全評估模式
PhpDebugConfigurable.import.use.statements=從評估上下文匯入命名空間和 'use' 語句
PhpDebugConfigurable.show.array.children.in.repl=在偵錯主控台中顯示陣列和物件子級
PhpDebugConfigurable.external.connections=外部連接
PhpDebugConfigurable.pass.required.configuration.options=通過命令行傳遞所需設定選項(仍需要手動啟用偵錯擴展)
PhpDebugConfigurable.advanced.settings=進階設定
PhpDebugConfigurable.notify.session.stopped.without.pause=在偵錯會話完成而不暫停時通知
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否將中斷點解析為另一行(Xdebug 2.8+)
PhpDebugConfigurable.detect.path.mappings.from.deployment=檢測部署設定的路徑映射
PhpDebugConfigurable.break.at.first.line=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.evaluation=評估
PhpDebugConfigurable.zero.configuration=預設定
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安裝
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 偵錯器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 伺服器上。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=驗證
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 伺服器上的偵錯器設定。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安裝
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=瀏覽器工具欄或小書籤。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 啟用 PHP 偵錯連接偵聽:
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具欄或小書籤在瀏覽器中啟動偵錯會話。
PhpDebugConfigurable.zero.configuration.tutorial=有關更多資訊，請參見
PhpDebugConfigurable.zero.configuration.tutorial.action=“零設定偵錯”教程

PhpDebugConfigurable.zero.configuration.listen.for.connections.action=開始偵聽
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止偵聽
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 啟動“PHP 遠端偵錯”執行設定。
PhpDebugConfigurable.web.page.pre.config.title=偵錯預設定
PhpDebugConfigurable.web.page.listen.for.connections=2. 啟動“PHP Web 頁面”執行設定。

PhpDebugSkippedPathsConfigurable.display.name=跳過的路徑
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳過的檔案
PhpDebugSkippedPathsConfigurable.column.title=跳過的路徑

PhpFrameworksCommonConfigurable.display.name=框架

PhpStepFiltersConfigurable.title.methods=方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名稱
PhpStepFiltersConfigurable.add.method=添加方法
PhpStepFiltersConfigurable.skip.magic.methods=跳過魔術方法
PhpStepFiltersConfigurable.skip.constructors=跳過構造函數
PhpStepFiltersConfigurable.skipped.methods=跳過的方法
PhpStepFiltersConfigurable.title.files=檔案
PhpStepFiltersConfigurable.skipped.files=跳過的檔案
PhpStepFilters.log.frame=框架已被跳過。函數名稱: {0}。遠端檔案 URL: {1}

PhpServerConfigurable.shared=共享(&S)
PhpServerConfigurable.host=主機
PhpServerConfigurable.host.label=主機(&H):
PhpServerConfigurable.port=連接埠
PhpServerConfigurable.port.label=連接埠(&P)
PhpServerConfigurable.debugger.label=偵錯器(&D)

# web server validation for debug
php.web.server.validation.title=驗證 Web 伺服器上的偵錯器設定
php.web.server.validation.action.text=Web 伺服器偵錯驗證
php.web.server.validation.local.web.server.radio=本地 Web 伺服器或共享資料夾(&L)
php.web.server.validation.remote.web.server.radio=遠端 Web 伺服器(&R)
php.web.server.validation.local.path.to.script=創建驗證腳本的路徑(&P):
php.web.server.validation.local.path.to.script.tooltip=所選路徑應可通過 Web 伺服器存取
php.web.server.validation.url.to.validation.script=驗證腳本的 URL(&U):
php.web.server.validation.url.to.validation.script.tooltip=所選 Web 路徑將用於執行驗證腳本
php.web.server.validation.deployment.server=部署伺服器(&D):
php.web.server.validation.deployment.server.tooltip=所選伺服器會用於將驗證腳本部署到遠端伺服器
php.web.server.validation.process.title=驗證 Web 伺服器
php.web.server.validation.dialog.validate.button=驗證(&V)
php.web.server.validation.chose.path.to.script=選擇驗證腳本的路徑
php.web.server.validation.chose.path.to.script.description=選擇本地資料夾以創建驗證腳本
php.web.server.validation.invalid.path.to.script=驗證目錄的路徑無效
php.web.server.validation.configure.local=請設定驗證腳本的本地和 Web 路徑
php.web.server.validation.configure.remote=請設定驗證腳本的路徑並選擇部署伺服器
php.web.server.validation.failed.to.find.web.path=請設定驗證腳本的 Web 路徑
php.web.server.validation.failed.to.find.deployment.settings=無法找到伺服器的部署設定
php.web.server.validation.failed.to.map.deployment.folder=請為驗證目錄設定遠端路徑映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=請為驗證目錄設定 Web 路徑映射
php.web.server.validation.uploading.validation.script=正在將驗證腳本上傳至 {0}
php.web.server.validation.failed.to.deploy.validation.script=無法將驗證腳本部署到伺服器
php.web.server.validation.failed.to.fetch.script.result=無法提取驗證腳本的結果
php.web.server.validation.script.result.is.empty=驗證腳本的結果為空
php.web.server.validation.script.result.wrong.format=驗證腳本的結果具有意外格式
php.web.server.validation.script.local.result.path.mapping.check=請檢查是否為 <b>''{0}''</b> 目錄正確設定了驗證腳本的 Web 路徑
php.web.server.validation.script.result.path.mapping.check=請檢查是否在部署設定中為 <b>''{0}''</b> 目錄正確設定了遠端和 Web 路徑映射
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到達，原因是: ''{0}''
php.web.server.validation.configuration.files=<b>已載入的 php.ini:</b> {0}
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 檔案:</b> {0}
php.web.server.validation.no.configuration.files=找不到 php.ini 檔案
php.web.server.validation.server.name=<b>伺服器名稱:</b> {0}
php.web.server.validation.server.name.is.empty=伺服器名稱為空
php.web.server.validation.server.name.is.empty.description=伺服器名稱對於 PhpStorm 中的標識是必要的。<br>請在 Web 伺服器設定檔案中進行設定。
php.web.server.validation.no.debugger.extension=未載入偵錯擴展
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 擴展均已載入
php.web.server.validation.multi.debugger.extension.description=只有一個偵錯器擴展可在 php.ini 中載入。
php.web.server.validation.loaded.debugger.extension=<b>偵錯器擴展:</b> {0}
php.web.server.validation.xdebug.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.xdebug.debugger.localhost=儘管伺服器主機可能不在本地，但遠端主機仍設定為 ''{0}''
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 檔案中，將 <b>''{0}''</b> 設為 <i>''{1}''</i> 或自 Web 伺服器可見的本地機器 IP 地址。
php.web.server.validation.xdebug.debugger.host.description=正在執行偵錯器<b>客戶端</b>的主機。
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必須通過 'zend_extension' 而不是 'extension' 載入
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 檔案中使用 <b>'zend_extension=path_to_xdebug.so'</b> 行以載入 Xdebug 擴展。
php.web.server.validation.xdebug.port=<b>遠端連接埠:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>遠端連接埠:</b> {0}，需要根權限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小於 1024 的連接埠，必須具有根權限。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 連接埠無效:</b> ''{0}''
php.web.server.validation.xdebug.wrong.port=Xdebug 連接埠(''{0}'')與“PHP->偵錯 IDE”設定(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=來自 php.ini (<b>{0}</b>)的 Xdebug 連接埠應與在 IDE 內(在 <b>PHP->偵錯</b>下)設定的連接埠相同。
php.web.server.validation.xdebug.remote.is.not.enable=遠端偵錯未啟用
php.web.server.validation.xdebug.remote.is.not.enable.description=將 <b>''{0}''</b> 行添加到 php.ini 檔案。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 選項設定為 ''{1}''，這對於 xdebug3 是無效模式。
php.web.server.validation.xdebug.remote.autostart.description=偵錯會話將嘗試為每個請求啟動。
php.web.server.validation.xdebug3.start.with.request.description=偵錯會話將嘗試根據相應設定自動啟動。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}:</b> 選項設定為 ''{1}''。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}:</b> 選項未啟用
php.web.server.validation.xdebug3.start.upon.error.description=偵錯會話將嘗試根據相應設定在錯誤時自動啟動。
php.web.server.validation.xdebug.option.is.enabled=<b>{0}:</b> 選項已啟用
php.web.server.validation.xdebug3.discover.client.with.discover.header=根據 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 將嘗試自動連接到客戶端。若失敗，則以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.discover.client=根據 <b>$_SERVER['HTTP_X_FORWARDED_FOR']</b> 和 <b>$_SERVER['REMOTE_ADDR']</b> 中的值，Xdebug 將嘗試自動連接到客戶端。若失敗，則回到 <b>'xdebug.client_host'</b>。
php.web.server.validation.xdebug3.discover.client.message=<b>發現客戶端主機:</b> xdebug 將嘗試自動提取客戶端主機。
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}:</b> 選項將被忽略。
php.web.server.validation.xdebug.remote.mode.jit=<b>遠端模式:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=偵錯會話將僅在出現錯誤後初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>遠端模式:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=偵錯會話將在腳本啟動時初始化。
php.web.server.validation.xdebug3.remote.mode.emulation.description=偵錯會話將在腳本啟動時初始化，與 xdebug2 的 <b>remote_mode=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>遠端模式:</b> xdebug2 的 ''{0}'' 已模擬。 
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 現在不接受外部連接
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的云 ID:</b> 與伺服器上的云 ID 不同
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的云 ID:</b> {0}<br><b>伺服器上的云 ID:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通過 Xdebug Cloud 連接:</b> 已禁用。請在 IDE 設定中進行啟用: <b>PHP->偵錯->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 云偵錯:</b> 已禁用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的云 ID:</b> 與伺服器上的云 ID 相同
php.web.server.validation.xdebug.mode.is.not.supported=不支持遠端模式 ''{0}''
php.web.server.validation.xdebug.remote.log=<b>{0}:</b> {1}
php.web.server.validation.xdebug.protocol.is.not.supported=不支持偵錯協議 ''{0}''
php.web.server.validation.zend.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.zend.debugger.localhost=儘管伺服器不在本地，但偵錯會話僅適用於本地主機。
php.web.server.validation.zend.debugger.localhost.description=將正在執行偵錯器<b>客戶端</b>的主機添加至 <b>'zend_debugger.allow_hosts'</b> 選項。
php.web.server.validation.zend.debugger.deny.host=<b>拒絕主機:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=無法使用拒絕主機從客戶端進行偵錯。
php.web.server.validation.zend.expose.remotely=<b>屬性 ''expose_remotely''</b> 設為 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=偵錯器會話將嘗試從 <b>'zend_debugger.allow_hosts'</b> 選項為主機啟動。
php.web.server.validation.zend.expose.remotely.always.description=偵錯器會話將嘗試為每個客戶端啟動。
php.web.server.validation.zend.expose.remotely.never.description=偵錯器會話將不會進行初始化，<b>'zend_debugger.allow_hosts'</b> 選項將被忽略。<br>將選項 <b>'zend_debugger.expose_remotely'</b> 設定為 'allowed_hosts' 或 'always' 以啟用 Web 伺服器偵錯。
php.web.server.validation.reference.to.documentation=請參閱<a href="{0}">{0}</a>獲取更多資訊。

PhpPathMappingsConfigurable.use.path.mappings.label=使用路徑映射(選擇伺服器是遠端伺服器還是使用符號鏈接)

PhpMappingSimpleResolveDialog.title=為伺服器上的檔案路徑選擇本地檔案

DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.ide.key=IDE 鍵:
DBGPProxyConfigurable.host=主機:
DBGPProxyConfigurable.port=連接埠:

xdebug.initializing.debugger.connection=正在連接到 {0}…
xdebug.initializing.connection.failed.with.timeout=無法連接到 {0}: 超時
xdebug.initializing.connection.debugger=偵錯器
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud

XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.connect.via.xdebug.cloud=連接到 Xdebug Cloud
XdebugCloudConfigurable.cloud.id=Cloud ID:
XdebugCloudConfigurable.custom.server=連接到預置 Xdebug Cloud
XdebugCloudConfigurable.base.host=Cloud 主機:
XdebugCloudConfigurable.port=Cloud 連接埠:

xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定義
xdebug.cloud.validation.host.not.defined=未定義預置 Xdebug Cloud 主機
xdebug.cloud.validation.port.invalid=預置 Xdebug Cloud 連接埠無效

xdebug.cloud.cannot.connect=無法連接到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 無法存取: {0}
xdebug.cloud.cannot.register.cloud.id=無法在 Xdebug Cloud 上註冊 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由於意外響應，無法註冊 Cloud ID
xdebug.cloud.cannot.open.new.debug.connection=打不開新的偵錯連接

PhpIncomingLocalConnectionDialog.file.path=檔案路徑:

PhpIncomingConnectionDialog.server.name=伺服器名稱:
PhpIncomingConnectionDialog.server.port=伺服器連接埠:
PhpIncomingConnectionDialog.request.uri=請求 URI:
PhpIncomingConnectionDialog.file.path.on.server=伺服器上的檔案路徑:

PhpInterpreter.php.sdk.type=PHP 解釋器
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解釋器依賴設定
PhpInterpreter.php.dependent.configuration.exists=所選 PHP 解釋器有{0}設定。確定要刪除此解釋器嗎?
PhpInterpreter.php.home.path.label=PHP 可執行檔案:
PhpInterpreter.php.debugger.label=偵錯器:
PhpInterpreter.php.general.title=一般
PhpInterpreter.configuration.in.project.settings.title=PHP 解釋器設定
PhpInterpreter.configuration.in.project.settings.message=無法將 PHP 解釋器指定為預設 SDK。您可以在“設定| PHP”中為當前專案設定
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名稱 ''{0}'' 的 PHP 解釋器。
PhpInterpreter.configuration.selection.list.title=選擇 CLI 解釋器
PhpInterpreter.configuration.interpreter.is.invalid=啟用“PHP Remote Interpreters”延伸模組以編輯解釋器。
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.reload.phpinfo=重新載入 phpinfo
PhpInterpreterConfigurable.show.phpinfo=顯示 phpinfo
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpInterpreterConfigurable.can.not.updated.phpinfo=無法更新 phpinfo
PhpInterpreterConfigurable.php.version=PHP 版本: {0}
PhpInterpreterConfigurable.not.installed=未安裝
PhpInterpreterConfigurable.configuration.project.level=僅對此專案可見
PhpInterpreterConfigurable.configuration.project.tooltip=檢查是否不想在專案之間共享解釋器
PhpInterpreterConfigurable.configuration.default.project.tooltip=無法僅為預設專案儲存解釋器。
PhpInterpreterConfigurable.debugger.extension.label=偵錯器擴展:
PhpInterpreterConfigurable.debugger.extension.title=選擇偵錯器擴展路徑
PhpInterpreterConfigurable.debugger.extension.description=將僅為從 CLI 執行設定啟動的偵錯會話載入偵錯器擴展
PhpInterpreterConfigurable.configuration.options.table.empty.text=為 php.ini 中允許的任何設定指令設定自訂值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允許名稱為空的設定選項
PhpInterpreterConfigurable.configuration.options.dialog.caption=設定選項
PhpInterpreterConfigurable.configuration.options.label=設定選項:
PhpInterpreterConfigurable.configuration.options.table.name=設定指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.description=這些選項將使用 '-d' 命令行選項傳遞
PhpInterpreterConfigurable.configuration.file.path=設定檔案: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=設定 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在評估設定檔案目錄…
PhpInterpreterConfigurable.configuration.file.fix.title=設定 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目錄中創建 php.ini 檔案，<br><br>點擊此<a href="http://docs.hhvm.com/manual/en/configuration.file.php">>鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目錄中創建 php.ini 檔案，<br><br>設定檔案模板可在 php 根資料夾中找到:<br>“php.ini-development”- 預設設定<br>“php.ini-production”- 推薦設定。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”指令確定設定檔案目錄。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>點擊此<a href="http://php.net/manual/en/configuration.file.php">鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.can.not.find.title=無法找到設定檔案
PhpInterpreterConfigurable.configuration.file.can.not.find=無法通過路徑找到檔案: ''{0}''
php.info.parse.exception=無法解析 php 資訊: {0} 是空的
PhpInterpreterConfigurable.update.helpers.title=正在更新幫助程序目錄…
PhpInterpreter.php.interpreter.name.conflict.title=解釋器名稱衝突
PhpInterpreter.php.interpreter.name.conflict=發現專案級和套用程序級解釋程序名稱存在衝突。為解決該問題，以下專案級解釋器被重命名:
remote.interpreter.browse.action.is.not.supported.for.docker=基於 Docker 的遠端解釋器不支持瀏覽操作
php.interpreter.info.failed.to.parse.validation.script=無法解析驗證腳本輸出

php.interpreter.base.configuration.interpreter.is.invalid=無法執行 {0}，因為 {1} 設定的解釋器無效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路徑未設定。您可以在“PHP|{0}”下進行修復
php.interpreter.base.configuration.working.directory=無法檢測工作目錄，請在執行設定中進行設定。
php.interpreter.base.configuration.fix.interpreter={0}。要修復，請<a href=''{1}''>更改</a>專案解釋器或<a href=''{2}''>檢查</a>設定。

PhpProjectConfigurable.language.level=PHP 語言級別:
PhpProjectConfigurable.interpreter=CLI 解釋器:
PhpProjectConfigurable.include.path=Include 路徑
PhpProjectConfigurable.0.interpreter.include.path=''{0}'' 解釋器 include 路徑
PhpProjectConfigurable.specify.other=指定其他…
PhpProjectConfigurable.all=所有
PhpProjectConfigurable.provide.include.path=提供 include 路徑
PhpProjectConfigurable.docker.default.project.error.tooltip=開啟或創建專案以設定 Docker 容器
PhpProjectConfigurable.php.runtime=PHP 執行時
PhpProjectConfigurable.advanced.settings=進階設定(&V)
PhpProjectConfigurable.default.stubs.path=預設存根路徑(&D):
PhpProjectConfigurable.select.default.stubs.path.title=選擇預設存根路徑
PhpProjectConfigurable.select.default.stubs.path.description=選擇預設存根路徑
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.exception.analysis=異常分析
PhpProjectConfigurable.exception.analysis.depth=調用樹分析路徑:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未檢查的異常
PhpProjectConfigurable.analysis.custom.format.functions=自訂格式函數
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.select.document.root.path.title=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.select.document.root.path.description=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑

custom.format.functions.dialog.validation.class.not.found=找不到類 {0}
custom.format.functions.dialog.validation.function.not.found=找不到函數 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
custom.format.functions.dialog.validation.format.index=索引必須為非負數
custom.format.functions.dialog.format.index.title=格式字串模板的索引
custom.format.functions.dialog.class.placeholder=留空以添加純函數

PhpUnitConfigurableForm.phpunit.library=PHPUnit 庫
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自動載入器
PhpUnitConfigurableForm.custom.loader.is.empty=自動載入器檔案的路徑為空
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自動載入器腳本
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路徑為空
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自動載入器不應為目錄，對於預設 Composer 設定，將路徑設定為“vendor/autoload.php”
PhpUnitConfigurableForm.download.phpunit.phar.link.text=從 {0} 下載 phpunit.phar
PhpUnitConfigurableForm.path.to.script=腳本路徑:
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路徑
PhpUnitConfigurableForm.test.runner=測試執行程序
PhpUnitConfigurableForm.use.configuration.file=預設設定檔案:
PhpUnitConfigurableForm.use.bootstrap.file=預設啟動檔案:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=為 ''{0}'' 提供設定檔案的路徑，或禁用“預設設定檔案”選項
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=為 ''{0}'' 提供啟動檔案的路徑，或禁用“預設啟動檔案”選項

phpunit.config.label=測試根
phpunit.config.directory.label=目錄:
phpunit.config.empty.pattern=空模式
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.not.tests.was.executed.title=未設定 PHPUnit
phpunit.not.tests.was.executed.message=要修復，為 <i>{0}</i> <a href="config">設定</a>自動載入檔案或 PHPUnit phar 路徑。
phpunit.can.not.rerun.failed.tests.title=無法執行失敗的 PHPUnit 測試。
frameworks.settings.none.installed=<html>沒有可用的框架設定提供程序。<br/>考慮安裝 Drupal Support、Joomla! Support 或 WordPress Support 延伸模組。</html>
framework.composer.packages.were.changed.0.test.config.title=Composer 軟體套件已被更改
framework.composer.packages.were.changed.0.test.config.popup={0} 設定已根據 composer.json 更新

PhpUnitConfiguration.interpreter.conflict=發現應用程式級 PHPUnit 設定衝突。為解決該問題，創建了以下設定的專案級副本:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 設定衝突

# php test framework
php.test.framework.select.type.of.settings.popup.title=選擇設定類型
php.test.framework.configuration.ui.library={0} 庫
php.test.framework.configuration.ui.test.runner=測試執行程序
php.test.framework.configuration.ui.path.to.exe={0} 可執行檔案路徑:
php.test.framework.configuration.ui.use.configuration.file=預設設定檔案:
php.test.framework.download.hyperlink={0} 版本: <a href={1}>{1}</a>
php.test.framework.configuration.ui.version={0} 版本: {1}
php.test.framework.configuration.ui.not.installed=未安裝
php.test.framework.configuration.ui.select.interpreter=請選擇 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=請選擇本地 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.configuration.can.not.update=無法更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=無法檢測到 {0} 版本。預設 PHP 解釋器不是本地解釋器

php.test.framework.version.getting.version.title=正在獲取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可執行檔案的路徑為空或無效。
php.test.framework.version.detector.empty.output=''{0}'' 指令輸出為空。
php.test.framework.version.configuration.ui.can.not.parse.version=無法解析版本指令輸出。\n\
{0}

php.test.framework.by.sdk.new.settings.dialog.title=通過遠端解釋器{0}
php.test.framework.by.sdk.dialog.label=解釋器(&I):
php.test.framework.by.sdk.settings.select.server=選擇遠端解釋器以設定遠端{0}
php.test.framework.by.sdk.settings.already.exist=所選解釋器的 {0} 設定已存在
php.test.framework.by.sdk.settings.remote.path.title=選擇伺服器上的路徑

php.test.framework.run.configuration.ui.scope=測試範圍:
php.test.framework.run.configuration.ui.type.radio.button=類型(&T)
php.test.framework.run.configuration.ui.directory.radio.button=目錄 (&D)
php.test.framework.run.configuration.ui.file.radio.button=檔案(&F)
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.configuration.radio.button=在設定檔案中定義(&C)
php.test.framework.run.configuration.ui.type.combo.box=類型:
php.test.framework.run.configuration.ui.directory.text.field=目錄:
php.test.framework.run.configuration.ui.file.text.field=檔案:
php.test.framework.run.configuration.ui.scenario.text.field=方法:
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代設定檔案(&U):
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=測試執行程序選項
php.test.framework.field.test.runner.options=測試執行程序選項(&O):
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定義
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路徑未設定。按“修復”以編輯您的 {0} 設定。

php.test.framework.interpreter.conflict=發現應用程式級 {0} 設定衝突。為解決該問題，創建了以下設定的專案級副本:
php.test.framework.interpreter.conflict.title={0} 設定衝突
php.test.framework.project.level=(當前專案)
php.test.framework.no.configuration.types.are.available=沒有可用的其他設定類型

# validation
php.test.framework.validation.run.configuration.no.type=如果未選擇類型則無法執行測試。
php.test.framework.validation.run.configuration.unsupported.type=無法通過 ''{0}'' 指令執行測試。
php.test.framework.validation.run.configuration.working.directory=目錄應該是工作目錄的子資料夾: ''{0}''
php.test.framework.validation.run.configuration.file.working.directory=檔案應該是工作目錄的子項: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''

php.executable.macro.description=專案設定中設定的 Php 可執行檔案
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc

inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在測試外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.missing.ext.require.bundled=需要 PHP 捆綁的擴展
add.to.composer.json.quick.fix=向 composer.json 中添加 ''{0}''

configure.php.include.paths=設定 PHP Include 路徑(&O)…

interpreter=解釋器

XdebugShowUserDefinedConstantsToggleAction.text=顯示使用者定義的常數
XdebugShowUserDefinedConstantsToggleAction.description=將其禁用會停止獲取使用者定義的常數資訊並提高偵錯器性能
XdebugAddMethodToSkipListToggleAction.text=將方法添加到跳過列表
PhpDebugHideEmptySuperGlobalsToggleAction.text=顯示空的超全域變數
PhpDebugBreakAtFirstLineToggleAction.text=在 PHP 腳本中的第一行中斷
PhpUserDefinedConstantsGroup.name=常數

PhpLanguageLevel.5.3.0.presentable.name=5.3
PhpLanguageLevel.5.3.0.short.description=命名空間，閉包
PhpLanguageLevel.5.4.0.presentable.name=5.4
PhpLanguageLevel.5.4.0.short.description=特徵，短陣列語法
PhpLanguageLevel.5.5.0.presentable.name=5.5
PhpLanguageLevel.5.5.0.short.description=finally，生成器
PhpLanguageLevel.5.6.0.presentable.name=5.6
PhpLanguageLevel.5.6.0.short.description=可變函數，實參解包
PhpLanguageLevel.7.0.0.presentable.name=7.0
PhpLanguageLevel.7.0.0.short.description=返回類型，標量類型提示
PhpLanguageLevel.7.1.0.presentable.name=7.1
PhpLanguageLevel.7.1.0.short.description=常數可見性，可為 null，多個異常
PhpLanguageLevel.7.2.0.presentable.name=7.2
PhpLanguageLevel.7.2.0.short.description=物件類型提示，abstract 函數覆寫
PhpLanguageLevel.7.3.0.presentable.name=7.3
PhpLanguageLevel.7.3.0.short.description=列表賦值中的引用，靈活的 heredoc
PhpLanguageLevel.7.4.0.presentable.name=7.4
PhpLanguageLevel.7.4.0.short.description=類型屬性，短閉包，null 合併運算符
PhpLanguageLevel.8.0.0.presentable.name=8.0
PhpLanguageLevel.8.0.0.short.description=聯合類型，命名實參，特性，match 表達式
PhpLanguageLevel.8.1.0.presentable.name=8.1
PhpLanguageLevel.8.1.0.short.description=enumerations, intersection types, 'readonly' properties

PhpLanguageFeature.traits.not.supported=從 PHP 5.4 起才允許使用特徵
PhpLanguageFeature.short.array.syntax.not.supported=從 PHP 5.4 起才允許使用短陣列語法
PhpLanguageFeature.array.dereferencing.not.supported=從 PHP 5.4 起才允許對調用進行陣列解引用
PhpLanguageFeature.class.member.access.on.instantiation.not.supported=從 PHP 5.4 起才允許對實例化進行類成員存取
PhpLanguageFeature.this.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 $this
PhpLanguageFeature.self.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 self
PhpLanguageFeature.parent.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 parent
PhpLanguageFeature.static.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 static
PhpLanguageFeature.binary.literal.not.supported=從 PHP 5.4 起才允許使用二進制文字
PhpLanguageFeature.literal.in.static.call.not.supported=從 PHP 5.4 起才允許在 static 調用中使用文字
PhpLanguageFeature.built.in.web.server=內建 Web 伺服器僅自 PHP 5.4 起可用
PhpLanguageFeature.var.break.argument.not.supported=PHP 5.4 不再支援具有非常數操作數的 'break' 運算符
PhpLanguageFeature.var.break.zero.argument.not.supported=自 PHP 5.4 起，'break' 運算符僅接受正數
PhpLanguageFeature.var.continue.not.supported=PHP 5.4 不再支援具有非常數操作數的 'continue' 運算符
PhpLanguageFeature.var.continue.zero.not.supported=自 PHP 5.4 起，'continue' 運算符僅接受正數
PhpLanguageFeature.call.time.pass.by.reference.not.supported=調用時通過引用傳遞在 PHP 5.4 中已被移除

PhpLanguageFeature.finally.not.supported=從 PHP 5.5 起才允許使用 'Finally' 子句
PhpLanguageFeature.generators.not.supported=從 PHP 5.5 起才允許使用生成器
PhpLanguageFeature.foreach.list.not.supported=從 PHP 5.5 起才允許在 foreach 中使用列表
PhpLanguageFeature.empty.any.expression.not.supported=從 PHP 5.5 起才允許在 'empty' 中使用任意表達式
PhpLanguageFeature.immediate.dereferencing.not.supported=從 PHP 5.5 起才允許直接解引用
PhpLanguageFeature.class.name.const.not.supported=從 PHP 5.5 起才允許使用類名常數

PhpLanguageFeature.constant.scalar.expressions=從 PHP 5.6 起才允許使用常數標量表達式
PhpLanguageFeature.variadic.functions=從 PHP 5.6 起才允許使用可變函數
PhpLanguageFeature.argument.unpacking=從 PHP 5.6 起才允許使用實參解包
PhpLanguageFeature.exponentiation=從 PHP 5.6 起才允許使用求冪
PhpLanguageFeature.use.function.and.const=從 PHP 5.6 起才允許 use function 和 use const

PhpLanguageFeature.return.types=從 PHP 7.0 起才允許使用返回類型宣告
PhpLanguageFeature.scalar.type.hints=從 PHP 7.0 起才允許使用標量類型提示
PhpLanguageFeature.spaceship.operator=從 PHP 7.0 起才允許使用宇宙飛船運算符
PhpLanguageFeature.coalesce.operator=從 PHP 7.0 起才允許使用合並運算符
PhpLanguageFeature.grouped.use=從 PHP 7.0 起才允許分組 use 宣告
PhpLanguageFeature.keyword.names=在 PHP 7.0 中關鍵字可用作名稱
PhpLanguageFeature.uniform.variable.syntax=從 PHP 7.0 起才允許統一變數語法
PhpLanguageFeature.anonymous.classes=從 PHP 7.0 起才允許使用匿名類

PhpLanguageFeature.return.void=從 PHP 7.1 起才允許返回 void
PhpLanguageFeature.nullables=從 PHP 7.1 起才允許可為 null
PhpLanguageFeature.iterable.type.hint=從 PHP 7.1 起才允許迭代類型提示
PhpLanguageFeature.catch.multiple=從 PHP 7.1 起才允許捕獲多條語句
PhpLanguageFeature.class.constant.visibility=從 PHP 7.1 起才允許類常數可見性
PhpLanguageFeature.list.keys=從 PHP 7.1 起才允許列表解包中的密鑰
PhpLanguageFeature.list.assign=從 PHP 7.1 起才允許列表解包中的 []
PhpLanguageFeature.negative.numeric.indices=從 PHP 7.1 起才允許負數值索引

PhpLanguageFeature.object.type.hint=從 PHP 7.2 起才允許物件類型提示
PhpLanguageFeature.abstract.function.override=從 PHP 7.2 起才允許抽象函數覆寫

PhpLanguageFeature.literal.in.instanceof=從 PHP 7.3 起才允許將文字作為第一個操作數
PhpLanguageFeature.references.in.list=從 PHP 7.3 起才允許在 [] 和 list() 賦值中使用引用
PhpLanguageFeature.trailing.comma.in.function.calls=從 PHP 7.3 起才允許在函數調用中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.parameter.list=從 PHP 8.0 起才允許在參數列表中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.closure.use.list=只有 PHP 8.0 支援在閉包 use 列表中使用尾隨逗號
PhpLanguageFeature.flexible.heredocs=靈活的 heredoc/nowdoc 語法

PhpLanguageFeature.typed.properties=從 PHP 7.4 起才允許使用類型化屬性
PhpLanguageFeature.spread.operator.in.array=從 PHP 7.4 起才允許在陣列中使用展開運算符
PhpLanguageFeature.coalesce.assign=從 PHP 7.4 起才允許使用 '??='
PhpLanguageFeature.arrow.function=從 PHP 7.4 起才允許箭頭函數語法
PhpLanguageFeature.numeric.literals.separators=從 PHP 7.4 起才允許使用數值文字分隔符
PhpLanguageFeature.exception.throw.from.toString=從 PHP 7.4 起才允許從 ''__toString'' 拋出異常，''{0}.__toString'' 可能會拋出異常

PhpLanguageFeature.union.types=從 PHP 8.0 起才允許聯合類型
PhpLanguageFeature.enum.classes=從 PHP 8.1 起才允許使用枚舉
PhpLanguageFeature.namespaced.name.as.single.token=從 PHP 8.0 起才允許關鍵字作為命名空間的一部分
PhpLanguageFeature.nullsafe.dereferencing=從 PHP 8.0 起才允許 Nullsafe 運算符
PhpLanguageFeature.abstract.private.trait.methods=從 PHP 8.0 起才允許使用 abstract private 特徵方法
PhpLanguageFeature.mixed.type.hint=從 PHP 8.0 起才允許 'mixed' 類型提示
PhpLanguageFeature.static.type.hint=從 PHP 8.0 起才允許 'static' 返回類型宣告
PhpLanguageFeature.named.arguments=從 PHP 8.0 起才允許使用命名實參
PhpLanguageFeature.match.expression=從 PHP 8.0 起才允許符合表達式
PhpLanguageFeature.throw.expression=從 PHP 8.0 起才允許使用 throw 表達式
PhpLanguageFeature.non.capturing.catches=從 PHP 8.0 起才允許捕捉異常而又不將異常捕獲到變數中
PhpLanguageFeature.class.name.literal.on.object=從 PHP 8.0 起才允許在物件上使用 '::class'
PhpLanguageFeature.attributes=從 PHP 8.0 起才允許使用特性
PhpLanguageFeature.property.promotion=從 PHP 8.0 起才允許構造函數屬性提升

#Empty project generation
php.empty.project.generator.name=PHP 空專案
php.empty.project.generator.description=為 PHP 創建空專案

#UML
error.cant.create.edge=無法創建關係鏈接
relationship.already.exists={0}和{1}之間的關係已存在
this.will.remove.relationship.link.between.classes=這將移除類之間的關係鏈接並修改類 {0}。繼續？
remove.relationship.link=移除關係鏈接
final.class.cant.be.inherited=類 {0} 為 final
node.is.interface=接口只能繼承一個接口
inspection.undefined.member.downgrade=如果類中存在 __magic 方法則降級嚴重性(&D)

#Phar
phar.include.into.project.action.title=將 phar 包含到專案中
phar.exclude.from.project.action.title=從專案中排除 phar
phar.exclude.or.include.into.project.action.title=在專案中包含或排除 Phar
phar.failed.to.parse=無法解析
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar

#Composer

framework.composer.name.composer=Composer
framework.composer.path.dialog.path.to.composer=Composer 路徑
framework.composer.path.dialog.path.to.composer.json=composer.json 路徑
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar:
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可執行檔案:
framework.composer.path.dialog.specify.composer.json=指定 composer.json:
framework.composer.configurable.title=Composer
framework.composer.init.dialog.title.composer.settings=Composer 設定
framework.composer.file.0.is.not.found=找不到檔案 ''{0}''。

framework.composer.add.dependency.task.title=添加依賴項
framework.composer.add.dependency.install.button=安裝
framework.composer.add.dependency.update.button=更新
framework.composer.add.dependency.close.button=關閉(&C)
framework.composer.failed.to.0=無法{0}。
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.dependency.show.output=顯示輸出
framework.composer.add.dependency.hide.tooltip=隱藏
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安裝 {0}，版本 {1}。
framework.composer.add.dependency.running=正在執行
framework.composer.add.composer.dependency.title=管理 Composer 依賴項
frameworks.composer.could.not.get.packages.info.0=無法獲取軟體套件資訊。{0}
frameworks.composer.could.not.get.package.info=無法獲取軟體套件資訊。
framework.composer.label.version.to.install=要安裝的版本(&V):
framework.composer.empty.package.name.in.0={0} 中的軟體套件名稱為空
framework.composer.no.package.versions.in.0={0} 中沒有軟體套件版本
framework.composer.expected.name.0.versions.0.description.got.1=應為 <name> {0} <versions> {0} <description>，獲得的是 {1}
framework.composer.add.dependency.available.packages.label=可用軟體套件
framework.composer.package.default.version=<預設>
framework.composer.add.dependency.no.package.selected=未選擇軟體套件
framework.composer.add.dependency.no.such.package=packagist 上無此類軟體套件
framework.composer.path.form.execution.validation.wrapper=<html>執行未設定。<br/>{0}</html>
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路徑為空
framework.composer.path.form.empty.path.to.composer.executable=Composer 可執行檔案路徑為空
framework.composer.project.generator.name=Composer 專案
framework.composer.project.generator.description=通過 Composer 指令創建專案。
framework.composer.failed.to.download.composer.phar=無法下載 composer-stable.phar
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=無法將臨時目錄 ''{0}'' 內容複製到專案根
framework.composer.project.generation.error.title=無法創建 Composer 專案
framework.composer.project.generator.notification.content.failed.to.find=無法找到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=無法在專案根中找到 composer.json
framework.composer=Composer
framework.composer.create.project.progress.title=創建專案
framework.composer.create.project.from=自以下創建專案
framework.composer.install.action.name=安裝
framework.composer.path.validation.0.is.a.directory={0} 是目錄
framework.composer.path.form.empty.path.to.composer.json=composer.json 路徑為空
framework.composer.vendors.library.name=Composer 供應商
framework.composer.selected.file.is.not.composer.json=所選檔案不是 composer.json
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=檔案 ''{0}'' 設定為 Composer 設定。
framework.composer.failed.to.parse.package.names=無法解析軟體套件名稱。
framework.composer.failed.to.load.package.names=無法載入軟體套件名稱。
framework.composer.failed.to.parse.package.description=無法解析軟體套件描述。
framework.composer.add.dependency.no.version.selected=未選擇版本
framework.composer.add.dependency.settings.cl.dialog.title=參數
framework.composer.add.dependency.settings.cl.label=命令行參數(&P):
framework.composer.add.dependency.settings.interpreter.label=PHP 解釋器:
framework.composer.add.dependency.settings.title=設定(&S)
framework.composer.no.description.available=無可用描述。
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 軟體套件已從 Composer 外部庫移至 PHP include 路徑。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 軟體套件已更改，因此更新了排除的資料夾。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 軟體套件已更改，因此更新了 PHP include 路徑。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 軟體套件已從排除的資料夾中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 軟體套件已從 PHP include 路徑中移除。
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 軟體套件已被添加到排除的資料夾中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 軟體套件已被添加到 PHP include 路徑中。
framework.composer.failed.to.0.1.script.was.cancelled=無法{0} {1}。腳本已被取消。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.updating.package.task.title=更新軟體套件
framework.composer.removing.package.task.title=移除軟體套件
framework.composer.update.action.name=更新
framework.composer.remove.action.name=移除
framework.composer.self.update.action.name=自我更新
framework.composer.label.installed.version=已安裝的版本:
framework.composer.path.to.php.executable.titled=PHP 可執行檔案的路徑
framework.composer.specify.php.executable.0=指定 PHP 可執行檔案 {0}
framework.composer.empty.path.to.0={0} 的路徑為空
framework.composer.default.project.interpreter=預設專案解釋器
framework.composer.default.interpreter.is.not.configured=尚未為此專案設定預設解釋器。
framework.composer.default.interpreter.for.this.project.is.remote=此專案的預設解釋器是遠端解釋器，無法使用。
framework.composer.default.composer.interpreter.name=Composer 的解釋器
framework.composer.interpreters.combo.default.interpreter=< 預設解釋器 >
framework.composer.interpreters.combo.default.project.interpreter=< 預設專案解釋器 >
framework.composer.interpreters.combo.no.default.interpreter=預設設定中沒有預設解釋器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此專案中沒有預設解釋器
framework.composer.interpreters.combo.default.interpreter.no.php.path=預設解釋器未提供 PHP 路徑
framework.composer.initialize.popup=找到了 Composer 設定檔案 {0}。專案設定與其同步。
framework.composer.install.task.title=正在安裝軟體套件
framework.composer.update.task.title=更新軟體套件
framework.composer.self.update.task.title=更新 Composer
framework.composer.script.run.configuration.name=Composer 腳本
framework.composer.script.run.configuration.description=Composer 腳本執行設定
framework.composer.run.path.to.composer.json=composer.json 路徑:
framework.composer.run.script=腳本:
framework.composer.run.script.missing=未指定 Composer 腳本
framework.composer.available.version=可用版本:
framework.composer.package.version.available.0={0}的更新
framework.composer.failed.check.for.update=無法執行 'update --dry-run' 指令。
framework.composer.checking.for.update=正在檢查更新…
framework.composer.loading.packages=正在載入 Composer 軟體套件
framework.composer.loading.package.description=正在載入軟體套件描述
framework.composer.load.update.availability=檢查可用的軟體套件更新
framework.composer.loading.update.availability=正在檢查 Composer 軟體套件更新

# Guzzle
guzzle.name=Guzzle
guzzle.http.request.gutter.name=Guzzle HTTP 請求
guzzle.open.http.request=在 HTTP 請求編輯器中開啟
guzzle.unable.to.add.new.request.to.file=無法向 ''{0}'' 檔案添加新請求
guzzle.invalid.http.request.file=檔案 ''{0}'' 是無效的 HTTP 請求檔案
guzzle.unable.to.extract.request.parameters=無法提取請求參數
http.client.request.init.debug.connection.title=正在初始化偵錯連接

php.interpreter.not.configured.title=未設定 PHP 解釋器
php.interpreter.not.configured=請<a href="">設定 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.is.remote.title=已設定遠端 PHP 解釋器
php.interpreter.is.remote.message=請<a href="">選擇本地 PHP 解釋器</a>以使用內建 Web 伺服器

php.cgi.not.found.title=找不到 {0}
php.cgi.not.found=請確保<a href="">設定的 PHP 解釋器</a>作為 CGI 程序建置(指定了 --enable-fastcgi)

php.smart.indent.codestyle.indent.in.php=縮排 PHP 標記中的程式碼

phpdoc.code.style.title=PHPDoc

phpdoc.code.style.generated.doc.blocks=生成的 PHPDoc 標記
phpdoc.code.style.sort.doc.blocks=PHPDoc 標籤順序

phpdoc.code.style.force.null.position=將 ‘null’ 置於以下類型中:
phpdoc.code.style.in.beginning.position=在開頭
phpdoc.code.style.in.end.position=在末尾

phpdoc.code.style.convert.true.false.to=將 True/False 常數轉換為:
phpdoc.code.style.convert.null.to=將 Null 常數轉換為：
php.code.style.convert.keyword.to.lowercase=將關鍵字轉換為小寫
php.code.style.convert.lower.case=小寫
php.code.style.convert.upper.case=大寫
php.code.style.sort.use.stmt=對 'use' 語句排序:
php.code.style.sort.alphabetically=按字母順序
php.code.style.sort.by.length=按長度

phpdoc.code.style.convert.else.if.to=將 else if/elseif 轉換為:
phpdoc.code.style.convert.else.if.separate=else if
phpdoc.code.style.convert.else.if.combine=elseif

phpdoc.code.style.throws.analysis.depth.performance.note.title=性能註釋
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建議深入分析多個級別，因為這可能會影響 IDE 性能。要繼續嗎?

phpdoc.code.style.param.spaces.panel=PHPDoc '@param' 空間
phpdoc.code.style.param.spaces.between.tag.and.type=在標籤和類型之間：
phpdoc.code.style.param.spaces.between.type.and.name=類型和名稱之間：
phpdoc.code.style.param.spaces.between.name.and.description=在名稱和描述之間：

php.conversion.code.style.title=程式碼轉換

php.generation.code.style.title=程式碼生成

array.declaration.style=陣列/列表宣告樣式

variable.naming.style.panel=變數命名樣式
variable.naming.style.mixed=混合
variable.naming.style.camel.case=駝峰式命名法
variable.naming.style.snake.case=snake_case

php.prefdefined.codestyle.psr12.chosen.title=PSR-12 程式碼樣式
php.prefdefined.codestyle.psr12.chosen.message=您可以啟用其他 PSR-12 檢查，這些檢查當前已禁用。
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 檢查已啟用。

fields.default.visibility.panel=屬性預設可見性
fields.default.visibility.private=private
fields.default.visibility.protected=protected
fields.default.visibility.public=public

getters.setters.style=Getter/Setter 樣式
getters.setters.order=Getter/Setter 順序:
getters.setters.getters.first=getter 優先
getters.setters.setters.first=setter 優先
getters.setters.naming.style=命名樣式:
getters.setters.configure=設定…

php.embedded.stubs.incorrect.path.warning.title=預設存根路徑不正確
php.embedded.stubs.incorrect.path.warning.message=設定的預設存根路徑 ''{0}'' 不存在，改為使用嵌入式存根。
php.embedded.stubs.notification.provider.notification=您正在查看不可變的嵌入式存根。為了能夠編輯這些存根，您需要克隆一個存根專案，然後通過“PHP/進階設定”提供預設存根路徑。
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.provide=提供預設存根路徑
php.embedded.stubs.notification.provider.do.not.show.again=不再顯示

auto.import.in.file.scope=在檔案範圍內啟用自動匯入
auto.import.in.namespace.scope=在命名空間範圍內啟用自動匯入
auto.import.from.global.space=處理來自全域空間的符號
auto.import.from.global.space.class=類
auto.import.from.global.space.function=函數
auto.import.from.global.space.constant=常數
auto.import.from.global.space.prefer.fallback=回退優先
auto.import.from.global.space.prefer.import=匯入優先
auto.import.from.global.space.prefer.fqn=FQN 優先
# non-strict
quickfix.non.strict.object.equality=非嚴格物件相等比較
inspection.non.strict.object.equality=非嚴格物件相等比較

exception.analysis.settings.path=PHP/分析
inspection.severity.with.magic=當 __magic 存在時顯示

import.references.on.paste.dialog.title=選擇要匯入的{0}
import.references.on.paste.dialog.message=<html>貼上的程式碼段使用 {0}，後者在目標範圍中不能通過匯入存取。<br/>選擇您想要匯入到範圍中的{0}。</html>
skip.constant.params=使用常數參數跳過調用
inspection.unused.declaration.option.test.entry_points=假定測試宣告為入口點
inspection.unused.declaration.option.show.unused_from_entries=顯示所有宣告
inspection.unused.declaration.option.show_strictly_unused=僅顯示未使用項
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.code.patterns.panel.errors.class = 模式必須是有效的 php fqn，僅接受 '*' 作為佔位符
inspection.code.patterns.panel.errors.member = 方法模式 {0} 必須是有效的 php 關鍵字，僅接受 ''*'' 作為佔位符
inspection.code.patterns.panel.description.label = 如果 fqn 名稱符合，則將程式碼標記為入口點
inspection.code.patterns.panel.description.text = 將方法留空以表示構造函數 \n\
 任何 * 都將與 fqn 名稱中的一個或多個字符符合
inspection.unusedd.description.code.patterns.button.label=程式碼模式
inspection.unused.description.code.suppressed.annotations=已禁止的註解
inspection.undefined.member.warnOnMixed=出現混合、物件、stdClass、未定義類型、null 的存取成員時通知
configurable.PhpServerConfigurable.display.name=伺服器
configurable.PhpDebugConfigurable.display.name=偵錯
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.QualityToolCommonConfigurable.display.name=品質工具
class.implements.solely.traversable=類 ''{0}'' 必須將接口 Traversable 作為 Iterator 或 IteratorAggregate 的一部分來實作
configurable.PhpServersConfigurable.display.name=伺服器
configurable.PhpTestFrameworksConfigurable.display.name=測試框架
configurable.PhpTemplatesCommonConfigurable.display.name=模板
PhpStepFiltersConfigurable.display.name=步進篩選器
remote.connection.settings.interpreter.is.not.remote=當前專案解釋器非遠端解釋器
remote.connection.settings.default.remote.interpreter=預設遠端解釋器
php.element.is.available.starting.with.php.version=''{0}'' 從 PHP 版本 {1} 開始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
settings.smart.keys.title=PHP
settings.smart.keys.enable.smart.function.parameters.completion=啟用智能函數參數補全
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=雙擊時選擇不含 '$' 符號的變數名稱
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中貼上時移除 PHP 開始/結束標記
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字串文字中貼上時轉義符號
settings.smart.keys.auto.insert.tag.after.typing=輸入 '<?' 後自動插入 '<?php' 標記
settings.smart.keys.auto.insert.semicolon=在函數調用內部鍵入時自動插入分號 
settings.smart.keys.find.usages.of.base.method.prompt=搜尋方法用法時顯示其他選項
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=貼上時取代不必要的雙引號
php.exception.is.never.thrown=函數中從未拋出異常 ''{0}''
php.remove.exception.from.throws=從 @throws 標記中移除 ''{0}''
php.remove.throws.tag=從 @throws 標記移除
php.add.exception=將 ''{0}'' 添加到現有 @throws 標記
ternary.condition.can.be.replaced.with.condition.expression=表達式可以安全地取代為 ''{0}''
php.replace.with=取代為 ''{0}''
php.tag.is.deprecated={0} 已棄用，將在 PHPUnit 9 中移除
potentially.polymorphic.call.multiple.subclasses=潛在的多態調用。該程式碼可能無法操作，具體取決於作為實參傳遞的實際類實例。
trait.already.contains.method=特徵 {0} 已包含方法 {1}
potentially.polymorphic.call.single.subclass=潛在的多態調用。{0} 的層次結構中沒有成員
navigate.to.meta.declaration=導航到 ''{0}''
meta.declaration.exists=''{1}'' 存在元宣告 ''{0}''
meta.multiple.declaration.exists=''{0}'' 存在多個元宣告
meta.declaration.line.marker.name=存在元宣告
unnecessary.local.variable=不必要的局部變數
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 將不支持 ClassName::<*> 註解
returned.by.iterator.aggregate.should.be.traversable=\\IteratorAggregate::getIterator() 返回的物件必須為 Traversable 或實作接口 Iterator
inspection.probably.undefined.property=屬性 '#ref' 已動態宣告，可能未定義
find.classes.without.member=尋找沒有成員的類
classes.without.member=層次結構中不帶 ''{0}'' 的類
remove.pass.by.ref=移除 '\\&'
pass.by.ref.is.not.effectively.used.inside.body=傳遞的引用不在主體中使用
suppress.if.annotated.by.tag=如果用 ''{0}'' 註解，則禁止
configure.suppressed.annotations=設定禁止的註解
enter.annotation=輸入註解
suppressed.annotation.title=已禁止的註解
move.class.to.separate.file.text.family=將類移至單獨的檔案
type.primitive.hints.names.are.forbidden=禁止名為 'true'、'false' 和 'null' 的類型提示
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名為 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的類
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名為 'void' 和 'iterable' 的類
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名為 'object' 的類
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 語句只能包含一個 'default' 子句
show.composer.settings.action.name=顯示 Composer 設定
composer.change.setting.action.name=更改設定
composer.diagnose.task.title=診斷
composer.simulating.update.task.title=模擬更新
composer.generating.autoloader.task.title=生成自動載入器
composer.autoloader.generation.settings.name=自動載入器生成設定
composer.generate.list.popup.title=生成
install.composer.packages.task.title=安裝 Composer 軟體套件
composer.listing.licenses.task.title=列出授權
composer.update.composer.task.title=更新 Composer
composer.checking.for.changes.in.code.of.dependencies.task.title=檢查依賴項程式碼中的變更
composer.update.composer.packages.task.title=更新 Composer 軟體套件
composer.validating.task.title=驗證
composer.validation.settings.name=驗證設定
composer.validate.dialog.action.button.title=驗證
composer.revert.action.name=還原
composer.clearing.cache.action.name=清除快取
composer.remove.action.name=移除(&R)
composer.checkbox.download.composer.phar.from.getcomposer.org=從 getcomposer.org 下載 composer-stable.phar
composer.label.phar=composer.phar
composer.label.executable='composer' 可執行檔案
composer.checkbox.check.if.composer.lock.is.up.to.date=檢查 composer.lock 是否為最新
composer.checkbox.autoload.classes.from.the.classmap.only=僅從類映射自動載入類
composer.label.can.be.time.consuming=可能較為耗時
composer.checkbox.disable.autoload.dev.dependencies=禁用 autoload-dev 依賴項
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=最佳化自動載入器(將 PSR-0/4 規則轉換為類映射)
composer.checkbox.skip.scripts.execution=跳過腳本執行
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 快取找到/未找到的類
composer.checkbox.allow.unbound.version.constraints=允許未綁定的版本約束
composer.checkbox.check.if.the.package.is.packagist.ready=檢查軟體套件是否為 Packagist 就緒
composer.checkbox.validate.package.dependencies=驗證軟體套件依賴項
composer.checkbox.synchronize.ide.settings.with.composer.json=將 IDE 設定與 composer.json 同步(&S)
composer.label.path.to.composer.json=composer.json 路徑(&C):
composer.label.the.settings.php.language.level.directories.may.be.updated=設定(Php 語言級別，目錄)可能已更新
composer.border.title.package=軟體套件
composer.label.package=軟體套件:
composer.label.version.to.install=要安裝的版本:
composer.label.filter.packages=篩選軟體套件(&F):
composer.label.label=標籤
composer.border.title.execution=執行
php.run.label.server=伺服器:
php.run.label.https=HTTPS:
php.run.label.url=URL:
php.run.label.query.string=查詢字串:
php.run.label.request.body=請求正文:
php.run.label.request.method=請求方法:
php.run.label.send.request.body.as=將請求正文發送為:
php.run.radio.button.key.value=鍵值
php.run.http.border.title.configuration=設定
php.run.label.interpreter=解釋器:
php.run.radio.button.text=文本
replace.with.alias.from.target.scope=取代為目標範圍中的別名
php.information.dialog.title=PHP 資訊
extract.method.parameter.name.column.title=參數
constant.with.same.name.already.exists.in.0={0} 中已經存在名稱相同的常數
path.0.is.invalid=路徑 ''{0}'' 無效
rename.parameters.dialog.title=重命名參數
rename.parameter.dialog.description=將層次結構中的參數重命名為:
quality.tools.custom.coding.standard=自訂編碼標準
quality.tools.0.added.to.ignored.files.list={0}已添加到忽略的檔案列表。
exclude.0.from.1.analysis.a=從{1}分析中排除{0}。
create.new.field.dialog.title=創建新字段
uml.wrong.name=錯誤的名稱
uml.0.already.exists.in.class.1=類 {1} 中已經存在 ''{0}''
rename.filename.quick.fix=將檔案 ''{0}'' 重命名為 ''{1}''
rename.psi.element.quick.fix=將{0} ''{1}'' 重命名為 ''{2}''
fix.package.text=將命名空間 ''{0}'' 取代為 ''{1}''
fix.package.text.family=修復命名空間 
variable.always.have.value.0=到達時，變數始終為 ''{0}''
introduce.named.constant.for.value.0=為值 ''{0}'' 引入命名常數


checkbox.add.packages.as.libraries=作為庫添加軟體套件(&A)
phpunit.label.data.set=資料集:
label.insert.imports.on.paste=貼上時插入匯入:
border.title.php=PHP
label.class.fqn=類 FQN
label.method.name=方法名稱
checkbox.move.to.another.class=移動到另一個類(&M)
label.visibility=可見性(&V)
label.initialize.in=初始化在(&I)
radio.button.const=const(&C)
radio.button.define=定義(&D)
border.title.constant.syntax=常數語法
border.title.visibility=可見性
radio.button.default=預設(&F)
radio.button.public=public(&U)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.by.concatenation=通過串聯(&C)
radio.button.by.embeding=通過嵌入(&E)
radio.button.class.constructor=類構造函數(&S)
radio.button.current.method=當前方法(&T)
radio.button.field.declaration=屬性宣告(&D)
border.title.initialize.in=初始化位置
border.title.introduce.field=引入屬性
radio.button.setup=設定(&U)
border.title.introduce.variable=引入變數
label.name=名稱:
label.visibility2=可見性:
checkbox.static=static
checkbox.check.clone.method=檢查 '__clone' 方法
checkbox.check.destruct.method=檢查 '__destruct' 方法
checkbox.check.sleep.method=檢查 '__sleep' 方法
checkbox.check.wakeup.method=檢查 '__wakeup' 方法
checkbox.align.parameter.property.names=對齊參數/屬性名稱
checkbox.align.tag.comments=對齊標記註釋
checkbox.blank.line.before.the.first.tag=在第一個標記前使用空行
checkbox.blank.lines.around.parameters=在參數周圍使用空行
checkbox.keep.blank.lines=保留空行
checkbox.sort.phpdoc.tags=對 PHPDoc 標記排序
checkbox.use.fully.qualified.class.names=使用完全限定類名
checkbox.wrap.long.lines=長行換行
checkbox.use.as.a.default.template=用作預設模板
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
tooltip.defaults.to.project.folder=預設為專案資料夾
border.title.include.analysis=Include 分析
button.sync.extensions.with.interpreter=將擴展與解釋器同步
checkbox.add.a.comma.after.last.element.in.multiline.array=在多行陣列中的最後一個元素之後添加逗號
checkbox.force.short.declaration.style=強制短宣告樣式
checkbox.add.phpdoc=添加 PHPDoc(&D):
radio.button.copy.from.base.class=從基類複製(&P)
radio.button.default.empty.template=預設/空模板(&E)
radio.button.with.inheritdoc.tag=帶有 @inheritDoc 標記(&I)
label.constant.syntax=常數語法(&C)
php.interpreter.label.label=標籤
no.expression.found=找不到表達式
empty.type=空類型
add.catch.clause.quick.fix=添加 'catch' 從句
php.delete.catch.clause.quick.fix=刪除 'catch' 子句
php.delete.exception.quick.fix=刪除異常
php.surround.with.try.catch.quick.fix=使用 'try-catch' 環繞
trait.use.rule.type.name=特徵 use 規則方法
member.has.0.access.but.class.has.magic.method.1=成員具備 {0} 可見性，但可以通過 ''{1}'' 魔術方法存取
member.has.0.access=成員具備 {0} 可見性
declaration.must.be.compatible.with.0=宣告必須與 {0} 相容
declaration.must.be.compatible.with.super=宣告必須與父級相容
return.type.declaration.must.be.compatible.with.super=返回類型宣告必須與父級相容
array.only.updated.but.never.queried=陣列僅被更新，但從未被查詢
composer.json.open.tool.settings.intention=開啟工具設定
composer.json.path.not.configured=自訂儲存庫無法載入。未設定 composer.json 路徑
composer.json.exec.not.configured=自訂儲存庫無法載入。未設定 Composer 可執行檔案路徑
composer.json.custom.packages.done=自訂儲存庫已載入
composer.json.custom.packages.empty=找不到軟體套件。請檢查您的儲存庫
composer.json.custom.invalid.json=json 無效
composer.json.packagist.packages.done=僅載入了 packagist 儲存庫
composer.json.packages.loading.error=軟體套件未重新載入
composer.json.packages.refresh=軟體套件正在重新整理
cant.save.interpreter=無法儲存 ''{0}'': {1}
method.is.undefined.in.class=方法 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
method.is.undefined=方法 '#ref' {0,choice,0#未定義|1#可能未定義}
property.is.undefined.in.class=屬性 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
property.is.undefined=屬性 '#ref' {0,choice,0#未定義|1#可能未定義}
find.cause=尋找原因
find.exception.cause.table.title=異常原因
php.find.clause.throws=可能拋出: {0}
action.PhpStanAddToIgnored.text=添加到 PHPStan 忽略列表
action.PhpStanAddToIgnored.description=添加到 PHPStan 忽略列表
inspection.php.unused.display.name=未使用的宣告
inspection.php.expression.always.constant.inspection.display.name=到達時，變數始終為 true/false
inspection.composer.json.file.references.inspection.display.name=未解析的檔案引用
inspection.php.doc.duplicate.type.inspection.display.name=類型已存在於 PHPDoc 標記中
inspection.php.class.implements.solely.traversable.inspection.display.name=類無法直接實作 Traversable
inspection.php.array.used.only.for.write.inspection.display.name=陣列僅用於寫存取
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 屬性可為局部
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 變數覆寫已定義的變數
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不當的 @inheritDoc
inspection.php.expression.with.same.operands.inspection.display.name=邏輯表達式有相同操作數
inspection.php.traits.use.list.inspection.display.name=每行一個特徵 use
inspection.php.long.type.form.inspection.display.name=類型關鍵字的縮寫
inspection.php.compound.namespace.depth.inspection.display.name=複合命名空間深度大於 2
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少參數列表
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.modifier.order.inspection.display.name=修飾符順序
inspection.php.missing.visibility.inspection.display.name=缺少可見性
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通過引用傳遞
inspection.php.accessed.array.is.always.empty=陣列在存取點始終為空
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以與後續條件合併
inspection.php.instanceof.is.always.true='instanceof' 的結果始終為 'true'
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可以取代為比較
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg' 調用可以取代為參數存取
inspection.php.format.function.call.with.single.argument=使用單個實參格式化函數調用
inspection.php.invalid.instanceof.argument.type='instanceof' 的實參只應是物件或字串
inspection.php.condition.always.evaluates.to.constant=條件始終評估為 'true/false'
inspection.php.condition.checked.by.next.condition=邏輯表達式內部的條件由後續條件檢查
inspection.php.array.write.access.is.not.used=未使用陣列寫入存取
inspection.php.redundant.optional.argument=冗餘的可選實參
inspection.php.property.only.written=屬性用法具有相同的存取權限
inspection.php.to.string.may.produce.exception='__toString' 可能會拋出異常
inspection.php.loop.never.iterates.name=迴圈未迭代
inspection.php.loop.never.iterates=''{0}'' 語句不迴圈
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表達式可以取代為條件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表達式可以取代為短版本
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的局部變數
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分號
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括號存取語法
inspection.php.single.statement.with.braces.inspection.display.name=單語句主體帶大括號
inspection.php.statement.without.braces.inspection.display.name=控制語句主體無大括號
inspection.php.str.functions.inspection.display.name='str*' 調用可以取代為 PHP 8 'str_*' 調用
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元運算符
inspection.php.doc.field.type.mismatch.inspection.display.name=類型與屬性的宣告類型不符合
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 語句沒有 default 分支
inspection.php.strict.comparison.of.operands.with.different.types=嚴格比較類型不相容的操作數
inspection.php.suspicious.name.combination.inspection.name=可疑名稱組合
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 語句中存在重複分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 語句中的重複分支
inspection.php.exception.is.immediately.rethrown=立即重新拋出異常
inspection.php.continue.targeting.switch='continue' 針對 'switch' 語句
inspection.php.redundant.continue.break.argument=冗餘的 'continue/break' 實參
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表達式中的重複 arm
inspection.php.field.assignment.type.mismatch.inspection.display.name=屬性賦值中的類型不符合
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=閉包可以轉換為箭頭函數
inspection.php.concatenation.with.arithmetic.usage=具有算術用法的串聯
inspection.php.parameter.always.have.same.value=參數值始終相同
inspection.php.method.return.value.is.never.used=方法的返回值從未使用
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可以取代為合併
inspection.php.cast.is.unnecessary=類型轉換不必要
inspection.php.unnecessary.curly.variable.syntax=變數的不必要大括號語法
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=無效類型的解包實參
inspection.php.missing.return.type.inspection.display.name=缺少返回類型宣告
inspection.php.missing.parameter.type.inspection.display.name=缺少參數的類型宣告
inspection.php.missing.field.type.inspection.display.name=缺少屬性的類型宣告
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表達式不帶澄清括號
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圓括號
inspection.php.method.may.be.static.inspection.display.name=方法可能為 'static'
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函數參數不符合
inspection.php.ignored.class.alias.declaration.display.name=忽略的類別名聲明
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重複的軟體套件條目
inspection.php.not.installed.packages.inspection.display.name=未安裝的 Composer 軟體套件
inspection.php.disabled.quality.tool.composer.inspection.display.name=品質工具檢查已禁用
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少擴展
inspection.php.disabled.extension.stubs.inspection.display.name=已禁用的擴展存根
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以轉換為迴圈
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=迴圈可以轉換為 'array_fill' 調用
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class' 可以取代為 '::class'
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter' 可以轉換為迴圈
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=迴圈可以轉換為 'array_filter' 調用
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=迴圈可以轉換為 'array_map' 調用
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map' 調用可以轉換為迴圈
inspection.php.short.open.tag.inspection.display.name=使用了短起始標記
inspection.php.constructor.style.inspection.display.name=舊式構造函數
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=賦值可取代為增量或減量
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=賦值可以取代為運算符賦值
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔術方法修飾符無效
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔術方法簽名不正確
inspection.php.array.access.on.illegal.type.display.name=非法類型的陣列偏移存取
inspection.php.parameter.name.chaged.during.inhertiance=在繼承期間更改了參數名稱
inspection.php.named.argument.may.be.unresolved=命名實參可能未解析
inspection.php.argument.without.name.identifier=無名稱關鍵字的實參
inspection.php.named.argument.usage=有名稱關鍵字的實參
inspection.php.named.arguments.with.changed.order=命名實參順序與參數順序不符合
inspection.php.mixed.return.type.can.be.reduced=可以限縮 'mixed' 返回類型的範圍
inspection.php.null.is.not.compatible.with.parameter='null' 與參數的宣告類型不相容
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname' 調用可以取代為 'levels' 參數用法
inspection.php.trait.method.use.is.located.inside.different.target.class=特徵 use 規則已解析為使用不同包含類的方法 
inspection.php.trait.usage=不允許特徵用法
inspection.php.class.cant.be.used.as.attribute=類不能用作特性
inspection.php.redundant.match.expression='match' 表達式只有 default arm，應當進行簡化
inspection.php.loop.can.be.replaced.with.str.repeat=迴圈可以取代為 'str_repeat'
inspection.php.concatenation.with.empty.string.can.be.merged=空字串的串聯可以與賦值合併
inspection.php.class.constant.accessed.via.child.class=通過子類引用的類常數
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表達式可以取代為三元表達式
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可以取代為 'match' 表達式
inspection.php.inapplicable.attribute.target.declaration=不適用的特性目標宣告
inspection.php.expected.values.should.be.used=應使用預期值
inspection.php.immutable.property.is.written.in.invalid.scope=在無效的作用域中寫入不可變屬性
inspection.php.attribute.is.not.repeatable=不可重複的特性
inspection.php.attribute.no.return.can.be.added=可以添加 NoReturn 特性
inspection.php.pure.contract.attribute.can.be.added=可以添加 '#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=純函數可能會產生副作用
inspection.php.attribute.array.shape.can.be.added=可以添加 '#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以將特性添加到覆寫成員
inspection.php.array.key.does.not.match.array.shape=陣列鍵與陣列形狀不符合 
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少嚴格類型宣告
inspection.php.incompatible.return.type.inspection.display.name=返回類型不相容
inspection.php.strict.type.checking.inspection.display.name=嚴格類型檢查規則違反
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非規範順序
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 運算符 '?->'
inspection.php.variable.variable.inspection.display.name=使用了可變變數
inspection.php.traditional.syntax.array.literal.inspection.display.name=檢測到傳統語法陣列文字
inspection.php.illegal.psr.class.path.inspection.display.name=類路徑與專案結構不符合
inspection.php.multiple.classes.declarations.in.one.file.display.name=一個檔案中有多個類宣告
inspection.php.redundant.catch.clause.inspection.display.name=冗餘 catch 子句
inspection.php.unhandled.exception.inspection.display.name=未處理的異常
inspection.php.non.strict.object.equality.inspection.display.name=非嚴格物件相等
inspection.php.duplicate.case.inspection.display.name=switch 語句中存在重複的 case
inspection.php.duplicate.match.condition.inspection.display.name=重複條件
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 條件
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中註釋被解析為特性
inspection.php.redundant.attribute.parenthesis=特性中的冗餘圓括號
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名稱
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名稱
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 驗證
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 驗證
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 驗證
inspection.php.usage.of.silence.operator.inspection.display.name=使用了靜默運算符
inspection.php.useless.trailing.comma.inspection.display.name=無用的尾隨逗號
inspection.php.useless.trailing.comma.inspection.desc=無用的尾隨逗號
inspection.php.remove.useless.trailing.comma=移除無用的尾隨逗號
inspection.php.add.line.break.after.trailing.comma=在尾隨逗號後添加換行符
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 陣列用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套與外部 'foreach' 變數衝突
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 語句
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=棄用的通過修飾符註解進行的 @covers/@uses
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=棄用的通過文檔標記進行的異常處理
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了棄用的 expectException
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=順序錯誤的 'assertEquals/assertNotEquals' 實參
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.contains.inspection.display.name=棄用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.can.be.replaced.with.fail=斷言可以取代為 'fail'
inspection.php.unit.assert.empty.inspection.display.name=斷言可以取代為 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.file.equals.inspection.display.name=棄用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.assert.equals.inspection.display.name=棄用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆蓋函數引用沒有 ‘::’
inspection.php.unit.undefined.data.provider.inspection.display.name=未定義的 PHPUnit 資料提供程序
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 測試缺少目標元素
inspection.php.constant.naming.convention.inspection.display.name=常數名稱未遵循編碼慣例
inspection.php.variable.naming.convention.inspection.display.name=變數名稱未遵循編碼慣例
inspection.php.property.naming.convention.inspection.display.name=屬性名稱未遵循編碼慣例
inspection.php.method.naming.convention.inspection.display.name=方法名稱未遵循編碼慣例
inspection.php.function.naming.convention.inspection.display.name=函數名稱未遵循編碼慣例
inspection.php.class.naming.convention.inspection.display.name=類名未遵循編碼慣例
inspection.php.overriding.method.visibility.inspection.display.name=方法可見性不應被覆寫
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法調用或類用法中的大小寫不符合
inspection.php.expression.result.unused.inspection.display.name=未使用表達式結果
inspection.php.throwable.not.thrown.inspection.display.name=未拋出 Throwable
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函數結果
inspection.php.redundant.closing.tag.inspection.display.name=冗餘結束標記
inspection.php.too.many.parameters.inspection.display.name=函數宣告中的參數過多
inspection.php.method.parameters.count.mismatch.inspection.display.name=參數數量與宣告不符合
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回點
inspection.php.redundant.variable.doc.type.inspection.display.name=冗餘 @var 標記
inspection.php.doc.redundant.throws.inspection.display.name=冗餘 @throws 標記
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 標記
inspection.php.redundant.doc.comment.inspection.display.name=冗餘 PHPDoc 註釋
inspection.php.doc.signature.inspection.display.name=PHPDoc 註釋符合函數/方法簽名
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 註釋簽名不完整
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 註釋中的返回類型與實際返回類型不符合
inspection.php.illegal.string.offset.inspection.display.name=非法字串偏移
inspection.php.illegal.array.key.type.inspection.display.name=非法陣列鍵類型
inspection.php.empty.index.operator.not.supported.for.strings.display.name=字串不支持的空索引運算符
inspection.php.empty.index.operator.not.supported.for.strings=字串不支持 '[]' 運算符
inspection.php.silly.assignment.inspection.display.name=冗餘賦值
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 註釋
inspection.php.unused.parameter.inspection.display.name=未使用的參數
inspection.php.wrong.foreach.argument.type.inspection.display.name=為 'foreach()' 提供的無效實參
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.assignment.in.condition.inspection.display.name=條件中的賦值
inspection.php.enum.case.with.value.not.found=枚舉中找不到包含指定值的 case
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句順序錯誤
inspection.php.wrong.string.concatenation.inspection.display.name=字串串聯錯誤
inspection.php.constant.reassignment.inspection.display.name=常數重新賦值
inspection.php.non.compound.use.inspection.display.name=不必要的語句使用
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 實作
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回類型
inspection.php.internal.entity.used.inspection.display.name=使用了內部實體
inspection.php.deprecated.implode.usage.inspection.display.name=棄用的 'implode/join' 用法
inspection.php.expression.always.null.inspection.display.name=表達式始終為 'null'
inspection.php.deprecated.cast.inspection.display.name=棄用的轉換
inspection.php.define.constant.name.with.leading.slash=使用前導斜杠定義的常數名稱
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常數名稱可以取代為 'const' 語法
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在設定的 PHP 版本中不可用
inspection.php.deprecation.inspection.display.name=已棄用
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 類型可以取代為 'array'
inspection.php.language.level.inspection.display.name=語言級別
inspection.php.unused.field.default.value.inspection.display.name=冗餘屬性初始設定式
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.local.variable.inspection.display.name=未使用的局部變數
inspection.php.write.access.to.referenced.array.value.without.unset=對無 'unset' 的引用陣列值的寫入權限
inspection.php.boolean.expression.can.be.simplified=可以簡化布爾表達式
inspection.array.access.can.be.replaced.with.foreach.value=陣列存取可以取代為 'foreach' 值
inspection.php.unused.private.field.inspection.display.name=未使用的 private 屬性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.goto.into.loop.inspection.display.name=Goto 轉入迴圈語句
inspection.php.pass.by.ref.inspection.display.name=通過引用傳遞參數
inspection.php.optional.before.required.parameters.inspection.display.name=可選參數在必選參數之前
inspection.php.params.inspection.display.name=參數類型
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.undefined.constant.inspection.display.name=未定義的常數
inspection.php.undefined.field.inspection.display.name=未定義的屬性
inspection.php.statement.has.empty.body.inspection.display.name=語句具有空體
inspection.php.missing.parent.call.magic.inspection.display.name=魔術方法缺少父調用
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父調用
inspection.php.missing.parent.constructor.inspection.display.name=構造函數缺少父調用
inspection.php.undefined.class.constant.inspection.display.name=未定義的類常數
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父類的方法宣告與實作的接口不相容
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=覆寫方法的宣告應與父類相容
inspection.php.abstract.static.method.inspection.display.name=static 函數不應為 abstract
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被調用為動態
inspection.php.dynamic.as.static.method.call.inspection.display.name=動態方法被調用為 static
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多態調用
inspection.php.promoted.field.usage=提升的屬性用法
inspection.field.can.be.promoted=可以提升屬性
inspection.php.redundant.assignment.to.promoted.field=冗餘的提升屬性賦值
inspection.php.undefined.callback.inspection.display.name=未定義的回調
inspection.php.undefined.function.inspection.display.name=未定義的函數
inspection.php.undefined.class.inspection.display.name=未定義的類
inspection.php.multiple.class.declarations.inspection.display.name=多個類宣告
inspection.php.undefined.namespace.inspection.display.name=未定義的命名空間
inspection.php.undefined.method.inspection.display.name=未定義的方法
inspection.php.undefined.variable.inspection.display.name=未定義的變數
inspection.php.undefined.goto.label.inspection.display.name=未定義的 goto 標籤
inspection.php.group.undefined=未定義的符號
inspection.php.group.probable.bugs=可能的錯誤
inspection.php.group.general=一般
inspection.php.group.strict.standards=PHP 嚴格標準
inspection.php.group.type.compatibility=類型相容性
inspection.php.group.control.flow=控制流
inspection.php.group.code.smell=程式碼異味
inspection.php.group.psr.12=PSR-12
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.code.style=程式碼樣式
inspection.php.group.composer=Composer
inspection.php.group.unused=未使用的符號
inspection.php.group.naming.conventions=命名慣例
inspection.php.group.phpunit=PHPUnit
inspection.php.group.quality.tools=品質工具
inspection.php.group.replacable.assignments=可取代賦值
inspection.php.group.error.handling=錯誤處理
inspection.php.group.attributes=特性
list.item.update.phpdoc.comment=更新 PHPDoc 註釋
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 語句
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.return.function='return' 不必要，因為是函數中的最後一條語句
inspection.php.unnecessary.return.method='return' 不必要，因為是方法中的最後一條語句
inspection.php.unnecessary.continue='continue' 不必要，因為是迴圈中的最後一條語句
php.unit.create.target.method.quick.fix.family.name=創建缺少的目標方法
inspection.php.missing.return.type.description=缺少函數的返回類型宣告
inspection.php.missing.param.type.description=缺少參數的類型宣告
quickfix.php.missing.param.type.description=作為參數類型添加 ''{0}''
quickfix.php.missing.param.type.batch.description=作為屬性類型添加推斷的類型
php.add.method.declaration.quick.fix.text=添加方法
php.add.tag.base.quick.fix.family.name=添加 {0} 標記
inspection.php.unused.field.default.value.description=屬性初始設定式冗餘
php.change.function.signature.manually.quick.fix.family.name=手動更改簽名
php.change.function.signature.from.usage.quick.fix.family.name=從用法改變函數簽名
searching.for.usages=正在搜尋用法…
php.replace.with.local.variable.quick.fix.family.name=將屬性取代為局部變數
inspection.php.private.field.can.be.local.variable.description=屬性可以取代為局部變數
inspection.php.abstract.static.method.description=PHP 嚴格標準: static 方法 '#ref' 不應為 abstract
php.replace.argument.with.cast.quick.fix.family.name=將實參轉換為{0}
php.change.cast.operation.quick.fix.family.name=將轉換更改為{0}
php.replace.with.null.quick.fix.family.name=取代為 'null'
inspection.php.expression.always.null.description='#ref' 始終為 'null'
inspection.unnecessary.static.reference=final 類中有冗餘的 'static'
inspection.unnecessary.string.cast=冗餘轉換為字串
inspection.unnecessary.bool.cast=冗餘轉換為布林值
php.configure.extensions.quick.fix.family.name=設定擴展存根
php.enable.extension.quick.fix.family.name=啟用擴展存根
php.enable.extension.quick.fix.text=啟用 ''{0}'' 擴展存根
inspection.php.disabled.extension.stubs.description=已禁用的 ''{0}'' 擴展存根
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用於沒有父級成員但含有 doc 註釋的成員
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 應僅用於類成員
php.inline.variable.quick.fix.family.name=內聯變數
update.php.doc.type.family.name=更新 PHPDoc 類型
update.php.doc.type.comment=取代為 ''{0}''
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回類型與實際返回類型不符合
inspection.php.doc.signature.description=重複的實參 PHPDoc
inspection.php.doc.signature.description2=返回類型與宣告的不符合
inspection.php.doc.signature.description3=不存在實參的 PHPDoc
inspection.php.doc.signature.description5=實參類型與宣告的不符合
php.flip.variable.and.type.quick.fix.family.name=翻轉變數和類型
inspection.php.non.canonical.elements.order.description=變數及其類型以非規範順序列出
php.make.class.abstract.quick.fix.family.name=將類設為 abstract
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.make.method.non.final.quick.fix.family.name=將方法設為非 final
inspection.php.short.open.tag.description=使用了短起始標記
php.make.method.non.static.quick.fix.family.name=將方法設為非 static
php.flip.arguments.quick.fix.family.name=翻轉第一和第二個實參
inspection.php.unused.alias.description=匯入 '#ref' 不必要
inspection.php.unused.alias.description2=匯入 '#ref' 從未使用
php.rename.wrong.reference.quick.fix.family.name=重命名引用
php.append.doc.static.fix.family.name=在函數引用前追加 '::'
inspection.php.include.description=無法解析表達式 ''{0}'' 的目標
inspection.php.include.description2=未找到路徑 ''{0}''
make.call.dynamic.quick.fix.family.name=使調用為動態
inspection.php.undefined.class.description=類 '#ref' 存在多個定義
inspection.php.undefined.class.description2=未定義的類 '#ref'
inspection.php.undefined.class.description5=存在類 '#ref' 的其他宣告
php.dead.code.entries=PHP 死碼條目
inspection.php.redundant.variable.doc.type.description=@var 標記指定了已從原始碼推斷出的類型
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的參數
transform=轉換
remove=移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除變數 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=取代為 '(float)' 轉換
php.create.data.provider.quick.fix.family.name=創建資料提供程序
inspection.php.undefined.namespace.description=未定義的命名空間 '#ref'
fix.not.available=修復不可用
php.unit.create.target.class.quick.fix.family.name=創建缺少的目標類
initialize.var.quick.fix.family.name=使用值初始化
inspection.php.statement.has.empty.body.description=語句具有空體
php.replace.with.interface.quick.fix.family.name=取代為 {0}
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
php.change.method.modifiers.quick.fix.family.name=更改修飾符
php.change.method.modifiers.quick.fix.text=移除修飾符
php.remove.statement.fix.family.name=移除
php.make.method.non.abstract.quick.fix.family.name=將方法設為非 abstract
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=將 '+=' 取代為 '.='
replace.plus.to.concat.quick.fix.family.name=將 '+' 取代為 '.'
replace.with.0=取代為 {0}
php.remove.ref.from.function.declaration.quick.fix.family.name=從函數宣告中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=將 '=\\&' 取代為 '='
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=從參數中移除 '&'
inspection.php.pass.by.ref.description=僅變數可通過引用返回
php.non.strict.object.equality.quick.fix.text=取代為身份比較
php.add.field.declaration.quick.fix.text=添加屬性
quick.fix.error=快速修復錯誤
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始類 {0} 不屬於該專案\n\
並且無法修改。
add.constant.declaration.quick.fix.text=添加常數
add.enum.declaration.quick.fix.text=添加枚舉 case
constant.ref.not.found.in=在 {0} 中未找到常數 ''#ref''
php.remove.parameters.quick.fix.text=移除未使用的參數
replace.extends.implements=取代 'extends'/'implements'
inspection.php.undefined.class.other.declaration.exists={0} 處存在類 ''#ref'' 的其他宣告
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 處存在類 ''#ref'' 的其他宣告
show.implementations.for.0={0} 的實作
show.super.types.for.0=顯示 {0} 的父類型
display.name.directory.0=目錄 ''{0}''
hint.text.element.doesn.t.have.fqn=元素沒有 FQN
instanceof.is.always.true={0} 已位於 {1} 的層次結構中
dialog.message.server.host.cannot.be.empty=伺服器主機不能為空
dialog.message.port.cannot.be.negative.number=端口號不能為負
dialog.message.query.string.cannot.start.with=查詢字串不能以 '?' 開頭
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=程式碼段過於複雜，無法解析，因此將作為純文本處理
inspection.message.control.flow.too.big.to.analyze=控制流太大，無法分析
remove.variable=移除變數
annotator.fix.remove=移除 ''{0}''
inspection.message.class.may.inherit.from.final.class=類可能無法繼承 final 類
inspection.message.key.element.cannot.be.reference=鍵元素不能為引用
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=應為 'insteadof' 特徵 use 規則指定絕對方法引用
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=生成器只能宣告 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回類型，不允許 {0}
find.usages.button.base.method=基方法
find.usages.button.current.method=當前方法
find.usages.prompt.dialog.implements=類 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中實作了{3,choice,0#方法|1#方法}\n\
要尋找基{3,choice,0#方法|1#方法}的用法嗎?
find.usages.prompt.dialog.overrides=類 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重寫了{3,choice,0#方法|1#方法}\n\
要尋找基{3,choice,0#方法|1#方法}的用法嗎?
more.actions=更多操作…
show.log.of.composer.related.actions=顯示 Composer 相關操作的日誌
show.log=顯示日誌
members.to.report=要報告的成員
entry.points=入口點
constructors=構造函數
inspection.message.type.mismatch.should.be.conditional.expression=類型不符合: 應為條件表達式
filetype.doctrine.query.description=Doctrine 查詢語言
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=類型化屬性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=類型化屬性 ''{0}'' 可能未初始化
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=僅物件或字串應用作 ''instanceof'' 實參，當前: ''{0}''
another.definition.with.same.name.exists.in.this.file=此檔案中存在另一個具有相同名稱的定義
method.with.same.name.already.defined.in.this.class=此類中已經定義了具有相同名稱的方法
global.code.should.be.enclosed.in.global.namespace.declaration=全域程式碼應包含在全域命名空間宣告中
static.property.cannot.be.unset=static 屬性不能取消設定
the.yield.expression.can.only.be.used.inside.a.function='yield' 表達式只能在函數中使用
multiple.modifiers.are.not.allowed=不允許多個修飾符
access.type.for.interface.member.must.be.omitted=接口成員的存取類型必須省略
final.modifier.is.not.allowed.here=此處不允許使用 'final' 修飾符
fields.cannot.be.declared.final=屬性不能宣告為 final
abstract.modifier.is.not.allowed.here=此處不允許使用 'Abstract' 修飾符
fields.cannot.be.declared.abstract=屬性不能宣告為 abstract
static.modifier.is.not.allowed.here=此處不允許使用 'Static' 修飾符
jump.into.a.finally.block.is.disallowed=不允許跳入 'finally' 塊
cannot.use.static.as.function.return.type.declaration=不允許 'static' 作為類範圍外部的返回類型宣告
void.type.cannot.be.nullable=void 類型不能是可為 null
can.only.be.used.as.standalone.type={0} 僅可用作獨立類型
void.can.only.be.used.as.return.type=Void 只能用作返回類型
static.is.not.allowed.in.parameter.type.declaration=參數類型宣告中不允許 'static'
cannot.use.this.as.parameter=不能將 $this 用作參數
only.the.last.parameter.can.be.variadic=只有最後一個參數可以是可變形參
expression.is.not.allowed.as.parameter.default.value=表達式不允許為參數預設值
default.value.for.parameters.with.a.class.type.can.only.be.null=具有類類型的參數的預設值只能為 'NULL'
argument.passed.must.be.of.the.type.0.1.given=傳遞的實參必須為 {0} 類型，給定的為 {1}
variadic.parameter.cannot.have.a.default.value=可變形參不能具有預設值
only.simple.expressions.are.allowed=只允許簡單表達式
target.trait.should.be.specified=應指定目標特徵
call.to.0.1.construct.from.invalid.context=從無效上下文調用 ''{0} {1}::__construct()''
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 關鍵字定義的常數必須在頂層範圍宣告
expression.is.not.allowed.as.constant.value=表達式不允許作為常量值
cannot.redeclare.constant.0=無法重新宣告常數 ''{0}''
expression.is.not.allowed.as.field.default.value=表達式不允許為欄位預設值
cannot.declare.self.referencing.constant=無法宣告自引用常數
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=類常數不得被稱為 'class'；後者被保留用於類名提取
traits.cannot.have.constants=特征不能有常數
redefinition.of.parameters.is.not.allowed=不允許參數重新定義
method.0.clone.cannot.accept.any.arguments=方法 ''{0}::__clone()'' 不能接受任何實參
return.type.declaration.is.not.allowed=不允許返回類型宣告
method.should.not.be.finished.with=方法不應以 ';' 結束
method.should.either.have.body.or.be.abstract=方法應具有主體或為 abstract
interface.method.can.t.have.body=接口方法不能有主體
anonymous.function.expected=應為匿名函數
label.with.same.name.already.defined.in.current.scope=當前範圍中已定義具有相同名稱的標籤
interfaces.may.not.include.member.variables=接口可能不包括成員變數
0.with.same.name.already.defined.in.this.class=此類中已經定義了具有相同名稱的{0}
field=欄位
cannot.redeclare.static.0.1.as.non.static.2.3=無法將 static ''{0}::${1}'' 重新宣告為非 static ''{2}::${3}''
cannot.redeclare.non.static.0.1.as.static.2.3=無法將非 static ''{0}::${1}'' 重新宣告為 static ''{2}::${3}''
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定義相同的屬性 ''{2}''
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::${1}'' 的存取級別必須為 {2} (與類 {3} 中一樣)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}::{1}'' 的存取級別必須為 {2} (與類 {3} 中一樣)或更低
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=無法從接口 ''{1}'' 繼承先前繼承的常數 ''{0}'' 或將其覆寫
empty.implements.list=空實作列表
a.trait.cannot.implement.an.interface=特徵無法實作接口
class.cannot.implement.previously.implemented.interface=類無法實作先前實作的接口
class.should.not.implement.itself=類不應自行實作
empty.extends.list=空 extends 列表
a.trait.cannot.extend.a.class=特徵無法擴展類
interface.cannot.extend.previously.extended.interface=接口無法擴展先前擴展的接口
class.cannot.extend.from.trait=類無法從特徵擴展
0.should.not.extend.itself={0} 不應自行擴展
class=類
class.declarations.may.not.be.nested=類宣告不能被嵌套
cannot.use.traits.inside.of.interfaces=無法在接口內部使用特徵
trait.expected.class.found=應為特徵，發現類
absolute.reference.is.not.allowed=不允許絕對引用
cannot.use.0.as.lexical.variable=無法將 ''${0}'' 用作詞法變數
duplicate.variable.0=重複的變數 ''{0}''
trailing.comma.is.not.allowed=不允許尾隨逗號
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必須在檔案的最外側範圍(全域範圍)或命名空間宣告內部宣告 'use' 關鍵字
static.is.not.allowed.in.compile.time.constants=編譯時常量中不允許使用 'static::'
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=檔案中的多個命名空間應使用相同的(最好帶大括號)語法
no.content.allowed.before.namespace.declaration=命名空間宣告之前不允許任何內容
an.object.s.clone.method.cannot.be.called.directly=無法直接調用物件的 '__clone()' 方法
property.write=@property-write
property.read=@property-read
isset.only.works.with.variables.and.arrays=isset 僅適用於變數和陣列
cannot.use.positional.argument.after.argument.unpacking=無法在實參解包後使用位置實參
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函數名稱必須可調用 - 字串、閉包或實作 ''__invoke'' 的類，當前為 ''{0}''
using.this.when.not.in.object.context=不在物件上下文中時使用 '$this'
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用於陣列析構賦值
function.call.is.not.allowed.here=此處不允許使用函數調用
expression.is.not.assignable=表達式不可賦值
call.to.method.clone.from.invalid.context=從無效上下文調用方法 '__clone'
cannot.use.for.reading=無法使用 '[]' 進行讀取
it.s.not.possible.to.unpack.array.argument.by.reference=無法通過引用對陣列實參解包
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多賦值變數不支持在陣列中使用展開運算符
it.s.not.possible.to.unpack.array.value.with.associated.key=無法使用關聯鍵解包陣列值
it.s.not.possible.to.unpack.array.key=無法解包陣列鍵
cannot.use.empty.array.elements.in.arrays=無法在陣列中使用空陣列元素
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=無效的八進制文字: 不會由 PHP 報告，但無法正常工作
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允許在數字文字中使用多個後續下劃線
expression.is.not.allowed.as.static.initializer=表達式不允許為 static 初始設定式
namespace.declarations.cannot.be.nested=命名空間宣告不能被嵌套
global.namespace.should.use.braced.syntax=全域命名空間應使用帶大括號的語法
halt.compiler.can.only.be.used.from.the.outermost.scope=僅可從最外側範圍使用 '__halt_compiler()'
cannot.use.match.as.identifier=無法將 'match' 用作關鍵字，自 PHP 8.0 起作為預留關鍵字
cannot.use.class.on.primitive.type=只允許在物件上使用 '::class'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 取代 '?' 作為聯合類型的一部分
intention.name.replace.null.as.part.union.type.with.nullable.notation=將 '|null' 作為聯合類型的一部分取代為 '?'
union.types.and.the.nullable.type.notation.cannot.be.mixed=聯合類型和可為 null 類型表示法不能混合
union.types.mixed.cannot.be.nullable=混合類型不能為可 null，'null' 已是混合類型的一部分
quick.fix.delete=刪除 ''{0}''
type.null.and.false.cannot.be.used.as.as.standalone.type='null' 和 'false' 不可用作獨立類型
is.duplicated.by.0=類型被 ''{0}'' 重複
intention.name.remove.duplicated.type=移除重複類型
popup.title.select.reference.to.remove=選擇要移除的類型
intention.family.name.append=追加 ''{0}''
intention.family.name.change.to.mixed=將類型更改為 'mixed'
inspection.php.redundant.type.in.union.type=類型宣告冗餘，可以簡化
inspection.php.redundant.type.in.union.type.template=類型宣告可以簡化為 ''{0}''
inspection.php.redundant.type.in.union.type.fix.name=簡化冗餘類型

inspection.message.always.true.because=條件始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because=Nullsafe 運算符{0,choice,0#將始終產生 ''null''|1#不必要}，因為此時 ''{1}'' 已經為 ''{2,choice,0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 運算符 ''{0,choice,0#將始終產生 ''null''|1#不必要}''，因為此時已評估 ''{1}''
inspection.message.always.true.because.evaluated=條件始終為 ''{0,choice,0#false|1#true}''，因為此時已評估 ''{1}''
hint.evaluation.makes.subsequent.condition.always.true=評估使後續條件始終為 'true'
hint.evaluation.fully.contains=評估結果完全覆蓋 ''{0}'' 的可能結果
hint.evaluation.makes.array.always.empty=評估使得陣列始終為空
intention.family.name.navigate.to.cause=導航到原因
intention.family.name.replace.ternary.expression.with.true.branch=將三元表達式取代為 ''{0}'' 分支
intention.family.name.replace.elseif.with.else=將 'elseif' 取代為 'else'
extract.condition=提取條件
delete.if=刪除 'if'
delete.elseif=刪除 'elseif'
action.show.in.log.text=在日誌中顯示
action.add.file.s.to.list.text=向列表中添加檔案
quality.tool.action.remove.file.s.from.list.text=從列表中移除檔案
quality.tool.action.clean.list.text=清除列表
quality.tool.border.title.ignored.files=已忽略的檔案
quality.tool.ignored.files={0} 忽略的檔案
intention.family.name.remove.redundant.arguments=移除冗餘的 {0, choice, 0#實參|1#實參}
inspection.message.redundant.argument={0, choice, 0#實參|1#實參}{0,choice,0#符合|1#符合}{0, choice, 0#參數的|1#參數的}預設{0, choice, 0#值|1#值}
plural.types.are.not.allowed.in.real.types=僅在 doc 類型中允許複數類型
intention.name.remove.brackets=刪除中括號
intention.name.replace.brackets.with.types=取代為 'array'
inspection.message.only.variables.can.be.passed.by.reference=僅可通過引用傳遞變數
expression.0=表達式 {0}
expression=表達式
notification.content.language.level.was.changed.to.based.on.project.usage=語言級別已根據專案中使用的功能設定為 {0}
action.revert.back.to.text=還原為 {0}
expected.class.reference=應為: 類引用
expected.expression=應為: 表達式
parser.unexpected=意外: {0}
parser.expected=應為: {0}
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由於與 ns 相關名稱衝突，命名空間不能以 "namespace" 開頭
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留關鍵字
incorrect.null.safe.operator=錯誤的 nullsafe 運算符
replace.with.quest=取代為 '?'
required.parameters.missing=缺少所需參數 ''{0}''
parameter.ref.type.is.not.compatible.with.declaration=參數 '#ref' 類型與宣告不相容
add.remote.interpreter=添加遠端解釋器
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 Remote Hosts Access 延伸模組。請在“{0} | 延伸模組”中啟用此延伸模組。
extract.side.effect=提取副作用
delete.unused.element=刪除未使用的元素
suppress.all.for.file=對檔案全部禁止
callers=調用方
callees=被調用方
call.tree=調用樹
execution.statistics=執行統計
suppress.for.method=對方法禁止
suppress.for.function=對函數禁止
delete.redundant.switch.branch=刪除冗餘 'switch' 分支
suppress.for.phpdoc.comment=對 PhpDoc 註釋禁止
dynamically.declared.field=動態宣告的欄位
convert.closure.to.arrow.function=將閉包轉換為箭頭函數
suppress.for.file=對檔案禁止
choose.a.valid.0.launcher=選擇有效的 {0} 啟動器
0.location={0} 位置
0.path={0} 路徑:
configure=設定
file.0.does.not.exists=檔案 {0} 不存在
expressions=表達式
target=目標
creates.a.composer.json.file=創建 composer.json 檔案
composer.json.file=composer.json 檔案
implement.method=實作方法
split.elseif=拆分 'elseif'
add.setter=添加 setter
php=PHP
filetype.php.description=PHP
remove.redundant.initializer=移除冗餘的初始設定式
delete.assignment=刪除賦值
in.0=\ ({0} 內)
merge.nested.conditions=合併嵌套的條件
replace.quotes=取代引號
variable.dereferenced=已取消引用變數
0.1={0}，{1}
declaration.in.parent.class.is.incompatible.with.interface=父類中的宣告與接口不相容
copy.switch.branch=複製 'switch' 分支
default=預設:
replace.if.with.switch=將 'if' 取代為 'switch'
choose.an.alias.to.use=選擇要使用的別名
update.signature.to.match.phpdoc.comment=更新簽名以符合 PHPDoc 註釋
no.members.to.pull.up.found=未找到要向上拉取的成員
inject.language.using.phpdoc=使用 PHPDoc 注入語言
negate.boolean.expression=布爾表達式求反
no.members.to.push.down.found=未找到要向下推送的成員
replace.if.clause.with.ternary.expression=將 if 子句取代為三元表達式
0.pushing.members.down.will.result.in.them.being.deleted={0}\n\
向下推送成員將導致它們被刪除
remove.pass.by.ref.sign=移除 '\\&'
make.non.nullable=設為不可 null
reference=引用
function=函數
foreach=foreach
while=while
0=\ ({0})
for=for
filetype.composer.log.description=Composer 日誌
clear.log=清除日誌
align.composer.log.console=對齊 Composer 日誌控制台
all.0=所有({0})
choose.executable.class.to.run.0=選擇用於執行 {0} 的可執行類
show.settings=顯示設定
enable=啟用
composite.test.patterns=複合測試模式
add.test.class.method=添加測試類/方法…
empty.pattern=空模式
ignore.imports.and.formatting=忽略匯入和格式設定
sort.the.elements.by.visibility.public.protected.private=按可見性對元素排序: public、protected、private
sort.by.visibility=按可見性排序
copy=複製
add=添加
replace.ternary.expression.with.if.clause=將三元表達式取代為 if 子句
information=資訊
always.show.pass.by.reference=始終顯示引用傳遞
show.name.for.all.arguments=顯示所有實參的名稱
composer.packages.versions=Composer 軟體套件版本
constructor.field=構造函數欄位
inspection.php.illegal.array.key.type.description={0} {1}
edit.template=編輯模板
remove.rule=移除規則
add.rule=添加規則
choose.super.class.or.interface=選擇超類或接口
choose.super.method=選擇 super 方法
extends.implements.overrides=擴展/實作/覆寫
remove.unnecessary.semicolon=移除不必要的分號
choose.properties=選擇屬性
composer=composer
composer.executable='composer' 可執行檔案
0.12={0}:{1}
label=標籤
namespace=命名空間
alias=別名
constant=常數
enum.case=枚舉 case
field1=欄位
class.constant=類常數
function2=函數
method=方法
class1=類
interface=接口
parameter=參數
variable=變數
cancel=取消
do.not.override=不覆寫
override=覆寫
method.name=方法名稱
proceed=繼續
add.custom.format.function=添加自訂格式函數…
02={0}::
add.class=添加類…
all.exceptions.considered.checked=所有異常均被視為已檢查
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>註: 核心擴展是 PHP 核心的一部分，不能放在包含編譯選項的 PHP 二進制檔案外部。</html>
choose.elements.to.generate.phpdoc.for=選擇要為其生成 PHPDoc 的元素
no.elements.to.generate.phpdoc.for=沒有任何可為其生成 PHPDoc 的元素
invalid.class.name=無效類名
target.class=目標類:
03=({0})
constant.0=常數 {0}
usage.in.return.type=返回類型中的用法
usage.in.import.statement=import 語句中的用法
overriding.implementing.methods=覆寫/實作方法
usage.in.type.hinting=類型提示中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.extends.clause=etends 子句中的用法
method.call=方法調用
function.call=函數調用
04={0}:
field.ref.not.found=找不到欄位 '#ref'
method.ref.not.found=找不到方法 '#ref'
0.extends.1={0} 擴展 {1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0# 擴展 |1# 執行 }{2}
remove.link.between.0.and.1=移除 {0} 與 {1} 之間的鏈接
import.from.deployment.configuration=從部署設定匯入
import=匯入
php.control.flow.viewer.0=PHP 控制流查看器: {0}
php.control.flow.viewer=PHP 控制流查看器
close=關閉(&C)
build.control.flow=建置控制流(&B)
change.member.access=更改成員存取
php.make.class.non.final.quick.fix.family.name=將類設為非 final
squash.repetitive.underscores=壓縮重複下劃線
replace.with.01=取代為 {0}
filetype.profiler.snapshot.description=分析器快照
proxy.configuration=代理設定
surround.with.0=使用 ''{0}'' 環繞
rename.constructor=重命名構造函數
rename=重命名
replace.with.alias=取代為別名
strict.type.declaration.is.available.in.php.7.only=從 PHP 7.0 起才允許使用嚴格類型宣告
recursive.call=遞歸調用
smarty=Smarty
add.property=添加 @property
all.scripts=<All scripts>
summary=摘要
can.t.use.nullsafe.operator.in.write.context=在寫入上下文中不能使用 nullsafe 運算符
intention.family.name.collapse.whitespaces=摺疊空格
inspection.message.qualified.name.can.t.contain.whitespaces=限定名稱不能包含空格
php.language.level.widget=PHP 語言級別
tooltip.configured.php.language.level.widget=已設定的 PHP 語言級別
tooltip.configured.php.language.level.widget.composer=通過 Composer 設定的 PHP 語言級別
change.php.language.level=更改 PHP 語言級別
function.fqn=函數 FQN
choose.class=選擇類
older=較舊…
intention.family.name.replace.with=取代為 ''{0}''
inspection.message.redundant.static.in.final.class=final 類中有冗餘的 'static'
link.label.inspection={0} 檢查
intention.name.add.as.function.s.return.type=將 ''{0}'' 作為函數返回類型添加
add.return.type=添加返回類型
php.class=類
php.interface=接口
php.trait=特徵
clearing.cache=清除快取
diagnosing=診斷
simulating.update=模擬更新
generating.autoloader=生成自動載入器
listing.licenses=列出授權
checking.for.changes.in.code.of.dependencies=檢查依賴項程式碼中的變更
validating=驗證
add.custom.format.function1=添加自訂格式函數
edit.custom.format.function=編輯自定義格式函數
no.item=沒有項
no.interpreter=<無解釋器>
open.in.editor=在編輯器中開啟
how.to.fix=修正方法
path.to.php=<php 路徑>
constructor.already.exists=構造函數已存在
fluent.setters=Fluent setter
no.private.fields.to.generate.getters.for=沒有要為之生成 getter 的 private 欄位
no.private.fields.to.generate.both.getters.and.setters.for=沒有要為之同時生成 getter 和 setter 的 private 欄位
no.private.fields.to.generate.setters.for=沒有要為之生成 setter 的 private 欄位
choose.methods.to.implement=選擇要實作的方法
make.0.1=將 ''{0}'' 設為{1}
arrays.are.not.supported.as.operands.for.0=不支持將陣列用作 ''{0}'' 的操作數
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支援的操作數類型將導致 PHP 8 TypeError
trait.method.0.will.not.be.applied.because.it.collides.with.1=由於與 ''{1}'' 衝突，因此不會套用特徵方法 ''{0}''
method.0.can.t.be.overridden.with.same.trait.1=無法使用相同的特徵 ''{1}'' 覆寫方法 ''{0}''
intention.name.make.non.final=將{0}設為非 final
replace.with.absolute.reference=取代為絕對引用
debug.output=輸出
no.candidate.methods.to.implement=沒有要實作的候選方法
choose.methods.to.implement1=選擇要實作的方法
choose.methods.to.override=選擇要覆寫的方法
no.candidate.methods.to.override=沒有要覆寫的候選方法
cannot.call.abstract.method.0.1=無法調用 abstract 方法 ''{0}::{1}''
intention.name.flip=翻轉 {0} 和 {1}
method.ref.is.deprecated=方法 '#ref' 已棄用
parameter.is.deprecated=參數 ''{0}'' 已棄用
function.ref.is.deprecated=函數 '#ref' 已棄用
class.ref.is.deprecated=類 '#ref' 已棄用
constant.ref.is.deprecated=常數 '#ref' 已棄用
field.ref.is.deprecated=欄位 '#ref' 已棄用
constant.ref.is.deprecated1=常數 '#ref' 已棄用
inspection.message.duplicate.case.expression=重複 case 表達式
inspection.message.duplicate.case.expression.ref=重複 case 表達式: #ref
replace.qualifier.with.an.import=將限定符取代為匯入
inspection.message.method.ref.marked.as.internal=方法 '#ref' 已標記為 @internal
inspection.message.function.ref.marked.as.internal=函數 '#ref' 已標記為 @internal
inspection.message.class.ref.marked.as.internal=類 '#ref' 已標記為 @internal
inspection.message.constant.ref.marked.as.internal=常數 '#ref' 已標記為 @internal
inspection.message.field.ref.marked.as.internal=欄位 '#ref' 已標記為 @internal
remove.from.the.parameter.0=從參數 ''{0}'' 中移除 ''\\&''
remove.from.function.0.declaration=從函數 ''{0}'' 宣告中移除 ''\\&''
remove.numeric.literals.separators=移除數字文字分隔符
intention.name.remove=移除 {0}
intention.name.convert.array.syntax.to.short=將陣列轉換為短語法
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=調用鏈過長，無法進行分析。請將其拆分為最多包含 {0} 個調用的片段
inspection.message.undefined.goto.label.ref=未定義的 goto 標籤 '#ref'
inspection.message.unused.private.property.ref=未使用的 private 屬性 '#ref'
intention.name.add.method.stubs=添加方法存根
inspection.message.from.php.this.allowed={0}。從 PHP {1} 起才允許這樣。
intention.name.make.abstract=將{0}設為 abstract
inspection.message.expression.without.parentheses=表達式沒有括號
add.clarifying.parentheses=添加澄清括號
replace.all.occurrences.with.php=將所有符合項取代為 '<?php'
inspection.message.parentheses.are.unnecessary=圓括號不必要
remove.unnecessary.parentheses=移除不必要的圓括號
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允許在迴圈或 switch 語句中使用 'goto' 標籤
dialog.title.configure.code.patterns=設定程式碼模式…
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 註釋
intention.family.name.copy.phpdoc.from.parent=從父項複製 PHPDoc
inspection.message.constant.reassignment=常數重新賦值
merge.with.0.branch=與 ''{0}'' 分支合併
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非複合名稱 '#ref' 的 'use' 語句沒有任何作用
insert.default.branch=插入 'default' 分支
inspection.message.tostring.method.must.return.string='__toString' 方法必須返回字串
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12: 複合命名空間的深度超過兩級
psr.12.extract.namespace=PSR-12: 提取命名空間
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12: 應當使用類型關鍵字的縮寫
psr.12.convert.to.short.form=PSR-12: 轉換為縮寫
inspection.message.psr.missing.visibility.definition=PSR-12: 缺少可見性定義
psr.12.add.public.visibility=PSR-12: 添加 'public' 可見性
inspection.message.psr.order.modifiers.incorrect=PSR-12: 修飾符的順序不正確
psr.12.fix.modifiers.order=PSR-12: 修復修飾符順序
inspection.message.psr.missing.parameter.list=PSR-12: 缺少參數列表
psr.12.add.missing.parameter.list=PSR-12: 添加缺少的參數列表
inspection.message.psr.usage.else.if.construct=PSR-12: 使用 'else if' 結構
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12: 必須以每行一個的形式添加特徵
psr.12.split.to.several.use.statements=PSR-12: 拆分為多個 'use' 語句
inspection.message.psr.usage.var=PSR-12: 'var' 的用法
psr.12.replace.var.with.public=PSR-12: 將 'var' 取代為 'public'
change.method.modifiers.to.0=將方法修飾符更改為 ''{0}''
intention.family.name.remove=移除 {0}
create.new.class.quickfix=創建新類
add.class1=添加類
intention.name.suppress.for.statement=對語句禁止
intention.name.change.cast.to=將 {0} 轉換更改為 {1}
intention.name.cast.to=將 {0} 轉換為 {1}
add.fluent.setter=添加 fluent setter
intention.family.name.add.getter.setter=添加 getter 和 setter
intention.family.name.add.getter=添加 getter
intention.family.name.add.number.separators=添加數字分隔符
convert.the.arrow.function.to.a.traditional.closure=將箭頭函數轉換為傳統閉包
intention.name.extract.if=提取 if ({0})
intention.family.name.initialize.properties=初始化屬性
merge.into.elseif=合併到 'elseif' 中
intention.family.name.replace.switch.with.if=將 'switch' 取代為 'if'
make.01=設為 ''{0}''
group.use.statements.by.selected.prefix=按所選前綴將 'use' 語句分組
intention.family.name.convert.heredoc.nowdoc.to.string.literal=將 HEREDOC/NOWDOC 轉換為字串文字
intention.family.name.convert.heredoc.to.string.literal=將 HEREDOC 轉換為字串文字
intention.family.name.convert.nowdoc.to.string.literal=將 NOWDOC 轉換為字串文字
convert.concatenation.to.sprintf.call=將串聯轉換為 'sprintf' 調用
convert.string.interpolation.to.concatenation=將字串插值轉換為串聯
convert.string.interpolation.to.sprintf.call=將字串插值轉換為 'sprintf' 調用
intention.name.convert.sprintf.call.to.concatenation=將 'sprintf' 調用轉換為串聯
copy.concatenated.string.to.clipboard=將串聯的字串複製到剪貼簿
extract.selected.string.part.as.concatenation.operand=將所選字串部分作為串聯操作數提取
extract.selected.string.part.as.format.function.argument=將所選字串部分作為格式函數實參提取
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 環繞
command.name.new.file=新建檔案
dialog.title.inline.variable=內聯變數
property.declaration=屬性宣告
class.constructor=類構造函數
label.global.namespace=<全域命名空間>
cannot.use.positional.argument.after.named.argument=無法在命名實參後面使用位置實參
named.parameter.overwrites.previous.argument=命名參數覆寫以前的實參
unknown.named.parameter=未知命名參數 ''{0}''
docker.compose.border.title.lifecycle=生命周期
action.configuration.text=設定…
inspection.message.constructor.cannot.be.static=構造函數不能為 static
inspection.message.destructor.cannot.be.static=析構函數不能為 static
inspection.message.clone.method.cannot.be.static='Clone' 方法不能為 static
inspection.message.cannot.make.non.abstract.method.abstract=無法將非 abstract 方法設為 abstract
inspection.message.cannot.override.final.method=無法覆寫 final 方法
inspection.message.cannot.make.method.visibility.lower.than.super.s=無法將方法的可見性設為低於父級的可見性
parsing.error.not.allowed=不允許使用 ''{0}''
parsing.error.unexpected.token=意外的標記: {0}
parsing.error.expression.not.assignable=表達式不可賦值
live.template.name.comment=註釋
php.remote.debug.name=PHP 遠端偵錯
php.web.application.name=PHP Web 套用程序
live.template.name.statement=語句
live.template.name.string.literal=字串文字
live.template.name.expression=表達式
cli.interpreters.name=CLI 解釋器
code.style.option.group.use=將 'use' 分組
code.style.option.attributes=特性
code.style.option.parameter.attributes=參數特性
code.style.option.in.namespace=在命名空間中
code.style.option.php.opening.tag=PHP 起始標記
code.style.option.new.line.after.php.tag=在 '<?php' 標記後換行
code.style.option.align.inline.comments=對齊內聯註釋
code.style.option.function.return.type=函數返回類型
code.style.option.return.type.on.new.line=返回類型位於新行上
code.style.option.align.key.value.pairs=對齊鍵值對
code.style.option.match.expression='match' 表達式
code.style.option.match.expression.align.match.arm.bodies=對齊 'match' arm 主體
code.style.option.place.on.new.line=將 ';' 置於新行
code.style.option.class.field.constant.groups=類屬性/常數組
code.style.option.align.properties.in.columns=對齊列中屬性
code.style.option.align.constants=對齊常數
code.style.option.align.consecutive.assignments=對齊連續賦值
code.style.option.keep.and.on.one.line=將 ')' 和 '{' 保持在同一行
code.style.option.for.foreach.statements=for()/foreach() 語句
code.style.option.place.for.constructor=放置構造函數的 '()'
code.style.option.in.anonymous.class.declaration=在匿名類宣告中
code.style.option.function.constructor.call.arguments=函數/構造函數調用實參
code.style.option.function.declaration.parameters=函數宣告參數
code.style.option.in.closure.declaration=在閉包宣告中
code.style.option.in.function.declaration=在函數宣告中
code.style.option.place.on.new.line2=在最後一個元素後換行
code.style.option.new.line.after=在第一個元素後換行
code.style.option.after='{' 之後:
code.style.option.before.return.statement=在 'return' 語句前:
code.style.option.after.function=函數之後:
code.style.option.after.opening.tag=起始標記之後:
code.style.option.between.group.use.statements=在 'Use' 語句組之間:
code.style.option.around.class.constants=環繞類常數:
code.style.option.after.class.body=類主體之後:
code.style.option.before.class.body=類主體之前:
code.style.option.after.use.statements=在 'Use' 語句後:
code.style.option.before.use.statements=在 'Use' 語句前:
code.style.option.after.namespace=命名空間之後:
code.style.option.before.namespace=命名空間之前:
code.style.option.around.property=環繞屬性:
code.style.option.multiplicative.operators=乘法運算符(*, /, %, **)
code.style.option.arrow.function.parentheses=箭頭函數括號
code.style.option.anonymous.function.parentheses=匿名函數括號
code.style.option.shift.operators=移位運算符(<<,>>)
code.style.option.and=<?= 和 ?>
code.style.option.brackets.around.variable.expression=使用中括號將變數/表達式括起來
code.style.option.between.and='?' 與 ':' 之間
code.style.option.unary.additive.operators=一元加法運算符(+,-,++,--)
code.style.option.after.unary.not=一元非(!)之後
code.style.option.before.unary.not=一元非(!)之前
code.style.option.array.initializer.parentheses=陣列初始設定式圓括號
code.style.option.function.left.brace=函數左大括號
code.style.option.function.declaration.parentheses=函數宣告括號
code.style.option.function.call.parentheses=函數調用括號
code.style.option.after.colon.in.return.type=返回類型中的冒號之後
code.style.option.space.around.pipe.in.union.types=聯合類型的 | 周圍
code.style.option.before.colon.in.return.type=返回類型中的冒號之前
code.style.option.before.colon.in.named.argument=命名實參中的冒號之前
code.style.option.after.colon.in.named.argument=命名實參中的冒號之後
code.style.option.before.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號前面
code.style.option.after.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號後面
code.style.option.assignment.in.declare.statement=在 declare 語句中賦值
code.style.option.null.coalescing.operator=null 合併運算符(??)
code.style.option.object.access.operator=物件存取運算符(->)
code.style.option.concatenation=串聯(.)
code.style.option.relational.operators=關係運算符(<, >, <=, >=, <=>)
code.style.option.place.braces.for.constructor.as.is=保留原樣
code.style.option.place.braces.for.constructor.always=始終
code.style.option.place.braces.for.constructor.never=從不
link.label.languages.frameworks.php=PHP
inspection.message.cannot.make.static.method.non.static=無法將 static 方法 {0} 設為非 static
inspection.message.cannot.make.non.static.method.static=無法將非 static 方法 {0} 設為 static
dialog.title.select.properties.to.initialize=選擇要初始化的屬性
split.selected.group.use.statement=拆分所選 'use' 語句組
intention.family.name.convert.string.literal.to.heredoc.nowdoc=將字串文字轉換為 HEREDOC/NOWDOC
intention.name.convert.string.literal.to.heredoc=將字串文字轉換為 HEREDOC
intention.name.convert.string.literal.to.nowdoc=將字串文字轉換為 NOWDOC
intention.name.convert.concatenation.to.string.interpolation=將串聯轉換為字串插值
intention.name.convert.concatenation.to.scalar.value=將串聯轉換為標量值
intention.name.convert.sprintf.call.to.string.interpolation=將 'sprintf' 調用轉換為字串插值
intention.name.convert.sprintf.call.to.scalar.value=將 'sprintf' 調用轉換為標量值
parsing.error,at.expected=應為 '@'
parsing.error.method.label.expected=應為方法標籤
live.template.class.member=類成員
live.template.interface.member=接口成員
live.template.trait.member=特徵成員
dialog.error.title.php.extract.class=PHP 提取類
quality.tools.label.by.default.project.interpreter=預設為專案解釋器
file.0.does.not.exist=檔案 {0} 不存在
languages.frameworks.php.php.runtime=PHP / PHP 執行時
do.not.ask.again=不再詢問
enable.support=啟用支援
validating1=正在驗證…
cache.creating=正在創建 psalm 快取…
can.not.parse.phpunit.version.output.0=無法解析 PHPUnit 版本輸出: {0}
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 設定廣播已啟動
directories=目錄
can.not.run.command.composer.execution.plugin.was.unloaded=無法執行指令: Composer 執行延伸模組已移除
can.not.find.specified.interpreter=找不到指定的解釋器
no.response.from.0.after.1.ms={1} ms 後 {0} 未響應
cannot.register.handler=無法註冊處理程序
handler.with.the.same.session.id.is.already.registered=已註冊使用相同會話 ID 的處理程序
unknown.debugger.type=未知偵錯器類型
functions.to.be.extracted=要提取的函數
failed.to.parse.php.ini.output.0=無法解析 php --ini 輸出: {0}
can.not.find.0.helper.script=找不到 ''{0}'' 幫助程序腳本
can.not.execute.tests=無法執行測試
failed.to.run.interpreter=無法執行解釋器
failed.to.find.interpreter=無法尋找解釋器
set=設定
proxy.init=代理初始化
register.ide=註冊 IDE
0.for.1.run.configuration={1} 執行設定的 {0}
project.is.already.disposed=專案已處置
can.not.execute.transfer.task.project.is.already.disposed=無法執行傳輸任務: 專案已處置
proxy.stop=代理停止
cancel.ide.registration=取消 IDE 註冊
getting.installed.standards=正在獲取已安裝的標準…
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 延伸模組未安裝
execution.result.is.null=執行結果為 null
can.not.delete.temporary.file.because.it.was.not.created=無法刪除臨時檔案，因為未創建該檔案
0.inspection={0} 檢查
failed.to.find.valid.interpreter.path=無法尋找有效的解釋器路徑
with.data.set.0=使用資料集 {1} 的 {0}
add.phpunit.test.pattern=添加 PHPUnit 測試模式
unused.code.rules=未使用的程式碼規則
naming.rules=命名規則
design.rules=設計規則
controversial.rules=有爭議的規則
code.size.rules=程式碼大小規則
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=無法執行遠端解釋器。啟用 PHP Remote Interpreter 延伸模組。
create.target.class.quick.fix=創建目標類快速修復
create.missing.target.method.fix=創建缺少的目標方法修復
php.extract.class=PHP 提取類
local=本地
project.files=專案檔案
include.path=include 路徑
inspection.message.parameter.name.changed.from.to=參數名稱由 ''{0}'' 更改為 ''{1}''
intention.family.name.rename.parameter.to.match.super=重命名參數以符合父級
intention.name.rename.to=重命名為 ''{0}''
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名實參
tooltip.update=更新 {0}
inspection.message.constant.ref.not.found=未找到常數 '#ref'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目標類。
hint.text.target.class.not.writable=目標類 {0} 不可寫。
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目標類 {0} 不屬於該專案\n\
並且無法修改。
inspection.message.cannot.make.non.abstract.method.abstract.1=無法將非 abstract 方法 {0} 設為 abstract
inspection.message.cannot.override.final.method.1=無法覆寫 final 方法 {0}
inspection.message.return.type.declaration.must.be.compatible.with=返回類型宣告必須與 {0} 相容: {1}
inspection.message.cannot.make.method=無法將 {0} 方法設為 {1} {2}
inspection.message.declaration.should.be.compatible.with=宣告應該與 {0} 相容
inspection.message.declaration.should.be.compatible.with.super=宣告應與父級相容
command.name.make.method.static=將方法設為 static
show.constants=顯示常數
show.properties=顯示屬性
show.includes=顯示 include
show.private.members=顯示 private 成員
show.protected.members=顯示 protected 成員
undefined.interpreter=未定義的解釋器
column.name.annotation.name=註解名稱
inspection.message.exception.never.thrown.in.corresponding.try.block=相應的 ''try'' 塊中從未拋出異常 ''{0}''
dialog.title.edit.phpunit.test.pattern=編輯 PHPUnit 測試模式
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正確
notification.title.cannot.read.snapshot=無法讀取快照
label.lt.no.server=<no server>
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中未找到可執行檔案 ''{0}''。請確保已指定該檔案。可能的解決方案:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，請重啟 IDE。
provide.the.full.path.to.executable=提供可執行檔案的完整路徑。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中未找到可執行檔案 ''{0}''。請確保已指定該檔案。可能的解決方案:
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，請重啟 IDE。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
label.authentication.data.not.specified=未指定身份驗證資料
configured.is.incorrect=設定的 {0} 不正確
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=驗證腳本已創建，但無法執行。可能的原因:
validated.web.server.is.not.running=驗證的 Web 伺服器未執行。
target.directory.for.validation.script.is.not.public=驗證腳本的目標目錄不是 public。
url.to.validation.script='驗證腳本的 URL'
follow.this.links.to.install.and.configure.0.or.1=點擊這些鏈接以安裝並設定 {0} 或 {1}。
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 檔案中設定偵錯擴展，請檢查未載入該擴展的可能原因:
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 檔案中進行更改後，未重新載入 Web 伺服器。
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在錯誤的 php.ini 中設定偵錯擴展(請參見下方已載入的 php.ini 檔案)。
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=嘗試載入偵錯擴展時出錯，例如版本不相容。
intention.name.change.signature=更改 {0}({1}) 的簽名
dialog.title.enter.tag.name=輸入標記名稱
method1=方法
open.inspection.settings=開啟 {0} 檢查設定
popup.content.enabled.disabled.extensions=已啟用{0}和已禁用{1}擴展
popup.content.configuration.remains.unchanged=當前設定與解釋器同步
unhandled.0=未處理的{0}
unhandled.exceptions=未處理的異常
label.docker.container=Docker 容器:
dialog.message.docker.account.not.specified=未指定 Docker 帳戶
dialog.message.docker.account.not.found=找不到 Docker 帳戶
dialog.message.could.not.find.network.interface=找不到 {0} 網絡接口
dialog.message.no.interface.addresses.for.network.interface=沒有 {0} 網絡接口的接口地址
validation.script.will.be.created.in.0.directory=驗證腳本將在 {0} 目錄中創建。
files.in.the.directory.should.be.accessible.by.0.request=目錄中的檔案應當可通過 {0} 請求進行存取。
caused.by.0=原因是:“{0}”
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=驗證腳本將在 {0} 目錄中創建並部署到 {1} 伺服器。
files.in.the.remote.directory.should.be.accessible.by.0.request=遠端目錄中的檔案應當可通過 {0} 請求進行存取。
follow.this.0.for.more.information.about.path.mappings=有關路徑映射的詳細資訊，請參閱{0}。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=驗證腳本將在本地創建，其結果將通過 http 請求提取。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=驗證腳本將在本地創建並部署到遠端伺服器。
the.result.of.validation.will.be.fetched.by.http.request=驗證結果將通過 http 請求提取。
follow.this.0.for.more.information.about.deployment=有關部署的詳細資訊，請參閱此{0}。
link=鏈接
no.type=NO_TYPE
in=位於
action.configure.php.runtime.text=設定 PHP 執行時…
action.configure.project.directories.text=設定專案目錄
inspection.message.interpolated.string.dereferencing.available.in.php.only=從 PHP 8.0 起才允許內插字串解引用
inspection.message.magic.constant.dereferencing.available.in.php.only=從 PHP 8.0 起才允許魔術常數解引用
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=從當前位置開始將名稱關鍵字添加到所有實參
intention.name.add.name.identifier=添加名稱關鍵字 ''{0}''
inspection.message.argument.without.name.identifier=無名稱關鍵字的實參
tooltip.wsl2.mappings=WSL2 映射
name=名稱
file=檔案
tooltip.from=來自{0}:
tooltip.from.volumes=來自{0}卷:
intention.family.name.sort.arguments=對實參排序
open.tool.settings=開啟 {0} 設定
init.cache=初始化快取
or.disable.inspection=或
inspection.message.type.can.be.reduced.to=類型範圍可以限縮為 ''{0}''
an.alias.was.defined.for.method.0.which.exists.in.1=已為 {1} 中的方法 {0}() 定義別名
intention.family.name.append.absolute.trait=追加 ''{0}::''
intention.family.name.remove.argument.name=移除實參名稱
intention.name.remove.argument.names.from.all.arguments.up.to.current=從截止到當前位置的所有實參中移除實參名稱
frameworl.composer.show.quick.actions=顯示具有快速操作的 composer.json 頂部面板
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目錄時通知
cannot.make.interface.method.non.static=無法將接口方法設為非 static
cannot.make.interface.method.static=無法將接口方法設為 static
access.must.be.public=存取必須為 public
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 規則解析為包含類 ''{0}'' 中的方法
intention.name.move.trait.use.rule.to.use.list=將特徵 ''use'' 規則移動到 ''{0}'' ''use'' 列表
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=將特徵 'use' 規則移動到解析的類 'use' 列表
required.trait.0.wasn.t.added.to.1=所需特徵 ''{0}'' 未添加到 ''{1}''
intention.family.name.add.trait.to.use.list=將特徵添加到 use 列表
intention.name.add.trait.to.use.list=將特徵 ''{0}'' 添加到 use 列表
intention.family.name.add.break.as.last.statement=將 'break' 作為最後一條語句添加
inspection.message.class.does.not.have.attribute=類 ''{0}'' 未使用 ''Attribute'' 註解
intention.family.name.add.attribute.attribute=使用 'Attribute' 註解
constant.expression.contains.invalid.operations=常數表達式包含無效運算
attribute.must.be.first.child.of.parent.element=特性必須是父元素的第一個子項
intention.family.name.move.attribute.to.start.element=將特性移動到元素開頭
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.duplicate.condition=移除重複條件
quickfix.remove.unused.condition=移除未使用的條件
inspection.duplicate.match.condition.message=重複條件
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能應用於 {0}，因為它不包含 ''{1}'' 標誌
inspection.message.attribute.is.not.repeatable=特性不可重複，因為它不包含 'Attribute::IS_REPEATABLE' 標誌
class2=類
class.constant1=類常數
property=屬性
parameter1=參數
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=從 PHP 8.0 起註釋被解析為特性
intention.family.name.insert.space.after=在 '#' 後面插入一個空格
inspection.message.condition.is.never.matched=條件從未符合
inspection.message.branch.is.unused=從不執行 'switch' 分支
inspection.php.arithmetic.type.check=算術運算中的 PHP 8 TypeError
introduce.variable.fix=引入變數
hint.text.use.statement.choice.s.removed={0} ''use'' 語句{1, choice, 0#|1#}已移除
hint.text.use.statements.checked.nothing.was.removed=已檢查 {0} ''use'' 語句，未移除任何內容
no.name=無名稱
debugger.method=方法
inspection.message.named.argument.usage=命名實參用法
percentage.lines={0}% 行
column.name.parameter=參數
column.name.file.directory=檔案/目錄
unknown=未知
intention.family.name.replace.with.get.class.call=取代為 'get_class' 調用
intention.family.name.replace.with.class.name.literal=取代為 '::class'
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class' 調用可以取代為 '::class'
intention.family.name.remove.parenthesis=移除圓括號
inspection.message.redundant.parenthesis=冗餘圓括號
intention.family.name.simplify.expression=簡化表達式
intention.family.name.replace.match.with.ternary=取代為三元表達式
attribute.can.be.added.to.overridden.method=可以將特性添加到覆寫方法
attribute.can.be.added.to.overridden.parameter=可以將特性添加到覆寫參數
intention.family.name.add.attribute.to.overridden.method=將特性添加到覆寫方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=將特性添加到抽象方法的覆寫方法
intention.family.name.add.attribute.to.overridden.parameter=將特性添加到覆寫參數
inspection.message.match.can.be.replaced.with.ternary='match' 表達式可以取代為三元表達式
intention.family.name.replace.with.traditional.property.declaration=取代為傳統屬性宣告
cannot.declare.promoted.property.outside.a.constructor=無法在構造函數外部宣告提升的屬性
only.visibility.modifiers.can.be.applied.to.promoted.property=只能將可見性修飾符套用到提升的屬性
intention.family.name.replace.with.public=取代為 'public'
cannot.declare.variadic.promoted.property=無法宣告可變提升屬性
cannot.declare.promoted.property.in.an.abstract.constructor=無法在 abstract 構造函數中宣告提升的屬性
inspection.message.promoted.field.usage=提升的屬性用法
inspection.message.redundant.assignment=冗餘的提升屬性賦值
remove.assignment=移除賦值
inspection.message.switch.can.be.replaced.with.match='switch' 語句無法轉換為 'match' 表達式
intention.family.name.replace.switch.with.match.expression=將 'switch' 取代為 'match' 表達式
intention.family.name.split.into.multiple.catch.statements=拆分為多個 'catch' 語句
exception.class=異常類
variable1=變數
identifier=關鍵字
field.name=欄位名稱
object.property=物件屬性
class.reference=類引用
array.index=陣列索引
line.separator=行分隔符
initializer=初始設定式
label1=標籤
expression1=表達式
type=類型
static.value=static 值
property.or.function=屬性或函數
default.value=預設值
extends=擴展
interface.name=接口名稱
extends.or.implements=擴展或實作
class.name=類名
modifier=修飾符
return.type=返回類型
inspection.message.duplicates.catch.statement=重複 ''{0}'' 語句
intention.name.merge.with=與 ''{0}'' 合併
intention.family.name.merge.with.duplicated.catch.statement=與重複的 'catch' 語句合併
intention.name.merge.with.match.arm=與 ''{0}'' arm 合併
intention.family.name.merge.with.duplicated.match.arm=與重複的 'match' arm 合併
intention.family.name.add.default.match.arm=添加 'default' 'match' arm
intention.family.name.add.attribute=添加 ''#[{0}]''
inspection.message.exitpoint.attribute.can.be.added=可以添加 #[NoReturn] 特性
intention.family.name.convert.to.promoted.field=轉換為提升的屬性
intention.family.name.convert.to.promoted.field.remove.doc.comment=轉換為提升的屬性並移除屬性 PHPDoc 註釋
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升屬性
cannot.use.unpacking.in.attribute.argument.list=無法在特性實參列表中使用解包
spread.operator.on.named.arguments.is.forbidden=禁止對命名實參使用展開運算符
inspection.message.should.be.one=值應為以下選項之一: {0}
0.by.remote.interpreter=通過遠端解釋器{0}
0.local={0}本地
inspection.message.double.quotes.are.unnecessary=雙引號不必要
inspection.php.unnecessary.double.quotes.display.name=不必要的雙引號
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 語句中有不必要的前導 '\'
replace.unnecessary.double.quotes=取代不必要的雙引號
quality.tool.can.not.create.temporary.file=PhpStorm 無法創建臨時檔案
dialog.message.cannot.create.file.because.project.already.disposed=由於專案已處置，無法創建檔案
dead.code.commented.out=註釋掉
dead.code.deleted=已刪除
intention.family.name.add.arrayshape.attribute=添加 '#[ArrayShape]' 特性
inspection.message.arrayshape.can.be.added=可以添加 '#[ArrayShape]'
inspection.option.label.php8.severity=PHP 8 嚴重性:
inspection.message.pure.can.be.added=可以添加 '#[Pure]'
intention.name.add.to.parameter=將 ''\\&'' 添加到參數 ''{0}''
intention.family.name.add.to.parameter=將 '\\&' 添加到參數
inspection.message.array.write.access.unused=未使用陣列寫入存取
intention.family.name.remove.pure=移除 '#[Pure]'
inspection.message.function.may.produce.side.effects=函數可能會產生副作用
inspection.message.method.may.produce.side.effects=方法可能會產生副作用
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=無效的不可變屬性寫入: 作用域 ''{0}'' 不允許在此處進行寫入存取
php.console=PHP 主控台
inspection.message.illegal.array.offset.access=嘗試存取類型為 ''{0}'' 的值的陣列偏移
attributes.are.inapplicable.for.constants=特性不適用於常數
intention.family.name.replace.with.define.call=取代為 'define' 調用
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不會修剪常數 FQN 中的前導斜杠
intention.family.name.remove.leading=移除前導 '\'
intention.family.name.replace.with.const.syntax=取代為 'const' 語法
inspection.message.can.be.replaced.with.const.syntax=可以取代為 'const' 語法
intention.family.name.force.fqcn.for.references.in.phpdoc=對 PHPDoc 中的引用強制 FQCN
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常數只能計算為標量值、陣列或資源
intention.family.name.merge.with.following.attribute.list=將特性列表與以下內容合併
intention.family.name.extract.attribute.into.separate.list=將特性提取到單獨的列表
intention.family.name.flip.attributes.lists=翻轉特性列表
inspection.message.too.many.messages.per.line=每行的訊息過多
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每個檔案中的訊息過多。僅顯示前 {0} 條。
can.not.correctly.run.the.tool.with.parameters=無法使用參數正確執行該工具:
possible.tool.process.hangup.after.0.sec={0} 秒後可能工具過程掛起。
inspection.message.write.access.to.variable.that.still.references.array.value=對仍引用 'foreach' 中先前所用陣列值的變數的寫入權限
if.with.common.parts=具有通用部分的 'if'
switch.with.common.parts=包含通用部分的 'switch'
intention.family.name.insert.unset.before=在前面插入 ''unset(${0});''
intention.family.name.collapse.if.statement=折疊 ''{0}'' 語句
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，並移除分支
intention.family.name.extract.common.parts=提取通用部分
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 語句
intention.name.replace.with=將 ''{0}'' 取代為 ''{1}''
inspection.message.property.only.written.but.never.read=屬性僅寫入，但從未讀取
inspection.message.property.only.read.but.never.written=屬性只讀取，但從未寫入
intention.family.name.delete.field=刪除屬性
intention.family.name.replace.with.class.constant=取代為類常數
invalid.condition.to.body.separator.should.be.used=條件與主體之間的分隔符無效: 應改用 '=>'
intention.family.name.invert.if.statement=反轉 'if' 語句
intention.family.name.unwrap.else=解開 'else'
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.array.always.empty.at.this.point=陣列在此點始終為空
intention.family.name.can.be.merged.with.sequential=''if'' 可以與後續 ''{0}'' 合併
intention.family.name.merge.with.sequential=與後續 ''{0}'' 合併
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同時包含 ''.'' 和 ''{0}'' 的無括號表達式可能會產生意外結果
intention.name.wrap.left.operand.in.parentheses=在圓括號中包裝左操作數
intention.name.wrap.right.operand.in.parentheses=在圓括號中包裝右操作數
parameter.type.is.not.convertible.from.null=參數類型不可從 'null' 轉換
inspection.message.value.parameter.always=參數值始終為 ''{0}''
intention.family.inline.value.for.parameter=內聯參數值
intention.name.inline.value=內聯值 ''{0}''
inspection.message.can.be.replaced.with.version=表達式可以取代為 '??' 版本
inspection.message.if.can.be.replaced.with.version='if' 可以取代為 '??' 版本
intention.family.name.replace.with.version=取代為 '??' 版本
intention.family.name.replace.with.ternary.expression=取代為三元表達式
popup.title.multiple.write.scopes.found=找到多個寫入範圍
closest.scope=最近範圍中的變數
all.values=所有變數
checkbox.rename.only.nearest.scope=僅重命名最近範圍中的變數
intention.family.name.make.method.void=將方法設為 'void'
inspection.message.return.value.method.never.used=方法的返回值從未使用
inspection.message.unnecessary.leading.slash=不必要的前導 '\'
inspection.message.cast.redundant=類型轉換冗餘
inspection.message.unnecessary.curly.braces=不必要的大括號
intention.family.name.unwrap.curly.braces=解開大括號
command.name.disable.synchronisation.with.composer=禁用與 composer.json 同步
navigate.to.composer.json=導航到 composer.json
notification.content.language.level.synchronisation.with.composer.was.disabled=已禁用與 composer.json 的語言級同步
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可以取代為直接參數存取
intention.family.name.replace.with.parameter.access=取代為參數存取
intention.family.name.unwrap.function.call=解開函數調用
inspection.message.with.single.string.argument=帶單個字串實參的 ''{0}''
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 迴圈可以取代為 'str_repeat'
intention.family.name.replace.with.str.repeat.call=取代為 'str_repeat' 調用
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 迴圈可以取代為 'implode'
intention.family.name.replace.with.implode.call=取代為 'implode' 調用
intention.family.name.unwrap.cast=解開轉換
inspection.message.unnecessary.cast.to.string=不必要地轉換為 ''{0}''
intention.family.name.merge.with.assignment=與賦值合併
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串聯可以與空字串文字賦值合併
inspection.message.operands.have.incompatible.types=操作數具有不相容的類型
short.arrow.function.cannot.return.void=箭頭函數不能有 'void' 返回類型
delete.void.return.type=刪除 'void' 返回類型
array.callback.must.have.exactly.two.elements=陣列回調必須正好有兩個元素
intention.family.name.split.into.separate.case.statements=拆分為獨立的 'case' 語句
invalid.syntax.for.multiple.case.expressions=多個 'case' 表達式的語法無效
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在賦值中不能混合鍵控和非鍵控陣列條目
cannot.use.empty.array.entries.in.keyed.array.assignment=在鍵控陣列賦值中不能使用空陣列條目
cannot.use.empty.list=無法使用空列表
unsupported.declare.0=不支持的宣告 ''{0}''
inspection.message.continue.targeting.switch.equivalent.to.break=針對 'switch' 的 'continue' 相當於 'break'
inspection.message.redundant.expression=冗餘表達式
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 宣告的值必須為 0 或 1
private.methods.cannot.be.final=private 方法不能是 final，因為它們從不會被其他類覆寫
cannot.use.yield.from.inside.a.by.reference.generator=不能在引用傳遞生成器中使用 'yield from'
intention.family.name.replace.with.check=取代為 '!==' 檢查
dialog.title.select.methods.to.propagate.safe.delete=選擇要傳播安全刪除的方法
dialog.title.select.parameters.to.propagate.safe.delete=選擇要傳播安全刪除的參數
referenced.calls=引用的調用
cannot.mix.and.list=不能混合 [] 與 list()
intention.family.name.replace.with.array=取代為數組
intention.family.name.replace.with.list=取代為 'list'
inspection.message.can.be.replaced.with=可以取代為 ''{0}''
intention.family.name.remove.unused.postfix.operation=移除未使用的後綴運算
inspection.message.results.postfix.expression.unused=未使用後綴表達式的結果
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 標記添加 PHPDoc 註釋
replace.variable.assignment.with.named.argument=將變數賦值取代為命名實參
action.run.composer.install.text=執行 'composer install'
notification.content.vendor.directory.not.found=未找到 'vendor' 目錄
intention.family.name.move.from.to.composer.json.section=將 ''{0}'' 從 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.flip=翻轉 '?:'
inspection.message.can.be.removed=可以移除 ''{0}''
intention.family.name.remove.unused.property=移除未使用的屬性
intention.family.name.simplify.ternary.expression=簡化 '?:'
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不應分配給 ''{1}''
extract.method.selector.title=要提取的程式碼
intention.family.name.replace.with.operator=取代為 '?->' 運算符
inspection.message.can.be.replaced.with.operator=可以取代為 '?->' 運算符
add.throw.before.exception=在表達式前面添加 'throw'
intention.family.name.replace.with.dirname.call=取代為 'dirname' 調用
inspection.php.redundant.method.override=冗餘方法覆寫
inspection.php.loop.can.be.replaced.with.implode=迴圈可以取代為 'implode'
inspection.message.redundant.method.override=方法覆寫冗餘
delete.redundant.method.override=移除方法
intention.family.name.replace.if.with.version=將 'if' 取代為 '??' 版本
anonymous.class=匿名類
anonymous.0=匿名{0}
lambda=Lambda
checkbox.anonymous.classes=匿名類
checkbox.lambdas=Lambda
inspection.message.trait.usage=不允許特徵用法
inspection.message.will.be.covered.by=非必要條件，因為它由 ''{0}'' 檢查
inspection.message.can.be.replaced.with.fail=可以取代為 ''{0}''
intention.name.replace.coalesce.expression.with.operand=將合併表達式取代為操作數
intention.name.replace.coalesce.expression.with=將合併表達式取代為 ''{0}''
label.align.named.arguments=對齊命名實參
delete.catch.statement=刪除 'catch' 語句
inspection.message.exception.immediately.rethrown=立即重新拋出異常
inspection.message.dangerous.array.initialization=危險的陣列初始化
replace.with.array=取代為直接賦值 '$array = array($value)'
replace.with.array.short.syntax=取代為直接賦值 '$array = [$value]'
intention.family.name.replace.with.comparison=取代為比較
quickfix.undefined.function.add.function=添加函數
enum.may.not.include.0=枚舉不得包含 ''{0}''
enum.may.not.include.extend=枚舉不得擴展其他類
enums.may.not.include.properties=枚舉不得包含屬性
enums.may.not.be.cloned=不得克隆枚舉
intention.family.name.make.containing.class.enum=將包含類設為枚舉
enum.properties.are.immutable=枚舉屬性不可變
enum.backing.type.must.be.int.or.string=枚舉支援類型必須為 'int' 或 'string'
enum.case.type.0.does.not.match.enum.backing.type.1=枚舉 case 類型 ''{0}'' 與枚舉支援類型 ''{1}'' 不符合
all.cases.of.backed.enum.must.have.a.value=備用枚舉的所有 case 必須包含值
case.of.non.backed.enum.must.not.have.a.value=非備用枚舉的 case 不得包含值
intention.family.name.delete.initializer=刪除初始設定式
intention.family.name.add.to.containing.enum=將 '' : {0}'' 添加到包含枚舉
intention.family.name.remove.backed.type.from.containing.enum=從包含枚舉中移除備用類型
enum.case.should.be.located.only.inside.enum.classes=枚舉 case 只應位於枚舉類內部
enum.case.value.must.be.constant=枚舉 case 值必須為常數
enum.backing.type.must.be.int.or.string.0.given=在給出 ''{0}'' 的情況下，枚舉支援類型必須為 ''int'' 或 ''string''
enums.may.not.implement.the.serializable.interface=枚舉可能不會實作 'Serializable' 接口
cannot.redeclare.methods.from.enum.implicit.interfaces=無法從枚舉隱式接口重新宣告方法
cannot.implement.interface.0=無法實作接口 ''{0}''
cannot.implement.interface.0.directly=無法直接實作接口 ''{0}''
non.enum.class.cannot.implement.interface=非枚舉類無法實作接口 ''{0}''
non.backed.enum.cannot.implement.interface.backedenum=非備用枚舉無法實作接口 'BackedEnum'
intention.family.name.count.comments.as.content=將註釋計為內容
inspection.message.constant.from.base.class.referenced.via.child.class=通過子類引用的基類 ''{0}'' 中的常數
intention.family.name.replace.with.class.reference.with.base.class=取代為對基類的類引用
intention.replace.with.method.call=取代為對現有方法的調用
inspection.php.uncovered.enum.cases=某些 'enum' case 未被覆蓋
inspection.message.uncovered.enum.cases='match' 表達式具有未被覆蓋的 'enum' case
inspection.message.uncovered.enum.cases.switch='switch' 語句有未被覆蓋的枚舉 case
intention.family.name.add.remaining.enum.cases=添加其餘 'enum' case
intention.family.name.split.into.two.separate.match.arms=將條件提取到單獨的 'match' arm
multiple.enum.identifiers.should.be.stated.in.different.cases=多個枚舉關鍵字應在不同的 case 中宣告
intention.family.name.split.into.multiple.enum.cases=拆分為多個枚舉 case
inspection.message.not.valid.backing.value.for.enum={0} 不是枚舉的有效支援值
intention.name.add.enum.case.with.value=添加具有 ''{0}'' 值的枚舉 case
intention.family.name.replace.with.concatenation=取代為串聯
intention.family.name.remove.empty.index.operator=移除 '[]' 運算符
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成員
inspection.php.enforce.doc.comment.inspection.display.name=強制執行 PHPDoc 註釋
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉類型和可 null 類型表示法不能混用
cannot.mix.amp.and.pipe.in.type.declaration=類型宣告中不能混用 '\\&' 和 '|'
PhpLanguageFeature.final.class.constants=自 PHP 8.1 起只允許使用 'final' 類常數
PhpLanguageFeature.intersection.types=從 PHP 8.1 起才允許交叉類型
PhpLanguageFeature.explicit.octal.literal=自 PHP 8.1 起只允許顯式八進制文字
cannot.use.readonly.as.identifier=無法將 'readonly' 用作關鍵字。自 PHP 8.1 起作為預留關鍵字
PhpLanguageFeature.readonly.properties=從 PHP 8.1 起才允許使用 'readonly' 屬性
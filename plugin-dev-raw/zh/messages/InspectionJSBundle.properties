add.require.amd.module.fix=新增 {0} 模組相依項
add.require.amd.module.group.name=Node.js
add.return.statement.fix.name=新增 return 語句
anonymous.function.contains.multiple.loops.error.string=#ref 包含 {0} 個迴圈 #loc
anonymous.function.contains.multiple.return.points.error.string=#ref 具有 {0} 個返回點 #loc
anonymous.function.contains.too.many.negation.error.string=#ref 包含 {0} 個否定 #loc
anonymous.function.display.name=匿名函式
anonymous.function.error.string=匿名函式 #loc
anonymous.function.has.inconsistent.return.points.error.string=#ref 的返回點不一致 #loc
anonymous.function.has.too.many.parameters.error.string=#ref 的參數過多 (參數數量 = {0}) #loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=#ref 過於複雜 (迴圈復雜度 = {0}) #loc
anonymous.function.is.overly.long.statement.error.string=#ref 過長 (語句數量 = {0}) #loc
anonymous.function.is.overly.nested.error.string=#ref 過度嵌套 (嵌套深度為 {0}，但允許的最大值為 {1}) #loc
assignment.replaceable.with.operator.assignment.display.name=賦值可被取代為運算符賦值
assignment.replaceable.with.operator.assignment.error.string=#ref 可以簡化為 {0} #loc
assignment.to.for.loop.parameter.display.name=賦值給 'for' 迴圈參數
assignment.to.for.loop.parameter.error.string=賦值給 for 迴圈參數 #ref #loc
assignment.to.function.parameter.display.name=賦值給函式參數
assignment.to.function.parameter.error.string=賦值給函式參數 '#ref' #loc
break.statement.display.name='break' 語句
break.statement.error.string='#ref' 語句 #loc
break.statement.with.label.display.name=帶標籤的 'break' 語句
break.statement.with.label.error.string='#ref' 語句帶有標籤 #loc
call.to.document.write.display.name=呼叫 'document.write()'
caller.display.name=使用 'caller' 屬性
caller.error.string=使用 '#ref' 屬性 #loc
chained.equality.display.name=鏈式相等
chained.equality.error.string=鏈式相等比較 <code>#ref</code> #loc
chained.function.call.display.name=鏈式函式呼叫
chained.function.call.problem.descriptor=鏈式呼叫函式 '#ref' #loc
class.name.doesnt.match.regex.error.string=類別名 ''{0}'' 與正則表達式 ''{1}'' 不符合 #loc
class.name.is.too.long.error.string=類別名 ''{0}'' 過長 #loc
class.name.is.too.short.error.string=類別名 ''{0}'' 過短 #loc
class.naming.convention.display.name=類別命名約定
collapse.conditional.expression.fix=摺疊條件表達式
collapse.if.statement.fix=摺疊 'if' 語句
comma.expression.display.name=逗號表達式
comma.expression.error.string=逗號表達式 #loc
conditional.expression.display.name=條件表達式
conditional.expression.error.string=條件表達式 #loc
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.expression.with.identical.branches.error.string=具有相同分支的條件表達式 <code>#ref</code> #loc
confusing.floating.point.literal.change.quickfix=更改為規範形式
confusing.floating.point.literal.display.name=浮點文字會引起混淆
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點文字 <code>#ref</code> #loc
confusing.pluses.or.minuses.display.name='+' 或 '-' 的序列會引起混淆
confusing.pluses.or.minuses.error.string=如果移除空格，則 '+' 或 '-' 序列的含義可能會改變 #loc
constant.conditional.expression.display.name=常數條件表達式
constant.conditional.expression.error.string=<code>#ref</code> 可以簡化 #loc
constant.on.left.side.of.comparison.display.name=常數位於比較的左側
constant.on.left.side.of.comparison.error.string=#ref: 常數位於比較的左側 #loc
constant.on.right.side.of.comparison.display.name=常數位於比較的右側
constant.on.right.side.of.comparison.error.string=#ref: 常數位於比較的右側 #loc
constructor.name.doesnt.match.regex.error.string=建構函式名稱 ''{0}'' 與正則表達式 ''{1}'' 不符合 #loc
constructor.name.is.too.long.error.string=建構函式名稱 ''{0}'' 過長 #loc
constructor.name.is.too.short.error.string=建構函式名稱 ''{0}'' 過短 #loc
continue.or.break.inside.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
continue.or.break.inside.finally.block.error.string='#ref' 位於 'finally' 塊內 #loc
continue.statement.display.name='continue' 語句
continue.statement.error.string='#ref' 語句 #loc
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
continue.statement.with.label.error.string='#ref' 語句帶有標籤 #loc
debugger.statement.display.name='debugger' 語句
debugger.statement.error.string='#ref' 語句 #loc
default.branch.not.last.case.in.switch.error.string=<code>#ref</code> 分支不是 'switch' 中的最後一個 case #loc
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
divide.by.zero.display.name=除以零
division.by.zero.error.string=除以零 #loc
document.write.error.string=呼叫 '#ref()' #loc
duplicate.case.label.display.name=重複的 'case' 標籤
duplicate.case.label.error.string=重複的 case 標籤 #ref #loc
duplicate.condition.error.string=重複條件 <code>#ref</code> #loc
duplicate.condition.in.if.statement.display.name='if' 語句中的重複條件
dynamically.generated.code.display.name=執行動態生成的程式碼
dynamically.generated.code.error.string=函式 '#ref' 表示動態生成的程式碼 #loc
empty.catch.block.display.name=空 'catch' 塊
empty.catch.block.error.string='#ref' 塊為空 #loc
empty.finally.block.display.name=空 'finally' 塊
empty.finally.block.error.string=空 'finally' 塊 #loc
empty.try.block.display.name=空 'try' 塊
empty.try.block.error.string='#ref' 塊為空 #loc
exception.caught.locally.error.string=本地捕獲異常的 '#ref' #loc
exception.used.for.local.control.flow.display.name=將異常用於本地控制流
expression.statement.is.not.assignment.or.call.error.string=表達式語句不是賦值或呼叫 #loc
expression.statement.which.is.not.assignment.or.call.display.name=非賦值或呼叫的表達式語句
fall.through.in.switch.statement.display.name='switch' 語句中的直落
fall.through.in.switch.statement.error.string='switch' 語句中存在 fallthrough #loc。缺少 'break' 或 'return'
flip.comparison.fix=翻轉比較
for.loop.not.use.loop.variable.display.name='for' 迴圈中的 update 或 condition 未使用迴圈變數
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=<code>#ref</code> 語句中的 condition 和 update 未使用 for 迴圈變數 #loc
for.loop.not.use.loop.variable.problem.descriptor.condition=<code>#ref</code> 語句中的 condition 未使用 for 迴圈變數 #loc
for.loop.not.use.loop.variable.problem.descriptor.update=<code>#ref</code> 語句中的 update 未使用 for 迴圈變數 #loc
for.loop.replaceable.by.while.display.name='for' 迴圈可被取代為 'while' 迴圈
for.loop.replaceable.by.while.ignore.option=忽略無條件迴圈的 'infinite'
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> 迴圈可被取代為 'while' 迴圈 #loc
for.loop.replaceable.by.while.replace.quickfix=取代為 'while'
function.complexity.limit.parameter=函式復雜度限制:
function.contains.multiple.loops.error.string=函式 ''#ref'' 包含 {0} 個迴圈 #loc
function.contains.multiple.return.points.error.string=函式 ''#ref'' 具有 {0} 個返回點 #loc
function.contains.too.many.negation.error.string=函式 ''#ref'' 包含 {0} 個否定 #loc
function.has.inconsistent.return.points.error.string=函式 '#ref' 的返回點不一致 #loc
function.has.too.many.parameters.error.string=函式 ''#ref'' 的參數過多 (參數數量 = {0}) #loc
function.is.overly.long.statement.error.string=函式 ''#ref'' 過長 (語句數量 = {0}) #loc
function.is.overly.nested.error.string=函式 ''#ref'' 過度嵌套 (嵌套深度為 {0}，但允許的最大值為 {1}) #loc
function.name.doesnt.match.regex.error.string=函式名稱 ''{0}'' 與正則表達式 ''{1}'' 不符合 #loc
function.name.is.too.long.error.string=函式名稱 ''{0}'' 過長 #loc
function.name.is.too.short.error.string=函式名稱 ''{0}'' 過短 #loc
function.naming.convention.display.name=函式命名約定
function.parameter.limit=函式參數限制:
function.parameter.naming.convention.display.name=函式參數命名約定
function.ref.is.overly.complex.cyclomatic.complexity.error.string=函式 ''#ref'' 過於複雜 (迴圈復雜度 = {0}) #loc
function.with.inconsistent.returns.display.name=函式的返回不一致
function.with.more.than.three.negations.display.name=函式包含三個以上的否定
function.with.multiple.loops.display.name=函式具有多個迴圈
function.with.multiple.return.points.display.name=函式具有多個返回點
function.with.too.many.parameters.display.name=函式的參數過多
group.path.javascript=JavaScript
if.statement.with.identical.branches.display.name='if' 語句的分支相同
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
if.statement.with.too.many.branches.error.string=''#ref'' 的分支過多 ({0}) #loc
include.anonymous.functions.parameter=包括匿名函式
include.statement.bodies.that.are.empty.code.blocks.parameter=包含空程式碼塊語句正文
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> 始終為 false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> 始終為 true #loc
infinite.loop.error.string=<code>#ref</code> 語句不能在未拋出異常的情況下完成 #loc
infinite.loop.statement.display.name=無限迴圈語句
infinite.recursion.display.name=無限遞迴
infinite.recursion.problem.descriptor=函式 <code>#ref</code> 無限遞迴，只能以拋出異常結束 #loc
inner.html.error.string=使用 '#ref' 屬性 #loc
invert.condition.fix=反轉條件
invert.if.condition.fix=反轉 'if' 條件
javascript.dom.issues.group.name=DOM 問題
js.inspection.group.path=JavaScript 和 TypeScript
js.inspection.switch.group.name=switch 語句問題
labeled.statement.display.name=標記語句
local.variable.naming.convention.display.name=區域變數命名約定
loop.statement.that.doesn.t.loop.display.name=不迴圈的迴圈語句
loop.statement.that.doesnt.loop.error.string=<code>#ref</code> 語句未迴圈 #loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 '#ref' #loc
maximum.number.of.branches.parameter=最大分支數:
maximum.number.of.terms.parameter=最大項數:
maximum.statements.per.function=每個函式的最大語句數:
missing.return.statement.error.string=缺少 return 語句 #loc
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.error.string=否定的條件表達式 #loc
negated.if.statement.display.name=否定的 'if' 語句
negated.ref.statement.error.string=否定的 '#ref' 語句 #loc
nested.anonymous.function.error.string=嵌套 #ref #loc
nested.assignment.display.name=嵌套賦值
nested.assignment.error.string=嵌套賦值 <code>#ref</code> #loc
nested.conditional.expression.display.name=嵌套條件表達式
nested.conditional.expression.error.string=嵌套條件表達式 #loc
nested.function.call.display.name=嵌套函式呼叫
nested.function.call.problem.descriptor=嵌套呼叫函式 '#ref' #loc
nested.function.display.name=嵌套函式
nested.function.error.string=嵌套函式 '#ref' #loc
nested.switch.statement.display.name=嵌套 'switch' 語句
nested.switch.statement.error.string=嵌套 '#ref' 語句 #loc
nesting.depth.limit=嵌套深度限制:
non.block.body.error.string=<code>#ref</code> 語句具有非塊主體 #loc
non.block.branch.error.string=<code>#ref</code> 語句具有非塊分支 #loc
non.block.statement.body.display.name=沒有大括號的語句體
octal.integer.display.name=八進制整數
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
overly.complex.arithmetic.expression.error.string=過於複雜的算術表達式 #loc
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
overly.complex.boolean.expression.error.string=布爾表達式過於複雜 #loc
overly.complex.function.display.name=函式過於複雜
overly.long.function.display.name=函式過長
overly.nested.function.display.name=函式過度嵌套
parameter.name.doesnt.match.regex.error.string=參數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
parameter.name.is.too.long.error.string=參數名稱 '#ref' 過長 #loc
parameter.name.is.too.short.error.string=參數名稱 '#ref' 過短 #loc
platform.detection.display.name=平台檢測不準確
platform.detection.error.string='#ref' 可能用於平台檢測 #loc
pointless.arithmetic.error.message=#ref 可被取代為 {0} #loc
pointless.arithmetic.expression.display.name=無意義的算術表達式
pointless.bitwise.expression.display.name=可以簡化按位表達式
pointless.bitwise.expression.ignore.option=在確定無意義表達式時忽略命名常數
pointless.bitwise.expression.problem.descriptor=''{1}'' 可被取代為 ''{0}'' #loc
pointless.bitwise.expression.simplify.quickfix=簡化
pointless.boolean.error.string=可以簡化為 {0} #loc
pointless.boolean.expression.display.name=無意義的語句或布爾表達式
pointless.statement.error.string={0} 語句可以簡化 #loc
redundant.conditional.expression.display.name=冗餘條件表達式
redundant.if.statement.display.name=冗餘的 'if' 語句
redundant.local.variable.display.name=冗餘區域變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.local.variable.quickfix=內聯變數
ref.statement.with.identical.branches.error.string=<code>#ref</code> 語句具有相同的分支 #loc
remove.label.fix=移除標籤
remove.unnecessary.continue.fix=移除不必要的 continue
remove.unnecessary.return.fix=移除不必要的 return
rename.fix=重新命名
replace.redundant.await.family.name=取代冗餘的 await
replace.with.operator.assign.fix=將 = 取代為 {0}=
reserved.word.used.as.name.display.name=保留詞用作名稱
reserved.word.used.as.name.error.string=保留詞 '#ref' 用作名稱
result.of.assignment.expression.used.error.string=使用的賦值表達式的結果 #loc
result.of.assignment.used.displayName=使用的賦值的結果
result.of.increment.or.decrement.expression.used.error.string=使用增量或減量表達式的結果 #loc
result.of.increment.or.decrement.used.display.name=使用增量或減量的結果
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.error.string=<code>new #ref()</code> 的結果被忽略 #loc
return.inside.finally.block.display.name='return' 位於 'finally' 塊內
return.inside.finally.block.error.string='#ref' 位於 'finally' 塊內 #loc
reuse.of.local.variable.display.name=區域變數的重用
reuse.of.local.variable.problem.descriptor=區域變數 <code>#ref</code> 的重用 #loc
set.return.type.to.void.fix.name=將返回值類型設定為 void
shift.operation.by.inappropriate.constant.display.name=通過可能錯誤的常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>#ref</code> 進行移位運算時使用的常量值為負 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>#ref</code> 進行移位運算時使用的常量值過大 #loc
shift.out.of.range.family.name=修復移位值
silly.assignment.display.name=變數被賦值給自己
silly.assignment.error.string=變數已分配給自己 #loc
simplify.fix=簡化
statement.has.empty.body.error.string=<code>#ref</code> 語句具有空體 #loc
statement.has.empty.branch.error.string=<code>#ref</code> 語句的分支為空 #loc
statement.label.error.string=語句標籤 '#ref' #loc
statement.simplify.quickfix=簡化語句
statement.with.empty.body.display.name=帶空體的語句
string.literal.breaks.html.display.name=中斷 HTML 解析的字串文字
string.literal.breaks.html.error.string=字串文字 #ref 可能會中斷 HTML 解析器 #loc
tail.recursion.display.name=尾遞迴
tail.recursion.problem.descriptor=尾部遞迴 #loc
terminate.statement.fix=終止語句
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.error.string='switch' 語句中存在文本標籤 <code>#ref:</code> #loc
this.expression.references.global.object.error.string=頂層 '#ref' 表達式 #loc
this.expression.which.references.the.global.object.display.name=參照全域物件的 'this' 表達式
throw.inside.finally.block.display.name='throw' 位於 'finally' 塊內
throw.inside.finally.block.error.string='#ref' 位於 'finally' 塊內 #loc
trivial.conditional.error.string=''{0}'' 可以簡化為 ''{1}'' #loc
trivial.if.error.string=<code>#ref</code> 語句可以簡化 #loc
typeof.using.incorrect.case.display.name=包含非標準值的 'typeof' 比較
typeof.using.incorrect.case.error=typeof 比較含非標準值
typeof.using.incorrect.convert=轉換為 {0}
typeof.using.incorrect.family.name=轉換為標準值
unnecessary.block.statement.display.name=不必要的塊語句
unnecessary.block.statement.error.string=不必要的塊語句 #loc
unnecessary.continue.error.string=<code>#ref</code> 不必要，因為是迴圈中的最後一條語句 #loc
unnecessary.continue.statement.display.name=不必要的 'continue' 語句
unnecessary.label.display.name=不必要的標籤
unnecessary.label.error.string=不必要的標籤 <code>#ref</code> #loc
unnecessary.label.on.break.error.string=<code>#ref</code> 語句包含不必要的標籤 #loc
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
unnecessary.label.on.continue.error.string=<code>#ref</code> 語句包含不必要的標籤 #loc
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
unnecessary.local.variable.problem.descriptor=區域變數 {0} 冗餘
unnecessary.return.error.string=<code>#ref</code> 不必要，因為它是沒有返回值的函式中的最後一條語句 #loc
unnecessary.return.statement.display.name=不必要的 'return' 語句
unreachable.code.display.name=無法存取的程式碼
unreachable.code.error.string=無法存取的程式碼 #loc
unterminated.statement.display.name=未終止的語句
unterminated.statement.error.string=未終止的語句 #loc
unterminated.statement.ignore.atend.of.block=允許塊末尾沒有分號
unterminated.statement.possibly.unterminated.statement.error=語句可能未終止 #loc
unused.catch.parameter.display.name=未使用的 'catch' 參數
unused.catch.parameter.ignore.catch.option=忽略包含註釋的 catch 塊
unused.catch.parameter.problem.descriptor=未使用的 catch 參數 <code>#ref</code> #loc
use.of.innerhtml.property.display.name=使用 'innerHTML' 屬性
variable.name.doesnt.match.regex.error.string=變數名稱 ''#ref'' 與正則表達式 ''{0}'' 不符合 #loc
variable.name.is.too.long.error.string=變數名稱 '#ref' 過長 #loc
variable.name.is.too.short.error.string=變數名稱 '#ref' 過短 #loc
void.expression.display.name='void' 表達式
void.expression.error.string='#ref' 表達式 #loc
with.expression.error.string='#ref' 語句 #loc
with.statement.display.name='with' 語句
wrap.statement.body.fix=包裝語句主體
xhtml.incompatabilities.error.string='#ref' 可能會為 XHTML 文檔生成不一致的結果 #loc
xhtml.incompatibilities.display.name=不相容的 XHTML 用法
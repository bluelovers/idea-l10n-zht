go.apply.fix=選擇 {0} 並按 {1}。
go.basic.and.smart.type.completion.difference.basic=要呼叫基本補全，您還可以按 {0}。\n按 {0}，檢視建議列表，然後選擇“{1}”。
go.basic.and.smart.type.completion.difference.smart=我們需要返回一個指針，但基本補全提示沒有指針。在這種情況下，智能類型符合程式碼補全可能會有所幫助。它會篩選建議列表並僅顯示適用於當前上下文的類型。\n按 {0} 呼叫智能補全，從列表中選擇“{1}”，然後按 {2} 取代當前值。
go.basic.and.smart.type.completion.goto.next.error=所選建議會在檔案中醒目提示為錯誤，按 {0} 可了解原因。
go.basic.and.smart.type.completion.name=基本和智能類型補全
go.basic.and.smart.type.completion.type.and.choose=預設情況下，<ide/> 會立即補全您的程式碼。在文字游標所在的位置開始輸入 {0}，您將看到帶有符合建議的彈出列表。您可以按 {2} 從列表中選擇“{1}”。
go.basic.completion.invoke.completion=請注意，<ide/> 會自動插入一個新的匯入。接下來，按 {0} 啟用基本補全，選擇 {1}，然後按 {2}。
go.basic.completion.lesson.name=基本補全
go.check.sdk.version=要嘗試本課程，您需要 Go {0}。您可以在設定中進行設定或下載。有關安裝 Go SDK 的詳細資訊，請參閱 <a href\="https\://www.jetbrains.com/help/go/create-new-go-project.html\#installing-go-sdk">GoLand 文檔中的說明</a>。
go.choose.name=按 {0} 完成重構。
go.code.completion.module.name=程式碼補全
go.comment.navigation.lesson.name=註釋中的宣告
go.comment.navigation.task={0} 軟體套件並不大，我們可以在其中輕鬆導覽。但是某些軟體套件可能非常龐大，其中會包含數百個程式碼和註釋行。\n在 IDE 中，如果這些宣告在同一軟體套件內，那麼您可以從註釋轉到宣告。註釋中，這些方法、函式和結構的名稱的顏色略有不同。類似於第 32 行註釋部分中的 {1} 函式。\n要從該註釋導覽到函式宣告，請先將文字游標放在註釋中的函式名稱處，然後按 {2}。
go.comments.comment.block=您可以註釋掉程式碼塊。例如，註釋掉選定的塊，然後按 {0}。
go.comments.comment.one.line=使用 {0} 註釋掉任意一行。
go.comments.lesson.name=新增和移除註釋
go.comments.uncomment.block=取消註釋程式碼塊。再次按 {0}。
go.comments.uncomment.line=撤消對使用相同快捷鍵 {0} 註釋過的行的註釋。
go.completion.for.functions.choose.item=從列表選擇閃爍的 {0} 函式，然後按 {1}。當您看到建議列表時，即可開始輸入，以減少結果數量。
go.completion.for.functions.press.twice=現在，輸入一個點({0})並按<strong>兩次</strong> {1}。在這種情況下，IDE 會尋找所有接受字串作為第一個實參的函式。請注意，點使它看起來像一個方法，但實際上不是。
go.debug.function.calls.add.arguments.for.evaluation=在括號內，鍵入 {0}。該欄位必須顯示 {1}。
go.debug.function.calls.click.evaluate=點擊“{0}”或按 {1}。隨後您可以關閉對話框。
go.debug.function.calls.enter.expression.to.evaluate=在 {0} 欄位中，開始鍵入 {1}，從建議列表中選擇 {2}。
go.debug.function.calls.evaluate.expression=按 {1} 呼叫 {0} 動作。
go.debug.function.calls.lesson.name=偵錯函式呼叫
go.debug.function.calls.mac.note=請記住，您的作業系統可能會要求您輸入密碼以啟動偵錯伺服器。
go.debug.function.calls.run.to.cursor=現在，文字游標位於第 15 行的末尾。按 {0} 檢視 {1} 動作的工作方式。
go.debug.function.calls.step.over=嘗試使用 {1} 單步跳過 {0} 建構。
go.debug.function.calls.toggle.breakpoint=在偵錯模式下，您可以將不同的值傳遞至函式，並檢視函式返回的內容。在<a href\="{0}">文檔</a>中了解有關“對表達式求值”功能的更多資訊。\n{1}要開始偵錯，您需要建立一個中斷點。按 {2} 切換中斷點。
go.debug.function.calls.version.warning=<strong>註</strong>\: 對於此功能，您需要安裝 Go 1.11 或更高版本。
go.debug.function.context.menu=可以通過多種方式偵錯程式碼。其中之一是借助右鍵選單。\n右鍵點擊編輯器中的某個區域，然後選擇醒目提示的選單條目“{0}”。請注意，確切的措辭可能有所不同\: 在 {2} 函式的上下文中可能為“{1}”，在其他上下文中可能為“{3}”。
go.debug.function.more.menu=點擊“{1}”工具視窗中的“{0}”按鈕。
go.debug.run.sample=選擇 {0} 目錄項或嘗試 {1}。
go.debug.stop.debug=按 {0} 停止偵錯並完成課次。
go.dump.goroutines.click.button.DlvFilterGoroutinesAction=在開啟的 {0} 頁籤中，點擊“{1}”按鈕。
go.dump.goroutines.click.button.more=從下拉列表中選擇“{0}”。
go.dump.goroutines.dump.tab={0} 頁籤會顯示應用程式的 Goroutine 列表。我們的應用程式有幾個 goroutine。但您的實際套用程序可能不止這些。\n在 <ide/> 中，您可以套用篩選器來搜尋特定的 goroutine，並研究篩選後的結果。
go.dump.goroutines.filter.goroutines=在 {0} 搜尋欄位中，鍵入 {1} 以篩選列表。此篩選器只保留名稱中含有 {1} 的 goroutine 的執行堆疊。
go.dump.goroutines.name=傾印 goroutine
go.dump.goroutines.toggle.breakpoint=在 Go 中，並發任務稱為 goroutine。要建立 goroutine，可以在函式或方法呼叫之前使用 {0} 語句。\n您可以建立程序使用的所有 goroutine 的傾印，套用搜尋特定 goroutine 的篩選器，並研究篩選的結果。\n要傾印 goroutine，需要啟動偵錯。但首先要建立一個中斷點。按 {1} 可切換中斷點。{2}
go.extract.inline.variables.extract.task=按 {0} 提取變數，選擇一個字串表達式，輸入新名稱，然後按 {1} 完成重構。
go.extract.inline.variables.inline.task=與 {0} 重構相反，{1} 有助於移除冗餘變數。按 {2} 可將變數內聯到其單個用法中。
go.extract.inline.variables.lesson.name=提取和內聯變數
go.extract.methods.with.returns.complete.refactoring=鍵入 {0} 並按 {1}。
go.extract.methods.with.returns.intro=使用 {0} 重構，您可以獲取程式碼段，將其移至單獨的方法，並用對新方法的呼叫取代舊程式碼。如果程式碼在 return 語句中離開，則按原樣提取。在<a href\="{1}">提取函式和方法</a>一文中進一步了解 {0} 重構。
go.extract.methods.with.returns.invoke.refactoring=文字游標位於您可以提取的 {0} 子句之前。按 {1}。
go.extract.methods.with.returns.lesson.name=提取方法
go.feature.trainer.specify.sdk.to.continue.learning.title=指定 Go SDK 以繼續學習
go.feature.trainer.too.old.go.sdk.notification.text=教程需要 Go SDK <b>{1}</b> 或更高版本才能對 Go 模組進行相依項管理。您當前的 Go SDK 版本為 <b>{0}</b>。
go.feature.trainer.too.old.go.sdk.notification.title=將 Go SDK 更新到 <b>{0}</b> 或更高版本
go.fmt.lesson.name=使用 go fmt 設定程式碼格式
go.fmt.task=如果您傾向於使用“{0}”設定程式碼格式，可以按 {1} 執行。
go.formatting.clear.selection=要清理選區，按 {0}。
go.formatting.lesson.name=使用內建格式化程序設定程式碼格式
go.formatting.reformat.selection=<ide/> 可以幫助您進行程式碼格式化。點擊 {0} 重新設定所選程式碼塊的格式。
go.formatting.whole.file=要重新設定整個原始檔的格式，請在未選擇任何行的情況下使用 {0}。
go.generics.change.casing=在生成測試檔案之前，我們先修正一下程式碼樣式。在官方 Go 文檔中，類型參數的名稱為大寫，我們程式碼中的 {0} 參數為小寫。\n要修正大小寫，我們可以使用快速修復。要執行此動作，請按 {1}，然後選擇“{2}”。
go.generics.click.function=點擊“{0}”，然後在“{1}”彈出視窗中，選擇“{2}”。
go.generics.fix.type=我們程式碼中的下一個問題是類型包含其本身，您將收到 {0} 錯誤。要避免此錯誤，應該包括指向類型的指針，而不是類型本身。IDE 有一個針對此情況的快速修復。\n按 {1}，然後選擇“{2}”。
go.generics.implement.methods.name=泛型\: 實作缺少的方法
go.generics.inspections.change.interface.to.any=繼續深入之前，我們再來重構一個東西。我們使用一個可被取代為 {0} 的空接口。\n按 {1}，然後選擇“{2}”。
go.generics.inspections.delete.type.parameters={0} 函式使用中括號來使用類型參數，但在這些中括號中，我們看到了空的參數列表。要修正該錯誤，請按 {1}，然後選擇“{2}”。
go.generics.inspections.title=類型參數的檢查
go.generics.inspections.union.interfaces.with.methods=根據 <a href\="{0}">Go 團隊</a>，在聯合體中您不能將接口與方法一起使用。因此，不能將 {1} 用作聯合體元素中的術語。\n刪除以 {1} 開頭、以豎線及其之後空格結尾的所選組。
go.generics.inspections.unused.type.parameter=類型參數為灰顯，因為我們在程式碼中的任何地方都不使用它們。我們來通過將參數部分中的 {0} 類型取代為 {1} 進行修正。
go.generics.right.click.function=我們已消除檔案中的所有錯誤，可以嘗試為 {0} 函式生成測試。\n右鍵點擊 {0} 函式。
go.generics.running.code.click.link=現在，點擊結果鏈接，在瀏覽器中開啟您的程式碼。\n要使用類型參數執行程式碼，點擊“{0}”按鈕即可。
go.generics.running.code.missing.go118.download.or.local=如果您之前安裝過 Go {0}，可以嘗試使用下拉列表進行尋找。或者，點擊“{1}”按鈕並選擇是要下載所需的 SDK 版本({2})，還是要導覽到硬盤驅動器上的本地副本({3})。\n通過上述方式，選擇比 Go {0} 更高的版本，然後在所有對話框中點擊“{4}”以套用新的 SDK。
go.generics.running.code.missing.go118.downloading=<ide/> 現在會下載並解壓縮 SDK。完成此步驟後，IDE 將為這些檔案編制索引，以便將它們用於程式碼輔助。
go.generics.running.code.missing.go118.indexing=現在，<ide/> 會索引 SDK 檔案。請等待處理完畢。之後，您就可以使用此 Go SDK 了。
go.generics.running.code.missing.go118.quickfix=您當前正在使用 Go {0}。要在本課次中使用泛型，您需要安裝或切換到 Go 1.18 或更高版本。\n您可以按 {1}，然後選擇“{2}”以執行該動作。
go.generics.running.code.name=執行程式碼
go.generics.running.code.playground=另一種執行程式碼的方法是使用“{0}”。\n要試用此功能，請按 {1}。如果出現確認對話框，請點擊“{2}”將檔案設為公開。將在編輯器的右下角顯示包含{0}中頁面的鏈接的彈出視窗。
go.generics.test.generation.module=為類型參數生成測試
go.goto.next.error=要導覽到檔案中下一個醒目提示的錯誤，請按 {0}。
go.navigation.module.description=在程式碼庫中進行移動
go.navigation.module.name=導覽
go.new.features.experimental.gc.intro=Go 1.25 引入了一個名為 GreenTea GC 的全新實驗性垃圾回收器(GC)，旨在提升 Go 應用程式的執行速度和可擴展性，尤其適用於會建立大量小物件或在多核 CPU 上執行的應用程式。預設不啟用此 GC，但您可以使用特殊標誌進行試用。
go.new.features.experimental.gc.run.with.flag=在終端中輸入以下指令，使用 GreenTea GC 執行程序\: {0}
go.new.features.experimental.gc.run.without.flag=現在執行不帶該標誌的程序。輸入以下指令並按 {0}\: {1}。\n注意\: 此功能尚處於實驗階段，每次執行的結果可能會有所不同。
go.new.features.experimental.gc.title=實驗性垃圾回收器
go.new.features.flight.recorder.intro=認識一下 {0}\: 這是一種內建工具，可以記錄最近的活動，並允許您在發生值得注意的事件(例如錯誤、峰值或 panic)時捕獲快照。
go.new.features.flight.recorder.run=讓我們模擬程序中的一個關鍵事件，並檢視輸出。\n在編輯器中的任意位置點擊右鍵，然後選擇 {0}；如果您在 {2} 函式的上下文中，則選擇 {1}。
go.new.features.flight.recorder.study.output=該追蹤已儲存到名為 {0} 的檔案中。\n要分析 Go 執行追蹤，您需要使用 {1} 執行本地伺服器。\n按 {2} 開啟終端。
go.new.features.flight.recorder.title=Flight Recorder
go.new.features.flight.version.json.m.build=在終端中，輸入並執行以下指令來建置應用程式\: {0}
go.new.features.flight.version.json.m.intro=Go 1.25 新增了一個有用的新命令行選項，能以 JSON 格式列印有關已編譯 Go 二進制檔案的詳細建置資訊，從而可以輕鬆地使用工具進行解析、分析或自動化。
go.new.features.flight.version.json.m.print=現在執行以下指令來列印有關二進制檔案的建置資訊\: {0}
go.new.features.flight.version.json.m.title=正在列印 'runtime/debug.BuildInfo' 結構
go.new.features.go.doc.open.terminal=按 {0} 開啟終端。
go.new.features.go.doc.running.go.doc=輸入 {0} 並按 {1}。等待伺服器啟動後，包含您文檔的瀏覽器將自動開啟。
go.new.features.go.doc.stopping.go.doc=點擊 {0} 工具視窗中的指令提示符，然後按 {1} 停止伺服器。
go.new.features.go.doc.title=新的 'go doc -http' 選項
go.new.features.go.doc.what.it.does={0} 指令會啟動一個本地 Web 伺服器，該伺服器會在您的瀏覽器中顯示您 Go 程式碼的文檔。您可以像瀏覽網站一樣瀏覽您自己的軟體套件，閱讀根據您的註釋生成的文檔，並探索您的程式碼和範例。您無需互聯網連線即可使用此功能。
go.new.features.go.vet.hostport.summary={0} 分析器會確保您的地址不會呈現為如下格式\: {1}。此模式無法正確處理類似 {2} 的 IPv6 地址，因為它會建立無效地址。\n請檢查編輯器中所選的行。您可以在此處改用 {3}。
go.new.features.go.vet.open.terminal=按 {0} 開啟終端。
go.new.features.go.vet.summary=Go 1.25 為 {0} 新增了兩項檢查以幫助您發現常見錯誤\: {1} 和 {2}。
go.new.features.go.vet.title=新的 vet 分析器
go.new.features.go.vet.waitgroup.summary={0} 分析器會檢查 goroutine 內部是否存在對 {1} 的呼叫。如果 goroutine 在 {2} 被呼叫之前就開始執行，可能會導致 {3} 過早完成，從而引發錯誤。\n請在編輯器中檢查所選行。要解決此問題，可以將 {1} 移出 goroutine。
go.new.features.ignore.directive.adding.to.ignore=在 {0} 指令內，輸入 {1} 和 {2}。
go.new.features.ignore.directive.running.go.list=輸入 {0} 並按 {1}。該指令列出了 {5} 模組中的 {2}、{3} 和 {4} 軟體套件。
go.new.features.ignore.directive.running.go.list.again=再次執行 {0} 以確保 {1} 和 {2} 軟體包被忽略。
go.new.features.ignore.directive.title=MOD 檔案中的 'ignore' 指令
go.new.features.ignore.directive.what.it.does={0} 指令的作用是什麼? ''ignore'' 指令會告訴 Go 工具\:在建置或測試應用時不要使用這些目錄中的程式碼。它會在 {1}、{2}、{3} 等指令中隱藏這些目錄。\n{4}\: 但被忽略的目錄仍然是您模組的一部分，並且當有人下載您的模組時(例如，使用 {5} 或通過模組 ZIP 檔案)，仍會包含這些目錄中的檔案。
go.new.features.ignore.directive.why.to.use.it=使用 {2} 指令排除非 Go 程式碼或不需要建置的目錄。例如，{0} 或 {1} 目錄中的前端程式碼，或 JavaScript 庫。目前，{2} 指令為空。我們來執行 {3} 並在 {4} 工具視窗中檢查其輸出。{3} 列出了我們模組中的所有 Go 軟體套件。按 {5} 開啟終端。
go.new.features.in.go.description=Go 1.25 中可能引起您注意的內容
go.new.features.in.go.name=Go 1.25 亮點
go.new.features.json.2.run.experiment=要使用此功能，您需要在<a href\="https\://www.jetbrains.com/help/go/configuring-build-constraints-and-vendoring.html\#using_go_experiments">設定</a>中啟用 {0} 實驗。或者，您也可以在命令行中使用 {1} 環境變數。\n要開啟終端，請按 {2}。
go.new.features.json.2.running.with.env.variable=鍵入 {0} 並按 {1}。
go.new.features.json.2.study.the.output=檢查應用程式輸出。大多數範例的兩個 JSON 版本都會執行，以便您進行比較。
go.new.features.json.2.summary=Go 1.25 引入了一種全新的、更快且更靈活的 JSON 實作。新的實作提升了性能(尤其是解碼性能)、錯誤訊息的可讀性、API 靈活性(新的功能和選項)以及 JSON 處理方式的一致性。請注意，{0} 仍處於實驗階段，其設計可能仍會發生變化。
go.new.features.json.2.title=新的 JSON 引擎('json/v2')
go.new.features.repanic.note={0}\:在本例中，您需要在 Go 1.24 和 Go 1.25 之間切換。要了解如何更改 Go SDK 版本，請參閱 <a href\="https\://www.jetbrains.com/help/go/create-new-go-project.html\#installing-go-sdk">GoLand 文檔</a>。如果您不想切換版本，可以在 <a href\="https\://tip.golang.org/doc/go1.25\#change-to-unhandled-panic-output">tip.golang.org 上的 Go 1.25 發行說明</a>中比較輸出差異。
go.new.features.repanic.run.with.go.124=我們來執行應用程式。在編輯器中點擊右鍵，然後選擇醒目提示的選單項 {0}。請注意，具體文字可能會有所不同\: 在 {2} 函式的上下文中，它可能是 {1}。
go.new.features.repanic.run.with.go.125=很好\! 再次在編輯器中點擊右鍵，重新執行應用程式，並檢查 panic 的輸出。現在輸出列印內容為\:\n{0}
go.new.features.repanic.set.go.124=將您的 Go SDK 版本設定為 1.24。要切換 SDK，請按照 <a href\="https\://www.jetbrains.com/help/go/create-new-go-project.html\#installing-go-sdk">GoLand 文檔中的說明</a>進行動作。
go.new.features.repanic.set.go.125=如果檢查輸出，您會看到其列印內容為\:\n{0}\n{1}\n{2}\n現在，我們來看看 Go 1.25 中是如何處理的。切換回 Go 1.25。
go.new.features.repanic.title=恢復後 panic 輸出更好
go.new.features.root.type.intro=Go 1.25 擴展了 {1} 軟體套件中的 {0} 類型，提供了一種在特定根目錄下執行安全、沙盒化檔案動作的強大方法。此更新新增了許多常見的檔案函式，例如 {2}、{3}、{4} 等。現在，您可以在單個受控的根中安全便捷地處理檔案。
go.new.features.root.type.run=您可以執行該套用程序來檢視其實際執行情況。出於安全考慮，{0} 方法尚未實作。\n在編輯器中的任意位置點擊右鍵，然後選擇 {1}；如果您在 {3} 函式的上下文中，則選擇 {2}。
go.new.features.root.type.title='os' 軟體套件中 'root' 類型的擴展
go.new.features.synctest.results={0} 幾乎立即完成。這是因為測試在一個虛擬時間氣泡中執行\: 第一次呼叫立即執行，第二次呼叫被阻塞，時間通過 {1} 快進 10 秒，第二次呼叫立即完成，無需任何實際等待。
go.new.features.synctest.running.slow.test=我們準備了一個同時使用一般方法和 {3} 方法的測試套件。應用程式本身包含 {0} 方法，該方法確保每次呼叫之間至少間隔 10 秒。之後，它會返回字串 {1}。\n執行 {2} 函式，檢視此測試不使用 {3} 時的執行情況。右鍵點擊測試名稱，然後選擇 {4}。
go.new.features.synctest.running.synctest.test=完成測試實際大約需要 10 秒。\n現在我們來執行 {0} 測試。右鍵點擊測試名稱並選擇 {1}。
go.new.features.synctest.summary={0} 軟體套件可幫助您測試並發程式碼，即使用 goroutine、計時器或休眠的程式碼。\n它允許您在受控環境(稱為“氣泡”)中使用虛擬時鐘來執行測試，而無需實際等待。我們來看一個範例。
go.new.features.synctest.title=更快地測試並發程式碼
go.new.features.testing.package.attributes=在 {0} 工具視窗中，您首先可能會注意到的改進是能夠將 key–value 特性附加到測試用例。當您想使用自訂元資料(例如版本、輸入或上下文)為測試執行新增標籤，或改進測試日誌的篩選和可讀性時，此功能會非常有用。為了生成這些標記，我們使用了以下程式碼\: {1}。在 {0} 工具視窗中生成輸出的公會在編輯器中醒目提示。
go.new.features.testing.package.delete=刪除所選程式碼。
go.new.features.testing.package.intro=Go 1.25 對 {0} 軟體套件進行了多項雖小但實用的改進，使您的測試日誌更加清晰，偵錯更加容易，尤其是在大型或並行測試套件中。
go.new.features.testing.package.output=在 {0} 工具視窗中向下滾動。您將看到，現在可以生成不帶檔案和行參照的輸出，這與 {1} 函式生成的輸出不同。新的 {2} 方法會返回一個直接寫入測試輸出的 {3}。\n點擊 {4} 鏈接導覽到使用標準 {1} 方法的程式碼；在此行下方，您將看到新的 {2} 方法。
go.new.features.testing.package.parallel=另一個重要更新是將 {0} 與 {1} 結合使用。之前，在並行測試執行期間執行 {1} 可能會產生不可靠的結果。現在，此程式碼將導致 panic。\n按 {2} 取消註釋以下行\: {3}
go.new.features.testing.package.rerun=點擊裝訂區中醒目提示的圖示並選擇 {0} 以重新執行測試。
go.new.features.testing.package.run=我們來執行整個測試套件以檢視這些改進。右鍵點擊醒目提示的裝訂區圖示，然後選擇 {0}。\n在 {1} 工具視窗中檢視結果。
go.new.features.testing.package.title='testing' 軟體套件中的其他更新
go.new.features.typeassert.intro=Go 1.25 在 {0} 軟體套件中引入了一個新函式\: {1}。此函式可幫助您更高效地從 {2} 中提取值，而無需先呼叫 {3}。
go.new.features.typeassert.new.way=現在看看 {0} 函式，它使用直接轉換，無需額外分配記憶體。這就像開啟一個神秘盒子，立刻就能知道裡面是什麼，而無需將其取出、複印並檢查。
go.new.features.typeassert.old.way=假設你有一個神秘盒子，裡面可能裝著不同類型的物品\: 可能是字串、數字，也可能是個人資訊。類型斷言就是一種確定盒子裡裝著什麼並進行適當處理的方式。\n請看 {0} 函式。它使用 {1} 來檢查裡面是什麼類型的物品。在這種方法中，首先會將物品從神秘盒子中取出並複製，然後再檢查其類型。
go.new.features.typeassert.run=我們來執行該套用程序。在編輯器中的任意位置點擊右鍵，然後選擇醒目提示的選單項 {0}。\n應用程式執行完成後，比較兩種方法之間的性能差異。
go.new.features.typeassert.title=直接值轉換
go.onboarding.apply.action=選擇“{0}”動作，然後按 {1}。
go.onboarding.apply.intention=選擇 {0} 並按 {1}。
go.onboarding.balloon.about.debug.panel=“{0}”工具視窗為工具列提供了各種偵錯動作。您可以稍後在“{1}”課次中進行嘗試。
go.onboarding.balloon.click.here=點擊此處設定中斷點
go.onboarding.balloon.open.file=雙擊以開啟 {0}
go.onboarding.balloon.open.learn.toolbar=切換到“{0}”工具視窗繼續學習本課次
go.onboarding.balloon.project.directory=雙擊專案目錄可以將其展開並檢視專案檔案
go.onboarding.balloon.project.view=點擊以開啟<strong>專案</strong>檢視
go.onboarding.balloon.start.debugging=點擊該圖示以開始偵錯
go.onboarding.balloon.stop.debugging=點擊該圖示以停止偵錯
go.onboarding.case.changed=大小寫已更改。
go.onboarding.change.ui.settings=在本課次中，<ide/> 會將某些 UI 設定更改為預設狀態。完成或離開課次後，將恢復您的偏好設定。
go.onboarding.click.run.button=點擊醒目提示的執行按鈕“{0}”以顯示執行選項。
go.onboarding.click.run.button.balloon=點擊以顯示執行選項
go.onboarding.close.debug.tool.window=要關閉{0}工具視窗，請按 {1}。
go.onboarding.context.menu=可以通過不同的方式執行程式碼。其中之一是借助 {1} 函式附近的執行按鈕“{0}”。
go.onboarding.epilog=恭喜\! 您已完成入門導覽。此時，您可以\:\n  - <callback id\="{0}">關閉</callback>學習專案{1}\n  - <callback id\="{2}">顯示</callback>更多課次
go.onboarding.feedback.system.found.sdks=已找到 SDK\:
go.onboarding.feedback.system.no.sdks=無
go.onboarding.feedback.system.used.sdk=已使用 SDK\:
go.onboarding.indexing.description=第一次開啟專案時，<ide/> 會掃描 Go SDK 和專案本身，以收集編碼輔助所需的詳細資訊。要繼續，請等待索引完成。
go.onboarding.invoke.completion.tip=<strong>提示</strong>\: 您可以按 {0} 在程式碼的任何位置顯示補全條目。
go.onboarding.invoke.intention.for.code=意圖還可以節省您的時間，讓編碼更輕鬆。我們使用意圖將 {0} 函式快速轉換為匯出函式。按 {1}。
go.onboarding.invoke.intention.for.code.balloon=按 {0} 顯示所有可用的意圖
go.onboarding.invoke.intention.for.warning.1=您剛剛修正了一個錯誤，但還可以進一步改進這段程式碼。<ide/> 將醒目提示可以改進的程式碼行，並為這些行新增黃色燈泡。
go.onboarding.invoke.intention.for.warning.2=按 {0} 預覽警告並套用快速修復。
go.onboarding.invoke.intention.for.warning.balloon=按 {0} 顯示所有可用的快速修復
go.onboarding.invoke.search.everywhere.1=在 <ide/> 中進行處理時，您可能想要搜尋專案中的檔案、符號、類型，乃至 IDE 動作。在本課次中，我們將搜尋 {0} 動作，以將 {1} 字串改為小寫。
go.onboarding.invoke.search.everywhere.2=按兩次 {0} 以開啟“{1}”對話框。
go.onboarding.lesson.name=熟悉 {0}
go.onboarding.module.description={0} 中的主要功能概覽
go.onboarding.module.name=入門導覽
go.onboarding.project.view.description=<strong>專案</strong>檢視是主要工具視窗之一。它包含專案目錄、SDK 特定的軟體套件和臨時檔案。點擊帶條紋的按鈕可以預覽示範專案。您也可以按 {0} 開啟。
go.onboarding.return.to.welcome=\ 並返回歡迎頁面
go.onboarding.run.sample=選擇“{0}”或嘗試“{1}”。
go.onboarding.run.widget.balloon=使用此小工具，您可以為所選組態執行常用的執行動作
go.onboarding.search.everywhere.description=可以看到，所選文本 {0} 已被自動複製到輸入字串中。我們不輸入 {0}，而是輸入 {1}。
go.onboarding.select.fix=套用第一個條目\: {0}。通過該修正消除了不必要的圓括號。
go.onboarding.select.item=<ide/> 會在您輸入時自動顯示補全選項。使用鍵盤上的箭頭選擇“{0}”條目，然後按 {1}。
go.onboarding.start.debugging=點擊“{0}”圖示啟動偵錯過程。
go.onboarding.start.typing=現在，開始輸入 {0} 以顯示補全選項。
go.onboarding.start.typing.balloon=開始輸入 {0} 以顯示補全選項
go.onboarding.stop.debugging=我們來停止偵錯。點擊“{0}”圖示。
go.onboarding.temporary.configuration.description=<ide/> 剛剛建立了一個臨時執行組態。您可以在“{0}”中找到此組態。使用此小工具，您可以為所選組態執行常用的執行動作，例如執行 {1}、偵錯 {2}。其他動作，如分析 {3} 以及使用覆蓋率執行 {4} 可通過點擊 {5} 顯示。
go.onboarding.toggle.breakpoint.1=您可能會注意到 {1} 方法沒有返回預期值 {0}，而是返回 {2}。我們來檢視 return 語句，偵錯有問題的程式碼。
go.onboarding.toggle.breakpoint.2=點擊醒目提示區域內的裝訂區域以設定中斷點。
go.onboarding.type.division=發現程式碼中的問題後，我們來修正。將得到的和除以值的長度。課次腳本已插入 {0}。
go.playground.module.name=在 Go Playground 中執行程式碼
go.playground.note=<strong>注意</strong>\: 在本課次中，您需要連接到 Go Playground 伺服器。
go.playground.paste.url=在“{0}”欄位中，按 {1} 貼上 URL，然後點擊“{2}”。
go.playground.run.code.in.playground=按工具列上的“{0}”按鈕可使用 Go Playround 伺服器執行您的程式碼。
go.playground.run.code.locally=按工具列上的“{0}”按鈕在您的計算機上執行程式碼。
go.playground.run.copy.link=您可以從檔案和 Go Playground 鏈接匯入程式碼。按 {0} 複製所選鏈接。
go.playground.select.open.in.playground=右鍵點擊所選程式碼並導覽到“{0} | {1}”。\n<ide/> 會將此程式碼匯入到臨時檔案。
go.playground.select.run.locally=我們在本地執行這段程式碼。要執行此動作，請選中工具列上的“{0}”複選框。
go.playground.select.url=在“{0}”對話框中，選擇“{1}”單選按鈕。
go.postfix.completion.better.variable.names.in.templates.description=<ide/> 可以幫助您對使用 {0} 和 {1} 後綴模板生成的變數進行命名。例如，在以下建議中，您可以會遇到\: 用於索引的 {2} 或 {3}，或者用於 {5} 的 {4}。\n輸入 {6}，然後從補全列表中選擇 {7} 後綴模板。
go.postfix.completion.lesson.name=後綴補全
go.postfix.completion.task=使用後綴模板，您可以根據點號、表達式類型及其上下文後的後綴，將已經輸入的表達式轉換為其他表達式。\n我們的字母切片已被打亂。要對字串切片正確排序，可以將 {1} 軟體套件中的 {0} 函式應用於切片。\n我們已經輸入保留切片的變數。接下來套用 {1} 後綴模板，無需反覆動作。在 {3} 變數之後輸入點號({2})，檢視後綴補全建議列表。從列表選擇 {1}，或在編輯器中輸入，然後按 {4} 補全語句。
go.press.and.apply.fix=按 {0} 並選擇 {1}。
go.refactoring.inline.dialog=在開啟的對話框中，點擊“{0}”。
go.refactoring.menu.extract.method=現在，我們來提取一個計算兩點之間距離的方法。按 {0} 並從列表中選擇“{1}”，或按 {2} 直接呼叫此動作。
go.refactoring.menu.inline.refactoring=要內聯方法，請按 {0} 並選擇“{1}”。
go.refactoring.menu.introduce.parameter.eng=假設您需要將 {0} 提取為常數。{1} 完全可以做到這一點。在重構選單中，從列表中選擇“{1}”，然後按 {2}。
go.refactoring.menu.lesson.name=重構選單
go.refactoring.menu.select.math.sqrt=選擇閃爍的表達式以提取程式碼中的整個方法，然後按 {0}。
go.refactoring.menu.show.refactoring.list=<ide/> 提供了各種重構。其中許多重構都有自己的快捷鍵，但您可以隨時按 {0} 來列出當前上下文中可用的所有重構。
go.refactoring.menu.start.refactoring=選擇“{0}”以取代程式碼中 {1} 的所有符合項。
go.refactorings.module.description=重構可使您的程式碼可靠、簡潔並易於維護
go.refactorings.module.name=重構
go.rename.apply.intention=為此欄位輸入新名稱。例如，鍵入 {0}，然後按 {1} 儲存結果。
go.rename.invoke.intentions=您可以將文字游標放在符號上，並使用 {0} 重構來重新命名任何內容。將文字游標放在程式碼任意位置的 {1} 欄位上，然後按 {2}。
go.rename.lesson.name=重新命名
go.running.code.context.menu=您可以通過不同的方式執行程式碼。其中一種方式是利用右鍵選單。\n嘗試通過右鍵點擊程式碼所在編輯器中的區域呼叫右鍵選單。
go.running.code.run.sample=點擊“{0}”執行您的程式碼。應用程式的輸出將顯示在“{1}”工具視窗中。
go.search.everywhere.goto.type=太棒了\! 但是，有時您需要只尋找類型，或者只在某些特定目錄中進行搜尋。使用“{0}”搜尋類型。
go.search.everywhere.quick.documentation=按 {0} 可預覽所選類型的文檔。
go.search.everywhere.type.popup.closed.warning.message=按 {0} 可再次開啟搜尋視窗。
go.search.everywhere.type.type.name=假設您需要尋找名為 {0} 的類型。輸入搜索詞的首字母 – {1}。暫時不要導覽到找到的類型。
go.search.everywhere.use.all.places=在示範專案中找到符合類型。但是，您可以尋找專案中未包含的其他類型。我們將“{0}”篩選器切換為“{1}”以從 Go SDK 中調出符合的類型。
go.smart.type.completion.lesson.name=智能類型補全
go.smart.type.completion.task=智能類型補全可以篩選建議列表，使其僅包含當前上下文中適用的類型。按 {0} 以檢視符合建議的列表。按 {1} 選擇第一個。
go.statement.completion.complete.condition=在括號 {0} 內新增一個條件，然後按 {1} 跳轉到 {2} 語句內。
go.statement.completion.complete.finish.body=鍵入一行程式碼\: {0}，然後按 {1} 補全語句並套用格式。
go.statement.completion.complete.for=按 {0} 補全 {1} 語句。
go.statement.completion.complete.if=鍵入 {0}，然後按 {1} 以生成語句。
go.statement.completion.help.link=語句補全
go.statement.completion.lesson.name=語句補全
go.support.for.table.tests.call.context.menu=在 <ide/> 中，您可以執行函式中的所有測試，或只執行部分測試。例如，點擊 {0} 函式附近的裝訂區域中的執行圖示，然後選擇“{1}”。您將執行此函式中的所有測試。
go.support.for.table.tests.name=支援表測試
go.support.for.table.tests.run.subtest=您可以使用相同的方法執行單個子測試。點擊 {0} 子測試附近的裝訂區域圖示，然後選擇“{1}”。\n這種方式當前存在多種限制，您可以在 <a href\="{2}">GoLand 文檔</a>中了解這些限制。
go.support.fuzz.testing.check.failing=糟糕，模糊測試失敗了\! 要找出原因，請在“{0}”工具視窗中向下滾動輸出，然後點擊指向 {1} 目錄的鏈接。
go.support.fuzz.testing.run=模糊測試是一種通過不斷提交各種輸入來自動執行測試的方式。我們來執行模糊測試，根據各種生成的資料檢查我們的函式。\n要執行模糊測試，請點擊裝訂區域中的閃爍圖示，然後選擇“{0}”。
go.support.fuzz.testing.title=模糊測試
go.support.of.godebug.directive.apply.quickfix=警告指出，該指令應在 {0} 子句之前宣告。\n要將該指令移動到正確位置，請按 {1} 並選擇“{2}”。
go.support.of.godebug.directive.go.to.warning={0} 指令是 Go 1.21 中引入的一項功能，允許開發者影響 Go 執行時的行為。<ide/> 提供了醒目提示和快速修復來幫助管理此指令。\n按 {1} 可導覽至警告。
go.support.of.godebug.directive.name=go\:debug 指令的基本支援
go.to.internal.directory=您可以導覽到存儲在 {0} 目錄中的接口。\n按 {1} 可轉到 {2} 接口的實作。
go.to.internal.directory.hover.over.tab=順便說一下，要檢視檔案位置，您可以將滑鼠指標懸停在編輯器中的頁籤上。例如，將指針懸停在“{0}”頁籤上。
go.to.internal.directory.name=導覽和程式碼格式設定
go.to.internal.directory.reformat.gofmt.on.save={0} 檔案需要重新設定程式碼格式。按 {1} 重新設定檔案格式。\n此外，預設情況下，<ide/> 將在內置的 <ide/> 格式化程序後執行{2}工具。此設定通過 {5} 中的“{4}”頁籤上的“{3}”選項進行組態。
go.type.parameters.description=可能有助於您使用泛型的功能
go.type.parameters.module.name=泛型(類型參數)
go.view.hierarchies.choose.any.implementation=選擇任何實作，然後按 {0} 或點擊它。
go.view.hierarchies.goto.implementation=按 {0} 尋找 {1} 的實作。
go.view.hierarchies.hide.find.tool.window=按 {0} 隱藏“{1}”工具視窗。
go.view.hierarchies.hide.method.hierarchy=我們也隱藏“{0}”。再次按 {1}。
go.view.hierarchies.invoke.implementations.again=基方法的宣告具有自身的裝訂區域圖示 {0}。點擊它或再次按 {1}。
go.view.hierarchies.lesson.name=檢視層次結構
go.view.hierarchies.navigate.to.base=您可以從派生方法導覽到基方法。按 {0} 或點擊編輯器裝訂區域中的“{1}”圖示。
go.view.hierarchies.open.in.find.tool.window=對於大型層次結構，您可能需要在“{0}”工具視窗中尋找實作。點擊“{1}”。
go.view.hierarchies.open.method.hierarchy=您可能需要探索此方法的整個層次結構。按 {0}。
go.view.hierarchies.open.type.hierarchy=要檢視子類型，請按 {0}。
go.working.with.json.add.key.to.tags=要新增 XML 和 ASN1 標記，也可以使用意圖動作。\n按 {0} 再次呼叫意圖動作，然後選擇 {1} 並鍵入 {2}。
go.working.with.json.change.style=您可以為標記中的欄位名稱套用不同的程式碼樣式。例如，將其更改為駝峰式命名法。\n按 {0}，點擊“{1}”，然後選擇“{2}”。
go.working.with.json.copy=<ide/> 有幾種工具可以幫助您更有效地處理 JSON 程式碼。\n按 {0} 複製所選的 JSON。
go.working.with.json.introduce.type=我們來提取 {0} 嵌入式結構體。\n按 {1} 並選擇“{2}”。
go.working.with.json.name=使用 JSON
go.working.with.json.name.struct=如果需要，請更改結構體名稱，然後按 {0} 完成編輯。IDE 將自動修正您的格式設定。
go.working.with.json.replace=按 {0} 取代註釋部分。\n<ide/> 會自動將複製的 JSON 部分轉換為結構體類型。
go.working.with.json.update.value.in.tags=標記值的批處理更新也是如此。假設我們想將 {0} 新增到當前結構體中的每個標記。\n按 {1}，選擇 {2}，然後鍵入 {3}。\n您也可以從建議列表中選擇 {0}。<ide/> 知道 JSON、XML 和 ASN1 標記的最常用值。
go.working.with.parameters.invoke.intentions.1=文字游標位於 {0} 方法的第一個參數處。按 {1} 呼叫意圖動作。
go.working.with.parameters.invoke.intentions.2=檢視編輯器中的 {0} 方法。文字游標位於第一個參數處。按 {1} 呼叫意圖動作。
go.working.with.parameters.invoke.intentions.3=如果方法實作接口時需要參數，那麼將其移除會不安全。按 {0} 檢視可能選項的列表。
go.working.with.parameters.lesson.name=上下文動作
go.working.with.parameters.press.action.again=現在，再按一下 {0}。
go.working.with.parameters.remove.parameters=<ide/> 僅醒目提示未使用參數的名稱，前提是其類型用於實作方法規范。在這種情況下，您可以將此參數重命名為 {0} 或完全移除其名稱。
go.working.with.parameters.signature.combined=注意簽名類型的組合方式。
go.working.with.parameters.signature.expanded=要將簽名恢復到初始狀態，請選擇 {0}。
go.working.with.parameters.single.type=如果函式或方法簽名中具有單個類型的多個參數，則可以為這些參數使用簡短的類型規範({0})，也可以為每個參數使用單獨的類型規範({1})。
go.working.with.parameters.that.are.not.used=<ide/> 可以檢測簽名中未用於方法或函式體的參數。只要它們未被使用，就可以通過“{0}”快速修復將其刪除。
toggle.case.part=大小寫

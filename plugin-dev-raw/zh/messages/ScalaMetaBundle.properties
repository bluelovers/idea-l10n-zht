### scala/meta/intellij/MetaExpansionsManager.scala
meta.annotation.class.could.not.be.found=未找到元註解類
tree.conversion.error=樹轉換錯誤: {0}
semantic.error=語意錯誤: {0}
stack.overflow.during.expansion=擴展 {0} 時堆疊溢出
internal.error.getmessage=內部錯誤: {0}

### scala/meta/intellij/QuasiquoteInferUtil.scala
failed.to.get.qq.ref.in.pattern=無法在 {0} 中獲取 QQ 引用
unknown.quasiquote.kind.prefix=未知的 Quasiquote 類型 - {0}

### scala/meta/intellij/psi/package.scala
meta.expansions.disabled.in.settings=元擴展在設定中已禁用
no.meta.annotation=沒有元註解
recursive.meta.expansion=遞歸元擴展

### scala/meta/trees/Namer.scala
synthetic.elements.not.implemented=未實作合成元素
package.and.object.types.shoud.be.singleton.not.name...=軟體套件和物件類型應為單例，而非名稱: {0}
failed.to.convert.type.tp=無法轉換類型 {0}
super.selector.cannot.be.non.name.type=Super 選擇器不能為非名稱類型
unexpected.type.in.parents.other=父項中存在意外類型: {0}

### scala/meta/trees/ScalaMetaException.scala
cannot.resolve.class.at.element=無法解析位於 {1} 的 {0}
cannot.calculate.type=無法計算類型: {0}
this.code.should.be.unreachable.reason=此程式碼應不可到達: {0}
this.code.should.be.unreachable=此程式碼應不可到達
failed.to.typecheck=無法檢查類型: {0}
this.code.path.is.not.implemented.yet.head=此程式碼路徑尚未實作[{0}]

### scala/meta/trees/TreeAdapter.scala
macro.definition.must.have.return.type.defined=巨集定義必須已定義返回類型
no.primary.constructor.in.class=類中沒有主構造函數
no.constructor.found.in.class=在類 {0} 中未找到構造函數
class.has.no.parents=類 {0} 沒有父項
empty.while.condition=空 while 條件
generator.has.no.expression=生成器沒有表達式
guard.has.no.condition=臨界沒有條件
forbinding.has.no.expression=for 綁定沒有表達式
imported.name.is.null=匯入的名稱在非萬用字元選擇器中為 null
reference.is.null=引用在非萬用字元選擇器中為 null
empty.throw.expression=空 throw 表達式

### scala/meta/trees/TypeAdapter.scala
number.of.parts.in.compound.type.must.be.greater.than.2=複合類型的部分數必須大於等於 2
cannot.convert.into.type.variables=無法轉換為類型變數

### scala/meta/trees/Utils.scala
unexpected.psi=意外 psi({0}): {1}

### <unused>
unexpected.type.in.constructor.type.element=構造函數類型元素 {0} 中存在意外類型

access.generic.problem=無法存取 ''{1}'' 中的 ''{0}''
access.package.local=''{0}'' 在 ''{1}'' 中不為 public。無法從外部軟體套件存取
access.private=''{0}'' 在 ''{1}'' 中具有 private 存取權限
access.protected=''{0}'' 在 ''{1}'' 中具有 protected 存取權限
annotation.attribute.duplicate=特性 ''{0}'' 重複
annotation.attribute.illegal.array.initializer=''{0}'' 的初始設定式非法
annotation.attribute.incompatible.type=不相容的類型。實際為 {1}''，需要 ''{0}''
annotation.attribute.name.missing=應為格式為 'name\=value' 的註解特性
annotation.attribute.non.class.literal=特性值必須為類別字面量
annotation.attribute.non.constant=特性值必須為常數
annotation.attribute.non.enum.constant=特性值必須為枚舉常數
annotation.attribute.unknown.method=找不到 @interface 方法 ''{0}()''
annotation.cannot.be.local=不允許區域註解
annotation.container.abstract=容器註解 ''{0}'' 沒有包含 ''{1}'' 的預設值
annotation.container.bad.type=無效的容器註解 ''{0}''\: ''value'' 方法的類型應為 ''{1}''
annotation.container.low.retention=容器註解 ''{0}'' 的保留長度(''{1}'')比包含的註解短
annotation.container.missed.annotation=容器註解 ''{0}'' 沒有必需的 @{1} 註解
annotation.container.no.value=無效的容器註解 ''{0}''\: 未宣告 ''value'' 方法
annotation.container.not.applicable=容器註解 ''@{0}'' 不適用於 {1}
annotation.container.wide.target=容器註解 ''{0}'' 的目標不是此註解目標的子集
annotation.container.wrong.place=容器註解 ''{0}'' 不得與它所包含的元素同時存在
annotation.cyclic.element.type=迴圈註解元素類型
annotation.duplicate=註解重複
annotation.duplicate.explained=註解重複。{0}
annotation.duplicate.non.repeatable=重複的註解。''{0}'' 的宣告沒有有效的 java.lang.annotation.Repeatable 註解
annotation.malformed.repeatable.explained={0}
annotation.may.not.have.extends.list=@interface 上不允許使用 'extends'
annotation.member.clash=@interface 成員與 {1} 中的 ''{0}'' 衝突
annotation.member.invalid.type=註解成員的類型 ''{0}'' 無效
annotation.member.may.not.have.parameters=@interface 成員可能沒有參數
annotation.member.may.not.have.throws.list=@interface 方法上不允許使用 'throws'
annotation.missing.attribute={0} 必要，但缺少
annotation.not.allowed.class=類別字面量類型可能未進行註解
annotation.not.allowed.here=此處不允許註解
annotation.not.allowed.in.permit.list='permits' 列表中不允許使用註解
annotation.not.allowed.on.package=軟體套件註解應位於檔案 package-info.java 中
annotation.not.allowed.ref=註解不適用於此類別參照
annotation.not.allowed.static=限定類型的 static 成員可能未註解
annotation.not.allowed.var='var' 類型可能未註解
annotation.not.allowed.void='void' 類型可能未進行註解
annotation.not.applicable=''@{0}'' 不適用於{1}
annotation.permits=@interface 上不允許使用 'permits'
annotation.repeated.target=重複的註解目標
annotation.type.expected=應為註解類型
array.empty.diamond=不允許使用 '<>' 建立陣列
array.generic=不允許建立泛型陣列
array.illegal.initializer=''{0}'' 的初始設定式非法
array.initializer.not.allowed=此處不允許陣列初始設定式
array.too.many.dimensions=陣列維度過多
array.type.arguments=不允許使用類型實參建立陣列
array.type.expected=應為陣列類型；實際為 ''{0}''
assignment.declared.outside.guard=無法為變數 ''{0}'' 賦值，因為它是在 guard 外部宣告的
assignment.to.final.variable=無法將值賦給 final 變數 ''{0}''
binary.operator.not.applicable=運算符 ''{0}'' 不能應用於 ''{1}''、''{2}''
break.out.of.switch.expression=不允許 switch 表達式外的 break
break.outside.switch.or.loop='break' 位於 switch 或迴圈外部
call.ambiguous=方法呼叫不明確\: ''{0}'' 和 ''{1}'' 均符合
call.ambiguous.no.match=無法解析 ''{1}'' 中的方法 ''{0}''
call.ambiguous.tooltip=<html><body><table border\=0><tr><td colspan\={0}>方法呼叫不明確。<b>{2}</b> 中的 </td></tr><tr>{1}<td>\\&nbsp;和 <b>{4}</b> 中的 </td></tr><tr>{3}<td>\\&nbsp;均符合</td></tr></table></body></html>
call.constructor.duplicate=建構函式中只允許一次顯式建構函式呼叫
call.constructor.must.be.first.statement=''{0}'' 呼叫必須是建構函式主體中的第一條語句
call.constructor.must.be.top.level.statement=對 ''{0}'' 的呼叫必須是建構函式主體中的頂層語句
call.constructor.only.allowed.in.constructor=只允許在建構函式主體中呼叫 ''{0}''
call.constructor.record.in.canonical=規範建構函式不能委託給其他建構函式
call.constructor.recursive=遞迴建構函式呼叫
call.direct.abstract.method.access=無法直接存取 abstract 方法 ''{0}''
call.expected=應為方法呼叫
call.formal.varargs.element.type.inaccessible.here=無法從此處存取正式的 vararg 元素類型 {0}
call.member.before.constructor=在呼叫超類別建構函式之前無法呼叫 ''{0}''
call.parsed.as.deconstruction.pattern=常數表達式、模式或 null 為必需項
call.qualifier.primitive=無法呼叫 ''{0}'' 類型的方法
call.static.interface.method.qualifier=static 方法只能在其包含接口上呼叫
call.super.enum.constructor=枚舉建構函式中不允許呼叫 'super'
call.super.qualifier.not.inner.class=不允許使用限定符，因為超類別 ''{0}'' 不是非 static 內部類別
call.type.inference.error={0}
call.unresolved=無法解析方法 ''{0}''
call.unresolved.name=無法解析方法 ''{0}''
call.wrong.arguments=''{1}'' 中的 ''{0}'' 無法應用於 ''{2}''
call.wrong.arguments.count.mismatch=應為{0, choice, 0\#無實參|1\#1 個實參|1<{0} 個實參}，但實際為 {1} 個
cast.inconvertible=不可轉換的類型；無法將 ''{0}'' 轉換為 ''{1}''
cast.intersection.inheritance.clash=無法使用不同的實參繼承 {0}\: {1} 和 {2}
cast.intersection.not.interface=此處應為接口
cast.intersection.repeated.interface=重複的接口
cast.intersection.unexpected.type=意外的類型\: 應為類別
catch.type.parameter=無法捕獲類型參數
clash.methods.message=''{0}'' 與 ''{1}'' 衝突
clash.methods.message.show.classes=''{2}'' 中的 ''{0}'' 與 ''{3}'' 中的 ''{1}'' 衝突
class.already.imported=已在此編譯單元中定義 ''{0}''
class.anonymous.extends.sealed=匿名類別不得擴展 sealed 類別
class.cannot.be.referenced.from.static.context=無法從 static 上下文參照 ''{0}''
class.cannot.extend.multiple.classes=類別不能擴展多個類別
class.clashes.with.package=類別 ''{0}'' 與同名的軟體套件衝突
class.cyclic.inheritance=涉及 ''{0}'' 的迴圈繼承
class.duplicate=重複的類別\: ''{0}''
class.duplicate.in.other.file=在檔案 ''{0}'' 中找到重複類別
class.extends.final=無法繼承自{1, choice, 1\# final 類別|2\#枚舉|3\#記錄|4\#非抽象值類別} ''{0}''
class.extends.interface=此處不應為接口
class.extends.prohibited.class=類別無法直接擴展 ''{0}''
class.extends.sealed.another.module=不允許類別擴展另一個模組中的 sealed 類別
class.extends.sealed.another.package=另一個軟體套件中的{0} ''{1}'' 不允許擴展未命名模組中的 sealed {2} ''{3}''
class.extends.sealed.local=區域類別不得擴展 sealed 類別
class.extends.sealed.not.permitted=sealed 層次結構中不允許使用 ''{0}''
class.generic.extends.exception=泛型類別不能擴展 'java.lang.Throwable'
class.implements.class=此處應為接口
class.implicit.initializer=壓縮原始檔中不允許使用初始設定式
class.implicit.invalid.file.name=壓縮原始檔的名稱不是有效的關鍵字
class.implicit.no.main.method=壓縮原始檔未包含 'main' 方法
class.implicit.package.statement=壓縮原始檔中不允許使用軟體套件語句
class.inheritance.different.type.arguments=''{0}'' 不能使用不同的類型實參繼承\: ''{1}'' 和 ''{2}''
class.inheritance.method.clash={1} 中的方法 {0} 和 {3} 中的方法 {2} 使用相同的簽名繼承
class.inheritance.raw.and.generic=''{0}'' 不能作為原始類型繼承，也不能使用泛型類型實參 ''{1}'' 繼承
class.inherits.abstract.and.default={0} 從類型 {2} 和 {3} 繼承 {1} 的 abstract 和 default 方法
class.inherits.type.parameter=類別無法從其類型參數繼承
class.inherits.unrelated.defaults={0} 從類型 {2} 和 {3} 中繼承 {1} 的不相關預設值
class.initializer.must.complete.normally=初始設定式必須能夠正常完成
class.must.implement.method=類別 ''{0}'' 必須在 ''{2}'' 中實作 abstract 方法 ''{1}''
class.must.implement.method.enum.constant=枚舉常數 ''{0}'' 必須在 ''{2}'' 中實作 abstract 方法 ''{1}''
class.must.implement.method.or.abstract=類別“{0}”必須宣告為抽象，或實作 ''{2}'' 中的 abstract 方法 ''{1}''
class.not.accessible=無法存取 {0}
class.not.enclosing=''{0}'' 不是封閉類別
class.or.package.expected=應為類別或軟體套件
class.permitted.must.have.modifier=所有 sealed 類別的子類別必須為 fianl、sealed 或 non-sealed 類型
class.permitted.not.direct.subclass=無效的 ''permits'' 子句\: ''{0}'' 必須直接{1, choice, 1\#擴展|2\#實作} ''{2}''
class.reference.list.duplicate=對 ''{1}'' 列表中 ''{0}'' 的重複參照
class.reference.list.inner.private=''{0}'' 在 ''{1}'' 中具有 private 存取權限
class.reference.list.name.expected=應為類別名
class.reference.list.no.enclosing.instance=作用域中沒有 ''{0}'' 類型的封閉實例
class.sealed.incomplete.permits=sealed 類別 permit 子句必須包含所有子類別
class.sealed.inheritor.expected.modifiers=應為修飾符 'sealed' 或 'non-sealed'
class.sealed.inheritor.expected.modifiers.can.be.final=應為修飾符 'sealed'、'non-sealed' 或 'final'
class.sealed.no.inheritors=sealed 類別必須有子類別
class.sealed.permits.on.non.sealed=無效的 ''permits'' 子句\: ''{0}'' 必須為 sealed
class.wrong.filename=類別 ''{0}'' 為 public，應在檔案 ''{0}.java'' 中宣告
comment.shebang.java.file=不支持在 .java 檔案中使用事件機制
comment.unclosed=未閉合註釋
constructor.ambiguous.implicit.call=不明確的隱式建構函式呼叫\: ''{0}'' 和 ''{1}'' 均符合
constructor.in.implicit.class=不允許在壓縮原始檔的隱式宣告類別中使用顯式建構函式
constructor.no.default=''{0}'' 中沒有可用的無實參建構函式
continue.out.of.switch.expression=不允許在 switch 表達式外部使用 continue
continue.outside.loop='continue' 語句不在 for 迴圈內
enum.constant.illegal.access.in.constructor=不允許從枚舉{1, choice, 1\#建構函式|2\#實例欄位初始設定式|3\#實例初始設定式}存取{0, choice, 1\# static 欄位|2\#枚舉常數}
enum.constant.modifier=不允許對枚舉常數使用修飾符
enum.extends=枚舉上不允許使用 'extends'
enum.permits=枚舉上不允許使用 'permits'
exception.already.caught=已捕捉到異常 ''{0}''
exception.must.be.disjoint=多 catch 中的類型必須不相交\: ''{0}'' 是 ''{1}'' 的子類別
exception.never.thrown.try=相應的 try 塊中從未拋出異常 ''{0}''
exception.never.thrown.try.multi=相應的 try 塊中從未拋出異常 ''{0}''
exception.unhandled=未處理的{1, choice, 0\#異常|2\#異常}\: {0}
exception.unhandled.close=來自可自動關閉資源的未處理{1, choice, 0\#異常|2\#異常}\: {0}
expression.class.parameterized.type=無法存取參數化類型的類別物件
expression.class.type.parameter=無法存取類型參數的類別物件
expression.expected=應為表達式
expression.qualified.class.expected=此處應為類別名
expression.super.bad.qualifier.method.overridden=預設 super 呼叫中的類型限定符錯誤\: 方法 {0} 在 {1} 中被覆寫
expression.super.bad.qualifier.redundant.extended=預設 super 呼叫中的類型限定符錯誤\: 冗餘接口 {0} 由 {1} 擴展
expression.super.dot.expected=應為 '.'
expression.super.no.enclosing.instance=作用域中沒有 ''{0}'' 類型的封閉實例
expression.super.not.enclosing.class=''{0}'' 不是封閉類別
expression.super.unqualified.default.method=擴展方法中不允許非限定 super 參照
field.initialized.before.constructor.call=無法在呼叫超類別建構函式之前指定初始化的欄位 ''{0}''
field.not.initialized=欄位 ''{0}'' 可能尚未初始化
foreach.not.applicable=Foreach 不適用於類型 ''{0}''
guard.evaluated.to.false=此 case 標籤有一個 guard，後者是一個值為 'false' 的常數表達式
guard.misplaced=只允許在模式後使用 guard
identifier.restricted=''{0}'' 為受限關鍵字，不能用於類型宣告
illegal.character=非法字元\: {0}
illegal.unicode.escape=非法 Unicode 轉義序列
import.list.extra.semicolon=import 語句之間不允許有額外的分號
import.single.class.conflict=已在單類型 import 中定義 ''{0}''
import.single.static.class.already.defined=已在單一 static import 中定義類別 ''{0}''
import.single.static.class.ambiguous=類別 ''{0}'' 在單一 static import 中不明確
import.single.static.field.already.defined=已在單一 static import 中定義欄位 ''{0}''
import.single.static.field.ambiguous=欄位 ''{0}'' 在單一 static import 中不明確
import.static.on.demand.resolves.to.class=找不到類別 {0}
incomplete.project.state.pending.reference=直到專案完全載入後才會解析
instanceof.illegal.generic.type=instanceof 的泛型類型非法
instanceof.type.parameter=應為類別或陣列
instanceof.unsafe.cast=''{0}'' 無法安全地轉換為 ''{1}''
instantiation.abstract=''{0}'' 為 abstract；無法實例化
instantiation.enum=無法實例化枚舉類型
instantiation.local.class.wrong.static.context=無法從其他 static 上下文實例化本地類別 ''{0}''
insufficient.language.level=語言級別 ''{1}'' 不支持 {0}
interface.class.initializer=接口中不允許使用類別初始設定式
interface.constructor=接口中不允許使用建構函式
interface.extends.class=此處應為接口
interface.implements=接口上不允許使用 'implements'
label.duplicate=標籤 ''{0}'' 已在使用中
label.must.be.loop=''continue'' 目標必須為迴圈標籤\: ''{0}''
label.unresolved=未定義的標籤\: ''{0}''
label.without.statement=無語句的標籤
lambda.incompatible.parameter.types=lambda 表達式中的參數類型不相容\: 應為 {0} 個，但實際為 {1} 個
lambda.inference.error={0}
lambda.multiple.sam.candidates=在 {0} 中找到多個非覆寫 abstract 方法
lambda.no.target.method.found=找不到目標方法
lambda.not.a.functional.interface={0} 不是函式式接口
lambda.not.expected=意外的 lambda 表達式
lambda.parameters.inconsistent.var=不能在 lambda 表達式中將 'var' 和顯式類型參數混合
lambda.return.type.error={0}
lambda.sam.generic=目標方法為泛型
lambda.sealed=Lambda 無法實作 sealed 接口
lambda.sealed.functional.interface=函式式接口不能宣告為 'sealed'
lambda.target.not.interface=lambda 轉換的目標類型必須為接口
lambda.type.inference.failure=無法推斷函式式接口類型
lambda.wrong.number.of.parameters=lambda 表達式中的參數數量錯誤\: 應為 {0} 個，但實際為 {1} 個
literal.binary.no.digits=二進制數值必須至少包含一個二進制數字
literal.character.empty=空字元字面量
literal.character.illegal.escape=字串字面量中有非法轉義字元
literal.character.too.long=字元字面量中的字元數過多
literal.character.unclosed=字元字面量未閉合
literal.floating.malformed=浮點字面量格式不正確
literal.floating.too.large=浮點數過大
literal.floating.too.small=浮點數過小
literal.hexadecimal.no.digits=十六進制數值必須至少包含一個十六進制數字
literal.illegal.underscore=非法下劃線
literal.integer.too.large=整數過大
literal.long.too.large=長整數過大
literal.string.illegal.escape=字串字面量中存在非法轉義字元
literal.string.illegal.line.end=字串字面量中不允許出現行尾
literal.text.block.no.new.line=非法的文本塊起始\: 左引號後缺少新行
literal.text.block.unclosed=文本塊未閉合
lvalue.variable.expected=應為變數
lvti.array=不允許將 'var' 作為陣列的元素類型
lvti.compound=複合宣告中不允許 'var'
lvti.lambda=無法推斷類型\: lambda 表達式需要顯式目標類型
lvti.method.reference=無法推斷類型\: 方法參照需要顯式目標類型
lvti.no.initializer=無法推斷類型\: 'var' 位於沒有初始設定式的變數上
lvti.null=無法推斷類型\: 變數初始設定式為 'null'
lvti.self.referenced=無法推斷 ''{0}'' 的類型，它被用於自己的變數初始設定式中
lvti.void=無法推斷類型\: 變數初始設定式為 'void'
method.abstract.body=abstract 方法不能有主體
method.abstract.in.non.abstract.class=非抽象類別中存在 abstract 方法
method.default.in.class=擴展方法只能在接口中使用
method.default.overrides.object.member=預設方法 ''{0}'' 覆寫 ''java.lang.Object'' 的成員
method.default.should.have.body=擴展方法應有主體
method.duplicate=已在 ''{1}'' 中定義 ''{0}''
method.generic.same.erasure={0}；兩個方法具有相同的擦除
method.generic.same.erasure.hide={0}；兩個方法具有相同的擦除，但都沒有隱藏另一個
method.generic.same.erasure.override={0}；兩個方法具有相同的擦除，但都沒有覆寫另一個
method.inheritance.clash.does.not.throw={0}；覆寫的方法未拋出 ''{1}''
method.inheritance.clash.incompatible.return.types={0}；返回值類型不相容
method.inheritance.clash.unrelated.return.types={0}；方法有不相關的返回值類型
method.inheritance.weaker.privileges={0}；嘗試指定較弱的存取權限(''{1}'')；曾為 ''{2}''
method.instance.overrides.static=''{1}'' 中的實例方法 ''{0}'' 無法覆寫 ''{3}'' 中的 static 方法 ''{2}''
method.interface.body=接口 abstract 方法不能有主體
method.missing.return.type=方法宣告無效；需要返回值類型
method.native.body=原生方法不能有主體
method.no.parameter.list=應為參數列表
method.overrides.final=''{0}'' 無法覆寫 ''{2}'' 中的 ''{1}''；被覆寫的方法為 final
method.private.in.interface.should.have.body=接口中的 private 方法應具有主體
method.reference.abstract.method=無法直接存取 abstract 方法 ''{0}''
method.reference.enclosing.instance.not.in.scope=作用域中沒有類型 {0} 的封閉實例
method.reference.inference.error={0}
method.reference.non.static.method.in.static.context=無法從 static 上下文參照非 static 方法
method.reference.not.expected=不應在此處使用方法參照表達式
method.reference.parameterized.qualifier=static 方法參照上存在參數化限定符
method.reference.qualifier.class.unresolved=找不到類別 {0}
method.reference.qualifier.wildcard=意外萬用字元
method.reference.raw.constructor=原始建構函式參照具有建構函式的顯式類型參數
method.reference.return.type.error={0}
method.reference.sealed=方法參照無法實作 sealed 接口
method.reference.static.method.non.static.qualifier=通過非 static 限定符參照 static 方法
method.reference.static.method.receiver=通過接收器參照 static 方法
method.reference.unresolved.constructor=無法解析建構函式 ''{0}''
method.reference.unresolved.method=無法解析方法 ''{0}''
method.should.have.body=應為方法體
method.should.have.body.or.abstract=應為方法體或 'abstract' 修飾符
method.static.in.interface.should.have.body=接口中的 static 方法應具有主體
method.static.overrides.instance=''{1}'' 中的 static 方法 ''{0}'' 無法覆寫 ''{3}'' 中的實例方法 ''{2}''
method.throws.class.name.expected=應為類別名
modifier.incompatible=非法的修飾符組合 ''{0}'' 和 ''{1}''
modifier.not.allowed=此處不允許使用修飾符 ''{0}''
modifier.not.allowed.local.class=不允許在區域類別上使用修飾符 ''{0}''
modifier.not.allowed.non.sealed=不允許在沒有 sealed 超類別的類別上使用修飾符 'non-sealed'
modifier.repeated=重複的修飾符 ''{0}''
module.access.bad.name=模組 ''{0}'' 的名稱無效
module.access.does.not.read=模組 ''{0}'' 無法讀取 ''{1}''
module.access.from.named=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者沒有將它匯出到模組 ''{2}''
module.access.from.unnamed=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者沒有將它匯出到未命名模組
module.access.jps.dependency.problem=專案結構中未指定 ''{0}'' 的模組相依項
module.access.not.in.graph=模組圖中缺少模組 ''{0}''
module.access.package.bad.name=軟體套件 ''{0}'' 在具有無效名稱(''{1}'')的模組中宣告
module.access.package.does.not.read=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但模組 ''{2}'' 沒有讀取它
module.access.package.not.in.graph=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者不在模組圖中
module.access.to.unnamed=軟體套件 ''{0}'' 在未命名的模組中宣告，但模組 ''{1}'' 沒有讀取它
module.conflicting.packages=軟體套件 ''{0}'' 存在於另一個模組中\: {1}
module.conflicting.reads=模組 ''{0}'' 同時從 ''{2}'' 和 ''{3}'' 讀取軟體套件 ''{1}''
module.cyclic.dependence=迴圈相依關係\: {0}
module.duplicate.exports=重複的 ''exports''\: {0}
module.duplicate.exports.target=重複的 ''exports'' 目標\: {0}
module.duplicate.implementation=重複的實作\: {0}
module.duplicate.opens=重複的 ''opens''\: {0}
module.duplicate.opens.target=重複的 ''opens'' 目標\: {0}
module.duplicate.provides=重複的 ''provides''\: {0}
module.duplicate.requires=重複的 ''requires''\: {0}
module.duplicate.uses=重複的 ''uses''\: {0}
module.file.duplicate=模組中已存在 'module-info.java'
module.file.wrong.location=模組宣告應位於模組的來源根中
module.file.wrong.name=模組宣告應位於名為 'module-info.java' 的檔案中
module.import.not.allowed=不允許匯入模組
module.no.package=模組檔案不應具有 'package' 語句
module.not.found=找不到模組\: {0}
module.not.on.path=模組不在相依項中\: {0}
module.opens.in.weak.module=開啟的模組中不允許 'opens'
module.reference.package.empty=軟體套件為空\: {0}
module.reference.package.not.found=找不到軟體套件\: {0}
module.service.abstract=該服務實作是抽象類別\: {0}
module.service.alien=服務實現必須在 provides 指令所在的同一模組中定義
module.service.enum=服務定義為枚舉\: {0}
module.service.implementation.type=服務實作類型必須為服務接口類型的子類型，或者具有 public static 無實參 'provider' 方法
module.service.inner=服務實現為內部類別\: {0}
module.service.no.constructor=服務實作沒有 public 預設建構函式\: {0}
module.service.provider.type=''provider'' 方法返回值類型必須是服務接口類型的子類型\: {0}
new.expression.anonymous.implements.interface.with.type.arguments=匿名類別實作接口；不能具有類型實參
new.expression.arguments.to.default.constructor.call=預設建構函式通過實參呼叫
new.expression.diamond.anonymous.inner.non.private=由於非 private 方法不會覆寫或實作父類型中的方法，無法使用 '<>'
new.expression.diamond.inference.failure={0}
new.expression.diamond.not.allowed=此處不允許菱形運算符
new.expression.diamond.not.applicable=菱形運算符不適用於非參數化類型
new.expression.qualified.anonymous.implements.interface=實作接口的匿名類別的意外限定符
new.expression.qualified.malformed=限定 new 無效
new.expression.qualified.qualified.class.reference=限定 new 中不允許使用限定類別參照
new.expression.qualified.static.class=static 類別的限定 new
new.expression.type.parameter=類型參數 ''{0}'' 不能直接實例化
new.expression.unresolved.constructor=無法解析建構函式 ''{0}''
override.on.non-overriding.method=方法未從其超類別覆寫方法
override.on.static.method=static 方法不能使用 @Override 註解
package.clashes.with.class=軟體套件 ''{0}'' 與同名的類別衝突
pattern.cannot.infer.type=無法推斷模式類型\: {0}
pattern.deconstruction.annotation=解構模式類型中不允許使用註解
pattern.deconstruction.count.mismatch=嵌套模式的數量不正確\: 應為 {0} 個，但實際為 {1} 個
pattern.deconstruction.requires.record=解構模式只能應用於記錄，''{0}'' 不是記錄
pattern.deconstruction.variable=此處不允許使用關鍵字
pattern.expected.class.or.array.type=需要類別或陣列類型
pattern.instanceof.equals=模式類型 ''{0}'' 與表達式類型相同
pattern.instanceof.supertype=模式類型 ''{0}'' 是表達式類型 ''{1}'' 的父類型
pattern.not.exhaustive=模式 ''{0}'' 在 ''{1}'' 上不詳盡
pattern.type.pattern.expected=應為類型模式
pattern.unsafe.cast=''{0}'' 無法安全地轉換為 ''{1}''
preview.api.usage={0} 是預覽 API，預設情況下處於停用狀態
receiver.name.mismatch=接收器名稱不符合封閉類別類型
receiver.static.context=接收器不能在 static 上下文中使用
receiver.type.mismatch=接收器類型不符合封閉類別類型
receiver.wrong.context=不允許接收器超出方法參數列表
receiver.wrong.position=接收器應為第一個參數
record.accessor=記錄組件存取器
record.accessor.non.public=記錄組件存取器必須為 'public'
record.accessor.wrong.return.type=組件存取器返回值類型不正確。應為 ''{0}''，實際為 ''{1}''
record.canonical.constructor=規範建構函式
record.canonical.constructor.wrong.parameter.name=規範建構函式參數名稱必須符合記錄組件名稱。應為 ''{0}''，實際為 ''{1}''
record.canonical.constructor.wrong.parameter.type=記錄組件 ''{0}'' 的參數類型不正確。應為 ''{1}''，實際為 ''{2}''
record.compact.constructor=緊湊建構函式
record.component.cstyle.declaration=記錄組件中不允許 C 樣式的陣列宣告
record.component.not.initialized=記錄組件 ''{0}'' 可能無法在規範建構函式中初始化
record.component.restricted.name=記錄組件名稱 ''{0}'' 非法
record.component.vararg.not.last=Vararg 記錄組件必須為列表中的最後一項
record.constructor.stronger.access={0} 存取級別的限制不能超過記錄存取級別(''{1}'')
record.extends=記錄上不允許使用 'extends'
record.header.regular.class=為非記錄宣告了記錄標頭
record.instance.field=記錄中不允許實例欄位
record.instance.initializer=記錄中不允許實例初始設定式
record.no.constructor.call.in.non.canonical=非規範記錄建構函式必須委託給其他建構函式
record.no.header=記錄沒有宣告標頭
record.permits=記錄上不允許使用 'permits'
record.special.method.throws={0} 不應宣告 ''throws'' 子句
record.special.method.type.parameters={0} 不能有類型參數
reference.ambiguous=對 ''{0}'' 的參照不明確，''{1}'' 和 ''{2}'' 均符合
reference.class.in.default.package=類別 ''{0}'' 位於預設軟體套件中
reference.enum.forward=無法在定義枚舉常數 ''{0}'' 之前對其進行參照
reference.enum.self=無法從枚舉常數 ''{0}'' 自己的定義中其進行參照
reference.field.forward=無法在定義欄位 ''{0}'' 之前讀取它的值
reference.field.self=無法從欄位定義內部讀取欄位 ''{0}'' 的值
reference.implicit.class=無法參照壓縮原始檔 ''{0}'' 的隱式宣告類別
reference.local.class.other.switch.branch=無法從另一個 switch 分支參照區域類別 ''{0}''
reference.member.before.constructor=在呼叫超類別建構函式之前無法參照 ''{0}''
reference.non.static.from.static.context=無法從 static 上下文參照非 static {0} ''{1}''
reference.outer.type.parameter.from.static.context=無法從 static 上下文參照 ''{0}''
reference.package.not.found=找不到軟體套件\: {0}
reference.qualifier.not.expression=限定符必須為表達式
reference.qualifier.primitive=無法存取 ''{0}'' 類型的欄位
reference.select.from.type.parameter=無法從類型參數中選擇
reference.type.argument.static.class=此處不允許類型實參，因為類別 ''{0}'' 為 static
reference.type.needs.type.arguments=格式不正確的類型\: ''{0}'' 需要類型實參，因為其限定符具有類型實參
reference.unresolved=無法解析符號 ''{0}''
resource.declaration.or.variable.expected=應為宣告、final 或 effectively final 變數
return.before.explicit.constructor.call=不允許在 ''{0}'' 呼叫之前使用 ''return''
return.compact.constructor=緊湊建構函式中不允許 'return' 語句
return.from.constructor=無法從建構函式返回值
return.from.void.method=無法從結果類型為 void 的方法返回值
return.missing=缺少 return 語句
return.outside.method=return 位於方法外部
return.outside.switch.expression=return 位於封閉 switch 表達式外部
return.value.missing=缺少返回值
safe.varargs.on.fixed.arity=具有固定元數的方法中不允許使用 @SafeVarargs
safe.varargs.on.non.final.method=非 final 實例方法中不允許使用 @SafeVarargs
safe.varargs.on.record.component=記錄組件中不允許使用 @SafeVarargs
statement.bad.expression=不是語句
statement.case.outside.switch=case 語句位於 switch 外部
statement.declaration.not.allowed=此處不允許宣告
statement.invalid=語句無效
statement.unreachable=不可到達的語句
statement.unreachable.loop.body=迴圈條件始終為 false，使循環體不可到達
string.template.processor.missing=字串模板表達式中缺少處理器
string.template.raw.processor=不允許使用原始處理器類型\: {0}
string.template.void.not.allowed.in.embedded=不允許將 'void' 類型的表達式作為字串模板嵌入表達式
switch.default.and.boolean='switch' 具有所有布林值和一個 default 標籤
switch.default.label.contains.case=預設 case 的標籤只能使用 'default' 關鍵字，不能使用 'case'
switch.default.label.not.allowed=此處不允許使用預設標籤\: 'default' 只能用作單個 case 標籤或僅與 'null' 配對
switch.default.null.order=無效的 case 標籤順序\: 'null' 必須為第一個，'default' 必須為第二個
switch.different.case.kinds='switch' 中使用了不同的 'case' 種類
switch.dominance.violation=標籤由先前的 case 標籤 ''{0}'' 支配
switch.empty=''switch'' {0} 沒有任何 case 子句
switch.expression.cannot.be.void=switch 表達式的目標類型不能為 void
switch.expression.incompatible.type=switch 表達式中存在錯誤類型\: {0} 無法轉換為 {1}
switch.expression.no.result='switch' 表達式沒有任何結果表達式
switch.expression.should.produce.result=switch 表達式應在所有執行路徑中產生結果
switch.fallthrough.to.pattern=到模式的直落非法
switch.incomplete=''switch'' {0} 未涵蓋所有可能的輸入值
switch.label.combination.constants.and.patterns=無效的 case 標籤組合\: 一個 case 標籤必須包含 case 常數列表或單個 case 模式
switch.label.combination.constants.and.patterns.unnamed=無效的 case 標籤組合\: 一個 case 標籤必須包含一個 case 常數列表或一個 case 模式列表
switch.label.constant.expected=需要常數表達式
switch.label.duplicate=標籤 ''{0}'' 重複
switch.label.duplicate.default=default 標籤重複
switch.label.duplicate.unconditional.pattern=無條件模式重複
switch.label.expected=必須在語句前面預置 case 標籤
switch.label.multiple.patterns=無效的 case 標籤組合\: 一個 case 標籤不得包含一個以上的 case 模式
switch.label.multiple.patterns.unnamed=無效的 case 標籤組合\: 只有所有模式都不宣告任何模式變數時，才允許使用多個模式
switch.label.pattern.expected=switch 選擇器類型 ''{0}'' 需要模式
switch.label.qualified.enum=枚舉 switch case 標籤必須是枚舉常數的非限定名稱
switch.label.unexpected=常數表達式、模式或 null 為必需項
switch.multiple.labels.with.pattern.variables=只有所有標籤都不宣告任何模式變數時，才允許為 switch 標記語句組使用多個 switch 標籤
switch.null.label.not.allowed=無效的 case 標籤組合\: 'null' 只能用作單個 case 標籤或僅與 'default' 配對
switch.null.type.incompatible=''null'' 無法轉換為 ''{0}''
switch.rule.should.produce.result=switch 表達式規則應在所有執行路徑中產生結果
switch.selector.type.invalid=不支持 ''{0}'' 的選擇器類型
switch.selector.type.invalid.level=語言級別 ''{1}'' 不支持選擇器類型 ''{0}''
switch.unconditional.pattern.and.boolean='switch' 具有所有布林值和一個無條件模式
switch.unconditional.pattern.and.default='switch' 同時具有無條件模式和 default 標籤
syntax.error={0}
type.argument.in.permits.list=permits 列表中不允許泛型
type.argument.not.allowed=此處不允許參照參數
type.argument.on.raw.method=在原始方法上提供類型實參
type.argument.on.raw.type=在原始類型上提供類型實參
type.argument.primitive=類型實參不能為基元類型
type.inaccessible=''{0}'' 無法從此處存取
type.incompatible=不相容的類型。實際為 {1}''，需要 ''{0}''
type.incompatible.reason.ambiguous.method.reference=原因\: 方法參照不明確\: ''{0}'' 和 ''{1}'' 均符合
type.incompatible.reason.inference=原因\: {0}
type.incompatible.tooltip.provided.type=提供\:
type.incompatible.tooltip.required.type=必需類型\:
type.parameter.absent.class=類型 ''{0}'' 沒有類型參數
type.parameter.absent.method=方法 ''{0}'' 沒有類型參數
type.parameter.actual.inferred.mismatch=實際類型實參與推斷的類型相矛盾
type.parameter.cannot.be.followed.by.other.bounds=類型參數後面不能跟隨其他邊界
type.parameter.count.mismatch=類型實參的數量錯誤\: {0} 個；要求 {1} 個
type.parameter.duplicate=重複的類型參數\: ''{0}''
type.parameter.extends.interface.expected=此處應為接口
type.parameter.incompatible.upper.bounds=類型參數 {0} 的上限不相容\: {1}
type.parameter.inferred.type.not.within.extend.bound=類型參數 ''{0}'' 的推斷類型 ''{2}'' 不在其界限內；應擴展 ''{1}''
type.parameter.inferred.type.not.within.implement.bound=類型參數 ''{0}'' 的推斷類型 ''{2}'' 不在其界限內；應實作 ''{1}''
type.parameter.on.annotation=@interface 可能沒有類型參數
type.parameter.on.annotation.member=@interface 成員可能沒有類型參數
type.parameter.on.enum=枚舉可能沒有類型參數
type.parameter.type.not.within.extend.bound=類型參數 ''{0}'' 不在其界限內；應擴展 ''{1}''
type.parameter.type.not.within.implement.bound=類型參數 ''{0}'' 不在其界限內；應實作 ''{1}''
type.restricted.identifier=非法參照受限類型 ''{0}''
type.unknown.class=未知類別\: ''{0}''
type.void.illegal=非法類型\: 'void'
type.void.not.allowed=此處不允許使用 'void' 類型
type.wildcard.cannot.be.instantiated=萬用字元類型 ''{0}'' 不能直接實例化
type.wildcard.may.be.used.only.as.reference.parameters=萬用字元只能用作參照參數
type.wildcard.not.expected=應為非萬用字元
unary.operator.not.applicable=運算符 ''{0}'' 不能應用於 ''{1}''
underscore.identifier=從 Java 9 起，'_' 為關鍵字，不能用作關鍵字
underscore.identifier.lambda=不允許使用 '_' 作為 lambda 參數名稱
underscore.identifier.unnamed=不允許使用 '_' 作為參照
unnamed.field.not.allowed=不允許使用未命名的欄位
unnamed.method.parameter.not.allowed=不允許使用未命名的方法參數
unnamed.variable.brackets=未命名變數宣告後不允許使用中括號
unnamed.variable.not.allowed.in.this.context=此上下文中不允許使用未命名的變數宣告
unnamed.variable.without.initializer=未命名變數宣告必須具有初始設定式
value.class.extends.non.abstract=值類別只能擴展抽象值類別或 'java.lang.Object'
vararg.cstyle.array.declaration=vararg 參數中不允許 C 樣式的陣列宣告
vararg.not.last.parameter=Vararg 參數必須為列表中的最後一個參數
variable.already.assigned=變數 ''{0}'' 可能尚未被賦值
variable.already.assigned.constructor=無法在鏈式建構函式呼叫''{0}'' {1, choice, 1\#前|2\#後}為 final 欄位賦值
variable.already.assigned.field=final 欄位 ''{0}'' 已在另一個欄位初始設定式中初始化
variable.already.assigned.initializer=final 欄位 ''{0}'' 已在類別初始設定式中初始化
variable.already.defined=作用域中已定義變數 ''{0}''
variable.assigned.in.loop=變數 ''{0}'' 可能在迴圈中賦值
variable.must.be.effectively.final=變數 ''{0}'' 從內部類別中存取，需要為 final 或有效 final
variable.must.be.effectively.final.guard=guard 表達式中使用的變數應為 final 或有效 final
variable.must.be.effectively.final.lambda=lambda 表達式中使用的變數應為 final 或有效 final
variable.must.be.final=變數 ''{0}'' 從內部類別中存取，需要宣告為 final
variable.must.be.final.resource=用作 try-with-resources 資源的變數應為 final 或有效 final
variable.not.initialized=變數 ''{0}'' 可能尚未初始化
yield.unexpected='yield' 位於 switch 表達式外部
yield.void=表達式類型不應為 'void'

found.space=已找到:
html.0.has.no.corresponding.expected.declaration.1.html={0} 沒有相應的預期宣告{1}
html.0.is.not.abstract.and.does.not.implement.abstract.base.class.member.br.1.html={0} 非抽象且無法實作抽象的基類成員<br/>{1}
html.0.is.not.abstract.and.does.not.implement.abstract.member.br.1.html={0} 非抽象且無法實作抽象成員<br/>{1}
html.0.method.may.be.missing.none.of.the.following.functions.will.be.called.ul.1.ul.html=可能缺失 ''{0}'' 方法。不會調用以下函數: <ul>{1}</ul>
html.candidate.resolution.will.be.changed.soon.please.use.fully.qualified.name.to.invoke.the.following.closer.candidate.explicitly.ul.0.ul.html=候選解析即將更改，請使用完全限定名稱顯式調用以下更接近的候選: <ul>{0}</ul>
html.expected.0.has.no.actual.declaration.in.module.1.2.html=預期的 {0} 在模組 {1}{2} 中沒有實際宣告
html.accidental.override.0.html=意外覆寫: {0}
html.method.contains.from.concurrenthashmap.may.have.unexpected.semantics.it.calls.containsvalue.instead.of.containskey.br.use.explicit.form.of.the.call.to.containskey.containsvalue.contains.or.cast.the.value.to.kotlin.collections.map.instead.br.see.https.youtrack.jetbrains.com.issue.kt.18053.for.more.details.html=來自 ConcurrentHashMap 的方法 'contains' 可能具有意外的語意: 它會調用 'containsValue' 而不是 'containsKey'。<br/>使用顯式形式的 'containsKey'/'containsValue'/'contains' 調用或將值轉換為 kotlin.collections.Map。<br/>有關更多詳細資訊，請參見 https://youtrack.jetbrains.com/issue/KT-18053
html.javascript.0.html=JavaScript: {0}
html.platform.declaration.clash.0.html=平台宣告衝突: {0}
html.internal.error.occurred.while.analyzing.this.expression.br.table.cellspacing.0.cellpadding.0.tr.td.strong.please.use.the.strong.td.td.img.src.0.td.td.strong.icon.in.the.bottom.right.corner.to.report.this.error.strong.td.tr.table.br.pre.0.pre.html=分析此表達式時出現內部錯誤<br/><table cellspacing="0" cellpadding="0"><tr><td>(<strong>請使用右下角的“</strong></td><td><img src="{0}"/></td><td><strong>”圖標報告此錯誤</strong>):</td></tr></table><br/><pre>{0}</pre>
html.property.delegate.must.have.a.0.method.none.of.the.following.functions.are.suitable.ul.1.ul.html=屬性委託必須具有 ''{0}'' 方法。以下函數均不合適。<ul>{1}</ul>
html.overload.resolution.ambiguity.on.method.0.all.these.functions.match.ul.1.ul.html=方法 ''{0}'' 具有多載解析多義性。所有這些函數均符合。<ul>{1}</ul>
html.unresolved.reference.br.none.of.the.following.candidates.is.applicable.because.of.receiver.type.mismatch.ul.0.ul.html=存在未解析的引用。<br/>以下候選項均不合適，因為接收器類型不符合: <ul>{0}</ul>
html.cannot.choose.among.the.following.candidates.without.completing.type.inference.ul.0.ul.html=不完成類型推斷，將無法選擇以下候選項: <ul>{0}</ul>
html.none.of.the.following.functions.can.be.called.with.the.arguments.supplied.ul.0.ul.html=使用提供的實參無法調用以下函數。<ul>{0}</ul>
html.overload.resolution.ambiguity.all.these.functions.match.ul.0.ul.html=多載解析多義性。所有這些函數均符合。<ul>{0}</ul>
html.function.return.type.mismatch.table.tr.td.expected.td.td.1.td.tr.tr.td.found.td.td.2.td.tr.table.html=函數返回類型不符合。<table><tr><td>應為:</td><td>{1}</td></tr><tr><td>實際:</td><td>{2}</td></tr></table>
html.0.must.override.1.br.because.it.inherits.many.implementations.of.it.html={0} 必須覆寫 {1}，<br />因為它繼承了後者的許多實作
html.types.of.inherited.var.properties.do.not.match.br.0.br.1.html=繼承的 var 屬性類型不符合:<br/>{0},<br/>{1}
html.types.of.inherited.properties.are.incompatible.br.0.br.1.html=繼承的屬性類型不相容:<br/>{0}，<br/>{1}
html.actual.class.0.has.no.corresponding.members.for.expected.class.members.1.html=實際類 ''{0}'' 沒有適合預期類成員的相應成員: {1}
html.val.property.cannot.override.var.property.br.1.html=val 屬性無法覆寫 var 屬性<br />{1}
html.var.property.type.is.0.which.is.not.a.type.of.overridden.br.1.html=var 屬性類型為 {0}，它不是已覆寫項的類型<br/>{1}
required.space=需要: 
type.inference.failed.expected.type.mismatch=類型推斷失敗。預期類型不符合:
html.setter.parameter.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=setter 參數類型必須與屬性類型相等。<table><tr><td>應為:</td><td>{0}</td></tr><tr><td>實際:</td><td>{1}</td></tr></table>
html.property.type.is.0.which.is.not.a.subtype.type.of.overridden.br.1.html=屬性類型為 {0}，它不是已覆寫項的子類型<br/>{1}
html.return.types.of.inherited.members.are.incompatible.br.0.br.1.html=繼承成員的返回類型不相容:<br/>{0}，<br/>{1}
html.return.type.is.0.which.is.not.a.subtype.of.overridden.br.1.html=返回類型為 ''{0}''，它不是已覆寫項的子類型<br/>{1}
html.loop.parameter.type.mismatch.table.tr.td.iterated.values.td.td.0.td.tr.tr.td.parameter.td.td.1.td.tr.table.html=迴圈參數類型不符合。<table><tr><td>迭代的值:</td><td>{0}</td></tr><tr><td>參數:</td><td>{1}</td></tr></table>
html.type.argument.is.not.within.its.bounds.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=類型實參不在其邊界內。<table><tr><td>應為:</td><td>{0}</td></tr><tr><td>實際:</td><td>{1}</td></tr></table>
html.method.iterator.is.ambiguous.for.this.expression.ul.0.ul.html=方法 ''iterator()'' 對此表達式不明確。<ul>{0}</ul>
html.getter.return.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=getter 返回類型必須與屬性類型相等。<table><tr><td>應為:</td><td>{0}</td></tr><tr><td>實際:</td><td>{1}</td></tr></table>
html.type.inference.failed.0.html=類型推斷失敗: {0}
html.assignment.operators.ambiguity.all.these.functions.match.ul.0.ul.table.html=賦值運算符多義性。所有這些函數均符合。<ul>{0}</ul></table>
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.br.projected.type.2.restricts.use.of.br.3.html=類型不符合。<table><tr><td>要求:</td><td>{0}</td></tr><tr><td>實際:</td><td>{1}</td></tr></table><br />\n映射的類型 {2} 限制使用 <br />\n{3}\n
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=類型不符合。<table><tr><td>要求:</td><td>{0}</td></tr><tr><td>實際:</td><td>{1}</td></tr></table>

intention.suppress.family=禁止警告
intention.suppress.text=禁止{1}{2}的 ''{0}''
intention.calculating.text=正在計算快速修復…

special.module.for.files.not.under.source.root=<不在源根下的檔案的特殊模組>
sdk.0=<sdk {0}>
sources.for.library.0=<庫 {0} 的源>
library.0=<庫 {0}>
source.for.script.dependencies=<腳本依賴項的原始碼>
script.dependencies=<Script dependencies>
script.0.1=<腳本 {0} {1}>
module.name.0.test={0} (測試)
platform.module.0.including.1=<包含 {1} 的平台模組 {0}>
the.following.declarations.have.the.same.jvm.signature.code.0.1.code.br.ul.2.ul=以下宣告具有相同的 JVM 簽名(<code>{0}{1}</code>):<br/>\n<ul>\n{2}</ul>
declaration.kind.object=物件
declaration.kind.companion.object=伴生物件
declaration.kind.initializer=初始設定式
declaration.kind.statement=語句
declaration.kind.file=檔案
declaration.name.0.of.1={0}/{1}
declaration.kind.secondary.constructor.of=輔助構造函數
declaration.kind.enum.entry=枚舉條目
declaration.kind.type.parameter=類型參數
declaration.kind.class=類
declaration.kind.interface=接口
declaration.kind.fun=fun
declaration.kind.parameter=參數
type.parameters.where=where
cannot.be.inferred=無法推斷
i.for.i.br.0=<i> for </i><br/>{0}
defined.in=定義位置
root.package=根軟體套件
automatically.declared.based.on.the.expected.type=基於預期類型自動宣告
0.smart.cast.to.1={0} 智能轉換為 {1}
unknown.receiver=未知接收器
implicit.receiver=隱式接收器
extension.implicit.receiver=擴展隱式接收器
always.null=始終為 null
value.captured.in.a.closure=在閉包中捕獲的值
wrapped.into.a.reference.object.to.be.modified.when.captured.in.a.closure=在閉包中捕獲時包裝成要修改的引用物件
smart.cast.to.0.for.1.call=智能轉換為 {0} (適用於 {1} 調用)
smart.cast.to.0=智能轉換為 {0}
replace.overloaded.operator.with.function.call=將多載運算符取代為函數調用
class.initializer=<類初始設定式>
object.0=物件{0}
show.non.public=顯示非 public
show.properties=顯示屬性

klib.metadata.short=Klib 元資料
function.arguments=實參:
function.receiver.0=接收器: {0}
kotlin.built.in.declarations=Kotlin 內建宣告
kotlin.javascript.meta.file=Kotlin JavaScript 元檔案

framework.name.kotlin.sdk=Kotlin SDK
kotlin.compiler.warning=Kotlin 編譯器警告
kotlin.compiler.error=Kotlin 編譯器錯誤
kotlin.compiler.warning.0.options=編譯器警告 ''{0}'' 選項
highlighting.for.0.is.suspended=由於內部錯誤，檔案 {0} 中的語法高亮顯示已暫時關閉
highlighting.action.text.ignore=忽略更改
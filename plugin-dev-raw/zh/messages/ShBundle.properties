sh.code.style.binary.ops.like.and.may.start.a.line=允許在二元運算符後換行
sh.code.style.choose.path=選擇 Shfmt 的路徑:
sh.code.style.download.link=下載 Shfmt 格式化程序
sh.code.style.keep.column.alignment.padding=保持列對齊填充
sh.code.style.minify.program.to.reduce.its.size=縮小程序以縮減其大小
sh.code.style.unix.line.separator=使用 Unix 行分隔符(\\n)
sh.code.style.redirect.operators.will.be.followed.by.a.space=在重定向運算符後添加空格
sh.code.style.switch.cases.will.be.indented=縮排 case 語句

sh.disable.inspection.text=禁用檢查 {0}

sh.explain.command.to.explain=要解釋的指令
sh.explain.inspection.text=解釋 shell
sh.explain.message.nothing.to.explain=沒有要解釋的內容
sh.explain.title.nothing.to.explain=沒有要解釋的內容

sh.fmt.cannot.download=無法下載 shfmt 格式化程序。請手動安裝。
sh.fmt.cannot.update=無法更新 shfmt 格式化程序。回滾到上一版。
sh.fmt.formatter=Shfmt 格式化程序
sh.fmt.indent.label=縮排
sh.fmt.update.question=要更新 shell 腳本格式化程序嗎?
sh.fmt.install.question=要安裝 shell 腳本格式化程序嗎?
sh.fmt.success.update=Shell 腳本格式化程序已成功更新
sh.fmt.success.install=Shell 腳本格式化程序已成功安裝
sh.fmt.missing.formatter=缺少格式化程序

sh.parser.expected.similar.close.bracket=應為類似的右中括號
sh.path.label=路徑:

sh.rename.all.occurrences=重命名所有符合項
sh.rename.occurence=重命名 {0}

sh.shell.script=Shell 腳本
filetype.sh.shell.script.description=Shell 腳本
sh.shellcheck.download.label.text=下載 shellcheck
sh.shellcheck.cannot.download=無法下載 shellcheck。請手動安裝。
sh.shellcheck.cannot.update=無法更新 shellcheck。回滾到上一版。
sh.shellcheck.path.label=選擇 Shellcheck 的路徑:
sh.shellcheck.install.question=要安裝 shellcheck 來驗證您的 shell 腳本嗎?
sh.shellcheck.update.question=要更新 shellcheck 嗎?
sh.shellcheck.success.install=Shellcheck 已成功安裝
sh.shellcheck.success.update=Shellcheck 已成功更新
sh.shellcheck.missing=\ 缺少 shellcheck

sh.suppress.inspection=禁止 {0}
sh.unnamed.element.presentable.name=<unnamed>

sh.label.download.shfmt.formatter=下載 shfmt 格式化程序
sh.label.choose.interpreter=選擇解釋器
sh.label.choose.script.working.directory=選擇腳本工作目錄
sh.label.choose.shell.script=選擇 Shell 腳本

action.ShGenerateUntilLoop.text=Until 迴圈
action.ShGenerateUntilLoop.description=創建 until 迴圈
action.ShGenerateWhileLoop.text=While 迴圈
action.ShGenerateWhileLoop.description=創建 while 迴圈
action.ShGenerateForLoop.text=For 迴圈
action.ShGenerateForLoop.description=創建 for 迴圈
action.runShellFileAction.text=執行檔案
action.runShellFileAction.description=執行終端當前的 shell 檔案

sh.color.function.declaration=函數宣告
sh.color.conditional.operators=條件運算符
sh.color.commands.subshell.command=指令//subshell 指令
sh.color.commands.generic.command=指令//泛型指令
sh.color.redirection=重定向
sh.color.backquotes=反引號
sh.color.braces.square.brackets=大括號//方括號
sh.color.braces.curly.brackets=大括號//大括號
sh.color.braces.parentheses=大括號//圓括號
sh.color.here.documents.end=Here 文檔結束
sh.color.here.documents.start=Here 文檔開始
sh.color.here.documents=Here 文檔
sh.color.shebang.comment=Shebang 註釋
sh.color.line.comment=行註釋
sh.color.raw.string=原始字串
sh.color.string=字串
sh.color.variables.composed.variable=變數//組合變數
sh.color.variables.variable.declaration=變數//變數宣告
sh.color.variables.variable.usage=變數//變數用法
sh.color.keyword=關鍵字
sh.color.number=數字

sh.run.interpreter.options=解釋器選項:
sh.run.interpreter.path=解釋器路徑:
sh.run.interpreter=解釋器
sh.run.interpreter.not.found=找不到解釋器
sh.run.interpreter.should.be.executable=解釋器應為可執行檔案
sh.run.working.dir=工作目錄:
sh.run.working.dir.not.found=找不到工作目錄
sh.run.script.options=腳本選項:
sh.run.script.path=腳本路徑:
sh.run.script.not.found=找不到 Shell 腳本
sh.run.execute.terminal=在終端中執行
sh.run.environment.variables=環境變數:
sh.run.execute.script.text=腳本文本
sh.run.execute.script.text.title=腳本文本:
sh.run.execute.script.file=腳本檔案
sh.run.execute=執行:

sh.update=更新
sh.install=安裝
sh.no.thanks=不
sh.skip.version=跳過此版本
sh.download=下載
sh.invalid.path=無效路徑。
find.usages.type.function=函數
# {0} is non-translated 'Shell Script' - language name
sh.run.configuration.description.0.configuration={0} 設定
error.message.cannot.determine.shell.script.parent.directory=無法確定 shell 腳本的父目錄
check1000.is.not.used.specially.and.should.therefore.be.escaped=$ 應轉義。
check1001.this.o.will.be.a.regular.o.in.this.context=在此上下文中，\\o 將是一般的 'o'。
check1003.want.to.escape.a.single.quote.echo.this.is.how.it.s.done=要轉義單引號? 對 'This is how it'\'s done' 進行 echo。
check1004.this.backslash.linefeed.is.literal.break.outside.single.quotes.if.you.just.want.to.break.the.line=此反斜杠+換行符是文字。如果您想斷行，應在單引號外斷行。
check1007.remove.space.after.if.trying.to.assign.a.value.or.for.empty.string.use.var=如果要賦值，請移除 '=' 後的空格(對於空字串，請使用 var=' … )。
check.1008.this.shebang.was.unrecognized.shellcheck.only.supports.sh.bash.dash.ksh.add.a.shell.directive.to.specify=此 shebang 未被識別。ShellCheck 僅支援 sh/bash/dash/ksh。添加 'shell' 指令進行指定。
check.1009.the.mentioned.parser.error.was.in=提及的解析器錯誤位於…
check.1010.use.semicolon.or.linefeed.before.done.or.quote.to.make.it.literal=在 'done' 前使用分號或換行符(或加引號使其為文字)。
check.1011.this.apostrophe.terminated.the.single.quoted.string=這個撇號終止了帶單引號的字串!
check.1012.is.just.literal.t.here.for.tab.use.printf.instead=`\t` 此處僅為文字 `t`。要添加制表符，請改用 "$(printf '\t')"。
check.1014.use.if.cmd.then.to.check.exit.code.or.if.cmd.to.check.output=使用 'if cmd; then ..' 檢查退出程式碼，或使用 'if [ "$(cmd)" = .. ]' 檢查輸出。
check.1015.this.is.a.unicode.double.quote.delete.and.retype.it=這是 Unicode 雙引號。將其刪除並重新輸入。
check.1016.this.is.a.unicode.single.quote.delete.and.retype.it=這是 Unicode 的單引號。將其刪除並重新輸入。
check.1017.literal.carriage.return.run.script.through.tr.d=文字回車。通過 `tr -d '\n'` 執行腳本。
check.1018.this.is.a.unicode.non.breaking.space.delete.it.and.retype.as.space=這是 Unicode 的不間斷空格。將其刪除並使用空格鍵重新輸入。
check.1019.expected.this.to.be.an.argument.to.the.unary.condition=這應是一元條件的參數。
check.1020.you.need.a.space.before.the.if.single.then.else=在 `]` 或 `]]` 前添加空格
check.1026.if.grouping.expressions.inside.use=如果對 [[..]] 內部的表達式分組，請使用 ( .. )。
check.1028.in.you.have.to.escape.or.preferably.combine.expressions=在 [..] 中需要轉義 \\( \\) 或優先結合 [..] 表達式。
check.1029.in.you.shouldn.t.escape.or=在 `[[..]]` 中不應轉義 `(` 或 `)`。
check.1035.you.need.a.space.here=在此處添加空格。
check.1036.is.invalid.here.did.you.forget.to.escape.it=`(` 在此處無效。您是否忘記將其轉義?
check.1037.braces.are.required.for.positionals.over.9.e.g.10=大於 9 (例如 10)的位置需要大括號。
check.1038.shells.are.space.sensitive.use.cmd.not.cmd=Shell 會受空格影響。使用 '< <(cmd)' 而非 '<<(cmd)'。
check.1039.remove.indentation.before.end.token.or.use.and.indent.with.tabs=移除結束令牌前的縮排(或使用 `<<-` 並以制表符縮排)。
check.1040.when.using.you.can.only.indent.with.tabs=使用 <<- 時，使用制表符縮排。
check.1041.found.eof.further.down.but.not.on.a.separate.line=在更下方找到 'eof'，但不在單獨的一行中。
check.1042.found.eof.further.down.but.not.on.a.separate.line=在更下方找到 'eof'，但不在單獨的一行中。
check.1044.couldn.t.find.end.token.eof.in.the.here.document=在 here 文檔中找不到結束令牌 `EOF'。
check.1045.it.s.not.foo.bar.just.foo.bar='foo \\&; bar' 中的分號冗餘。應為 'foo \\& bar'。
check.1046.couldn.t.find.fi.for.this.if=找不到此 'if' 的 'fi'。
check.1047.expected.fi.matching.previously.mentioned.if='fi' 應符合先前提及的 'if'。
check.1048.can.t.have.empty.then.clauses.use.true.as.a.no.op=不能有空 then 子句(使用 'true' 作為無操作)。
check.1049.did.you.forget.the.then.for.this.if=您是否忘記了為這個 'if' 指定 'then'?
check.1045.expected.then=應為 'then'。
check.1051.semicolons.directly.after.then.are.not.allowed.just.remove.it=不允許在 'then' 後面直接使用分號。
check.1052.semicolons.directly.after.then.are.not.allowed.just.remove.it=不允許在 'then' 後面直接使用分號。
check.1053.semicolons.directly.after.else.are.not.allowed.just.remove.it=不允許在 'else' 後面直接使用分號。
check.1054.you.need.a.space.after.the=在 '{' 後面添加空格。
check.1058.expected.do=應為 `do`。
check.1061.couldn.t.find.done.for.this.do=找不到此 'do' 的 'done'。
check.1062.expected.done.matching.previously.mentioned.do='done' 應符合先前提及的 'do'。
check.1064.expected.a.to.open.the.function.definition=應使用 '{' 來開啟函數定義。
check.1065.trying.to.declare.parameters.don.t.use.and.refer.to.params.as.1.2=不宣告參數。使用 ()，並將參數引用為 $1、$2，以此類推。
check.1066.don.t.use.on.the.left.side.of.assignments=不在賦值的左側使用 '$'。
check.1068.don.t.put.spaces.around.the.in.assignments=不在賦值中的 '=' 周圍放置空格。
check.1069.you.need.a.space.before.the=在 '[' 前面添加空格。
check.1071.shellcheck.only.supports.sh.bash.dash.ksh.scripts.sorry=ShellCheck 僅支援 sh/bash/dash/ksh 腳本。
check.1072.unexpected=意外 ..
check.1073.couldn.t.parse.this.thing.fix.to.allow.more.checks=無法解析此項。修正以允許更多檢查。
check.1075.use.elif.instead.of.else.if=使用 'elif' 而非 'else if'。
check.1077.for.command.expansion.the.tick.should.slant.left.vs=對於指令擴展，請使用反引號: (` vs ´)。
check.1078.did.you.forget.to.close.this.double.quoted.string=您是否忘記關閉帶雙引號的字串?
check.1079.this.is.actually.an.end.quote.but.due.to.next.char.it.looks.suspect=這是右引號，但是由於下一個字符的緣故，它看起來很可疑。
check.1081.scripts.are.case.sensitive.use.if.not.if=腳本區分大小寫。使用 'if'，而不是 'If'。
check.1082.this.file.has.a.utf.8.bom.remove.it.with.lc.ctype.c.sed.1s.yourscript=此檔案具有 UTF-8 BOM。使用此指令將其移除: LC_CTYPE=C sed '1s/^...//' < yourscript
check.1083.this.is.literal.check.expression.missing.or.quote.it=此 `{`/`}` 為文字。檢查是否缺少 `;` 或使用引號將表達式引起。
check.1084.use.not.for.the.shebang=該 shebang 不是 '!#'，而是 '#!'。
check.1086.don.t.use.on.the.iterator.name.in.for.loops=不要在 for 迴圈的迭代器名稱中使用 '$'。
check.1087.use.braces.when.expanding.arrays.e.g.array.idx.or.var.to.quiet=展開陣列時使用大括號，例如: ${array[idx]} (或 ${var}[.. 以靜默)。
check.1088.parsing.stopped.here.invalid.use.of.parentheses=解析到此為止。括號使用是否無效?
check.1089.parsing.stopped.here.is.this.keyword.correctly.matched.up=解析在此處停止。此關鍵字是否正確符合?
check.1090.can.t.follow.non.constant.source.use.a.directive.to.specify.location=無法追踪非常數源。使用指令指定位置。
check.1091.not.following.error.message.here=未遵循: (此處為錯誤訊息)
check.1094.parsing.of.sourced.file.failed.ignoring.it=解析源文件失敗。忽略。
check.1095.you.need.a.space.or.linefeed.between.the.function.name.and.body=您需要在函數名稱和體之間使用空格或換行符。
check.1097.unexpected.for.assignment.use.for.comparison.use=意外 '=='。對於賦值，請使用 '='。對於比較，請將 '==' 表達式放在方括號中。
check.1098.quote.escape.special.characters.when.using.eval.e.g.eval.a.b=使用 eval 時，使用引號或轉義特殊字符，例如: eval "a=(b)"。
check.1099.you.need.a.space.before.the=在 '#' 前面添加空格。
check.1100.this.is.a.unicode.dash.delete.and.retype.as.ascii.minus=這是 Unicode 短划線。刪除並重新輸入為 ASCII 減號字符。
check.1101.delete.trailing.spaces.after.to.break.line.or.use.quotes.for.literal.space=刪除 \\ 後面的尾隨空格以斷行(或用引號表示文字空格)。
check.1102.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.command.substitution.add.a.space.after.it=Shell 以不同方式消除 $(( 歧義或根本不消除歧義。如果首個 $( 應開始指令取代，則在其後添加空格。
check.1104.use.not.just.for.the.shebang=該 shebang 不是 '!'，而是 '#!'。
check.1105.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.a.subshell.add.a.space.after.it=Shell 以不同方式消除 (( 歧義或根本不消除歧義。如果首個 ( 應開始 subshell，則在其後添加空格。
check.1107.this.directive.is.unknown.it.will.be.ignored=該指令未知。它將被忽略。
check.1108.you.need.a.space.before.and.after.the=在 '=' 前後添加空格。
check.1109.this.is.an.unquoted.html.entity.replace.with.corresponding.character=這是未加引號的 HTML 實體。取代為相應的字符。
check.1110.this.is.a.unicode.quote.delete.and.retype.it.or.quote.to.make.literal=這是 Unicode 引號。刪除或重新輸入(或加引號使其為文字)。
check.1111.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.singlequote.for.literal=這是 Unicode 引號。刪除或重新輸入(或加單引號使其為文字)。
check.1112.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.doublequote.for.literal=這是 Unicode 引號。刪除或重新輸入(或加雙引號使其為文字)。
check.1113.use.not.just.for.the.sheban=該 shebang 不是 '#'，而是 '#!'。
check.1114.remove.leading.spaces.before.the.shebang=移除 shebang 的前導空格。
check.1115.remove.spaces.between.and.in.the.shebang=在 shebang 中移除 '#' 和 '!' 之間的空格。
check.1116.missing.on.a.expression.or.use.for.arrays='$((..))' 表達式中缺少 '$'? 如果是陣列，請使用 '( ('。
check.1117.backslash.is.literal.in.prefer.explicit.escaping.n=反斜杠為 "\n" 中的文字。首選顯式轉義: "\\n"。
check.1118.delete.whitespace.after.the.here.doc.end.token=刪除 here document 結束標記後面的空格。
check.1119.add.a.linefeed.between.end.token.and.terminating=在結束令牌和終止 ')' 之間添加換行符。
check.1120.no.comments.allowed.after.here.doc.token.comment.the.next.line.instead=here document 標記後面不允許註釋。改為註釋下一行。
check.1121.add.terminators.and.other.syntax.on.the.line.with.the.not.here=在含有 '<<' 的行中添加 ;/\\& 終止符(和其他語法)，而不是在這裡添加。
check.1122.nothing.allowed.after.end.token.to.continue.a.command.put.it.on.the.line.with.the=結束令牌後面不允許有任何內容。要繼續一條指令，請將其放在包含 `<<` 的行中。
check.1123.shellcheck.directives.are.only.valid.in.front.of.complete.compound.commands.like.if.not.e.g.individual.elif.branches=ShellCheck 指令僅在 `if` 等完整複合指令(而非單個 `elif` 分支)前有效。
check.1124.shellcheck.directives.are.only.valid.in.front.of.complete.commands.like.case.statements.not.individual.case.branches=ShellCheck 指令僅在完整指令前有效，如 'case' 語句，而非單個 case 分支。
check.1126.place.shellcheck.directives.before.commands.not.after=將 ShellCheck 指令放在指令前面，而不是後面。
check.1127.was.this.intended.as.a.comment.use.in.sh=如果這是註釋，請使用 `#`。
check.1128.the.shebang.must.be.on.the.first.line.delete.blanks.and.move.comments=shebang 必須在第一行。刪除空格並移動註釋。
check.1129.you.need.a.space.before.the=在 '!' 前面添加空格。
check.1130.you.need.a.space.before.the=在 ':' 前面添加空格。
check.1131.use.elif.to.start.another.branch=使用 `elif` 開始另一個分支。
this.terminates.the.command.escape.it.or.add.space.after.to.silence=此 `\\&` 會終止指令。將其轉義或在 `\\&` 後面添加空格以靜默。
unexpected.start.of.line.if.breaking.lines.should.be.at.the.end.of.the.previous.one=意外的新行首。如需斷行，|/||/\\&\\& 應在前一個行的末尾。
arrays.implicitly.concatenate.in.use.a.loop.or.explicit.instead.of=陣列在 `[[ ]]` 中隱式串聯。使用迴圈(或顯式 '*' 來代替 '@')。
arrays.don.t.work.as.operands.in.use.a.loop.or.concatenate.with.instead.of=陣列在 '[ ]' 中不作為操作數使用。使用迴圈(或以 '*' 代替 '@' 來進行串聯)。
fgrep.is.non.standard.and.deprecated.use.grep.f.instead=fgrep 非標準，已棄用。請改用 grep -F。
egrep.is.non.standard.and.deprecated.use.grep.e.instead=egrep 非標準，已棄用。請改用 grep -E。
this.pattern.will.never.match.the.case.statement.s.word.double.check.them=此模式決不會與 case 語句的單詞符合。
this.word.is.constant.did.you.forget.the.on.a.variable=此單詞為常數。您是否忘記了變數上的 '$' 字符?
the.arguments.to.this.comparison.can.never.be.equal.make.sure.your.syntax.is.correct=此比較的參數永遠不能相等。確保您的語法正確。
this.array.element.has.no.value.remove.spaces.after.or.use.for.empty.string=該陣列元素沒有值。移除 '=' 後面的空格，或使用 "" 表示空字串。
the.here.is.literal.to.assign.by.index.use.index.value.with.no.spaces.to.keep.as.literal.quote.it=此處的等號字符 '=' 是文字。要按索引賦值，請使用 ( [index]=值 )，不帶空格。要保留為文字，請使用引號。
elements.in.associative.arrays.need.index.e.g.array.index.value=關聯陣列中的元素要求索引，例如: array=( [index]=value )。
you.can.t.have.between.this.redirection.and.the.command.it.should.apply.to=您不能在此重定向與其套用的指令之間放置 '|'。
this.redirection.doesn.t.have.a.command.move.to.its.command.or.use.true.as.no.op=此重定向沒有指令。移動到其指令(或使用 'true' 作為無操作)。
ash.scripts.will.be.checked.as.dash.add.shellcheck.shell.dash.to.silence=Ash 腳本將被檢查為 Dash。添加 '# shellcheck shell=dash' 以靜默。
tempfile.is.deprecated.use.mktemp.instead=tempfile 已棄用。請改用 mktemp。
some.finds.don.t.have.a.default.path.specify.explicitly=部分尋找沒有預設路徑。顯式指定 '.'。
quote.arguments.to.unset.so.they.re.not.glob.expanded=將實參放在引號中以忽略 glob 語法。
this.format.string.has.2.variables.but.is.passed.1.arguments=該格式字串有 2 個變數，但傳遞了 1 個實參。
this.printf.format.string.has.no.variables.other.arguments.are.ignored=此 printf 格式字串沒有變量。其他參數被忽略。
check.exit.code.directly.with.e.g.if.mycmd.not.indirectly.with=使用 'if mycmd;' 直接檢查退出程式碼，而不是使用 '$'? 間接檢查。
bash.does.not.support.multidimensional.arrays.use.1d.or.associative.arrays=Bash 不支持多維陣列。只使用一維陣列或關聯陣列。
use.array.item.to.append.items.to.an.array=使用 'array+=("item")' 將條目追加到陣列。
variable.was.used.as.an.array.but.is.now.assigned.a.string=變數被用作陣列，但現在被分配了一個字串。
time.is.undefined.for.compound.commands.time.sh.c.instead=未對組合指令定義 'time'，改用 'time sh -c'。
time.is.undefined.for.pipelines.time.single.stage.or.bash.c.instead=未對管道定義 'time'。改用單階段的 `time` 或 `time bash -c`。
quote.this.invalid.brace.expansion.since.it.should.be.passed.literally.to.eval=為此無效大括號展開加引號，因為它應照字面傳遞給 eval。
when.used.with.p.m.only.applies.to.the.deepest.directory=與 '-p' 一起使用時，'-m' 僅適用於最深的目錄。
sigkill.sigstop.can.not.be.trapped=SIGKILL 和 SIGSTOP 無法被捕獲。
trapping.signals.by.number.is.not.well.defined.prefer.signal.names=按數字捕獲信號的定義不明確。首選信號名稱。
numerical.eq.does.not.dereference.in.expand.or.use.string.operator=數字 '-'eq 在 [..] 中不取消引用。展開或使用字串運算符。
in.dash.something.is.not.supported=Dash 中不支持此功能。
local.is.only.valid.in.functions='local' 僅在函數中有效。
this.parent.loop.has.its.index.variable.overridden=此父迴圈的索引變數被覆寫。
prefer.p.q.as.p.a.q.is.not.well.defined=首選 '[ p ] \\&\\& [ q ]'，因為 '[ p -a q ]' 的定義不明確。
this.nested.loop.overrides.the.index.variable.of.its.parent=此嵌套迴圈覆寫其父級的索引變數。
use.cd.exit.in.case.cd.fails=如果持續部署失敗，請使用 cd … || exit。
this.does.not.export.foo.remove.for.that.or.use.var.to.quiet=這不會匯出 'FOO'。移除 '$' 和 '${}' 或使用 '${var?}' 以靜默。
read.without.r.will.mangle.backslashes=沒有 '-r' 的 'read' 將擾亂反斜杠。
instead.of.1.use.true=使用 'true' 代替 '[ 1 ]'。
instead.of.true.just.use.true=不使用 '[ true ]'，而是使用 'true'。
0.is.true.use.false.instead='[ 0 ]' 為 true。改用 'false'。
false.is.true.remove.the.brackets='[ false ]' 為 true。移除中括號。
argument.to.implicit.n.is.always.true.due.to.literal.strings=由於文字字串，隱式 '-n' 的實參始終為 true。
injecting.filenames.is.fragile.and.insecure.use.parameters=注入文件名脆弱且不安全。使用參數。
declare.and.assign.separately.to.avoid.masking.return.values=分別宣告和分配，避免掩蓋返回值。
var.is.referenced.but.not.assigned='var' 被引用但未賦值。
possible.misspelling.myvariable.may.not.be.assigned.but.my.variable.is=可能拼寫錯誤: MYVARIABLE 可能未分配，而分配的是 MY_VARIABLE。
can.only.return.0.255.other.data.should.be.written.to.stdout=只能返回 0-255。其他資料應寫入 stdout。
only.one.integer.0.255.can.be.returned.use.stdout.for.other.data=只能返回一個整數 0-255。將 stdout 用於其他資料。
exec.does.not.automatically.invoke.a.shell.use.exec.sh.c.for.that='-exec' 不自動調用 shell。為此使用 '-exec sh -c'。
remove.for.numeric.index.or.escape.it.for.string=對於數字索引，移除 '$' 和 '${}'；對於字串，將其轉義。
tips.depend.on.target.shell.and.yours.is.unknown.add.a.shebang=提示取決於目標 shell。添加 shebang。
literal.tilde.in.path.works.poorly.across.programs=PATH 中的文字顎化符在各個程序之間的效果不佳。
this.action.ignores.everything.before.the.o.use.to.group=此操作將忽略 '-o' 前面的所有內容。使用 \\( \\) 分組。
argument.mixes.string.and.array.use.or.separate.argument=實參混合字串和陣列。使用 '*' 或單獨的實參。
e.doesn.t.work.with.globs.use.a.for.loop='-e' 不適用於 glob。使用 for 迴圈。
use.grep.q.instead.of.comparing.output.with.n=使用 'grep -q' 而不是將輸出與 '[ -n .. ]' 相比較。
aliases.can.t.use.positional.parameters.use.a.function=別名無法使用位置參數。使用函數。
did.you.mean.ifs=是否為 IFS=$'\t' ?
word.is.on.the.form.a.b.c.b.indicated.did.you.mean.abc.or.a.b.c=\ 單詞格式為“A”B“C”(表示 B)。您是否指的是“ABC”或“A\\”B\\“C”?
this.expands.when.defined.not.when.used.consider.escaping=在定義時展開，而不是在使用時。考慮轉義。
eq.is.for.integer.comparisons.use.instead='-eq' 用於整數比較。改用 '='。
consider.using.cmd1.cmd2.file.instead.of.individual.redirects=考慮使用 '{ cmd1; cmd2; } >> file' 取代單個重定向。
expanding.an.array.without.an.index.only.gives.the.first.element=展開沒有索引的陣列只會得到第一個元素。
consider.using.grep.c.instead.of.grep.wc=考慮使用 'grep -c' 代替 'grep|wc'。
brace.expansions.and.globs.are.literal.in.assignments.quote.it.or.use.an.array=大括號展開和 glob 是賦值中的文字。使用引號或陣列。
assigning.an.array.to.a.string.assign.as.array.or.use.instead.of.to.concatenate=將陣列分配給字串! 分配為數組或使用 '*' 代替 '@' 進行串聯。
path.is.the.shell.search.path.use.another.name=PATH 是 shell 搜尋路徑。使用其他名稱。
is.not.a.valid.operator.use.a.b.instead='>=' 不是有效運算符。改用 '! a < b'。
to.assign.a.variable.use.just.var.value.no.set=要分配變數，不要使用 'set ..'，而是使用 'var=value'。
foo.references.arguments.but.none.are.ever.passed='foo' 引用了實參，但這些實參從未被傳遞。
use.foo.if.function.s.1.should.mean.script.s.1=如果函數的 '$1' 實參應表示腳本的 '$1' 實參，則使用 'foo "$@"'。
to.run.commands.as.another.user.use.su.c.or.sudo=要以其他使用者身份執行指令，請使用 'su -c' 或 'sudo'。
useless.echo.instead.of.cmd.echo.foo.just.use.cmd.foo=冗餘的 echo? 不使用 'cmd $(echo foo)'，而是使用 'cmd foo'。
use.var.to.ensure.this.never.expands.to=使用“${var:?}”確保其絕不展開至 /*。
warning.deletes.a.system.directory=警告: 刪除系統目錄。
function.keyword.is.non.standard.delete.it='function' 關鍵字非標準。將其刪除。
in.use.instead.of.o=在 '[\\[..]]' 中，不使用 '-o'，而是使用 '||'。
instead.of.a.b.use.a.b=不使用 '[ a || b ]'，而是使用 '[ a ] || [ b ]'。
in.use.instead.of.a=在 '[\\[..]]' 中，不使用 '-a'，而是使用 '\\&\\&'。
instead.of.a.b.use.a.b2=不使用 '[ a \\&\\& b ]'，而是使用 '[ a ] \\&\\& [ b ]'。
sc2106.this.only.exits.the.subshell.caused.by.the.pipeline=SC2106: 這僅退出由管道引起的 subshell。
break.is.only.valid.in.loops=`break` 僅在迴圈中有效。
in.functions.use.return.instead.of.break=在函數中，不使用 'break'，而是使用 'return'。
use.a.subshell.to.avoid.having.to.cd.back=使用 ( subshell ) 避免必須反向持續部署。
ranges.can.only.match.single.chars.mentioned.due.to.duplicates=範圍只能符合單個字符(由於重複而提及)。
named.class.needs.outer.e.g.digit=命名類需要外部 '[]'，例如: [[:digit:]\\]
use.for.arithmetics.e.g.i.i.2=為算數使用 `$((..))`，例如: i=$((i + 2))
this.expansion.will.not.see.the.mentioned.assignment=此展開將看不到提及的賦值。
this.assignment.is.only.seen.by.the.forked.process=僅在復刻行程中才能看到此賦值。
on.most.os.shebangs.can.only.specify.a.single.parameter=在大多數操作系統中，shebang 只能指定一個參數。
add.dev.null.to.prevent.ssh.from.swallowing.stdin=添加 '< /dev/null' 以防止 ssh 吞下 stdin。
sc2094.make.sure.not.to.read.and.write.the.same.file.in.the.same.pipeline=SC2094 確保不要在同一管道中讀取和寫入同一檔案。
remove.exec.if.script.should.continue.after.this.command=如果腳本應在此指令後繼續，則移除 "exec "。
remove.backticks.to.avoid.executing.output=移除反引號以避免執行輸出。
remove.surrounding.to.avoid.executing.output=移除環繞的 '$()' 以避免執行輸出。
quotes.backslashes.in.this.variable.will.not.be.respected=該變數中的引號和反斜杠將不被遵循。
quotes.backslashes.will.be.treated.literally.use.an.array=引號和反斜杠將按文字處理。使用陣列。
tilde.does.not.expand.in.quotes.use.home=引號中的顎化符不會展開。使用 $HOME。
quote.eof.to.make.here.document.expansions.happen.on.the.server.side.rather.than.on.the.client=在 'EOF' 周圍添加引號，以使 here document 在服務器端而不是在客戶端展開。
double.quote.to.prevent.globbing.and.word.splitting=使用雙引號防止亂碼和單詞分割。
remove.or.use.expr.to.avoid.executing.output=移除 '$' 或使用 '_=$((expr))' 以避免執行輸出。
to.expand.via.indirection.use.name.foo.n.echo.name=要通過間接展開，請使用 name="foo$n"; echo "${!name}"。
can.t.match.globs.use.or.grep=`[ .. ]` 無法符合 glob。使用 `[[ .. ]]` 或 grep。
numbers.with.leading.0.are.considered.octal=認為前導 0 的數字為八進制。
doesn.t.support.decimals.use.bc.or.awk='(( ))' 不支持十進制。使用 'bc' 或 'awk'。
this.expression.is.constant.did.you.forget.a.somewhere=此表達式為常數。您是否遺忘了 `$`?
you.need.spaces.around.the.comparison.operator=比較運算符周圍需要空格。
don.t.quote.rhs.of.it.ll.match.literally.rather.than.as.a.regex=不要為 =~ 的 rhs 加引號，它會按文字符合而不是作為正則表達式。
can.t.use.in.use.instead=無法在 `[ ]` 中使用 `=~`。改用 `[[..]]`。
decimals.are.not.supported.either.use.integers.only.or.use.bc.or.awk.to.compare=不支持十進制。僅使用整數，或使用 'bc' 或 'awk' 進行比較。
is.for.string.comparisons.use.gt.instead='>' 用於字串比較。改用 '-gt'。
n.doesn.t.work.with.unquoted.arguments.quote.or.use=`-n` 不適用於未加引號的參數。加引號或使用 ``[[ ]]``。
to.redirect.stdout.stderr.2.1.must.be.last.or.use.cmd.file.2.1.to.clarify=要重定向 stdout+stderr，'2>\\&1' 必須是最後一個(或者用 '{ cmd > file; } 2>\\&1' 說明)。
double.quote.array.expansions.to.avoid.re.splitting.elements=用雙引號引起陣列擴展，避免重新分割元素。
missing.or.terminating.exec.you.can.t.use.and.has.to.be.a.separate.quoted.argument=缺少 ';' 或 '+' 將終止 '-exec'。不使用 |/||/\\&\\&，並使用引號將 ';' 引起。
since.you.double.quoted.this.it.will.not.word.split.and.the.loop.will.only.run.once=由於您用雙引號將其引起，因此單詞不會分割，並且迴圈將只執行一次。
this.is.interpreted.as.a.shell.file.redirection.not.a.comparison=這被解釋為 shell 檔案重定向，而非比較。
use.single.quotes.otherwise.this.expands.now.rather.than.when.signalled=僅在發出信號時才使用單引號展開，而不是立即展開。
grep.uses.regex.but.this.looks.like.a.glob=Grep 使用正則表達式，但這看起來像是 glob。
quote.the.grep.pattern.so.the.shell.won.t.interpret.it=為 grep 模式加引號，這樣 shell 就不會解釋它。
quote.the.parameter.to.name.so.the.shell.won.t.interpret.it=為 '-name' 的參數加引號，這樣 shell 就不會解釋它。
quote.parameters.to.tr.to.prevent.glob.expansion=為 'tr' 的參數加引號，防止 glob 展開。
don.t.use.variables.in.the.printf.format.string.use.printf.s.foo=不要在 printf 格式字串中使用變數。而是使用如下語法: printf "..%s.." "$foo"。
unknown.unaryoperator=未知一元運算符。
unknown.binary.operator=未知二元運算符。
you.probably.wanted.here=使用 '\\&\\&'.
use.spaces.not.commas.to.separate.array.elements=使用空格而非逗號分隔陣列元素。
quote.the.rhs.of.in.to.prevent.glob.matching=在 '[[ ]]' 中為 'rhs of =' 加引號，防止 glob 符合。
bash.doesn.t.support.variables.in.brace.range.expansions=Bash 在大括號範圍展開中不支持變數。
this.expression.is.constant.did.you.forget.the.on.a.variable=此表達式為常數。您是否遺忘了變數上的 `$`?
is.for.regex.but.this.looks.like.a.glob.use.instead='=~' 用於正則表達式，但這看起來像是 glob。改用 '='。
use.with.quotes.to.prevent.whitespace.problems=使用“$@”(不帶引號)防止空格問題。
quote.this.to.prevent.word.splitting=使用引號將其引起，以防止單詞分割。
iterating.over.ls.output.is.fragile.use.globs=對 ls 輸出進行迭代較為脆弱。使用 glob。
for.loops.over.find.output.are.fragile.use.find.exec.or.a.while.read.loop=find 輸出上的 for 迴圈較脆弱。使用 'find -exec' 或 while read 迴圈。
this.loop.will.only.ever.run.once.for.a.constant.value.did.you.perhaps.mean.to.loop.over.dir.var.or.cmd=此迴圈只對一個常量值執行一次。是否想在 'dir/*'、'$var' 或 '$(cmd)'上迴圈?
this.is.a.literal.string.to.run.as.a.command.use.instead.of=這是文字字串。要作為指令執行，不要使用 '..'，而是使用 '$(..)'。
bin.sh.was.specified.so.is.not.supported.even.when.sh.is.actually.bash='#!/bin/sh' 已指定，因此即使 sh 實際是 bash 也不支持 ____。
in.posix.sh.something.is.undefined=在 POSIX sh 中，某些行為未定義。
use.print0.0.or.find.exec.to.allow.for.non.alphanumeric.filenames=使用 '-print0'、'-0' 或 'find -exec +'，以允許使用非字母數字文件名。
to.assign.the.output.of.a.command.use.var.cmd=要分配指令的輸出，請使用 'var=$(cmd)'。
if.you.wanted.to.assign.the.output.of.the.pipeline.use.a.b.c=如果您想分配管道的輸出，請使用 'a=$(b | c)'。
use.glob.or.glob.so.names.with.dashes.won.t.become.options=使用 './\\*glob*' 或 '-- \\*glob*'，以使帶短劃線的名稱不會成為選項。
foo.appears.unused.verify.it.or.export.it='foo' 似乎未使用。對其進行驗證或匯出。
shell.functions.can.t.be.passed.to.external.commands=Shell 函數不能傳遞給外部指令。
use.own.script.or.sh.c.to.run.this.from.su=使用自身腳本或 sh -c '..' 從 su 執行。
var.was.modified.in.a.subshell.that.change.might.be.lost=在 subshell 中對 'var' 進行了修改。這種變更可能丟失。
modification.of.var.is.local.to.subshell.caused.by.pipeline='var' 的修改是局部的(對於管道引起的 subshell)。
note.that.unescaped.this.expands.on.the.client.side=如果未轉義，將在客戶端展開。
echo.won.t.expand.escape.sequences.consider.printf='echo' 不會展開轉義序列。考慮使用 'printf'。
the.surrounding.quotes.actually.unquote.this.remove.or.escape.them=周圍的引號實際取消了引號。將其移除或轉義。
this.word.is.outside.of.quotes.did.you.intend.to.nest.single.quotes.instead=這個詞在引號之外。您是想 '嵌套 '"'單引號'"' 嗎?
make.sure.all.escape.sequences.are.enclosed.in.to.prevent.line.wrapping.issues=確保所有轉義序列都被 `\\[..\\]` 封閉，防止出現換行問題
sudo.doesn.t.affect.redirects.use.sudo.tee.file=`sudo` 不影響重定向。使用 `..| sudo tee file`
note.that.unlike.globs.o.here.matches.ooo.but.not.oscar=請注意，不同於 glob，'o*' 在此處符合 'ooo' 而非 'oscar'
don.t.use.around.ranges.in.tr.it.replaces.literal.square.brackets=不要在 'tr' 範圍內使用 '[]'，它會取代文字方中括號。
tr.replaces.sets.of.chars.not.words.mentioned.due.to.duplicates='tr' 取代字符集，而非單詞(由於重複而提及)。
use.upper.to.support.accents.and.foreign.alphabets=使用 '[:upper:]' 支援重音和外來字母。
use.lower.to.support.accents.and.foreign.alphabets=使用 '[:lower:]' 支援重音和外來字母。
increase.precision.by.replacing.a.b.c.with.a.c.b=將 'a/b\\*c' 取代為 'a\\*c/b' 以提高精度。
expressions.don.t.expand.in.single.quotes.use.double.quotes.for.that=表達式不套用單引號展開，使用雙引號。
note.that.a.b.c.is.not.if.then.else.c.may.run.when.a.is.true=注意，'A \\&\\& B || C' 並非 'if-then-else'。A 為 true 時 C 可能執行。
this.will.expand.once.before.find.runs.not.per.file.found=這將在 find 執行之前展開一次，而不是針對每個檔案。
to.read.lines.rather.than.words.pipe.redirect.to.a.while.read.loop=要讀取行而不是單詞，應通過管道通向或重定向輸出到 'while read' 迴圈。
use.find.instead.of.ls.to.better.handle.non.alphanumeric.filenames=使用 `find` 而不是 `ls` 以更好地處理非字母數字文件名。
don.t.use.ls.grep.use.a.glob.or.a.for.loop.with.a.condition.to.allow.non.alphanumeric.filenames=不要使用 'ls | grep'。使用 glob 或 for 迴圈與條件，以允許使用非字母數字文件名。
sc2009.consider.using.pgrep.instead.of.grepping.ps.output=SC2009 考慮使用 pgrep 代替 grepping ps 輸出。
echo.doesn.t.read.from.stdin.are.you.sure.you.should.be.piping.to.it='echo' 不從 stdin 讀取。不建議通過管道來通向它。
use.instead.of.deprecated=不使用棄用的 '$[..]'，而是使用 '$((..))'。
use.notation.instead.of.legacy.backticked=不使用過去的反引號 `` `...` `，而是使用 '$(...)' 表示法。
useless.echo.instead.of.echo.cmd.just.use.cmd=冗餘的 `echo`? 不使用 `echo $(cmd)`，而是使用 `cmd`。
is.unnecessary.on.arithmetic.variables='$' 和 '${}' 在算術變數上不必要。
expr.is.antiquated.consider.rewriting.this.using.or='expr' 已過時。可使用 '$((..))'、'${}' 或 '\\[\\[ \\]\\]' 進行覆寫。
useless.cat.consider.cmd.file.or.cmd.file.instead=冗餘的 'cat'。可以考慮改用 'cmd < file | ..' 或 'cmd file | ..'。
sc2001.see.if.you.can.use.variable.search.replace.instead=SC2001: 確認是否可改用 ${variable//search/replace}。
consider.adding.a.default.case.even.if.it.just.exits.with.error=考慮添加預設 '*)' case，即便它因為錯誤而退出。
flip.leading.and.if.this.should.be.a.quoted.substitution=如果這應是加引號的取代，則翻轉前導 '$' 和 '"'。
this.shebang.specifies.a.directory.ensure.the.interpreter.is.a.file=該 shebang 指定目錄。確保解釋器是檔案。
d.only.applies.to.the.first.expansion.of.this.glob.use.a.loop.to.check.any.all='-d' 僅適用於此 glob 的第一個展開。使用迴圈檢查任意一個/全部。
prefer.explicit.n.to.check.non.empty.string.or.use.ne.to.check.boolean.integer=首選顯式 '-n' 檢查非空字串。使用 '=' 或 '-ne' 檢查布林值和整數。
prefer.explicit.n.to.check.for.output.or.run.command.without.to.check.for.success=首選顯式 '-n' 檢查輸出。執行無 '[' 和 '[[' 的指令以檢查成功與否。
can.only.exit.with.status.0.255.other.data.should.be.written.to.stdout.stderr=只能以 0-255 狀態退出。其他資料應寫入 stdout/stderr。
the.exit.status.can.only.be.one.integer.0.255.use.stdout.for.other.data=退出狀態只能是一個整數 0-255。將 stdout 用於其他資料。
the.dot.command.does.not.support.arguments.in.sh.dash.set.them.as.variables=dot 指令不支持 sh/dash 中的參數。將它們設定為變數。
ensure.the.shebang.uses.the.absolute.path.to.the.interpreter=確保 shebang 指定解釋器的絕對路徑。
redirecting.to.from.command.name.instead.of.file.did.you.want.pipes.xargs.or.quote.to.ignore=重定向到或重定向自指令名稱而非檔案。改用管道或 xargs (或加引號以忽略)。
use.n.instead.of.z=使用 `[ -n .. ]` 而不是 `! [ -z .. ]`。
use.n.instead.of.z2=使用 `-n` 而不是 `! -z`。
use.instead.of.to.avoid.subshell.overhead=使用 `{ ..; }` 而非 `(..)` 以避免 subshell 開銷。
remove.superfluous.around.test.command=移除測試指令周圍多餘的 `(..)`。
remove.superfluous.around.condition=移除條件周圍多餘的 `(..)`。
can.t.use.sudo.with.builtins.like.cd.did.you.want.sudo.sh.c.instead=無法對 'cd' 等內建項使用 'sudo'。改用 'sudo sh -c'。
quote.expansions.in.this.for.loop.glob.to.prevent.wordsplitting.e.g.dir.txt=在此 for 迴圈 glob 中為展開加引號，防止單詞分割，例如: "$dir"/*.txt
which.is.non.standard.use.builtin.command.v.instead=非標準 'which'。改用內建的 'command -v'。
this.does.not.read.foo.remove.for.that.or.use.var.to.quiet=這不會讀取 'foo'。移除 '$' 和 '${}' 或使用 '${var?}' 以靜默。
redirection.applies.to.the.find.command.itself.rewrite.to.work.per.action.or.move.to.end=重定向適用於 'find' 指令本身。覆寫到每個操作的工作(或移至末尾)。
this.ln.has.no.destination.check.the.arguments.or.specify.explicitly=此 'ln' 沒有目標。檢查實參，或顯式指定 '.'。
this.cp.has.no.destination.check.the.arguments=此 'cp' 沒有目標。檢查實參。
this.mv.has.no.destination.check.the.arguments=此 'mv' 沒有目標。檢查實參。
this.default.assignment.may.cause.dos.due.to.globbing.quote.it=此預設賦值可能會由於 glob 而導致 DoS。使用引號將其引起。
this.pattern.never.matches.because.of.a.previous.pattern=由於先前的模式，此模式永遠不會符合。
this.pattern.always.overrides.a.later.one=此模式始終會覆寫後續模式。
invalid.flags.are.not.handled.add.a.case=不處理無效的標誌。添加一個 `*)` case。
instead.of.let.expr.prefer.expr=相較於 `let expr` 更偏好 `(( expr ))`。
this.function.is.only.defined.later.move.the.definition.up=此函數僅在後續定義。向上移動定義。
redirecting.to.echo.a.command.that.doesn.t.read.stdin.bad.quoting.or.missing.xargs=重定向到 'echo'，一個不讀取 stdin 的指令。引號使用錯誤還是缺少 xargs?
piping.to.rm.a.command.that.doesn.t.read.stdin.wrong.command.or.missing.xargs=管道通向 'rm'，一個不讀取 stdin 的指令。指令錯誤還是缺少 xargs?
this.flag.is.used.as.a.command.name.bad.line.break.or.missing=此標誌被用作指令名稱。換行錯誤還是缺少 `[ .. ]`?
this.case.is.not.specified.by.getopts='getopts' 未指定此 case。
getopts.specified.n.but.it.s.not.handled.by.this.case='getopts' 指定了 '-n'，但未被此 'case' 處理。
use.false.instead.of.empty.conditionals=使用 'false'，不使用空的 '[' 和 '[[' 條件。
this.is.a.glob.used.as.a.command.name.was.it.supposed.to.be.in.array.or.is.it.missing.quoting=這是一個用作指令名稱的 glob。它是應該在 ''${..}'' 還是陣列中? 如果不是，使用引號。
this.is.a.file.redirection.was.it.supposed.to.be.a.comparison.or.fd.operation=這是檔案重定向。它應是比較還是 fd 運算?
use.var.command.to.assign.output.or.quote.to.assign.string=使用 'var=$(command)' 分配輸出(或加引號以分配字串)。
use.or.quote.arguments.to.v.to.avoid.glob.expansion=使用 `[[ ]]` 或為 '-v' 選項的實參加引號以避免 glob 展開。
prefer.mapfile.or.read.a.to.split.command.output.or.quote.to.avoid.splitting=首選 'mapfile' 或 'read -a' 以分割指令輸出(或加引號以避免分割)。
quote.to.prevent.word.splitting.or.split.robustly.with.mapfile.or.read.a=加引號以防止單詞分割，或使用 'mapfile' 或 'read -a' 進行穩健分割。
is.a.subshell.did.you.mean.a.test.expression='(..)' 為 subshell。您是否指的是測試表達式 '[ .. ]'?
globs.are.ignored.in.except.right.of.use.a.loop=除了 '=' 和 '!=' 的右側外，glob 在 `[[ ]]` 中被忽略。使用迴圈。
globs.don.t.work.as.operands.in.use.a.loop=glob 不能用作 '[ ]' 中的操作數。使用迴圈。
brace.expansion.doesn.t.happen.in.use.a.loop=大括號展開不會在 `[[ ]]` 中發生。使用迴圈。
brace.expansions.don.t.work.as.operands.in.use.a.loop=大括號展開不能用作 '[ ]' 中的操作數。使用迴圈。
error.message.can.t.find.info.in.your.path=在 $PATH 變數中找不到資訊。
# {)} is a file name
line.marker.run.0=執行 {0}
i.do.mind.path.placeholder=我會在意
display.name.shell.check=ShellCheck
intention.shell.script=Shell 腳本
sh.markdown.runner.title=在終端中執行
notification.group.shell.script=有可用的 shell 腳本工具
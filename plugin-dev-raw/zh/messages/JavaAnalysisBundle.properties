add.explicit.type.arguments=添加顯式類型實參

# suppress inspection "UnusedProperty"
annotation.target.ANNOTATION_TYPE=注解類型
# suppress inspection "UnusedProperty"
annotation.target.CONSTRUCTOR=構造函數
# suppress inspection "UnusedProperty"
annotation.target.FIELD=字段
# suppress inspection "UnusedProperty"
annotation.target.LOCAL_VARIABLE=局部變量
# suppress inspection "UnusedProperty"
annotation.target.METHOD=方法
# suppress inspection "UnusedProperty"
annotation.target.MODULE=模塊
# suppress inspection "UnusedProperty"
annotation.target.PACKAGE=軟件包
# suppress inspection "UnusedProperty"
annotation.target.PARAMETER=形參
# suppress inspection "UnusedProperty"
annotation.target.RECORD_COMPONENT=記錄組件
# suppress inspection "UnusedProperty"
annotation.target.TYPE=類型
# suppress inspection "UnusedProperty"
annotation.target.TYPE_PARAMETER=類型形參
# suppress inspection "UnusedProperty"
annotation.target.TYPE_USE=類型使用

change.type.arguments=更改類型實參
change.type.arguments.to.0=將類型實參更改為 <{0}>
convert.0.to.float=將 ''{0}'' 轉換為 float

dataflow.message.array.index.out.of.bounds=數組索引超出範圍
dataflow.message.negative.array.size=數組大小為負
dataflow.message.arraystore=將 <code>{0}</code> 類型的元素存儲到 <code>{1}</code> 元素的數組將生成 <code>ArrayStoreException</code>
dataflow.message.assigning.null.notannotated=正在將 <code>null</code> 值指定給非注解字段
dataflow.message.assigning.null=<code>null</code> 被分配到一個是注解變量 @NotNull
dataflow.message.assigning.nullable.notannotated=表達式 <code>#ref</code> #loc 可能為 null，但被指定給非注解字段
dataflow.message.assigning.nullable=表達式 <code>#ref</code> 可能為 null ,但是它被分配了注解 @NotNull
dataflow.message.cce.always=將 <code>{0}</code> 轉換為 <code>#ref</code> #loc 會為任意非 null 值生成 <code>ClassCastException</code>
dataflow.message.cce=從<code>{0}</code> 到 <code>#ref</code> #loc 可能產生 <code>java.lang.ClassCastException</code>
dataflow.message.constant.condition.when.reached=到達時，條件 <code>#ref</code> #loc 始終為 <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.condition=條件 <code>#ref</code> #loc 始終為 <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.method.reference=方法引用結果始終為''{0}''
dataflow.message.constant.no.ref=條件始終為 {0, choice, 0#false|1#true}
dataflow.message.contract.fail.index=由於實參超出範圍，對 '#ref' 的調用總是失敗
dataflow.message.contract.fail=依據其方法約定，對 '#ref' 的調用始終失敗
dataflow.message.immutable.modified=不可變對象已被修改
dataflow.message.immutable.passed=不可變對象在預期可變位置傳遞
dataflow.message.npe.array.access.sure=數組訪問 <code>#ref</code> #loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.array.access=數組訪問 <code>#ref</code> #loc 可能產生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access.sure=引用 <code>#ref</code> #loc 會產生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access=取消引用<code>#ref</code> #loc 可能導致 <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=內部類構造將生成 <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=內聯類建立可能會產生<code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=方法調用 <code>#ref</code> #loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.method.invocation=方法調用 <code>#ref</code> #loc 可能產生 <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=方法引用調用 <code>#ref</code> #loc 可能會產生 <code>java.lang.NullPointerException</code>
dataflow.message.only.switch.label=Switch 標籤 <code>#ref</code> #loc 是整個 switch 中唯一可訪問的對象
dataflow.message.passing.null.argument.nonannotated=正在將 <code>null</code> 實參傳遞到非注解形參
dataflow.message.passing.null.argument=正在將 <code>null</code> 實參傳遞到注解為 @NotNull 的形參
dataflow.message.passing.nullable.argument.methodref.nonannotated=方法引用實參可能為 null，但被傳遞給非注解形參
dataflow.message.passing.nullable.argument.methodref=方法引用實參可能為空
dataflow.message.passing.nullable.argument.nonannotated=實參 <code>#ref</code> #loc 可能為 null，但被傳遞給非注解形參
dataflow.message.passing.nullable.argument=實參 <code>#ref</code> #loc 可能為null
dataflow.message.passing.non.null.argument.to.optional=正在將非 null 實參傳遞到 <code>Optional</code>
dataflow.message.passing.null.argument.to.optional=正在將 <code>null</code> 實參傳遞到 <code>Optional</code>
dataflow.message.pointless.assignment.expression=條件 <code>#ref</code> #loc 在賦值表達式的左側是永遠 <code>{0}</code>. 可以簡化
dataflow.message.pointless.same.arguments='#ref' 的實參相同。調用包含相同實參的此方法毫無意義
dataflow.message.pointless.same.argument.and.result='#ref' 的結果與{0,choice,1#第 1 個|2#第 2 個}實參相同使調用毫無意義
dataflow.message.redundant.assignment=變量已被指定給此值
dataflow.message.redundant.instanceof=條件 <code>#ref</code> #loc是多餘的，可以用 <code>!= null</code>
dataflow.message.redundant.update=變量更新不執行任何操作
dataflow.message.return.notnull.from.nullable=@{0} 方法 ''{1}'' 始終返回非 null 值
dataflow.message.return.null.from.notnull=<code>null</code> 由聲明為 @{0} 的方法返回
dataflow.message.return.null.from.notnullable=<code>null</code> 由未被聲明為 @{0} 的方法返回
dataflow.message.return.nullable.from.notnull.function=函數可能返回null,但這裡不允許
dataflow.message.return.nullable.from.notnull=表達式 <code>#ref</code> 可能會評估為 null，但由聲明為 @{0} 的方法返回
dataflow.message.return.nullable.from.notnullable=表達式 <code>#ref</code> 可能會評估為 null，但由未被聲明為 @{0} 的方法返回
dataflow.message.storing.array.null=<code>null</code> 已存儲到 @NotNull 元素的數組中
dataflow.message.storing.array.nullable=表達式 <code>#ref</code> 可能會評估為 null，但已存儲到 @NotNull 元素的數組
dataflow.message.unboxing.nullable.argument.methodref=將實參傳遞到方法引用需要拆箱，這可能會產生 <code>NullPointerException</code>
dataflow.message.unboxing.method.reference=使用 <code>#ref</code> #loc 需要取消裝箱，這可能會產生 <code>java.lang.NullPointerException</code>
dataflow.message.unboxing=拆箱的 <code>#ref</code> #loc 可能產生 <code>java.lang.NullPointerException</code>
dataflow.message.unreachable.switch.label=Switch 標籤 <code>#ref</code> #loc 不可到達
dataflow.message.constant.expression=<code>#ref</code> #loc 的結果總是 ''{0}''
dataflow.message.constant.value=值 <code>#ref</code> #loc 總是 ''{0}''
dataflow.method.fails.with.null.argument=當形參為 null 時，方法將拋出異常
dataflow.message.unknown.nullability=(可 null 性未知)
dataflow.not.precise={0} 複雜: 數據流結果可能不準確
dataflow.too.complex=方法 <code>#ref</code> 太複雜，無法通過數據流算法進行分析

delete.repeated.0=刪除重複的 ''{0}''
delete.repeated.interface=刪除重複的接口
exception.removal.will.break.source.code.proceed.anyway=異常移除會破壞源代碼。仍然繼續?

feature.generics=泛型
feature.annotations=注解
feature.static.imports=靜態導入
feature.for.each=For-each 循環
feature.varargs=可變 arity 方法
feature.hex.fp.literals=十六進制浮點文字
feature.diamond.types=Diamond 類型
feature.multi.catch=多 catch
feature.try.with.resources=Try-with-resources
feature.binary.literals=二進制文字
feature.underscores.in.literals=在文字中加下划線
feature.extension.methods=擴展方法
feature.method.references=方法引用
feature.lambda.expressions=Lambda 表達式
feature.type.annotations=類型注解
feature.type.receivers=接收器形參
feature.intersections.in.casts=轉換中的交叉類型
feature.static.interface.calls=static 接口方法調用
feature.try.with.resources.refs=資源引用
feature.modules=模塊
feature.lvti=局部變量類型推理
feature.var.lambda.parameter=lambda 形參中的 'var'
feature.text.blocks=文本塊文字
feature.text.block.escape.sequences='\\s' 和 '\' 轉義序列
feature.enhanced.switch=增強的 'switch' 塊
feature.switch.expressions='switch' 表達式
feature.records=記錄
feature.patterns.instanceof='instanceof' 中的模式
feature.sealed.classes=密封類
feature.local.interfaces=本地接口
feature.local.enums=本地枚舉
feature.inner.statics=內部類中的 static 聲明

find.searching.for.references.to.class.progress=正在查找對類 {0} 的引用…
find.usages.panel.title.derived.classes=派生類
find.usages.panel.title.derived.interfaces=派生接口
find.usages.panel.title.implementing.classes=實現類
find.usages.panel.title.implementing.methods=實現方法
find.usages.panel.title.overloaded.methods.usages=重載方法
find.usages.panel.title.overriding.methods=重寫方法
message.class.inaccessible.from.module=類 ''{0}'' 無法從模塊 ''{1}'' 訪問
message.class.inaccessible=類 ''{0}'' 無法在此處訪問

inspection.i18n.quickfix.annotate=注解…
inspection.i18n.quickfix.annotate.as=注解為 @{0}
inspection.i18n.quickfix.annotate.element=註釋 {0} ''{1}''…
inspection.i18n.quickfix.annotate.element.as=在{0} ''{1}'' 上添加注解 @{2}
inspection.reference.default.package=<預設>
error.message.invalid.java.type=無效的 Java 類型
move.0.to.the.beginning=將 ''{0}'' 移動到開頭
move.to.front=移到前面
processing.method.usages=正在處理方法用例…
qualify.0=限定 {0}
qualify.with.0.this=使用 {0}.this 限定
remove.annotation=移除注解
remove.left.side.of.assignment=移除賦值的左側
replace.get.class.with.class.literal=使用 .class 文字替換 getClass()
service.provides=提供服務
service.uses=使用服務
suppress.for.parameter=對形參禁止
suppress.for.statement.with.comment=對包含註釋的語句禁止
intention.add.annotation.family=添加注解
intention.add.type.annotation.family=添加類型注解
intention.text.remove.annotation=移除

scope.package=軟件包 {0}

0.field.is.always.initialized.not.null=@{0} 字段始終為初始化的非 null
access.can.be.0=訪問可以是 {0}
access.to.field.code.ref.code.outside.of.declared.guards.loc=訪問聲明的臨界外部的字段 <code>#ref</code> #loc
call.to.method.code.ref.code.outside.of.declared.guards.loc=在聲明的臨界之外調用方法 <code>#ref()</code> #loc
annotate.as.safevarargs=注解為 '@SafeVarargs'
annotate.overridden.methods.parameters.family.name=注解被重寫的方法形參
annotate.overridden.methods.parameters=將被重寫的方法形參注解為 ''@{0}''
anonymous.ref.loc.can.be.replaced.with.0=匿名 #ref #loc 可以替換為 {0}
anonymous.ref.loc.can.be.replaced.with.lambda=匿名 #ref #loc 可以替換為 lambda
assigning.a.collection.of.nullable.elements=正在將可空元素集合指定給非空元素集合
nullable.stuff.error.overriding.nullable.with.notnull=使用非 null 元素集合重寫可 null 元素的集合
nullable.stuff.error.overriding.notnull.with.nullable=使用可 null 元素集合重寫非 null 元素的集合
comparision.between.object.and.primitive=對象與基元之間的比較非法，僅在 java 7 中接受
custom.exception.class.should.have.a.function Object() { [native code] }=自定義異常類應具有一個包含字符串類型的單個消息形參的構造函數
delimiters.argument.contains.duplicated.characters=分隔符實參包含重複的字符
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=棄用的成員 ''{0}'' 仍在使用
detach.library.quickfix.name=分離庫
detach.library.roots.quickfix.name=分離未使用的庫根
don.t.report.unused.jars.inside.used.library=不要在使用的庫內報告未使用的 jar
explicit.type.argument.ref.loc.can.be.replaced.with=顯式類型實參 #ref #loc 可以替換為 <>
exports.to.itself.delete.module.ref.fix=刪除模塊''{0}''的引用
exports.to.itself.delete.statement.fix=刪除聲明
html.classes.exposed.with.code.module.info.code.html=<html>類通過 <code>module-info</code> 公開</html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>在未棄用的 super 中忽略棄用的 abstract 方法的重寫</html>
ignore.casts.in.suspicious.collections.method.calls=忽略澄清轉換
ignore.exceptions.thrown.by.entry.points.methods=忽略由入口點方法引發的異常
ignore.in.the.same.outermost.class=在相同的最外側類中忽略
ignore.inside.deprecated.members=在棄用的成員內忽略
ignore.inside.non.static.imports=在非靜態導入內忽略
ignore.members.of.deprecated.classes=忽略棄用類的成員
ignore.operation.which.results.in.negative.value=忽略 '<<' 操作，後者會導致負值
inspection.annotate.method.quickfix.family.name=標註方法
inspection.annotate.method.quickfix.name=使用 ''@{0}'' 注解方法
inspection.annotate.overridden.method.and.self.quickfix.family.name=注解重寫的方法和本身
inspection.annotate.overridden.method.and.self.quickfix.name=使用 ''@{0}'' 注解重寫的方法和本身
inspection.annotate.overridden.method.quickfix.family.name=註釋覆蓋方法
inspection.annotate.overridden.method.quickfix.name=使用 ''@{0}'' 注解重寫的方法
inspection.annotate.overridden.method.nullable.quickfix.name=將重寫的方法注解為 ''@{0}''
inspection.c.style.array.declarations.option=忽略變量中的 C 樣式聲明
inspection.can.be.final.accept.quickfix=設為 final
inspection.can.be.final.option1=報告方法
inspection.can.be.final.option2=報告字段
inspection.can.be.final.option=報告類
inspection.can.be.local.parameter.problem.descriptor=形參 <code>#ref</code> 可以具有 <code>final</code> 修飾符
inspection.can.be.local.variable.problem.descriptor=變量 <code>#ref</code> 可以具有 <code>final</code> 修飾符
inspection.can.be.replaced.with.message=可以替換為 ''{0}''
inspection.class.getclass.display.name='Class.getClass()' 調用可疑
inspection.class.getclass.fix.remove.name=移除 'getClass()' 調用
inspection.class.getclass.fix.replace.name=替換為 'Class.class'
inspection.class.getclass.message=在類實例上調用了 'getClass()'
inspection.class.has.no.to.string.method.description=類 ''{0}'' 不會重寫 ''function toString() { [native code] }()'' 方法
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=排除類 (reg exp):
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=忽略 abstract 類
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=忽略棄用的類
inspection.class.has.no.to.string.method.ignore.enum.classes.option=忽略枚舉類
inspection.class.has.no.to.string.method.ignore.records.option=忽略記錄
inspection.class.has.no.to.string.method.ignore.exception.classes.option=忽略異常類
inspection.class.has.no.to.string.method.ignore.inner.classes.option=忽略內部類
inspection.class.has.no.to.string.method.ignore.test.classes.option=忽略測試類
inspection.common.if.parts.disable.highlight.tail.call=如果尾語句是調用，則不要高亮顯示公用部分
inspection.common.if.parts.family.else.if.description=可以合併 'else if'
inspection.common.if.parts.family.else.if=合併 'else if' 語句
inspection.common.if.parts.family=提取 'if' 語句的公用部分
inspection.common.if.parts.settings.highlight.when.tail.call=在最後一條公用語句為調用時高亮顯示
inspection.compiler.javac.quirks.anno.array.comma.fix=移除尾隨逗號
inspection.compiler.javac.quirks.anno.array.comma.problem=注解數組初始值設定項中的尾隨逗號可能會在某些 Javac 版本(例如 JDK 5 和 JDK 6)中導致編譯錯誤。
inspection.compiler.javac.quirks.name=Javac 雜項
inspection.compiler.javac.quirks.qualifier.type.args.fix=移除泛型形參
inspection.compiler.javac.quirks.qualifier.type.args.problem=限定符引用中的泛型可能會導致某些Javac版本(例如JDK 5和JDK 6)中的編譯錯誤.
inspection.constant.on.wrong.side.of.a.comparison.side.option=常量應在比較的這一側:
inspection.contract.display.name=合同的問題
inspection.data.flow.redundant.instanceof.quickfix=替換為!= null
inspection.data.flow.simplify.boolean.expression.quickfix=簡化布爾表達式
inspection.data.flow.simplify.to.assignment.quickfix.name=簡化正常作業
inspection.data.flow.turn.off.constant.references.quickfix=不要報告總是不變的值
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=不要報告總是返回非空值的方法
inspection.data.flow.turn.off.true.asserts.quickfix=不要報告總是為true的斷言
inspection.duplicate.throws.display.name=重複拋出
inspection.duplicate.throws.ignore.subclassing.option=忽略子類化其他異常的異常
inspection.duplicate.throws.more.general.problem=在拋出列表,這是一個普通異常''{0}''.
inspection.duplicate.throws.problem=throws 重複
inspection.equals.hashcode.only.one.defined.problem.descriptor=類有{0}定義但沒有定義{1}
inspection.export.results.can.be.final.description=聲明可以具有 final 修飾符
inspection.expression.can.be.replaced.with.message=表達式可以替換為 ''{0}''
inspection.field.not.used.in.to.string.description2=字段 ''{0}'' 未在 ''function toString() { [native code] }()'' 方法中使用
inspection.field.not.used.in.to.string.description=方法 ''{0}'' 未在 ''function toString() { [native code] }()'' 方法中使用
inspection.implicit.subclass.display.forClass=類 ''{0}'' 可以隱式子類化，並且不得為 final
inspection.implicit.subclass.display.name=final 聲明不能在運行時被重寫
inspection.implicit.subclass.extendable=使''{0}''可以覆蓋
inspection.implicit.subclass.make.class.extendable=使類''{0}'' {1,choice,0#|1#和方法 {2} |1<和 {1} 個必須的方法}可擴展
inspection.infinite.loop.option=放置在 Thread.run 中時忽略
inspection.java.module.naming.terminal.digits=模塊名稱組件''{0}''應避免終端數字
inspection.java.module.naming=Java 模塊名稱與慣例相矛盾
inspection.local.can.be.final.display.name=局部變量或形參可以是 final
inspection.local.can.be.final.option1=報告方法形參
inspection.local.can.be.final.option2=報告 catch 形參
inspection.local.can.be.final.option3=報告 foreach 形參
inspection.local.can.be.final.option4=報告為隱式最終的變量
inspection.local.can.be.final.option=報告局部變量
inspection.module.exports.package.to.itself=模塊將軟件包導出/打開到本身
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=使用 @{0} 注解的形參不得重寫 @{1} 形參
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=使用 @{0} 注解的形參不應重寫非注解形參
inspection.nullable.problems.NotNull.parameter.receives.null.literal=使用 @{0} 注解的形參不應該接收 ''null'' 作為實參
inspection.nullable.problems.Nullable.NotNull.conflict=不能同時使用 @{0} 和 @{1} 注解
inspection.nullable.problems.Nullable.method.overrides.NotNull=@Nullable 注解的方法不能重寫為 @NotNull 方法
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=@{0} 字段的構造函數形參可能會使用 @{0} 自身注解
inspection.nullable.problems.annotated.field.getter.conflict=@{0}字段的Getter已經注解 @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated=@{0}字段的Getter可能會注解 @{0}本身
inspection.nullable.problems.annotated.field.setter.parameter.conflict=@{0} 字段的 setter 形參使用 @{1} 注解
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=@{0} 字段的 setter 形參可能會使用 @{0} 自身注解
inspection.nullable.problems.method.overrides.NotNull=未注解的方法重寫為 @NotNull 注解的方法
inspection.nullable.problems.parameter.overrides.NotNull=未注解的形參重寫 @{0} 形參
inspection.nullable.problems.primitive.type.annotation=不能注解基元類型成員
inspection.nullable.problems.receiver.annotation=接收器參數本身非 null
inspection.nullable.problems.outer.type=外部類型本身非 null
inspection.nullable.problems.at.function Object() { [native code] }=可 null 性注解不適用於構造函數
inspection.nullable.problems.at.enum.constant=可 null 性注解不適用於枚舉常量
inspection.nullable.problems.at.wildcard=可 null 性注解不適用於通配符類型
inspection.nullable.problems.at.local.variable=可 null 性注解不適用於局部變量
inspection.nullable.problems.at.type.parameter=可 null 性注解不適用於類型形參
inspection.nullable.problems.at.reference.list=可 null 性注解不適用於 extends/implements 子句
inspection.objects.equals.can.be.simplified.display.name=Objects.equals() 可以替換為 equals()
inspection.redundant.cast.problem.descriptor=轉換{0}到{1}是冗餘的
inspection.redundant.cast.remove.quickfix=移除多餘的轉換
inspection.redundant.field.initialization.option=僅在初始化為 null 時發出警告
inspection.redundant.requires.statement.description=冗餘語句 ''requires {0}''
inspection.redundant.requires.statement.fix.family=刪除冗餘 'requires' 語句
inspection.redundant.requires.statement.fix.name=刪除語句 ''requires {0}''
inspection.redundant.throws.problem.descriptor1=聲明的異常{0}是從不扔在這個方法中,還是在其derivables
inspection.redundant.throws.problem.descriptor2=聲明的異常{0}從未拋出
inspection.redundant.throws.problem.descriptor=聲明的異常{0}在方法中從未拋出
inspection.redundant.throws.remove.quickfix=刪除不必要的拋出聲明
inspection.redundant.type.display.name=冗餘類型實參
inspection.redundant.type.no.generics.method.reference.problem.descriptor=類型實參對於非泛型方法引用是冗餘的
inspection.redundant.type.no.generics.problem.descriptor=類型實參對於非泛型方法調用是冗餘的
inspection.redundant.type.problem.descriptor=顯式類型實參可以推斷
inspection.redundant.type.remove.quickfix=移除類型實參
inspection.reference.anonymous.name=匿名 ({0})
inspection.reference.implicit.function Object() { [native code] }.name=隱式構造函數{0}
inspection.reference.jsp.holder.method.anonymous.name=<% 頁面內容 %>
inspection.requires.auto.module.message=自動導入模塊需要'requires'指令
inspection.requires.auto.module.option=僅高亮顯示傳遞依賴
inspection.requires.auto.module.transitive=自動模塊需要'requires transitive'指令
inspection.requires.auto.module=依賴於自動模塊
inspection.same.return.value.display.name=方法返回相同的值
inspection.same.return.value.problem.descriptor1=方法和它的所有變量總是返回{0}
inspection.same.return.value.problem.descriptor2=此方法的所有實現始終都返回{0}
inspection.same.return.value.problem.descriptor=方法總是返回{0}
inspection.surround.requirenonnull.quickfix=替換為''Objects.requireNonNull({0})''
inspection.suspicious.array.method.call.display.name='Arrays' 方法調用可疑
inspection.suspicious.array.method.call.problem.arrays=Array類型不兼容：數組總是不同的
inspection.suspicious.array.method.call.problem.element=元素類型與數組類型不兼容
inspection.suspicious.collections.method.calls.display.name=可疑的集合方法調用
inspection.suspicious.collections.method.calls.problem.descriptor1=可疑的調用''{0}''
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}''可能不包含對象類型''{1}''
inspection.suspicious.getter.setter.field.option=僅在存在字段匹配 getter/setter 名稱時發出警告
inspection.suspicious.integer.div.assignment.option=報告可疑但可能準確的除法
inspection.unary.plus.unary.binary.option=僅在混亂的二進制或一元表達式上下文中報告
inspection.unnecessary.super.qualifier.option=忽略說明 'super' 限定符
inspection.use.compare.method.fix.family.name=替換為單個比較方法
inspection.visibility.accept.quickfix=接受建議的訪問級別
inspection.visibility.compose.suggestion=可以是 {0}
inspection.visibility.option.constants=為常量建議較弱的可見性
inspection.visibility.option.package.private.members=為類成員建議 package-private 可見性級別
inspection.visibility.package.private.top.level.classes=為頂級類建議 package-private 可見性級別
inspection.visibility.private.inner.members=<html>僅在從外部類引用時為內部類成員建議 private</html>
instance.member.guarded.by.static.0.loc=由 static“{0}”保護的實例成員 #loc
instance.member.guarded.by.static.ref.loc=由 static #ref 保護的實例成員 #loc
junit.rule.classrule.option=報告 @ClassRule 問題
junit.rule.rule.option=報告 @Rule 問題
make.0.default.annotation=將“{0}”設為預設注解
make.default.the.last.case.family.name=使 'default' 為最後一個 case
make.final.and.annotate.as.safevarargs=設為 final 並注解為 '@SafeVarargs'
method.reference.mapped.to.comparator=映射到 'Comparator' 接口的方法引用不會履行 'Comparator' 約定
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=語言級別為 {1} 的模塊 {0} 取決於語言級別為 {3} 的模塊 {2}
non.final.field.code.ref.code.in.immutable.class.loc=非最終字段 <code>#ref</code> 位於 @Immutable 類中 #loc
non.final.guarded.by.field.0.loc=非最終 @GuardedBy 字段“{0}”#loc
non.final.guarded.by.field.ref.loc=非最終 @GuardedBy 字段 #ref #loc
non.null.type.argument.is.expected=應為非 null 類型實參
not.annotated.method.is.used.as.an.override.for.a.method.annotated.with.0=非注解方法被用作使用 {0} 注解的方法的重寫
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=被重寫的方法形參不會被注解
nullable.stuff.problems.overridden.methods.are.not.annotated=重寫的方法不是註釋
parameter.can.be.null=形參可以為 null
parameter.is.always.not.null=形參始終為非 null
possible.heap.pollution.from.parameterized.vararg.type.loc=來自形參化 vararg 類型的可能的堆污染 #loc
redundant.block.marker=冗餘塊標記
remove.block.marker.comments=移除塊標記註釋
remove.dependency=移除依賴項
remove.switch.branch.0=移除 switch 分支 ''{0}''
remove.switch.label.0=移除 switch 標籤 ''{0}''
remove.switch.label=移除 switch 標籤
replace.0.with=將“{0}”替換為“=”
replace.anonymous.class.with.lambda.alternative=將匿名類替換為 lambda 替代項
replace.operator.assignment.with.assignment=將運算符賦值替換為賦值
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=將 StringTokenizer 分隔符形參替換為唯一的符號
replace.var.with.explicit.type=將 'var' 替換為顯式類型
replace.with.0=替換為 {0}
replace.with.comparator=替換為比較運算符
replace.with.constant.value=替換為常量值
replace.with.expression.lambda=替換為表達式 lambda
replace.with.lambda=替換為 lambda
report.suspicious.but.possibly.correct.method.calls=報告可疑的，但可能是正確的方法調用 (&R)
report.when.interface.is.not.annotated.with.functional.interface=在接口未使用 @FunctionalInterface 注解時報告
searching.for.overriding.methods=正在搜索重寫方法
statement.lambda.can.be.replaced.with.expression.lambda=語句 lambda 可以替換為表達式 lambda
static.inheritrance.fix.replace.progress=正在替換 {0} 的用例
static.member.guarded.by.instance.0.loc=由實例“{0}”保護的 static 成員 #loc
static.member.guarded.by.instance.ref.loc=由實例保護的 static 成員 #ref #loc
suppress.all.for.class=禁止類的所有檢查
suppress.inspection.class=對類禁止
suppress.inspection.field=對字段禁止
suppress.inspection.member=對成員禁止
suppress.inspection.method=對方法禁止
suppress.inspection.module=對模塊聲明禁止
suspected.module.dependency.problem.descriptor=模塊''{0}''不依賴於模塊''{1}''. 雖然''{2}''不需要為輸出依賴關係檢查''{1}''
unknown.guardedby.reference.0.loc=未知的 @GuardedBy 引用“{0}”#loc
unknown.guardedby.reference.ref.loc=未知的 @GuardedBy 引用 #ref #loc
unnecessary.module.dependency.display.name=不必要的模塊依賴
unnecessary.module.dependency.problem.descriptor=模塊''{0}''源不依賴於模塊''{1}''源
unused.import.display.name=未使用的 import
unused.import.statement=未使用的 import 語句
unused.library.display.name=未使用的庫
unused.library.problem.descriptor=未使用的庫''{0}''
unused.library.roots.problem.descriptor=未使用的根{0}從庫''{1}''
var.can.be.replaced.with.explicit.type='var' 可以替換為顯式類型
vararg.method.call.with.50.poly.arguments=具有超過 50 個 poly 實參的 vararg 方法調用可能會導致編譯和分析速度減慢
inspection.inconsistent.language.level.display.name=語言級別設置不一致
inspection.weaker.access.display.name=聲明訪問可能較弱
inspection.can.be.final.display.name=聲明可以具有 final 修飾符
inspection.redundant.throws.display.name=冗餘 'throws' 子句
inspection.java.9.redundant.requires.statement.display.name=module-info 中的冗餘 'requires' 語句
inspection.numeric.overflow.display.name=數值溢出
inspection.redundant.cast.display.name=冗餘類型轉換
inspection.deprecated.is.still.used.display.name=棄用的成員仍在使用
inspection.deprecated.class.usage.inspection.display.name=XML 中的棄用 API 用法
inspection.field.access.not.guarded.display.name=不受保護的字段訪問或方法調用
inspection.instance.guarded.by.static.display.name=由 static 字段保護的實例成員
inspection.non.final.field.in.immutable.display.name=非 final 字段位於 @Immutable 類中
inspection.non.final.guard.display.name=非 final @GuardedBy 字段
inspection.static.guarded.by.instance.display.name=由實例字段或 this 防護的 static 成員
inspection.unknown.guard.display.name=未知 @GuardedBy 字段
inspection.use.compare.method.display.name=可以使用 'compare()' 方法比較數值
inspection.convert.2.diamond.display.name=顯式類型可以替換為 <>
inspection.convert.2.lambda.display.name=匿名類型可以替換為 lambda
inspection.invalid.comparator.method.reference.display.name=用於 'Comparator' 的無效方法引用
inspection.safe.varargs.detector.display.name=形參化 vararg 類型可能導致堆污染
inspection.block.marker.comments.display.name=塊標記註釋
inspection.string.tokenizer.delimiter.display.name=java.util.StringTokenizer 中的分隔符重複
inspection.anonymous.has.lambda.alternative.display.name=匿名類型有較短的 lambda 替代項
inspection.java.8.list.sort.display.name=Collections.sort() 可以替換為 List.sort()
inspection.class.has.no.to.string.method.display.name=類不會重寫 'function toString() { [native code] }()' 方法
inspection.field.not.used.in.to.string.display.name=字段未在 'function toString() { [native code] }()' 方法中使用
inspection.contract.checker.clause.syntax=協定子句的格式必須為 arg1, ..., argN -> 返回值
inspection.contract.checker.unknown.return.value=返回值應為以下值之一: {0}。實際為 {1}
inspection.contract.checker.unknown.constraint=約束應為以下值之一: {0}。實際為 {1}
inspection.contract.checker.empty.constraint=約束不應為空
inspection.contract.checker.unreachable.contract.clause=協定子句 ''{0}'' 不可到達: 以前的協定涵蓋了所有可能的情況
inspection.contract.checker.contract.clause.never.satisfied=協定子句 ''{0}'' 從未滿足，因為以前的協定涵蓋了其條件
inspection.contract.checker.pure.method.mutation.contract=純方法不能有突變協定
inspection.contract.checker.parameter.count.mismatch=方法採用 {0} 個形參，而協定子句 ''{1}'' 預期 {2} 個
inspection.contract.checker.primitive.parameter.nullability=形參 ''{0}'' 具有基元類型 ''{1}''，因此 ''{2}'' 不適用
inspection.contract.checker.inferred.notnull.parameter.null=形參 ''{0}'' 被推斷為非 null，因此 ''null'' 不適用
inspection.contract.checker.notnull.parameter.null=形參 ''{0}'' 被注解為非 null，因此 ''null'' 不適用
inspection.contract.checker.inferred.notnull.parameter.notnull=形參 ''{0}'' 被推斷為非 null，因此 ''!null'' 始終滿足
inspection.contract.checker.notnull.parameter.notnull=形參 ''{0}'' 被注解為非 null，因此 ''!null'' 始終滿足
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=形參 ''{0}'' 具有 ''{1}'' 類型(應為布爾型)
inspection.contract.checker.contract.violated=違反協定子句 ''{0}''
inspection.contract.checker.no.exception.thrown=違反協定子句 ''{0}'': 未拋出異常
inspection.contract.checker.method.always.fails.trivial=子句 ''{0}'' 的返回值可以替換為 ''fail''，因為方法總是失敗
inspection.contract.checker.method.always.fails.nontrivial=子句 ''{0}'' 的返回值可以替換為 ''fail''，因為此子句中的方法總是失敗
contract.return.validator.not.applicable.for.function Object() { [native code] }=不適用於構造函數
contract.return.validator.not.applicable.static=不適用於 static 方法
contract.return.validator.not.applicable.primitive=不適用於基元返回類型 ''{0}''
contract.return.validator.return.type.must.be.boolean=方法返回類型必須為 'boolean'
contract.return.validator.method.return.incompatible.with.method.containing.class=方法返回類型應與包含類的方法兼容
contract.return.validator.too.few.parameters=不適用於{0, choice, 0#無形參|1#有一個形參|2#有 {0} 個形參}的方法
contract.return.validator.incompatible.return.parameter.type=返回類型 ''{0}'' 必須可以從形參類型 ''{1}'' 轉換而來
contract.return.value.validation.prefix=協定返回值 ''{0}'':
suspicious.invocation.handler.implementation.display.name=可疑的 InvocationHandler 實現
suspicious.invocation.handler.implementation.method.unused.message=方法從未在 'invoke' 中使用: 'hashCode'、'equals' 和 'function toString() { [native code] }' 不太可能正確實現
suspicious.invocation.handler.implementation.type.mismatch.message=代理方法 ''{0}()'' 時，可能返回不兼容類型: 要求 {1}，實際為 {2}
suspicious.invocation.handler.implementation.null.returned.for.function toString() { [native code] }.message=代理方法 'function toString() { [native code] }()' 時，可能返回 null: 不建議如此操作
suspicious.invocation.handler.implementation.null.returned.message=代理方法 ''{0}()'' 時，可能返回 null: 這可能導致 NullPointerException
error.class.not.found=找不到類 {0}
intention.name.qualify.expression=使用 ''{1}'' 限定 {0} 表達式
nullability.null=null
nullability.nullable=可 null
nullability.non.null=非 null
duplication.policy.ask=詢問
duplication.policy.replace=替換現有
duplication.policy.generate.duplicate=生成重複方法
dftype.presentation.empty.optional=空 Optional
dftype.presentation.present.optional=目前的 Optional
mutability.unknown=未知
mutability.modifiable=可修改
mutability.must.not.modify=不應修改的輸入形參
mutability.unmodifiable.view=不可修改的視圖
mutability.unmodifiable=不可修改
special.field.array.length=數組長度
special.field.string.length=字符串長度
special.field.collection.size=大小
special.field.unboxed.value=拆箱的值
special.field.optional.value=可選值
text.unused.import.in.template=未使用的 import (在模板中指定)
text.raw.ctor.reference.with.type.parameters=原始構造函數引用具有構造函數的顯式類型形參

dfa.find.cause.unable=找不到原因
dfa.find.cause.cast.may.fail=轉換可能失敗
dfa.find.cause.may.be.null=可能為 null
dfa.find.cause.call.always.fails=調用始終失敗
dfa.find.cause.one.of.the.following.happens=發生以下情況之一:
dfa.find.cause.an.execution.might.exist.where=一個執行可能存在於:
dfa.find.cause.value.is.always.the.same=值始終為 {0}
dfa.find.cause.value.x.is.always.the.same=值 ''{0}'' 始終為 ''{1}''
dfa.find.cause.compile.time.constant=編譯時常量，值為 ''{0}''
dfa.find.cause.equality.established.from.condition=''{0}'' 自條件建立
dfa.find.cause.was.assigned.to=''{0}'' 已分配到 ''{1}''
dfa.find.cause.was.assigned=''{0}'' 已分配
dfa.find.cause.operand.of.boolean.expression.is.the.same={1, choice, 0#and|1#or}-鏈的操作數 #{0} 是 {2}
dfa.find.cause.comparison.arguments.are.the.same=比較實參相同
dfa.find.cause.comparison.arguments.are.different.constants=比較實參為不同常量
dfa.find.cause.variable.is.initialized={0} ''{1}'' 初始化為 {2}
dfa.find.cause.object.kind.generic=對象
dfa.find.cause.object.kind.expression=表達式
dfa.find.cause.object.kind.method.return=方法返回
dfa.find.cause.type.known={0} 類型為 {1}
# ___PLACE___ is replaced with dfa.find.cause.place.*
dfa.find.cause.type.is.known.from.place=從 ___PLACE___ 已知 ''{0}'' 類型
dfa.find.cause.condition.is.known.from.place=已知 ''{0}'' 來自 ___PLACE___
dfa.find.cause.range.is.known.from.place=從 ___PLACE___ 已知範圍
dfa.find.cause.value.is.known.from.place=''{0}'' 已知為來自 ___PLACE___ 的 ''{1}''
dfa.find.cause.place.line.number=行 #{0}
dfa.find.cause.place.here=此處
dfa.find.cause.values.cannot.be.equal.because=值不能相等，因為 {0}
dfa.find.cause.condition.was.checked.before=條件 ''{0}'' 先前已檢查
dfa.find.cause.condition.was.deduced=條件 ''{0}'' 已被推導
dfa.find.cause.was.passed.as.non.null.parameter=''{0}'' 作為實參傳遞到接受非 null 形參的方法
dfa.find.cause.was.dereferenced=''{0}'' 已取消引用
dfa.find.cause.instanceof.implies.non.nullity='instanceof' 檢查表示非 null
dfa.find.cause.nullability.inferred={0} ''{1}'' 已推斷為 ''{2}''
dfa.find.cause.nullability.externally.annotated={0} ''{1}'' 外部注解為 ''{2}''
dfa.find.cause.nullability.explicitly.annotated={0} ''{1}'' 注解為 ''{2}''
dfa.find.cause.nullability.inherited.from.container={0} ''{1}'' 繼承容器注解，因此 ''{2}''
dfa.find.cause.nullability.inherited.from.class={0} ''{1}'' 自類 {2} 繼承注解，因此 ''{3}''
dfa.find.cause.nullability.inherited.from.package={0} ''{1}'' 自軟件包 {2} 繼承注解，因此 ''{3}''
dfa.find.cause.nullability.inherited.from.named.element={0} ''{1}'' 繼承自 {2}，因此 ''{3}''
dfa.find.cause.field.initializer.nullability=字段 ''{0}'' 初始化為 ''{1}'' 值
dfa.find.cause.field.assigned.nullability=已知字段 ''{0}'' 始終初始化為 ''{1}'' 值
dfa.find.cause.array.length.is.always.non.negative=數組長度始終為非負數
dfa.find.cause.string.length.is.always.non.negative=字符串長度始終為非負數
dfa.find.cause.collection.size.is.always.non.negative=集合大小始終為非負數
dfa.find.cause.range.is.specified.by.annotation=注解將 ''{0}'' 的範圍指定為 {1}
# %s is replaced with value range like {0..255} or 'odd', etc. (see long.range.set.presentation.* above)
dfa.find.cause.result.of.primitive.cast.template=''({0})'' 轉換的結果為 %s
dfa.find.cause.result.of.numeric.operation.template=''{0}'' 的結果為 %s
dfa.find.cause.left.operand.range.template=左操作數為 %s
dfa.find.cause.right.operand.range.template=右操作數為 %s
dfa.find.cause.numeric.cast.operand.template=轉換操作數為 %s
dfa.find.cause.numeric.range.generic.template=值為 %s
# Here {0} is replaced with dfa.find.cause.nonnull.expression.kind.*
dfa.find.cause.obviously.non.null.expression=表達式不可為 null，因為它是 {0}
dfa.find.cause.nonnull.expression.kind.newly.created.object=新創建的對象
dfa.find.cause.nonnull.expression.kind.literal=文字
dfa.find.cause.nonnull.expression.kind.primitive.type=基元類型 ''{0}'' 的值
dfa.find.cause.nonnull.expression.kind.concatenation=串聯
dfa.find.cause.nonnull.expression.kind.this.object='this' 對象
# Here {0} is replaced with dfa.find.cause.contract.kind.*
dfa.find.cause.contract.trivial=根據 {0}，{1} ''{2}'' 始終返回 ''{3}'' 值
dfa.find.cause.contract.throws.on.condition=根據 {0}，{1} ''{2}'' 會在 {3} 時引發異常
dfa.find.cause.contract.returns.on.condition=根據 {0}，{1} ''{2}'' 會在 {4} 時返回 ''{3}''
dfa.find.cause.contract.kind.explicit=約定
dfa.find.cause.contract.kind.inferred=推斷約定
dfa.find.cause.contract.kind.hard.coded=硬編碼約定

type.constraint.assignability.explanation.exact={0} 已知為 {1}
type.constraint.assignability.explanation.exact.subtype={0} 類型恰好是 {1}，是 {2} 的子類型
type.constraint.assignability.explanation.exact.not.subtype={0} 類型恰好是 {1}，不是 {2} 的子類型
type.constraint.assignability.explanation.subtype.of.subtype=已知 {0} 是 {1}，是 {2} 的子類型
type.constraint.assignability.explanation.not.instance.of=已知 {0} 不是 {1}
type.constraint.assignability.explanation.not.instance.of.supertype=已知 {0} 不是 {2} 的父類型 {1}
type.constraint.assignability.explanation.definitely.inconvertible=已知 {0} 是 {1}，與 {2} 絕對不兼容
inspection.message.javac.quick.intersection.type.problem=因為 ''{1}'' 為 final，交叉點類型 ''{0}'' 無法實例化
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9=在導出的軟件包中為類建議 package-private 可見性級別(Java 9+)
generate.members.position.at.caret=文本光標處
generate.members.position.after.equals.and.hashcode=equals() 和 hashCode() 后
generate.members.position.at.the.end.of.class=類結尾處

navigate.to.overridden.methods.title={0} 的重寫方法
subclasses.search.progress.title=正在搜索重寫方法
progress.title.searching.for.overridden.methods=正在搜索重寫方法
arguments.count.mismatch=應為 {0} 個實參，但實際為 {1} 個
inspection.message.nullable.method.implements.non.null.method=''{1}'' 中可為 null 的方法 ''{0}'' 實現 ''{2}'' 中的非 null 方法
inspection.message.non.annotated.method.implements.non.null.method=''{1}'' 中的非注解方法 ''{0}'' 實現 ''{2}'' 中的非 null 方法
inspection.message.non.null.parameter.should.not.override.nullable.parameter=''{2}'' 中方法 ''{1}'' 的非 null 形參 ''{0}'' 不應當重寫 ''{3}'' 中可為 null 的形參
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter=''{2}'' 中方法 ''{1}'' 的非注解形參 ''{0}'' 不應當重寫 ''{3}'' 中非 null 形參
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter=''{2}'' 中方法 ''{1}'' 的非 null 形參 ''{0}'' 不應當重寫 ''{3}'' 中的非注解形參
element.kind.keys=鍵
element.kind.values=值
element.kind.objects=對象
mutation.signature.problem.static.method.cannot.mutate.this=static 方法無法改變 'this'
mutation.signature.problem.reference.to.parameter.invalid=形參 #{0} 的引用無效
mutation.signature.problem.parameter.has.immutable.type=形參 #{0} 具有不可變類型 ''{1}''
mutation.signature.problem.invalid.token=無效的令牌: {0}；受支持的令牌為 ''this''、''param1''、''param2'' 等。
required.type=必需類型
provided.type=已提供
type.mismatch.reason=原因: {0}
inspection.message.code.generation.different.nullability.annotation.will.be.used=生成的代碼將使用 ''{1}'' 而不是 ''{0}''。
change.visibility.level=將 {0} 設為 {1}
text.shebang.mechanism.in.java.files.not.permitted=不支持在 .java 文件中使用事件機制
inspection.redundant.tostring.option.notnull.qualifier=僅在已知限定符為非 null 時報告
highlighting.try.blocks=正在高亮顯示 try 塊…
intention.family.name.remove.new.family.name=移除 'new'
intention.name.remove.new.display.name=移除 'new'
inspection.unsatisfied.range.display.name=返回值超出聲明的範圍
inspection.unsatisfied.range.message=返回值範圍 ''{0}'' 在聲明的範圍 ''{1}'' 之外
inspection.unsatisfied.range.message.value=返回值 ''{0}'' 超出聲明的範圍 ''{1}''
replace.with.boolean.equals=替換為 Boolean.equals
find.usages.panel.title.base.methods=基方法的用法
feature.patterns.in.switch=switch 中的模式
feature.guarded.and.parenthesised.patterns=受保護和帶圓括號的模式
dfa.find.cause.special.field.of.something={0}/{1}
find.usages.panel.title.derived.classes.cap=派生類
find.usages.panel.title.derived.interfaces.cap=派生接口
find.usages.panel.title.implementing.classes.cap=實現類
find.usages.panel.title.implementing.methods.cap=實現方法
find.usages.panel.title.overloaded.methods.usages.cap=重載方法
find.usages.panel.title.overriding.methods.cap=重寫方法
find.usages.panel.title.base.methods.cap=基方法的用法
special.field.enum.ordinal=枚舉序數
service.click.to.navigate=點擊以導航
inspection.reference.lambda.name=lambda ({0})
inspection.reference.default.lambda.name=lambda
inspection.reference.method.reference.name=方法引用 ({0})
inspection.reference.default.method.reference.name=方法引用
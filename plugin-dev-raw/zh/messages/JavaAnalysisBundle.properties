add.explicit.type.arguments=添加顯式類型實參

# suppress inspection "UnusedProperty"
annotation.target.ANNOTATION_TYPE=註解類型
# suppress inspection "UnusedProperty"
annotation.target.CONSTRUCTOR=構造函數
# suppress inspection "UnusedProperty"
annotation.target.FIELD=欄位
# suppress inspection "UnusedProperty"
annotation.target.LOCAL_VARIABLE=局部變數
# suppress inspection "UnusedProperty"
annotation.target.METHOD=方法
# suppress inspection "UnusedProperty"
annotation.target.MODULE=模組
# suppress inspection "UnusedProperty"
annotation.target.PACKAGE=軟體套件
# suppress inspection "UnusedProperty"
annotation.target.PARAMETER=參數
# suppress inspection "UnusedProperty"
annotation.target.RECORD_COMPONENT=記錄組件
# suppress inspection "UnusedProperty"
annotation.target.TYPE=類型
# suppress inspection "UnusedProperty"
annotation.target.TYPE_PARAMETER=類型參數
# suppress inspection "UnusedProperty"
annotation.target.TYPE_USE=類型使用

change.type.arguments=更改類型實參
change.type.arguments.to.0=將類型實參更改為 <{0}>
convert.0.to.float=將 ''{0}'' 轉換為 float

dataflow.message.array.index.out.of.bounds=陣列索引超出範圍
dataflow.message.negative.array.size=陣列大小為負
dataflow.message.arraystore=將 <code>{0}</code> 類型的元素存儲到 <code>{1}</code> 元素的陣列將生成 <code>ArrayStoreException</code>
dataflow.message.assigning.null.notannotated=正在將 <code>null</code> 值指定給非註解欄位
dataflow.message.assigning.null=<code>null</code> 被分配到一個是註解變數 @NotNull
dataflow.message.assigning.nullable.notannotated=表達式 <code>#ref</code> #loc 可能為 null，但被指定給非註解欄位
dataflow.message.assigning.nullable=表達式 <code>#ref</code> 可能為 null ,但是它被分配了註解 @NotNull
dataflow.message.cce.always=將 <code>{0}</code> 轉換為 <code>#ref</code> #loc 會為任意非 null 值生成 <code>ClassCastException</code>
dataflow.message.cce=從<code>{0}</code> 到 <code>#ref</code> #loc 可能產生 <code>java.lang.ClassCastException</code>
dataflow.message.constant.condition.when.reached=到達時，條件 <code>#ref</code> #loc 始終為 <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.condition=條件 <code>#ref</code> #loc 始終為 <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.method.reference=方法引用結果始終為''{0}''
dataflow.message.constant.no.ref=條件始終為 {0, choice, 0#false|1#true}
dataflow.message.contract.fail.index=由於實參超出範圍，對 '#ref' 的調用總是失敗
dataflow.message.contract.fail=依據其方法約定，對 '#ref' 的調用始終失敗
dataflow.message.immutable.modified=不可變物件已被修改
dataflow.message.immutable.passed=不可變物件在預期可變位置傳遞
dataflow.message.npe.array.access.sure=陣列存取 <code>#ref</code> #loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.array.access=陣列存取 <code>#ref</code> #loc 可能產生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access.sure=引用 <code>#ref</code> #loc 會產生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access=取消引用<code>#ref</code> #loc 可能導致 <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=內部類構造將生成 <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=內聯類建立可能會產生<code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=方法調用 <code>#ref</code> #loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.method.invocation=方法調用 <code>#ref</code> #loc 可能產生 <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=方法引用調用 <code>#ref</code> #loc 可能會產生 <code>java.lang.NullPointerException</code>
dataflow.message.only.switch.label=Switch 標籤 <code>#ref</code> #loc 是整個 switch 中唯一可存取的物件
dataflow.message.passing.null.argument.nonannotated=正在將 <code>null</code> 實參傳遞到非註解參數
dataflow.message.passing.null.argument=正在將 <code>null</code> 實參傳遞到註解為 @NotNull 的參數
dataflow.message.passing.nullable.argument.methodref.nonannotated=方法引用實參可能為 null，但被傳遞給非註解參數
dataflow.message.passing.nullable.argument.methodref=方法引用實參可能為空
dataflow.message.passing.nullable.argument.nonannotated=實參 <code>#ref</code> #loc 可能為 null，但被傳遞給非註解參數
dataflow.message.passing.nullable.argument=實參 <code>#ref</code> #loc 可能為null
dataflow.message.passing.non.null.argument.to.optional=正在將非 null 實參傳遞到 <code>Optional</code>
dataflow.message.passing.null.argument.to.optional=正在將 <code>null</code> 實參傳遞到 <code>Optional</code>
dataflow.message.pointless.assignment.expression=條件 <code>#ref</code> #loc 在賦值表達式的左側是永遠 <code>{0}</code>. 可以簡化
dataflow.message.pointless.same.arguments='#ref' 的實參相同。調用包含相同實參的此方法毫無意義
dataflow.message.pointless.same.argument.and.result='#ref' 的結果與{0,choice,1#第 1 個|2#第 2 個}實參相同使調用毫無意義
dataflow.message.redundant.assignment=變數已被指定給此值
dataflow.message.redundant.instanceof=條件 <code>#ref</code> #loc是多餘的，可以用 <code>!= null</code>
dataflow.message.redundant.update=變數更新不執行任何操作
dataflow.message.return.notnull.from.nullable=@{0} 方法 ''{1}'' 始終返回非 null 值
dataflow.message.return.null.from.notnull=<code>null</code> 由宣告為 @{0} 的方法返回
dataflow.message.return.null.from.notnullable=<code>null</code> 由未被宣告為 @{0} 的方法返回
dataflow.message.return.nullable.from.notnull.function=函數可能返回null,但這裡不允許
dataflow.message.return.nullable.from.notnull=表達式 <code>#ref</code> 可能會評估為 null，但由宣告為 @{0} 的方法返回
dataflow.message.return.nullable.from.notnullable=表達式 <code>#ref</code> 可能會評估為 null，但由未被宣告為 @{0} 的方法返回
dataflow.message.storing.array.null=<code>null</code> 已存儲到 @NotNull 元素的陣列中
dataflow.message.storing.array.nullable=表達式 <code>#ref</code> 可能會評估為 null，但已存儲到 @NotNull 元素的陣列
dataflow.message.unboxing.nullable.argument.methodref=將實參傳遞到方法引用需要拆箱，這可能會產生 <code>NullPointerException</code>
dataflow.message.unboxing.method.reference=使用 <code>#ref</code> #loc 需要取消裝箱，這可能會產生 <code>java.lang.NullPointerException</code>
dataflow.message.unboxing=拆箱的 <code>#ref</code> #loc 可能產生 <code>java.lang.NullPointerException</code>
dataflow.message.unreachable.switch.label=Switch 標籤 <code>#ref</code> #loc 不可到達
dataflow.message.constant.expression=<code>#ref</code> #loc 的結果總是 ''{0}''
dataflow.message.constant.value=值 <code>#ref</code> #loc 總是 ''{0}''
dataflow.method.fails.with.null.argument=當參數為 null 時，方法將拋出異常
dataflow.message.unknown.nullability=(可 null 性未知)
dataflow.not.precise={0} 複雜: 數據流結果可能不準確
dataflow.too.complex=方法 <code>#ref</code> 太複雜，無法通過數據流演算法進行分析

delete.repeated.0=刪除重複的 ''{0}''
delete.repeated.interface=刪除重複的接口
exception.removal.will.break.source.code.proceed.anyway=異常移除會破壞原始碼。仍然繼續?

feature.generics=泛型
feature.annotations=註解
feature.static.imports=靜態匯入
feature.for.each=For-each 迴圈
feature.varargs=可變 arity 方法
feature.hex.fp.literals=十六進制浮點文字
feature.diamond.types=Diamond 類型
feature.multi.catch=多 catch
feature.try.with.resources=Try-with-resources
feature.binary.literals=二進制文字
feature.underscores.in.literals=在文字中加下劃線
feature.extension.methods=擴展方法
feature.method.references=方法引用
feature.lambda.expressions=Lambda 表達式
feature.type.annotations=類型註解
feature.type.receivers=接收器參數
feature.intersections.in.casts=轉換中的交叉類型
feature.static.interface.calls=static 接口方法調用
feature.try.with.resources.refs=資源引用
feature.modules=模組
feature.lvti=局部變數類型推斷
feature.var.lambda.parameter=lambda 參數中的 'var'
feature.text.blocks=文本塊文字
feature.text.block.escape.sequences='\\s' 和 '\' 轉義序列
feature.enhanced.switch=增強的 'switch' 塊
feature.switch.expressions='switch' 表達式
feature.records=記錄
feature.patterns.instanceof='instanceof' 中的模式
feature.sealed.classes=密封類
feature.local.interfaces=本地接口
feature.local.enums=本地枚舉
feature.inner.statics=內部類中的 static 宣告

find.searching.for.references.to.class.progress=正在尋找對類 {0} 的引用…
find.usages.panel.title.derived.classes=派生類
find.usages.panel.title.derived.interfaces=派生接口
find.usages.panel.title.implementing.classes=實作類
find.usages.panel.title.implementing.methods=實作方法
find.usages.panel.title.overloaded.methods.usages=多載方法
find.usages.panel.title.overriding.methods=覆寫方法
message.class.inaccessible.from.module=類 ''{0}'' 無法從模組 ''{1}'' 存取
message.class.inaccessible=類 ''{0}'' 無法在此處存取

inspection.i18n.quickfix.annotate=註解…
inspection.i18n.quickfix.annotate.as=註解為 @{0}
inspection.i18n.quickfix.annotate.element=註釋 {0} ''{1}''…
inspection.i18n.quickfix.annotate.element.as=在{0} ''{1}'' 上添加註解 @{2}
inspection.reference.default.package=<預設>
error.message.invalid.java.type=無效的 Java 類型
move.0.to.the.beginning=將 ''{0}'' 移動到開頭
move.to.front=移到前面
processing.method.usages=正在處理方法用例…
qualify.0=限定 {0}
qualify.with.0.this=使用 {0}.this 限定
remove.annotation=移除註解
remove.left.side.of.assignment=移除賦值的左側
replace.get.class.with.class.literal=使用 .class 文字取代 getClass()
service.provides=提供服務
service.uses=使用服務
suppress.for.parameter=對參數禁止
suppress.for.statement.with.comment=對包含註釋的語句禁止
intention.add.annotation.family=添加註解
intention.add.type.annotation.family=添加類型註解
intention.text.remove.annotation=移除

scope.package=軟體套件 {0}

0.field.is.always.initialized.not.null=@{0} 欄位始終為初始化的非 null
access.can.be.0=存取可以是 {0}
access.to.field.code.ref.code.outside.of.declared.guards.loc=存取宣告的臨界外部的欄位 <code>#ref</code> #loc
call.to.method.code.ref.code.outside.of.declared.guards.loc=在宣告的臨界之外調用方法 <code>#ref()</code> #loc
annotate.as.safevarargs=註解為 '@SafeVarargs'
annotate.overridden.methods.parameters.family.name=註解被覆寫的方法參數
annotate.overridden.methods.parameters=將被覆寫的方法參數註解為 ''@{0}''
anonymous.ref.loc.can.be.replaced.with.0=匿名 #ref #loc 可被取代為 {0}
anonymous.ref.loc.can.be.replaced.with.lambda=匿名 #ref #loc 可被取代為 lambda
assigning.a.collection.of.nullable.elements=正在將可空元素集合指定給非空元素集合
nullable.stuff.error.overriding.nullable.with.notnull=使用非 null 元素集合覆寫可 null 元素的集合
nullable.stuff.error.overriding.notnull.with.nullable=使用可 null 元素集合覆寫非 null 元素的集合
comparision.between.object.and.primitive=物件與基元之間的比較非法，僅在 java 7 中接受
custom.exception.class.should.have.a.constructor=自訂異常類應具有一個包含字串類型的單個訊息參數的構造函數
delimiters.argument.contains.duplicated.characters=分隔符實參包含重複的字符
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=棄用的成員 ''{0}'' 仍在使用
detach.library.quickfix.name=分離庫
detach.library.roots.quickfix.name=分離未使用的庫根
don.t.report.unused.jars.inside.used.library=不要在使用的庫內報告未使用的 jar
explicit.type.argument.ref.loc.can.be.replaced.with=顯式類型實參 #ref #loc 可被取代為 <>
exports.to.itself.delete.module.ref.fix=刪除模組''{0}''的引用
exports.to.itself.delete.statement.fix=刪除宣告
html.classes.exposed.with.code.module.info.code.html=<html>類通過 <code>module-info</code> 公開</html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>在未棄用的 super 中忽略棄用的 abstract 方法的覆寫</html>
ignore.casts.in.suspicious.collections.method.calls=忽略澄清轉換
ignore.exceptions.thrown.by.entry.points.methods=忽略由入口點方法引發的異常
ignore.in.the.same.outermost.class=在相同的最外側類中忽略
ignore.inside.deprecated.members=在棄用的成員內忽略
ignore.inside.non.static.imports=在非靜態匯入內忽略
ignore.members.of.deprecated.classes=忽略棄用類的成員
ignore.operation.which.results.in.negative.value=忽略 '<<' 操作，後者會導致負值
inspection.annotate.method.quickfix.family.name=標註方法
inspection.annotate.method.quickfix.name=使用 ''@{0}'' 註解方法
inspection.annotate.overridden.method.and.self.quickfix.family.name=註解覆寫的方法和本身
inspection.annotate.overridden.method.and.self.quickfix.name=使用 ''@{0}'' 註解覆寫的方法和本身
inspection.annotate.overridden.method.quickfix.family.name=註釋覆蓋方法
inspection.annotate.overridden.method.quickfix.name=使用 ''@{0}'' 註解覆寫的方法
inspection.annotate.overridden.method.nullable.quickfix.name=將覆寫的方法註解為 ''@{0}''
inspection.c.style.array.declarations.option=忽略變數中的 C 樣式宣告
inspection.can.be.final.accept.quickfix=設為 final
inspection.can.be.final.option1=報告方法
inspection.can.be.final.option2=報告欄位
inspection.can.be.final.option=報告類
inspection.can.be.local.parameter.problem.descriptor=參數 <code>#ref</code> 可以具有 <code>final</code> 修飾符
inspection.can.be.local.variable.problem.descriptor=變數 <code>#ref</code> 可以具有 <code>final</code> 修飾符
inspection.can.be.replaced.with.message=可被取代為 ''{0}''
inspection.class.getclass.display.name='Class.getClass()' 調用可疑
inspection.class.getclass.fix.remove.name=移除 'getClass()' 調用
inspection.class.getclass.fix.replace.name=取代為 'Class.class'
inspection.class.getclass.message=在類實例上調用了 'getClass()'
inspection.class.has.no.to.string.method.description=類 ''{0}'' 不會覆寫 ''toString()'' 方法
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=排除類 (reg exp):
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=忽略 abstract 類
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=忽略棄用的類
inspection.class.has.no.to.string.method.ignore.enum.classes.option=忽略枚舉類
inspection.class.has.no.to.string.method.ignore.records.option=忽略記錄
inspection.class.has.no.to.string.method.ignore.exception.classes.option=忽略異常類
inspection.class.has.no.to.string.method.ignore.inner.classes.option=忽略內部類
inspection.class.has.no.to.string.method.ignore.test.classes.option=忽略測試類
inspection.common.if.parts.disable.highlight.tail.call=如果尾語句是調用，則不要高亮顯示公用部分
inspection.common.if.parts.family.else.if.description=可以合併 'else if'
inspection.common.if.parts.family.else.if=合併 'else if' 語句
inspection.common.if.parts.family=提取 'if' 語句的公用部分
inspection.common.if.parts.settings.highlight.when.tail.call=在最後一條公用語句為調用時高亮顯示
inspection.compiler.javac.quirks.anno.array.comma.fix=移除尾隨逗號
inspection.compiler.javac.quirks.anno.array.comma.problem=註解陣列初始設定式中的尾隨逗號可能會在某些 Javac 版本(例如 JDK 5 和 JDK 6)中導致編譯錯誤。
inspection.compiler.javac.quirks.name=Javac 雜項
inspection.compiler.javac.quirks.qualifier.type.args.fix=移除泛型參數
inspection.compiler.javac.quirks.qualifier.type.args.problem=限定符引用中的泛型可能會導致某些Javac版本(例如JDK 5和JDK 6)中的編譯錯誤.
inspection.constant.on.wrong.side.of.a.comparison.side.option=常數應在比較的這一側:
inspection.contract.display.name=合同的問題
inspection.data.flow.redundant.instanceof.quickfix=取代為!= null
inspection.data.flow.simplify.boolean.expression.quickfix=簡化布爾表達式
inspection.data.flow.simplify.to.assignment.quickfix.name=簡化正常作業
inspection.data.flow.turn.off.constant.references.quickfix=不要報告總是不變的值
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=不要報告總是返回非空值的方法
inspection.data.flow.turn.off.true.asserts.quickfix=不要報告總是為true的斷言
inspection.duplicate.throws.display.name=重複拋出
inspection.duplicate.throws.ignore.subclassing.option=忽略子類化其他異常的異常
inspection.duplicate.throws.more.general.problem=在拋出列表,這是一個普通異常''{0}''.
inspection.duplicate.throws.problem=throws 重複
inspection.equals.hashcode.only.one.defined.problem.descriptor=類有{0}定義但沒有定義{1}
inspection.export.results.can.be.final.description=宣告可以具有 final 修飾符
inspection.expression.can.be.replaced.with.message=表達式可被取代為 ''{0}''
inspection.field.not.used.in.to.string.description2=欄位 ''{0}'' 未在 ''toString()'' 方法中使用
inspection.field.not.used.in.to.string.description=方法 ''{0}'' 未在 ''toString()'' 方法中使用
inspection.implicit.subclass.display.forClass=類 ''{0}'' 可以隱式子類化，並且不得為 final
inspection.implicit.subclass.display.name=final 宣告不能在執行時被覆寫
inspection.implicit.subclass.extendable=使''{0}''可以覆蓋
inspection.implicit.subclass.make.class.extendable=使類''{0}'' {1,choice,0#|1#和方法 {2} |1<和 {1} 個必須的方法}可擴展
inspection.infinite.loop.option=放置在 Thread.run 中時忽略
inspection.java.module.naming.terminal.digits=模組名稱組件''{0}''應避免終端數字
inspection.java.module.naming=Java 模組名稱與慣例相矛盾
inspection.local.can.be.final.display.name=局部變數或參數可以是 'final'
inspection.local.can.be.final.option1=報告方法參數
inspection.local.can.be.final.option2=報告 catch 參數
inspection.local.can.be.final.option3=報告 foreach 參數
inspection.local.can.be.final.option4=<html>報告為隱式 final 的變數<br/>(多 catch 或使用 try-with-resources 參數)</html>
inspection.local.can.be.final.option=報告局部變數
inspection.module.exports.package.to.itself=模組將軟體套件匯出/開啟到本身
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=使用 @{0} 註解的參數不得覆寫 @{1} 參數
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=使用 @{0} 註解的參數不應覆寫非註解參數
inspection.nullable.problems.NotNull.parameter.receives.null.literal=使用 @{0} 註解的參數不應該接收 ''null'' 作為實參
inspection.nullable.problems.Nullable.NotNull.conflict=不能同時使用 @{0} 和 @{1} 註解
inspection.nullable.problems.Nullable.method.overrides.NotNull=@Nullable 註解的方法不能覆寫為 @NotNull 方法
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=@{0} 欄位的構造函數參數可能會使用 @{0} 自身註解
inspection.nullable.problems.annotated.field.getter.conflict=@{0}欄位的Getter已經註解 @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated=@{0}欄位的Getter可能會註解 @{0}本身
inspection.nullable.problems.annotated.field.setter.parameter.conflict=@{0} 欄位的 setter 參數使用 @{1} 註解
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=@{0} 欄位的 setter 參數可能會使用 @{0} 自身註解
inspection.nullable.problems.method.overrides.NotNull=未註解的方法覆寫為 @NotNull 註解的方法
inspection.nullable.problems.parameter.overrides.NotNull=未註解的參數覆寫 @{0} 參數
inspection.nullable.problems.primitive.type.annotation=不能註解基元類型成員
inspection.nullable.problems.receiver.annotation=接收器參數本身非 null
inspection.nullable.problems.outer.type=外部類型本身非 null
inspection.nullable.problems.at.constructor=可 null 性註解不適用於構造函數
inspection.nullable.problems.at.enum.constant=可 null 性註解不適用於枚舉常數
inspection.nullable.problems.at.wildcard=可 null 性註解不適用於萬用字元類型
inspection.nullable.problems.at.local.variable=可 null 性註解不適用於局部變數
inspection.nullable.problems.at.type.parameter=可 null 性註解不適用於類型參數
inspection.nullable.problems.at.reference.list=可 null 性註解不適用於 extends/implements 子句
inspection.objects.equals.can.be.simplified.display.name='Objects.equals()' 可被取代為 'equals()'
inspection.redundant.cast.problem.descriptor=轉換{0}到{1}是冗餘的
inspection.redundant.cast.remove.quickfix=移除多餘的轉換
inspection.redundant.field.initialization.option=僅在初始化為 null 時發出警告
inspection.redundant.requires.statement.description=冗餘語句 ''requires {0}''
inspection.redundant.requires.statement.fix.family=刪除冗餘 'requires' 語句
inspection.redundant.requires.statement.fix.name=刪除語句 ''requires {0}''
inspection.redundant.throws.problem.descriptor1=宣告的異常{0}是從不扔在這個方法中,還是在其derivables
inspection.redundant.throws.problem.descriptor2=宣告的異常{0}從未拋出
inspection.redundant.throws.problem.descriptor=宣告的異常{0}在方法中從未拋出
inspection.redundant.throws.remove.quickfix=刪除不必要的拋出宣告
inspection.redundant.type.display.name=冗餘類型實參
inspection.redundant.type.no.generics.method.reference.problem.descriptor=類型實參對於非泛型方法引用是冗餘的
inspection.redundant.type.no.generics.problem.descriptor=類型實參對於非泛型方法調用是冗餘的
inspection.redundant.type.problem.descriptor=顯式類型實參可以推斷
inspection.redundant.type.remove.quickfix=移除類型實參
inspection.reference.anonymous.name=匿名 ({0})
inspection.reference.implicit.constructor.name=隱式構造函數{0}
inspection.reference.jsp.holder.method.anonymous.name=<% 頁面內容 %>
inspection.requires.auto.module.message=自動匯入模組需要'requires'指令
inspection.requires.auto.module.option=僅高亮顯示可傳遞依賴項
inspection.requires.auto.module.transitive=自動模組需要'requires transitive'指令
inspection.requires.auto.module=依賴於自動模組
inspection.same.return.value.display.name=方法返回相同的值
inspection.same.return.value.problem.descriptor1=方法和它的所有變量總是返回{0}
inspection.same.return.value.problem.descriptor2=此方法的所有實作始終都返回{0}
inspection.same.return.value.problem.descriptor=方法總是返回{0}
inspection.surround.requirenonnull.quickfix=取代為''Objects.requireNonNull({0})''
inspection.suspicious.array.method.call.display.name=可疑的 'Arrays' 方法調用
inspection.suspicious.array.method.call.problem.arrays=Array類型不相容：陣列總是不同的
inspection.suspicious.array.method.call.problem.element=元素類型與陣列類型不相容
inspection.suspicious.collections.method.calls.display.name=可疑的集合方法調用
inspection.suspicious.collections.method.calls.problem.descriptor1=可疑的調用''{0}''
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}''可能不包含物件類型''{1}''
inspection.suspicious.getter.setter.field.option=僅在存在欄位符合 getter/setter 名稱時發出警告
inspection.suspicious.integer.div.assignment.option=報告可疑但可能準確的除法
inspection.unary.plus.unary.binary.option=僅在混亂的二進制或一元表達式上下文中報告
inspection.unnecessary.super.qualifier.option=忽略說明 'super' 限定符
inspection.use.compare.method.fix.family.name=取代為單個比較方法
inspection.visibility.accept.quickfix=接受建議的存取級別
inspection.visibility.compose.suggestion=可以是 {0}
inspection.visibility.option.constants=為常數建議較弱的可見性
inspection.visibility.option.package.private.members=為類成員建議 package-private 可見性級別
inspection.visibility.package.private.top.level.classes=為頂級類建議 package-private 可見性級別
inspection.visibility.private.inner.members=<html>僅在從外部類引用時為內部類成員建議 private</html>
instance.member.guarded.by.static.0.loc=由 static“{0}”保護的實例成員 #loc
instance.member.guarded.by.static.ref.loc=由 static #ref 保護的實例成員 #loc
junit.rule.classrule.option=報告 @ClassRule 問題
junit.rule.rule.option=報告 @Rule 問題
make.0.default.annotation=將“{0}”設為預設註解
make.default.the.last.case.family.name=使 'default' 為最後一個 case
make.final.and.annotate.as.safevarargs=設為 final 並註解為 '@SafeVarargs'
method.reference.mapped.to.comparator=映射到 'Comparator' 接口的方法引用不會履行 'Comparator' 約定
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=語言級別為 {1} 的模組 {0} 取決於語言級別為 {3} 的模組 {2}
non.final.field.code.ref.code.in.immutable.class.loc=非最終欄位 <code>#ref</code> 位於 @Immutable 類中 #loc
non.final.guarded.by.field.0.loc=非最終 @GuardedBy 欄位“{0}”#loc
non.final.guarded.by.field.ref.loc=非最終 @GuardedBy 欄位 #ref #loc
non.null.type.argument.is.expected=應為非 null 類型實參
not.annotated.method.is.used.as.an.override.for.a.method.annotated.with.0=非註解方法被用作使用 {0} 註解的方法的覆寫
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=被覆寫的方法參數不會被註解
nullable.stuff.problems.overridden.methods.are.not.annotated=覆寫的方法不是註釋
parameter.can.be.null=參數可以為 null
parameter.is.always.not.null=參數始終為非 null
possible.heap.pollution.from.parameterized.vararg.type.loc=來自參數化 vararg 類型的可能的堆污染 #loc
redundant.block.marker=冗餘塊標記
remove.block.marker.comments=移除塊標記註釋
remove.dependency=移除依賴項
remove.switch.branch.0=移除 switch 分支 ''{0}''
remove.switch.label.0=移除 switch 標籤 ''{0}''
remove.switch.label=移除 switch 標籤
replace.0.with=將“{0}”取代為“=”
replace.anonymous.class.with.lambda.alternative=將匿名類取代為 lambda 替代項
replace.operator.assignment.with.assignment=將運算符賦值取代為賦值
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=將 StringTokenizer 分隔符參數取代為唯一的符號
replace.var.with.explicit.type=將 'var' 取代為顯式類型
replace.with.0=取代為 {0}
replace.with.comparator=取代為比較運算符
replace.with.constant.value=取代為常量值
replace.with.expression.lambda=取代為表達式 lambda
replace.with.lambda=取代為 lambda
report.suspicious.but.possibly.correct.method.calls=報告可疑的，但可能是正確的方法調用 (&R)
report.when.interface.is.not.annotated.with.functional.interface=在接口未使用 @FunctionalInterface 註解時報告
searching.for.overriding.methods=正在搜尋覆寫方法
statement.lambda.can.be.replaced.with.expression.lambda=語句 lambda 可被取代為表達式 lambda
static.inheritrance.fix.replace.progress=正在取代 {0} 的用例
static.member.guarded.by.instance.0.loc=由實例“{0}”保護的 static 成員 #loc
static.member.guarded.by.instance.ref.loc=由實例保護的 static 成員 #ref #loc
suppress.all.for.class=禁止類的所有檢查
suppress.inspection.class=抑制類(class)
suppress.inspection.field=對欄位禁止
suppress.inspection.member=抑制分子
suppress.inspection.method=對方法禁止
suppress.inspection.module=對模組宣告禁止
suspected.module.dependency.problem.descriptor=模組''{0}''不依賴於模組''{1}''. 雖然''{2}''不需要為輸出依賴關係檢查''{1}''
unknown.guardedby.reference.0.loc=未知的 @GuardedBy 引用“{0}”#loc
unknown.guardedby.reference.ref.loc=未知的 @GuardedBy 引用 #ref #loc
unnecessary.module.dependency.display.name=不必要的模組依賴
unnecessary.module.dependency.problem.descriptor=模組''{0}''源不依賴於模組''{1}''源
unused.import.display.name=未使用的 import
unused.import.statement=未使用的 import 語句
unused.library.display.name=未使用的庫
unused.library.problem.descriptor=未使用的庫''{0}''
unused.library.roots.problem.descriptor=未使用的根{0}從庫''{1}''
var.can.be.replaced.with.explicit.type='var' 可被取代為顯式類型
vararg.method.call.with.50.poly.arguments=具有超過 50 個 poly 實參的 vararg 方法調用可能會導致編譯和分析速度減慢
inspection.inconsistent.language.level.display.name=語言級別設定不一致
inspection.weaker.access.display.name=宣告存取可能較弱
inspection.can.be.final.display.name=宣告可以有 'final' 修飾符
inspection.redundant.throws.display.name=冗餘 'throws' 子句
inspection.java.9.redundant.requires.statement.display.name=module-info 中的冗餘 'requires' 指令
inspection.numeric.overflow.display.name=數值溢出
inspection.redundant.cast.display.name=冗餘類型轉換
inspection.deprecated.is.still.used.display.name=棄用的成員仍在使用
inspection.deprecated.class.usage.inspection.display.name=XML 中的棄用 API 用法
inspection.field.access.not.guarded.display.name=不受保護的欄位存取或方法調用
inspection.instance.guarded.by.static.display.name=由 static 欄位保護的實例成員
inspection.non.final.field.in.immutable.display.name='@Immutable' 類中有非 final 欄位
inspection.non.final.guard.display.name=非 final '@GuardedBy' 欄位
inspection.static.guarded.by.instance.display.name=由實例欄位或 this 防護的 static 成員
inspection.unknown.guard.display.name=未知 '@GuardedBy' 欄位
inspection.use.compare.method.display.name=可以使用 'compare()' 方法比較數值
inspection.convert.2.diamond.display.name=顯式類型可被取代為 '<>'
inspection.convert.2.lambda.display.name=匿名類型可被取代為 lambda
inspection.invalid.comparator.method.reference.display.name=用於 'Comparator' 的無效方法引用
inspection.safe.varargs.detector.display.name=參數化 vararg 類型可能導致堆污染
inspection.block.marker.comments.display.name=塊標記註釋
inspection.string.tokenizer.delimiter.display.name='StringTokenizer' 中的分隔符重複
inspection.anonymous.has.lambda.alternative.display.name=匿名類型有較短的 lambda 替代項
inspection.java.8.list.sort.display.name='Collections.sort()' 可被取代為 'List.sort()'
inspection.class.has.no.to.string.method.display.name=類不會覆寫 'toString()' 方法
inspection.field.not.used.in.to.string.display.name=欄位未在 'toString()' 方法中使用
inspection.contract.checker.clause.syntax=協定子句的格式必須為 arg1, ..., argN -> 返回值
inspection.contract.checker.unknown.return.value=返回值應為以下值之一: {0}。實際為 {1}
inspection.contract.checker.unknown.constraint=約束應為以下值之一: {0}。實際為 {1}
inspection.contract.checker.empty.constraint=約束不應為空
inspection.contract.checker.unreachable.contract.clause=協定子句 ''{0}'' 不可到達: 以前的協定涵蓋了所有可能的情況
inspection.contract.checker.contract.clause.never.satisfied=協定子句 ''{0}'' 從未滿足，因為以前的協定涵蓋了其條件
inspection.contract.checker.pure.method.mutation.contract=純方法不能有突變協定
inspection.contract.checker.parameter.count.mismatch=方法採用 {0} 個參數，而協定子句 ''{1}'' 預期 {2} 個
inspection.contract.checker.primitive.parameter.nullability=參數 ''{0}'' 具有基元類型 ''{1}''，因此 ''{2}'' 不適用
inspection.contract.checker.inferred.notnull.parameter.null=參數 ''{0}'' 被推斷為非 null，因此 ''null'' 不適用
inspection.contract.checker.notnull.parameter.null=參數 ''{0}'' 被註解為非 null，因此 ''null'' 不適用
inspection.contract.checker.inferred.notnull.parameter.notnull=參數 ''{0}'' 被推斷為非 null，因此 ''!null'' 始終滿足
inspection.contract.checker.notnull.parameter.notnull=參數 ''{0}'' 被註解為非 null，因此 ''!null'' 始終滿足
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=參數 ''{0}'' 具有 ''{1}'' 類型(應為布爾型)
inspection.contract.checker.contract.violated=違反協定子句 ''{0}''
inspection.contract.checker.no.exception.thrown=違反協定子句 ''{0}'': 未拋出異常
inspection.contract.checker.method.always.fails.trivial=子句 ''{0}'' 的返回值可被取代為 ''fail''，因為方法總是失敗
inspection.contract.checker.method.always.fails.nontrivial=子句 ''{0}'' 的返回值可被取代為 ''fail''，因為此子句中的方法總是失敗
contract.return.validator.not.applicable.for.constructor=不適用於構造函數
contract.return.validator.not.applicable.static=不適用於 static 方法
contract.return.validator.not.applicable.primitive=不適用於基元返回類型 ''{0}''
contract.return.validator.return.type.must.be.boolean=方法返回類型必須為 'boolean'
contract.return.validator.method.return.incompatible.with.method.containing.class=方法返回類型應與包含類的方法相容
contract.return.validator.too.few.parameters=不適用於{0, choice, 0#無形參|1#有一個參數|2#有 {0} 個參數}的方法
contract.return.validator.incompatible.return.parameter.type=返回類型 ''{0}'' 必須可以從參數類型 ''{1}'' 轉換而來
contract.return.value.validation.prefix=協定返回值 ''{0}'':
suspicious.invocation.handler.implementation.display.name=可疑的 'InvocationHandler' 實作
suspicious.invocation.handler.implementation.method.unused.message=方法從未在 'invoke' 中使用: 'hashCode'、'equals' 和 'toString' 不太可能正確實作
suspicious.invocation.handler.implementation.type.mismatch.message=代理方法 ''{0}()'' 時，可能返回不相容類型: 要求 {1}，實際為 {2}
suspicious.invocation.handler.implementation.null.returned.for.toString.message=代理方法 'toString()' 時，可能返回 null: 不建議如此操作
suspicious.invocation.handler.implementation.null.returned.message=代理方法 ''{0}()'' 時，可能返回 null: 這可能導致 NullPointerException
error.class.not.found=找不到類 {0}
intention.name.qualify.expression=使用 ''{1}'' 限定 {0} 表達式
nullability.null=null
nullability.nullable=可 null
nullability.non.null=非 null
duplication.policy.ask=詢問
duplication.policy.replace=取代現有
duplication.policy.generate.duplicate=生成重複方法
dftype.presentation.empty.optional=空 Optional
dftype.presentation.present.optional=目前的 Optional
mutability.unknown=未知
mutability.modifiable=可修改
mutability.must.not.modify=不應修改的輸入參數
mutability.unmodifiable.view=不可修改的檢視
mutability.unmodifiable=不可修改
special.field.array.length=陣列長度
special.field.string.length=字串長度
special.field.collection.size=大小
special.field.unboxed.value=拆箱的值
special.field.optional.value=可選值
text.unused.import.in.template=未使用的 import (在模板中指定)
text.raw.ctor.reference.with.type.parameters=原始構造函數引用具有構造函數的顯式類型參數

dfa.find.cause.unable=找不到原因
dfa.find.cause.cast.may.fail=轉換可能失敗
dfa.find.cause.may.be.null=可能為 null
dfa.find.cause.call.always.fails=調用始終失敗
dfa.find.cause.one.of.the.following.happens=發生以下情況之一:
dfa.find.cause.an.execution.might.exist.where=一個執行可能存在於:
dfa.find.cause.value.is.always.the.same=值始終為 {0}
dfa.find.cause.value.x.is.always.the.same=值 ''{0}'' 始終為 ''{1}''
dfa.find.cause.compile.time.constant=編譯時常量，值為 ''{0}''
dfa.find.cause.equality.established.from.condition=''{0}'' 自條件建立
dfa.find.cause.was.assigned.to=''{0}'' 已分配到 ''{1}''
dfa.find.cause.was.assigned=''{0}'' 已分配
dfa.find.cause.operand.of.boolean.expression.is.the.same={1, choice, 0#and|1#or}-鏈的操作數 #{0} 是 {2}
dfa.find.cause.comparison.arguments.are.the.same=比較實參相同
dfa.find.cause.comparison.arguments.are.different.constants=比較實參為不同常數
dfa.find.cause.variable.is.initialized={0} ''{1}'' 初始化為 {2}
dfa.find.cause.object.kind.generic=物件
dfa.find.cause.object.kind.expression=表達式
dfa.find.cause.object.kind.method.return=方法返回
dfa.find.cause.type.known={0} 類型為 {1}
# ___PLACE___ is replaced with dfa.find.cause.place.*
dfa.find.cause.type.is.known.from.place=從 ___PLACE___ 已知 ''{0}'' 類型
dfa.find.cause.condition.is.known.from.place=已知 ''{0}'' 來自 ___PLACE___
dfa.find.cause.range.is.known.from.place=從 ___PLACE___ 已知範圍
dfa.find.cause.value.is.known.from.place=''{0}'' 已知為來自 ___PLACE___ 的 ''{1}''
dfa.find.cause.place.line.number=行 #{0}
dfa.find.cause.place.here=此處
dfa.find.cause.values.cannot.be.equal.because=值不能相等，因為 {0}
dfa.find.cause.condition.was.checked.before=條件 ''{0}'' 先前已檢查
dfa.find.cause.condition.was.deduced=條件 ''{0}'' 已被推導
dfa.find.cause.was.passed.as.non.null.parameter=''{0}'' 作為實參傳遞到接受非 null 參數的方法
dfa.find.cause.was.dereferenced=''{0}'' 已取消引用
dfa.find.cause.instanceof.implies.non.nullity='instanceof' 檢查表示非 null
dfa.find.cause.nullability.inferred={0} ''{1}'' 已推斷為 ''{2}''
dfa.find.cause.nullability.externally.annotated={0} ''{1}'' 外部註解為 ''{2}''
dfa.find.cause.nullability.explicitly.annotated={0} ''{1}'' 註解為 ''{2}''
dfa.find.cause.nullability.inherited.from.container={0} ''{1}'' 繼承容器註解，因此 ''{2}''
dfa.find.cause.nullability.inherited.from.class={0} ''{1}'' 自類 {2} 繼承註解，因此 ''{3}''
dfa.find.cause.nullability.inherited.from.package={0} ''{1}'' 自軟體套件 {2} 繼承註解，因此 ''{3}''
dfa.find.cause.nullability.inherited.from.named.element={0} ''{1}'' 繼承自 {2}，因此 ''{3}''
dfa.find.cause.field.initializer.nullability=欄位 ''{0}'' 初始化為 ''{1}'' 值
dfa.find.cause.field.assigned.nullability=已知欄位 ''{0}'' 始終初始化為 ''{1}'' 值
dfa.find.cause.array.length.is.always.non.negative=陣列長度始終為非負數
dfa.find.cause.string.length.is.always.non.negative=字串長度始終為非負數
dfa.find.cause.collection.size.is.always.non.negative=集合大小始終為非負數
dfa.find.cause.range.is.specified.by.annotation=註解將 ''{0}'' 的範圍指定為 {1}
# %s is replaced with value range like {0..255} or 'odd', etc. (see long.range.set.presentation.* above)
dfa.find.cause.result.of.primitive.cast.template=''({0})'' 轉換的結果為 %s
dfa.find.cause.result.of.numeric.operation.template=''{0}'' 的結果為 %s
dfa.find.cause.left.operand.range.template=左操作數為 %s
dfa.find.cause.right.operand.range.template=右操作數為 %s
dfa.find.cause.numeric.cast.operand.template=轉換操作數為 %s
dfa.find.cause.numeric.range.generic.template=值為 %s
# Here {0} is replaced with dfa.find.cause.nonnull.expression.kind.*
dfa.find.cause.obviously.non.null.expression=表達式不可為 null，因為它是 {0}
dfa.find.cause.nonnull.expression.kind.newly.created.object=新創建的物件
dfa.find.cause.nonnull.expression.kind.literal=文字
dfa.find.cause.nonnull.expression.kind.primitive.type=基元類型 ''{0}'' 的值
dfa.find.cause.nonnull.expression.kind.concatenation=串聯
dfa.find.cause.nonnull.expression.kind.this.object='this' 物件
# Here {0} is replaced with dfa.find.cause.contract.kind.*
dfa.find.cause.contract.trivial=根據{0}，{1} ''{2}'' 始終返回 ''{3}'' 值
dfa.find.cause.contract.throws.on.condition=根據{0}，{1} ''{2}'' 會在{3}時拋出異常
dfa.find.cause.contract.returns.on.condition=根據{0}，{1} ''{2}'' 會在{4}時返回 ''{3}''
dfa.find.cause.contract.kind.explicit=約定
dfa.find.cause.contract.kind.inferred=推斷約定
dfa.find.cause.contract.kind.hard.coded=硬編碼約定

type.constraint.assignability.explanation.exact={0} 已知為 {1}
type.constraint.assignability.explanation.exact.subtype={0} 類型恰好是 {1}，是 {2} 的子類型
type.constraint.assignability.explanation.exact.not.subtype={0} 類型恰好是 {1}，不是 {2} 的子類型
type.constraint.assignability.explanation.subtype.of.subtype=已知 {0} 是 {1}，是 {2} 的子類型
type.constraint.assignability.explanation.not.instance.of=已知 {0} 不是 {1}
type.constraint.assignability.explanation.not.instance.of.supertype=已知 {0} 不是 {2} 的父類型 {1}
type.constraint.assignability.explanation.definitely.inconvertible=已知 {0} 是 {1}，與 {2} 絕對不相容
inspection.message.javac.quick.intersection.type.problem=因為 ''{1}'' 為 final，交叉點類型 ''{0}'' 無法實例化
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9=在匯出的軟體套件中為類建議 package-private 可見性級別(Java 9+)
generate.members.position.at.caret=文字游標處
generate.members.position.after.equals.and.hashcode=equals() 和 hashCode() 後
generate.members.position.at.the.end.of.class=類結尾處

navigate.to.overridden.methods.title={0} 的覆寫方法
subclasses.search.progress.title=正在搜尋被覆寫的方法
progress.title.searching.for.overridden.methods=正在搜尋被覆寫的方法
arguments.count.mismatch=應為 {0} 個實參，但實際為 {1} 個
inspection.message.nullable.method.implements.non.null.method=''{1}'' 中可為 null 的方法 ''{0}'' 實作 ''{2}'' 中的非 null 方法
inspection.message.non.annotated.method.implements.non.null.method=''{1}'' 中的非註解方法 ''{0}'' 實作 ''{2}'' 中的非 null 方法
inspection.message.non.null.parameter.should.not.override.nullable.parameter=''{2}'' 中方法 ''{1}'' 的非 null 參數 ''{0}'' 不應當覆寫 ''{3}'' 中可為 null 的參數
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter=''{2}'' 中方法 ''{1}'' 的非註解參數 ''{0}'' 不應當覆寫 ''{3}'' 中非 null 參數
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter=''{2}'' 中方法 ''{1}'' 的非 null 參數 ''{0}'' 不應當覆寫 ''{3}'' 中的非註解參數
element.kind.keys=鍵
element.kind.values=值
element.kind.objects=物件
mutation.signature.problem.static.method.cannot.mutate.this=static 方法無法改變 'this'
mutation.signature.problem.reference.to.parameter.invalid=參數 #{0} 的引用無效
mutation.signature.problem.parameter.has.immutable.type=參數 #{0} 具有不可變類型 ''{1}''
mutation.signature.problem.invalid.token=無效的令牌: {0}；受支援的令牌為 ''this''、''param1''、''param2'' 等。
required.type=必需類型
provided.type=已提供
type.mismatch.reason=原因: {0}
inspection.message.code.generation.different.nullability.annotation.will.be.used=生成的程式碼將使用 ''{1}'' 而不是 ''{0}''。
change.visibility.level=將 {0} 設為 {1}
text.shebang.mechanism.in.java.files.not.permitted=不支持在 .java 檔案中使用事件機制
inspection.redundant.tostring.option.notnull.qualifier=僅在已知限定符為非 null 時報告
highlighting.try.blocks=正在高亮顯示 try 塊…
intention.family.name.remove.new.family.name=移除 'new'
intention.name.remove.new.display.name=移除 'new'
inspection.unsatisfied.range.display.name=返回值超出宣告的範圍
inspection.unsatisfied.range.message=返回值範圍 ''{0}'' 在宣告的範圍 ''{1}'' 之外
inspection.unsatisfied.range.message.value=返回值 ''{0}'' 超出宣告的範圍 ''{1}''
replace.with.boolean.equals=取代為 Boolean.equals
find.usages.panel.title.base.methods=基方法的用法
feature.patterns.in.switch=switch 中的模式
feature.guarded.and.parenthesised.patterns=受保護和帶圓括號的模式
dfa.find.cause.special.field.of.something={0}/{1}
find.usages.panel.title.derived.classes.cap=派生類
find.usages.panel.title.derived.interfaces.cap=派生接口
find.usages.panel.title.implementing.classes.cap=實作類
find.usages.panel.title.implementing.methods.cap=實作方法
find.usages.panel.title.overloaded.methods.usages.cap=多載方法
find.usages.panel.title.overriding.methods.cap=覆寫方法
find.usages.panel.title.base.methods.cap=基方法的用法
special.field.enum.ordinal=枚舉序數
service.click.to.navigate=點擊以導航
inspection.reference.lambda.name=lambda ({0})
inspection.reference.default.lambda.name=lambda
inspection.reference.method.reference.name=方法引用({0})
inspection.reference.default.method.reference.name=方法引用
dfa.find.cause.size.is.always.zero=大小始終為 0
dfa.find.cause.primitive.boxed=基元值已裝箱
inspection.use.compare.method.option.double=建議使用 Double.compare() 和 Float.compare()
inspection.use.compare.method.turn.off.double=不建議使用 Double.compare() 和 Float.compare() 方法
intention.family.name.move.annotation.to.array=將註解移動到陣列
ignore.in.the.same.project=忽略此專案中宣告的 API
inspection.message.scheduled.for.removal.annotation.can.be.replaced.by.attribute=@ScheduledForRemoval 註解可取代為 @Deprecated 註解中的 'forRemoval' 特性 
inspection.fix.name.remove.scheduled.for.removal.annotation.by.attribute=將 @ScheduledForRemoval 取代為 @Deprecated 註解中的 'forRemoval' 特性  
inspection.message.scheduled.for.removal.annotation.can.be.removed=可以移除 @ScheduledForRemoval 註解
inspection.name.redundant.scheduled.for.removal.annotation=冗餘的 @ScheduledForRemoval 註解
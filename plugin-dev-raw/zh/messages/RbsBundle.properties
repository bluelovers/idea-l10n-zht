filetype.rbs.description=RBS

rbs.model.attribute.accessor.shortDescription=特性存取器 ''{0}''
rbs.model.attribute.accessor.longDescription={1} 的特性存取器 ''{0}''
rbs.model.attribute.reader.shortDescription=特性讀取器 ''{0}''
rbs.model.attribute.reader.longDescription={1} 的特性讀取器 ''{0}''
rbs.model.attribute.writer.shortDescription=特性編寫器 ''{0}''
rbs.model.attribute.writer.longDescription={1} 的特性編寫器 ''{0}''
rbs.model.class.shortDescription=類 ''{0}''
rbs.model.class.longDescription=''{1}'' 中的類 ''{0}''
rbs.model.class.variable.shortDescription=類變數 ''{0}''
rbs.model.class.variable.longDescription={1} 的類變數 ''{0}''
rbs.model.constant.shortDescription=常數 ''{0}''
rbs.model.global.variable.shortDescription=全域變數 ''{0}''
rbs.model.instance.variable.shortDescription=實例變數 ''{0}''
rbs.model.instance.variable.longDescription={1} 的實例變數 ''{0}''
rbs.model.interface.shortDescription=接口 ''{0}''
rbs.model.interface.longDescription=''{1}'' 中的接口 ''{0}''
rbs.model.method.shortDescription=方法 ''{0}''
rbs.model.method.longDescription={1} 的方法 ''{0}''
rbs.model.module.shortDescription=模組 ''{0}''
rbs.model.module.longDescription=''{1}'' 中的模組 ''{0}''
rbs.model.singleton.shortDescription=單例 ''{0}''
rbs.model.type.alias.shortDescription=類型別名 ''{0}''
rbs.model.type.variable.shortDescription=類型變數 ''{0}''
rbs.model.type.variable.longDescription={1} 的類型變數 ''{0}''

rbs.model.descriptions.private.prefix=Private


# inspections
rbs.inspection.group.rbs.probable.bugs.name=可能的錯誤

# annotations
rbs.annotation.module.included.in.interface=接口中包含的類/模組
rbs.annotation.singleton.in.interface=接口內部的單例方法定義

# Line markers

rbs.lineMarker.partial.declarations=RBS 部分宣告
rbs.lineMarker.partial.declarations.title=選擇部分宣告

# actions

rbs.actions.create.file.text=RBS 檔案/類
rbs.actions.create.file.description=創建新的 RBS 檔案/類
rbs.actions.create.file.name=創建 RBS 檔案/類 {0}
rbs.actions.create.file.title=新建 RBS 檔案/類名
rbs.actions.create.dialog.file=檔案
rbs.actions.create.dialog.class=類
rbs.actions.create.dialog.module=模組
rbs.actions.create.dialog.interface=接口
rbs.actions.create.error.invalid.name=此名稱對所選類型無效
rbs.model.keyword.shortDescription=關鍵字 ''{0}''
rbs.model.parameter.shortDescription=參數 ''{0}''
rbs.inspection.duplicate=重複宣告
rbs.inspection.duplicate.type.alias=重複的類型別名宣告
rbs.inspection.duplicate.global.variable=重複的全域變數宣告
rbs.inspection.duplicate.constant=重複的常數宣告
rbs.inspection.duplicate.class.exists=''{0}'' 已作為類存在
rbs.inspection.duplicate.module.exists=''{0}'' 已作為模組存在
rbs.inspection.duplicate.different.superclass={0} 已使用 ''{1}'' 進行宣告
rbs.inspection.duplicate.interface=重複的接口宣告
rbs.inspection.duplicate.method=重複的方法定義
rbs.inspection.duplicate.includes.method=包括方法 ''{0}'' 的重複定義
rbs.inspection.duplicate.interface.include=已包含 {0}
rbs.inspection.duplicate.parameter=重複的參數
rbs.live.template.presentable.name=RBS
rbs.model.constant.longDescription=''{1}'' 中的常數 ''{0}''
rbs.model.type.alias.longDescription=''{1}'' 中的類型別名 ''{0}''
rbs.actions.run.anything.group.name=RBS
steep.actions.run.anything.group.name=Steep
rbs.actions.run.anything.help.placeholder=rbs <command>
steep.actions.run.anything.help.placeholder=steep <command>
action.rbs.cli.validate.description=確保 RBS 檔案中存在類型名稱並且類型套用程序具有正確的實參數量
action.rbs.cli.prototype.description=生成原型 RBS 檔案。支援的生成器包括 rb、rbi 和 runtime
action.rbs.cli.ancestors.description=顯示給定類或模組的上級。
action.rbs.cli.ast.description=列印所載入環境的 JSON AST。您可以指定使用文件名篩選宣告的模式
action.rbs.cli.constant.description=解析 RBS 內的給定常數
action.rbs.cli.list.description=列出所有類、模組和接口與定義
action.rbs.cli.method.description=顯示通過 `type_name` 和 `method_name` 指定的方法的定義
action.rbs.cli.methods.description=顯示在給定類或模組中定義的所有方法
action.rbs.cli.parse.description=解析給定 RBS 檔案並列印任何語法錯誤
action.rbs.cli.paths.description=顯示用於載入 RBS 檔案的路徑
action.rbs.cli.test.description=使用給定選項執行測試
action.rbs.cli.vendor.description=專案目錄中的供應商簽名
action.steep.cli.init.description=生成 Steepfile
action.steep.cli.validate.description=驗證 Steep 設定
action.steep.cli.check.description=執行類型檢查
action.steep.cli.annotations.description=檢查給定原始碼中的註解
action.rbs.generate.from.ruby.description=生成 Ruby 檔案的 RBS 簽名
rbs.action.output.null=無法執行 RBS prototype 指令
rbs.action.non.zero.exit.code=RBS 的非零退出程式碼: {0}
rbs.action.error.generating.rbs=生成 RBS 時出錯: {0}
action.rbs.generate.from.ruby.text=生成類型簽名
rbs.action.generate.title=正在生成類型簽名
action.rbs.cli.validate.text=執行 RBS Validate
action.rbs.cli.prototype.text=執行 RBS Prototype
action.rbs.cli.ancestors.text=執行 RBS Ancestors
action.rbs.cli.ast.text=執行 RBS Ast
action.rbs.cli.constant.text=執行 RBS Constant
action.rbs.cli.list.text=執行 RBS List
action.rbs.cli.method.text=執行 RBS Method
action.rbs.cli.methods.text=執行 RBS Methods
action.rbs.cli.parse.text=執行 RBS Parse
action.rbs.cli.paths.text=執行 RBS Paths
action.rbs.cli.test.text=執行 RBS Test
action.rbs.cli.vendor.text=執行 RBS Vendor
action.steep.cli.init.text=執行 Steep Init
action.steep.cli.validate.text=執行 Steep Validate
action.steep.cli.check.text=執行 Steep Check
action.steep.cli.annotations.text=執行 Steep Annotations
action.steep.cli.project.text=執行 Steep Project
action.steep.cli.watch.text=執行 Steep Watch
action.steep.cli.langserver.text=執行 Steep Langserver
action.steep.cli.stats.text=執行 Steep Stats
action.rbs.generate.from.ruby.popup.text=類型簽名
rbs.lineMarker.partial.declarations.tooltip.one=在以下位置有部分宣告:
rbs.lineMarker.partial.declarations.tooltip.few=在以下位置有部分宣告:
rbs.lineMarker.partial.declarations.tooltip.many=在多個檔案中有部分宣告
rbs.action.tab.title=執行 {0}
rbs.structure.view.qualified.name={1}中的{0}
rbs.rubysigs.location=庫根
rbs.rubysigs.name=rbs ({0}) [bundled]
rbs.rubysigs.name.with.version=rbs (v{0}, {1}) [bundled]
rbs.rubysigs.banner=已捆綁的簽名檔案(使用 RBS v{0} 和 Ruby v{1} 生成)
rbs.lineMarker.overloaded.declarations=RBS 多載方法
rbs.lineMarker.overloaded.declarations.title=選擇多載宣告
rbs.lineMarker.overloaded.declarations.tooltip.one=在以下位置有多載宣告:
rbs.lineMarker.overloaded.declarations.tooltip.few=在以下位置有多載宣告:
rbs.lineMarker.overloaded.declarations.tooltip.many=在多個檔案中有多載宣告
rbs.inspection.group.rbs=RBS
rbs.inspection.group.rbs.code.style.name=程式碼樣式問題
rbs.inspection.literal.class.referenced.name=引用的文字類
rbs.inspection.literal.class.referenced.description=引用的是 ''{0}''，而不是 ''{1}''
rbs.inspection.literal.class.referenced.replace.quickfix.name=取代為 ''{0}''
rbs.inspection.literal.class.referenced.replace.quickfix.family.name=取代為各自的文字
rbs.inspection.unnecessary.parentheses.name=不必要的圓括號
rbs.inspection.unnecessary.parentheses.description=函數類型中不必要的圓括號
rbs.inspection.unnecessary.parentheses.remove.quickfix.name=移除不必要的圓括號
rbs.inspection.incorrect.type.argument.count.name=類型實參計數不正確
rbs.inspection.incorrect.type.argument.count.add.description={0} 需要 {1, choice, 1# 1 個類型實參|2#{1} 個類型實參}
rbs.inspection.incorrect.type.argument.count.add.quickfix.name=添加{1, choice, 1#類型實參|2#{0} 個類型實參}
rbs.inspection.incorrect.type.argument.count.add.quickfix.family.name=添加缺少的類型實參
rbs.inspection.incorrect.type.argument.count.remove.description=提供的類型實參過多
rbs.inspection.incorrect.type.argument.count.remove.quickfix.name=移除多餘的{0, choice, 1#類型實參|2#類型實參}
rbs.inspection.incorrect.type.argument.count.remove.all.quickfix.name=移除{0, choice, 1#類型實參|2#類型實參}
rbs.inspection.incorrect.type.argument.count.remove.quickfix.family.name=移除多餘的類型實參
rbs.annotation.type.alias.used.as.self.type=用作自類型的類型別名
rbs.annotation.type.alias.used.as.self.type.remove.intention.name=移除 ''{0}''
rbs.annotation.type.alias.used.as.self.type.remove.intention.family.name=移除無效的自類型
rbs.inspection.group.rbs.data.flow.name=數據流
rbs.inspection.unused.type.alias.name=未使用的類型別名
rbs.inspection.unused.type.alias.description={0} 未使用
rbs.inspection.unused.type.alias.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.type.alias.remove.quickfix.family.name=移除未使用的類型別名
rbs.inspection.unused.interface.name=未使用的接口
rbs.inspection.unused.interface.description={0} 未使用
rbs.inspection.unused.interface.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.interface.remove.quickfix.family.name=移除未使用的接口
rbs.inspection.simplifiable.boolean.union.name=可簡化的布爾並集
rbs.inspection.simplifiable.boolean.union.description=可以簡化 ''{0} | {1}''
rbs.inspection.simplifiable.boolean.union.replace.quickfix.name=將 ''{0} | {1}'' 取代為 ''bool''
rbs.inspection.simplifiable.boolean.union.replace.quickfix.family.name=簡化布爾並集
rbs.inspection.dynamic.type.used.in.static.context.name=在 static 上下文中使用了動態類型
rbs.inspection.dynamic.type.used.in.static.context.description=在 static 上下文中使用了 ''{0}''
rbs.inspection.dynamic.type.used.in.static.context.replace.quickfix.name=取代為 ''{0}''
rbs.inspection.dynamic.type.used.in.static.context.replace.quickfix.family.name=取代為 static 對等項
rbs.search.presentation.element.in.container={0} ({1} 內)
rbs.search.usageType.alias.group=別名
rbs.search.usageType.declaration.group=宣告
rbs.search.usageType.superclass.clause.group=超類子句
rbs.search.usageType.self.type.clause.group=self 型子句
rbs.search.usageType.extend.include.prepend.call.group=extend/include/prepend 調用中的用法
rbs.search.usageType.nested.constant.access.group=嵌套常數存取
rbs.search.usageType.type.signature.group=類型簽名
rbs.inspection.group.rbs.inheritance.name=繼承問題
rbs.inspection.module.used.as.superclass.name=用作超類的模組
rbs.inspection.module.used.as.superclass.description=用作超類的 {0}
rbs.inspection.module.used.as.superclass.remove.quickfix.name=移除 ''< {0}''
rbs.inspection.module.used.as.superclass.remove.quickfix.family.name=移除無效的超類
rbs.annotation.interface.prepended=接口無法預置
rbs.annotation.interface.prepended.remove.quickfix.name=移除 ''prepend {0}''
rbs.annotation.interface.prepended.remove.quickfix.family.name=移除預置接口
rbs.inspection.unused.type.variable.name=未使用的類型變數
rbs.inspection.unused.type.variable.description={0} 未使用
rbs.inspection.unused.type.variable.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.type.variable.remove.quickfix.family.name=移除未使用的類型變數
rbs.inspection.invalid.method.overload.name=方法多載無效
rbs.inspection.invalid.method.overload.description=找不到 {0} 的非多載宣告
rbs.inspection.invalid.method.overload.remove.quickfix.family.name=移除 '...'
rbs.inspection.invalid.method.overload.replace.quickfix.family.name=取代為 '() -> untyped'
rbs.inspection.invalid.method.overload.remove.method.quickfix.name=移除 ''{0}''
rbs.inspection.invalid.method.overload.remove.method.quickfix.family.name=移除方法
rbs.inspection.unresolved.reference.name=未解析的引用
rbs.inspection.unresolved.reference.description=無法找到 ''{0}''
rbs.inspection.incorrect.declaration.type.variable.count.name=類型變數計數不正確
rbs.inspection.incorrect.declaration.type.variable.count.description={0} {1, choice, 0#沒有類型變數|1#有 1 個類型變數|2#有 {1} 個類型變數}，這與其他宣告衝突
rbs.inspection.incorrect.declaration.type.variable.count.add.quickfix.name=添加{0, choice, 1#類型變數|2#{0} 個類型變數}
rbs.inspection.incorrect.declaration.type.variable.count.add.quickfix.family.name=添加缺少的類型變數
rbs.inspection.incorrect.declaration.type.variable.count.remove.quickfix.name=移除{0, choice, 1#類型變數|2#{0} 個類型變數}
rbs.inspection.incorrect.declaration.type.variable.count.remove.quickfix.family.name=移除多餘的類型變數
rbs.inspection.incorrect.declaration.type.variable.count.goTo.quickfix.family.name=轉到衝突的宣告
rbs.inspection.incorrect.declaration.type.variable.count.goTo.quickfix.name.popup.title=選擇衝突的宣告
rbs.inspection.incorrect.inclusion.statement=包含調用不正確
rbs.inspection.incorrect.inclusion.statement.remove.quickfix.family.name=移除不正確的包含調用
rbs.inspection.incorrect.inclusion.statement.include.description=在 ''include'' 調用中使用的 {0}
rbs.inspection.incorrect.inclusion.statement.include.remove.quickfix.name=移除 ''include {0}''
rbs.inspection.incorrect.inclusion.statement.prepend.description=在 ''prepend'' 調用中使用的 {0}
rbs.inspection.incorrect.inclusion.statement.prepend.remove.quickfix.name=移除 ''prepend {0}''
rbs.inspection.incorrect.inclusion.statement.extend.description=在 ''extend'' 調用中使用的 {0}
rbs.inspection.incorrect.inclusion.statement.extend.remove.quickfix.name=移除 ''extend {0}''
rbs.annotation.interface.prepended.replace.include.quickfix.name=將 ''prepend {0}'' 更改為 ''include {0}''
rbs.annotation.interface.prepended.replace.include.quickfix.family.name=將預置接口更改為 'include'
rbs.annotation.interface.prepended.replace.extend.quickfix.name=將 ''prepend {0}'' 更改為 ''extend {0}''
rbs.annotation.interface.prepended.replace.extend.quickfix.family.name=將預置接口更改為 'extend'
rbs.annotation.remove.statement.fix=移除語句
rbs.annotation.singleton.in.interface.remove.quickfix.name=移除單例方法
rbs.annotation.singleton.in.interface.remove.alias.quickfix.name=移除單例別名
rbs.annotation.singleton.method.in.interface.quickfix.name=轉換為實例方法
rbs.annotation.singleton.alias.in.interface.quickfix.name=轉換為實例別名
rbs.annotation.remove.include.statement.quickfix.name=移除 'include' 語句
rbs.annotation.singleton.method.in.interface.quickfix.family.name=將單例方法轉換為實例方法
rbs.annotation.singleton.alias.in.interface.quickfix.family.name=將單例別名轉換為實例別名
rbs.inspection.duplicate.inclusion.call.remove.quickfix.name=移除''{0}''調用
rbs.inspection.duplicate.remove.superclass.quickfix.name=移除衝突的超類
rbs.inspection.duplicate.remove.quickfix.family.name=移除重複的宣告
rbs.inspection.duplicate.remove.method.quickfix.name=移除重複的方法
rbs.inspection.duplicate.remove.interface.quickfix.name=移除重複的接口
rbs.inspection.duplicate.remove.constant.quickfix.name=移除重複的常數
rbs.inspection.duplicate.remove.global.variable.quickfix.name=移除重複的全域變數
rbs.inspection.duplicate.remove.type.alias.quickfix.name=移除重複的類型別名
rbs.inspection.duplicate.go.to.duplicate.quickfix.name=轉到重複的宣告
rbs.inspection.duplicate.go.to.duplicate.title=選擇重複的宣告
rbs.inspection.duplicate.go.to.conflicting.declarations.quickfix.name=轉到衝突的宣告
rbs.inspection.duplicate.go.to.conflicting.declarations.title=選擇衝突的宣告
rbs.inspection.duplicate.remove.conflicting.class.quickfix.name=移除衝突的類
rbs.inspection.duplicate.remove.conflicting.module.quickfix.name=移除衝突的模組
rbs.inspection.duplicate.go.to.duplicate.included.method.quickfix.name=轉到重複包含的方法
rbs.inspection.duplicate.go.to.duplicate.included.method.title=選擇重複包含的方法
rbs.inspection.conflicting.type.variable.variance.name=類型變數差異衝突
rbs.inspection.conflicting.type.variable.variance.description={0} 有一個與{1, choice, 1#其他宣告|2#其他宣告}衝突的差異
rbs.model.descriptions.contravariant=逆變
rbs.model.descriptions.covariant=協變
rbs.model.descriptions.invariant=不變
rbs.inspection.incorrect.type.argument.variance.name=類型實參差異不正確
rbs.inspection.incorrect.type.argument.variance.description=用作{2, choice, 0#不變|1#協變|2#逆變}實參的 {0} {1}
rbs.inspection.invalid.type.argument.usage.name=類型實參用法無效
rbs.inspection.invalid.type.argument.usage.description={0} {1} 用於{2, choice, 0#不變|1#協變|2#逆變}位置
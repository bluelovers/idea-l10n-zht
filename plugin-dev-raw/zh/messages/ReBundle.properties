DbColumnsCheckboxTreeCellRenderer.forAssociation=用於關聯
DbColumnsCheckboxTreeCellRenderer.from=從
DbColumnsCheckboxTreeCellRenderer.incomingAttribute.tooltip=通過外鍵約束從 ''{0}'' 參照 - ''{1}''
DbColumnsCheckboxTreeCellRenderer.notNull=非 null
DbColumnsCheckboxTreeCellRenderer.to=到
DbColumnsCheckboxTreeCellRenderer.viaJoinTable=通過聯接表
DisplayName.entityDeclaration=JPA 實體宣告
DisplayName.reverseEngineering=JPA 逆向工程
NameCase.AsIs=保留原樣
NameCase.Lower=小寫
NameCase.Upper=大寫
RelationPanel.label.id.columns=ID 列\:
SettingsPage.accessModifier=預設實體特性存取修飾符
SettingsPage.accessModifierPrivate=private
SettingsPage.accessModifierProtected=protected
SettingsPage.className=類別名
SettingsPage.className.error=應指定類別名
SettingsPage.className.notFoundError=找不到指定類別名的類別
SettingsPage.constants.columnNames=列名
SettingsPage.constants.entityNames=實體名稱
SettingsPage.constants.error=必須指定所有持久性單元的類別名
SettingsPage.constants.tableNames=表名
SettingsPage.constantsSeparator=常數生成
SettingsPage.generateJpaOnGetter=在 getter 方法上生成 JPA 註解
SettingsPage.generateSerialVersionUID=生成串行版本 UID 欄位
SettingsPage.generationLanguage=基架語言
SettingsPage.indexConstraintNameCase=索引/約束名稱大小寫
SettingsPage.innerClassName=內部類別名
SettingsPage.interfaceName=接口名稱
SettingsPage.interfaceName.notInterface=指定的接口不是接口
SettingsPage.lombok.allArgsConstructor=生成 @AllArgsConstructor
SettingsPage.lombok.builder=生成 @Builder
SettingsPage.lombok.getterAndSetter=生成 @Getter 和 @Setter
SettingsPage.lombok.noArgsConstructor=生成 @NoArgsConstructor
SettingsPage.lombok.onlyExplicitlyIncluded=生成 @ToString 且 onlyExplicitlyIncluded \= true
SettingsPage.lombok.separator=Lombok
SettingsPage.lombok.toString=生成 @ToString
SettingsPage.mapReferencesToBasicType=將 ORM 參照取代為基本類型特性
SettingsPage.placeToGenerate=放置常數的位置
SettingsPage.putValuesIntoConstants=為新物件名稱生成常數
SettingsPage.re.naming.strategy.algorithm=算法
SettingsPage.re.naming.strategy.algorithm.incorrect=無法編譯自訂命名演算法
SettingsPage.re.naming.strategy.configs=組態
SettingsPage.registerTypesOnEntity=在實體上註冊 Hibernate 自訂類型
SettingsPage.templatesSeparator=名稱模板
SettingsPage.unpluralizeTableName=將表名轉換為單數形式以生成類別名
SettingsPage.useBuilderSetters=在特性 setter 中生成 "return this;"
SettingsPage.useLazy=為 @OneToOne 和 @ManyToOne 關聯使用 FetchType.LAZY
SettingsPage.useValidationAnnotation=使用驗證註解(NotNull、Size 等…)
action.JpbCreateUJpaEntityFromTable.text=從資料庫建立 {0}…
action.ReBulkReverseEngineering.text=資料庫中的{0}…
action.ReEntityAttributeFromDb.text=從資料庫建立 {0}…
action.ReNewEntityAttributeFromDb.text=資料庫中的實體特性…
action.move.down.text=下移
action.move.up.text=上移
action.refresh.description=重新整理
action.refresh.text=重新整理
addition.options=選項
column.name.attribute=特性
column.name.case=大小寫
column.name.class=類別
column.name.column.reference.name=列/參照名
column.name.mapping.type=映射類型
column.name.name=名稱
column.name.persistence.unit=持久性單元
column.name.pluralize=複數化
column.name.postfix=後綴
column.name.prefix=前綴
column.name.target=目標
column.name.underscore=下劃線
command.name.create.datatype.objects=建立資料類型物件
command.name.create.entity.attributes=建立實體特性
comment.saving.strategy=新增為
comments=<html>表和列註釋</html>
db.type=資料庫類型
java.type=特性/轉換器/Hibernate 類型
label.error=錯誤\!
mapping.type.editor=映射類型編輯器
naming.rules=命名規則
please.select.table=請選擇 {0}
popup.title.reverse.engineering=逆向工程
prefixes.to.skip.in.column.name=列名中要跳過的前綴
prefixes.to.skip.in.column.name.description=如果要跳過的前綴被指定為 <b>d_, t_</b>，並且對 <b>d_first_name</b> 和 <b>t_email</b> 列套用了逆向工程，則它們的前綴將不會出現在相應的實體欄位名稱中，因此得到的名稱將是 <b>firstName</b> 和 <b>email</b>，而不是 <b>dFirstName</b> 和 <b>tEmail</b>
prefixes.to.skip.in.table.name=表名中要跳過的前綴
prefixes.to.skip.in.table.name.description=如果要跳過的前綴被指定為 <b>sys_、p_</b>，並且對 <b>sys_user</b> 和 <b>p_product</b> 表套用了逆向工程，則它們的前綴將不會出現在相應的實體名稱中，因此得到的名稱將是 <b>User</b> 和 <b>Product</b>，而不是 <b>SysUser</b> 和 <b>PProduct</b>
progress.title.create.entity.attributes=建立實體特性…
relation.panel.initRelations=初始化實體關係
reserved.keyword.field.suffix=保留關鍵字欄位後綴
reverseEngineering.notifications=JPA 逆向工程通知
sql.type=SQL 類型
suffixes.to.skip.in.column.name=列名中要跳過的後綴
suffixes.to.skip.in.column.name.description=如果要跳過的後綴被指定為 <b>_d, _t</b>，並且對 <b>first_name_d</b> 和 <b>email_t</b> 列套用了逆向工程，則它們的前綴將不會出現在相應的實體欄位名稱中，因此得到的名稱將是 <b>firstName</b> 和 <b>email</b>，而不是 <b>firstNameD</b> 和 <b>emailT</b>
suffixes.to.skip.in.table.name=表名中要跳過的後綴
suffixes.to.skip.in.table.name.description=如果要跳過的後綴被指定為 <b>_sys、_p</b>，並且對 <b>user_sys</b> 和 <b>product_p</b> 表套用了逆向工程，則它們的前綴將不會出現在相應的實體名稱中，因此得到的名稱將是 <b>User</b> 和 <b>Product</b>，而不是 <b>UserSys</b> 和 <b>ProductP</b>
target.type=目標類型
unmapped.parent.attributes=<html>父實體的某些特性被映射到相應表中不存在的列。如果您想保留這些特性，可以手動建立它們的列，或使用專用動作自動生成 DDL (<a href\='https\://www.jetbrains.com/help/idea/jpa-buddy-database-versioning.html\#generate-differential-ddl'>指南</a>)。</html>
warning.composite.key.not.supported={0} 不支持組合鍵，因此無法自動正確映射此表
zero.table.found=<html><p>在資料庫中找不到任何可以生成實體的表/檢視。可能的原因之如下\:</p><ol><li>選擇了錯誤的資料庫連線。</li><li>資料庫中不存在表或檢視。</li><li>表或檢視位於非預設架構中。在這種情況下，請嘗試按照以下<a href\="https\://www.jetbrains.com/help/idea/schemas.html" target\="_blank">說明</a>調整資料庫連線。</html>

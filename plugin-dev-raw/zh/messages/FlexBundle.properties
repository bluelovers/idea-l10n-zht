flash.module.type.name=Flash 模組
flash.module.type.description=Flash 模組旨在用於開發以 <b>Adobe Flash</b> 平台為目標的內容。<br>利用該模組提供的建置設定，您可以為 web (Flash Player)、桌面 (Adobe AIR) 和 AIR 移動平台創建 <b>Flex</b> 或純 <b>ActionScript</b> 應用程式和庫。

debugger.waiting.player=正在等待 AIR 或 Flash Player 連接
remote.flash.debug.computer=<html>偵錯器正在等待 Flash 套用程序連接:<br><ul><li>在此計算機上啟動 Flash 或 AIR 套用程序。它將自動連接到偵錯器。</li><li>或右鍵點擊此計算機或遠端計算機上正在執行的 Flash Player，然後從右鍵選單中選擇“偵錯器”。</li></ul>此計算機的 IP 地址: {0}</html>
remote.flash.debug.mobile.network=<html>在 {0} 裝置上啟動移動 AIR 應用程式以開始偵錯。<br>(必須打包該套用程序，才能通過網絡進行偵錯)。<br><br>此計算機的 IP 地址: {1}</html>
remote.flash.debug.mobile.usb=<html>在 {0} 裝置上啟動移動 AIR 應用程式以開始偵錯。<br>(必須打包該套用程序，才能通過 USB 進行偵錯，連接埠 {1})。
initializing.flex.debugger=初始化 Flex 偵錯器
flex.debugger.startup.error=Flex 偵錯器啟動錯誤
flex.debugger.unexpected.communication.error=意外的偵錯播放器通信問題

must.accompany.includein.or.excludefrom.attribute={0} 必須伴隨 includeIn 或 excludeFrom 特性。
flex.invalid.enumeration.value={0} 不在可接受的枚舉值內
flex.break.point.title=Flex 中斷點
flex.invalid.integer.value=整數值無效
flex.invalid.number.value=數值無效

no.file.to.run=找不到 HTML 包裝器或 SWF 檔案來開始執行/偵錯
remote.url.is.not.accessible.title=遠端 URL 不可存取
remote.url.is.not.accessible.message=嘗試提取 ''{0}'' 時遇到以下 IO 異常: \n{1}\n要繼續嗎?
flex.run.config.url.can.not.be.run.with.flash.player=無法使用 Flash Player 啟動 URL
html.wrapper.can.not.be.run.with.flash.player=無法使用 Flash Player 啟動 HTML 包裝器
path.to.flash.player.not.set=未設定 Flash Player 的路徑('Launch with' 選項)
flash.player.not.found=找不到 Flash Player 可執行檔案: {0}
run.trusted=將輸出資料夾放到本地信任沙盒中(&E)
flex.run.config.incorrect.url=URL 不正確
flex.run.config.url.not.set=未設定要啟動的 URL 或檔案
debugger.sdk.not.found=找不到 SDK: {0}
file.not.found=找不到檔案: {0}
main.class.not.set=未指定主類
main.class.not.found=找不到主類 ''{0}''
rlm.main.class.not.set=未指定執行時載入模組的主類。
rlm.main.class.not.found=找不到執行時載入模組的主類: {0}
rlm.main.class.equal.to.bc.main.class=執行時載入模組的主類等於主套用程序類: ''{0}''
rlm.output.equal.to.bc.output=執行時載入模組的輸出檔案等於主套用程序的輸出檔案: ''{0}''
output.file.name.not.specified=未指定輸出文件名。
rlm.output.file.name.not.specified=未指定執行時載入模組的輸出檔案。
output.file.must.have.swf.extension=輸出檔案必須有 swf 副檔名。
rlm.output.file.must.have.swf.extension=執行時載入模組的輸出檔案必須有 swf 副檔名。
flex.sdk.version.unknown=未知版本
popup.title.step.into.function=單步進入函數
sdk.can.not.be.selected=無法在此處選擇 SDK ''{0}''。\n請選擇 Flex/AIR SDK。
select.flex.sdk=選擇 Flex/AIR SDK
cannot.resolve.state=狀態引用無效
configuration.not.valid=執行設定錯誤: {0}
module.not.specified=未指定模組
module.not.found=找不到模組 ''{0}''
flexunit.not.found.for.bc=建置設定 ''{0}'' 的依賴項不包括 FlexUnit 庫
no.test.method.specified=未指定測試方法
method.not.valid=方法 ''{0}'' 不存在或不適合在測試中執行
package.not.valid=缺少 ''{0}'' 軟體套件或此軟體套件為空
class.not.public=''{0}'' 不為 public
class.not.specified=未指定類
test.class.not.specified=未指定測試類
class.not.found=未找到類 ''{0}''
class.contains.no.tests=類 ''{0}'' 不包含測試
tests.in=''{0}'' 中的測試
no.free.port=找不到空閒連接埠
flexunit.startup.error=無法啟動 FlexUnit 會話: {0}
port.is.busy=連接埠 {0} 繁忙

flexunit.inspections.group=FlexUnit
flexunit.inspection.testclassvisibility.displayname=測試類不為 public
flexunit.inspection.testmethodvisibility.displayname=測試方法不為 public
flexunit.inspection.testclassvisibility.message=測試類應為 public
flexunit.inspection.testmethodvisibility.message=測試方法應為 public
flexunit.inspection.testmethodisstatic.displayname=測試方法為 static
flexunit.inspection.testmethodisstatic.message=測試方法不應為 static
flexunit.fix.remove.static.modifier=移除 static 修飾符
flexunit.inspection.testmethodisproperty.displayname=測試方法為 getter/setter
flexunit.inspection.testmethodisproperty.message=測試方法不應為 getter 或 setter
flexunit.inspection.testmethodhasparameters.displayname=測試方法具有必需參數
flexunit.inspection.testmethodhasparameters.message=測試方法不應具有必需參數
flexunit.inspection.testmethodreturntype.displayname=測試方法應返回 void
flexunit.inspection.testmethodreturntype.message=測試方法應返回 void
flexunit.inspection.mixedapi.displayname=擴展 FlexUnit 1 或 Flunit TestCase 的類中的 FlexUnit 4 測試方法
flexunit.inspection.mixedapi.message=擴展 FlexUnit 1 或 Flunit TestCase 的類中的 FlexUnit 4 測試方法
flexunit.inspection.testclassinproductsource.displayname=產品源中的測試類
flexunit.inspection.testclassinproductsource.message=產品源中的測試類
flexunit.inspection.testclasswithnotests.displayname=測試類沒有測試
flexunit.inspection.testclasswithnotests.message=測試類沒有測試
flexunit.inspection.runnerclass.displayname=自訂執行程序類實作 IRunner 接口
flexunit.inspection.runnerclass.message=類未實作 IRunner 接口
flexunit.inspection.testmethodinsuite.message=測試方法位於套件中
flexunit.inspection.testmethodinsuite.displayname=測試方法位於套件中
flexunit.inspection.emptysuite.message=測試套件為空
flexunit.inspection.emptysuite.displayname=測試套件為空
flexunit.inspection.suitewithnorunner.displayname=測試套件未指定執行程序類
flexunit.inspection.suitewithnorunner.message=測試套件未指定執行程序類
flexunit.test.runner.caption=FlexUnit 測試執行程序
invalid.flex.compiler.heap.size=Flex 編譯器堆大小無效
fcsh.out.of.memory.and.restarted=Flex 編譯器 shell 記憶體不足，將重啟。在“{0} | 編譯器 | Flex 編譯器”頁面可以增加其堆大小
compiling.module=正在編譯模組 ''{0}''…
unnamed=未命名
js.actionscript.specific.group.name=ActionScript 特定
js.implicitly.internal.declaration.inspection.name=具有隱式存取類型的宣告
js.implicitly.internal.declaration.problem=宣告具有隱式軟體套件內部範圍 #loc
js.implicitly.internal.declaration.problem.add.internal.fix=添加顯式 internal 修飾符
js.untyped.declaration.inspection.name=沒有類型的宣告
js.untyped.variable.problem=變數 {0} 沒有類型 #loc
js.untyped.function.problem=函數 {0} 沒有返回類型 #loc
js.untyped.declaration.problem.addtype.fix=向宣告中添加類型
js.field.can.be.local.name=欄位可以為本地欄位
js.field.can.be.converted.to.local=欄位可以被轉換為一個局部變數
js.convert.to.local.quick.fix=轉換為本地

flash.builder=Flash Builder
flash.builder.project.import.title=Flash Builder 專案匯入
sdk.for.imported.projects=所匯入的 Flash Builder {0, choice, 1#專案|2#專案}的 SDK: 
flash.builder.workspace.or.project.dir=Flash Builder 工作區或專案，*.fxp、*.fxpl 或 *.zip 檔案(&F)
select.flash.builder.workspace.or.project=選擇 *.fxp、*.fxpl 或 *.zip 檔案、Flash Builder 工作區或專案
specify.flash.builder.workspace.or.project.dir=未設定檔案或資料夾路徑
dialog.title.import.from.flash.builder=從 Flash Builder 匯入 {0}
folder.not.empty=資料夾不為空: \n{0}\n某些檔案可能會被覆蓋。\n\n是否繼續?
folder.does.not.exist=資料夾不存在: ''{0}''
file.or.folder.not.found=找不到檔案或資料夾: {0}
flash.builder.projects.not.found.in=在所選資料夾中找不到 Flash Builder 專案
not.flash.builder.project=所選檔案不是 Flash Builder 專案
does.not.contain.flash.builder.projects=所選歸檔不包含 Flash Builder 專案
incorrect.file.format=所選歸檔的格式不正確
folder.to.unzip.one.FB.project=將專案提取到
folder.to.unzip.several.FB.projects=找到多個專案。將它們提取到以下專案的對應子資料夾:
note.multiple.projects.extract.to.subfolders=注意: 找到多個專案。它們將被提取到對應的子資料夾。
extract.single.to.subfolder.0=為提取的專案創建子資料夾 ''{0}''
project.location=專案位置
project.files.location=專案檔案位置
open.project.0=開啟專案 ''{0}''
failed.to.extract.project=無法提取專案: \n{0}
project.name.empty=專案名稱不能為空
project.path.empty=專案檔案的位置不能為空
looking.for.flash.builder.projects=正在尋找 Flash Builder 專案

adl.not.set.check.sdk.settings=未設定 AIR Debug Launcher。檢查 SDK ''{0}'' 的設定
adl.not.found.check.sdk.settings=在 ''{0}'' 處找不到 AIR Debug Launcher。檢查 SDK ''{1}'' 的設定
adl.not.found.check.sdk.installation=在 ''{0}'' 處找不到 AIR Debug Launcher。檢查 SDK ''{1}'' 的安裝
air.runtime.not.set.check.sdk.settings=未設定 AIR 執行時。檢查 SDK ''{0}'' 的設定
air.runtime.not.found.check.sdk.settings=在 ''{0}'' 處找不到 AIR 執行時。檢查 SDK ''{1}'' 的設定
checking.url=正在檢查 URL ''{0}''
bad.url=錯誤的 URL: {0}
no.response.from.server={0} 秒內伺服器無響應
choose.event.class.title=選擇事件類
compilation.skipped.because.nothing.changed.in=自上次編譯以來，模組 ''{0}'' 中沒有進行過任何更改。跳過…\n點擊“建置”選單中的“重新建置專案”以強制進行編譯。
compilation.skipped.because.nothing.changed=自上次編譯以來沒有進行過任何更改。跳過…\n點擊“建置”選單中的“重新建置專案”以強制進行編譯。
compilation.skipped=已跳過編譯
dumb.mode.flex.unit.warning=更新索引時無法執行 FlexUnit 測試。建置索引後，請再次執行此執行設定。
debugger.show.full.value=查看
breakpoint.condition.error=中斷點條件錯誤
failed.to.evaluate.breakpoint.condition=無法評估中斷點條件: {0}\n\n要在中斷點處停止嗎?
not.boolean.breakpoint.condition=無法評估中斷點條件: {0}\n結果值不是布林值: {1}\n\n要在中斷點處停止嗎?

error.creating.flash.player.trust.folder=SWF 檔案未添加到本地信任沙盒\n無法創建 FlashPlayerTrust 資料夾: {0}
flash.player.trust.folder.does.not.exist=SWF 檔案未添加到本地信任沙盒\nFlashPlayerTrust 資料夾不存在
error.creating.idea.trust.cfg.file=SWF 檔案未添加到本地信任沙盒\n無法在 FlashPlayerTrust 資料夾中創建 {0} 檔案: {1}
could.not.find.swf.to.trust=找不到要添加到本地信任沙盒的 SWF 檔案
failed.to.update.idea.trust.cfg.file=無法更新 FlashPlayerTrust 資料夾中的 {0} 檔案: {1}

file.created=已創建 <a href="">{0}</a>
html.wrapper.creation.failed=無法創建 HTML 包裝器\n{0}
error.title=錯誤

root.tag.must.contain.language.namespace=根標記必須包含語言命名空間宣告
different.language.namespaces=在 MXML 檔案中宣告了不同的語言命名空間
remove.namespace.declaration=移除命名空間宣告
declare.namespace=宣告命名空間 {0}
flex.choose.color.dialog.title=選擇顏色
system.default.application=系統預設套用程序
launch.with.title=啟動方式
cant.launch=無法使用 {1}\n開啟 {0}\n錯誤: {2}
css.files.title=要編譯為 SWF 的 CSS 檔案

livetemplate.description.iter=迭代 (for each..in)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.ritar=以相反順序遍歷陣列的元素

create.skin=創建皮膚 ''{0}''
invalid.element.name=無效 {0} 名稱: {1}
element.name.empty={0} 名稱為空
choose.host.component=選擇主機組件
css.inspections.stray.brace=Flex CSS 中的雜散大括號
css.inspections.stray.closing.brace=右大括號沒有對應的左大括號
css.inspections.stray.opening.brace=左大括號沒有對應的右大括號
choose.parent.component.dialog.title=選擇父組件
intention.create.subclass.or.implement.interface=創建子類或實作接口
intention.create.event.handler=創建事件處理程序

threads=執行緒
processes=行程
using.builtin.compiler=使用內建的編譯器 shell，最多 {0} 個並行執行緒
using.mxmlc.compc=使用 Flex SDK 中的 mxmlc/compc 工具，最多 {0} 個並行進程
or.asc.2.0=，或 ASC 2.0(如果可用)，用於純 ActionScript 建置設定
see.flex.compiler.page=在“{0} | 編譯器 Flex 編譯器”頁面中查看編譯器設定
can.not.use.built.in.compiler.shell=無法使用內建的編譯器 shell，原因是為不同的建置設定設定了不同的 Flex SDK。

add.doc.url.button=添加文檔 URL

generating.flex.configs=正在生成 Flex 編譯器設定檔案
generating.flex.config.for=正在為 {0} 生成 Flex 編譯器設定檔案
flexmojos.warning.short=<html>無法生成 Flex 編譯器設定檔案。<br><a href="">詳細資訊…</a></html>
flexmojos.warning.detailed=<html><p>IntelliJ IDEA 無法生成 <b>Flex 編譯器設定檔案</b>和其他輔助檔案<br>(target/[project_name]-config-report.xml and target/classes/config-[version]/*.*)</p><br><p>這些檔案對於 Flexmojos 專案中的正確程式碼高亮顯示、補全和編譯而言必不可少。<br>要確保所需檔案處於最新狀態，請從命令行執行以下 Maven 指令: </p><pre><b>mvn compile -DconfigurationReport=true</b></pre></html>

flexmojos4.details.start=日誌中提供了完整的資訊(幫助 | 顯示日誌)\n\n{0}
flexmojos4.warning=無法生成 Flex 編譯器設定檔案。\n{0}
flexmojos4.warning.with.link=<html>無法生成 Flex 編譯器設定檔案。<br><a href="">詳細資訊…</a></html>
flexmojos.maven.plugin.outdated.warning=請從您的 POM ({0})中移除過時的 idea-flexmojos-maven-plugin

flexmojos.project.import=Flexmojos 專案匯入
run.when.ide.builder.turned.off=<html>為<a href="BuildConfiguration">建置設定 ''{0}''</a>(模組 ''{1}'')設定了“跳過編譯”標誌。<br>啟動的應用程式可能丟失或已過時。<br><br><a href="DisableWarning">禁用警告</a></html>
run.when.compile.before.run.turned.off=<html>此<a href="RunConfiguration">執行設定</a>的“啟動前建置”選項已關閉。<br>啟動的應用程式可能丟失或已過時。<br><br><a href="DisableWarning">禁用警告</a></html>
flex.sdk.3.mac.debug.problem=<html>Flex SDK {0} 中的偵錯器不適用於 Flash Player11.x。<br/>建議在<a href="RunConfiguration">執行設定</a>的“使用 SDK 中的偵錯器”欄位選擇 Flex SDK 4.x。
edit.configuration.title=編輯設定
replace.base.component.prompt=將基礎組件 ''{0}'' 取代為 ''{1}''?
replace.base.class.prompt=將基類 ''{0}'' 取代為 ''{1}''?
create.edge.title=創建邊緣
create.extends.relationship.command.name={0} 擴展 {1}
create.implements.relationship.command.name={0} 實作 {1}
base.component.needed.message=無法移除與基礎組件的關係
remove.edge.title=移除邊緣
remove.inheritance.link.prompt=移除 ''{0}'' 與 ''{1}'' 之間的繼承鏈接?
remove.relationship.command.name=移除繼承關係
move.0=移動 {0} {1}
move.file.local.0=移動內部{0}{1}
move.elements=移動指定的元素
move.command.name=將 {0} 移至 {1}
element.to.be.moved.to={0} 將被移至 {1}
elements.to.be.moved.to=元素將被移至{0}
references.in.code.to.0=程式碼中對{0}的引用
package.name.title=軟體套件名稱:
to.package.title=到軟體套件:
element.to.be.moved.to.upper.level=內部{0}將被移至上一個級別({1})
move.to.upper.level.command.name=將內部{0}移至{1}
references.in.code.to.inner.0=程式碼中對內部{0}的引用
element.name={0} 名稱(&N):
android.application.launched=在裝置上啟動的 Android 套用
ios.application.packaged.to.run=<html>iOS 套用程序軟體套件 <a href="">{0}</a> 已成功創建。<br>您現在可以使用 iTunes 將其安裝在裝置上。</html>
ios.application.packaged.to.debug=<html>iOS 套用程序軟體套件 <a href="">{0}</a> 已成功創建。<br>您現在可以使用 iTunes 在裝置上進行安裝。<br><br>偵錯器正在等待在該裝置上啟動應用程式…</html>
ios.application.installed.to.run=已成功安裝 iOS 套用程序 ''{0}''，\n現在您可以在裝置上啟動它了。
ios.application.installed.to.debug=已成功安裝 iOS 套用程序 ''{0}''，\n現在您可以在裝置上啟動並開始偵錯了。
ios.simulator.application.launched=在 iOS 模擬器上啟動的應用程式

css.flex.dialect.name=Flex
unexpected.empty.adt.output=ADT 工具無輸出
air.mobile.version.problem.title=AIR 版本
air.ios.debug.via.usb.requires.3.4=要通過 USB 偵錯 iOS 套用程序，需要使用 <b>AIR 3.4 或更高版本</b>。
air.ios.simulator.requires.3.3=要在 iOS 模擬器上執行應用程式，需要使用 <b>AIR 3.3 或更高版本</b>。
air.captive.packaging.requires.3.0=要使用 captive runtime 創建 AIR 軟體套件，需要使用 <b>AIR 3.0 或更高版本</b>。
air.mobile.ios.fast.packaging.requires.2.7=要在解釋器模式(快速打包)下創建 iOS 軟體套件，需要使用 <b>AIR 2.7 或更高版本</b>。
air.mobile.packaging.requires.2.6=要創建 AIR 移動軟體套件，需要使用 <b>AIR 2.6 或更高版本</b>。
air.mobile.packaging.version.problem=<html>{0}<br><br>SDK ''{1}'' 包含 AIR {2}。<br>您可以執行下面的一項操作:<ul><li>在當前使用的 Flex SDK 上解壓縮 AIR SDK {3} 或更高版本</li><li>使用已包含 AIR {3} 或更高版本的 Flex SDK 的另一個版本</li></ul></html>
launch.android.application.title=啟動 Android 套用
launching.android.application=啟動 Android 套用 {0}
launch.ios.application.title=啟動 iOS 套用程序
launching.ios.application=啟動 iOS 套用程序 {0}
adb.forward.title=ADB 前向
check.ios.devices.title=檢查 iOS 裝置
checking.ios.devices=正在檢查 iOS 裝置
more.than.one.ios.device=多台 iOS 裝置已連接到計算機
idb.forward=IDB 前向
idb.forward.title=IDB 前向
packaging.application=打包 {0} 套用程序
air.application.created=創建的 <html>AIR {0, choice, 1#套用程序|2#套用程序}: <br>{1}</html>
dialog.edit.template.checkbox.mxml=MXML(&M)
air.runtime.version.title=AIR 運行時版本
air.runtime.not.installed=裝置上未安裝 AIR 執行時。\nSDK ''{0}'' 包含 AIR 執行時 {1}。\n\n要安裝嗎?
update.air.runtime.question=裝置上已安裝 AIR 執行時 {0}。\nSDK ''{1} 包含 AIR 執行時 {2}。\n\n要安裝較新的版本嗎?
check.air.version.title=檢查 AIR 版本
checking.air.version=正在檢查 AIR 版本
uninstall.air.runtime.title=解除安裝 AIR 運行時
uninstalling.air.runtime=正在解除安裝 AIR 運行時
install.air.runtime.title=安裝 AIR 執行時
installing.air.runtime=正在安裝 AIR 執行時 {0}
create.android.package.title=創建 Android 軟體套件
create.ios.package.title=創建 iOS 軟體套件
creating.android.package=正在創建 Android 軟體套件
creating.ios.package=正在創建 iOS 軟體套件
install.android.application.title=安裝 Android 套用
install.ipa.on.simulator.title=在 iOS 模擬器上安裝應用程式
install.ios.app.title=安裝 iOS 套用程序
installing.0=正在安裝 {0}
uninstall.android.application.title=移除 Android 套用
uninstall.ios.simulator.application.title=從 iOS 模擬器移除應用程式
uninstalling.0=正在移除 {0}
clear.directive.state.specific.error='@Clear' 指令只能用於狀態特定的樣式屬性
clear.directive.IStyleClient.error=僅允許實作 mx.styles.IStyleClient 接口的類的樣式屬性使用 '@Clear()' 指令
unknown.color.error=未知顏色: ''{0}''
sdk.not.set=未設定 SDK
output.file.name.not.set=未設定輸出文件名
output.file.wrong.extension=輸出文件名必須有 {0} 副檔名
not.a.css.runtime.stylesheet=檔案 ''{0}'' 不能用作執行時樣式表，僅允許使用 CSS 檔案。
css.not.found=執行時樣式表: 檔案不存在: {0}
file.to.include.in.swc.not.found=要包含在 SWC 中的檔案: 檔案 ''{0}'' 不存在
output.folder.not.set=未設定輸出資料夾
flexunit.output.folder.not.set=未設定專案輸出資料夾或其路徑不是絕對路徑(FlexUnit 需要絕對路徑)
output.folder.not.absolute=輸出資料夾的路徑必須為絕對路徑: {0}
html.template.folder.not.set=未設定包含 HTML 包裝器模板的資料夾
html.template.folder.not.found=包含 HTML 包裝器模板的資料夾不存在: ''{0}''
package.file.name.not.set=未設定 {0} 軟體套件文件名
packaging.options.empty.file.name={0} 打包選項，要打包的檔案: 表中的路徑為空
packaging.options.empty.relative.path={0} 打包選項，要打包的檔案: 表中的相對路徑為空
folder.to.package.includes.output={0} 打包選項: 要打包的資料夾包含輸出資料夾: {1}
packaging.options.bad.ios.sdk.path={0} 打包選項: 在 {1} 下找不到 iOS SDK
ios.provisioning.profile.not.set=未設定 iOS 預配設定檔案
ios.provisioning.profile.not.found=找不到 iOS 預配設定檔案: {0}
keystore.not.set={0} 簽名選項: 未設定密鑰庫
keystore.not.found={0} 簽名選項: 找不到密鑰庫檔案: {1}
packaging.options.relative.path.not.matches={0} 打包選項，要打包的檔案: 相對資料夾路徑與其完整路徑不符合: {1}
packaging.options.file.not.found={0} 打包選項，找不到檔案: {1}
additional.config.file.not.found=找不到其他編譯器設定檔案: {0}
bc.dependency.problem=發現禁止的依賴項: \n建置設定 ''{0}'' ({2}，模組 ''{1}'')\n依賴於建置設定 ''{3}'' ({5}，模組 ''{4}'')。\n依賴項類型: {6}
run.configuration.0=執行設定 ''{0}''
project.setup.problem=專案設定問題: {0}
project.setup.problem.title=專案設定問題
bc.dependency.does.not.exist=建置設定 ''{0}'' (模組''{1}'')不存在。\n設定為建置設定 ''{2}'' (模組 ''{3}'')的依賴項
bc.not.specified=未指定建置設定
module.does.not.contain.bc=模組 ''{0}'' 不包含建置設定 ''{1}''
bc.does.not.produce.app=建置設定 ''{0}'' (模組 ''{1}'')不會生成可執行的應用程式
android.disabled.in.bc=未在建置設定 ''{0}'' (模組 ''{1}'')中啟用 Android 支援
ios.disabled.in.bc=未在建置設定 ''{0}'' (模組 ''{1}'')中啟用 iOS 支援
bc.0.module.1.android.custom.descriptor.not.set=建置設定 ''{0}'' (模組 ''{1}''):\n未設定自訂 Android 套用描述符路徑
bc.0.module.1.ios.custom.descriptor.not.set=建置設定 ''{0}'' (模組 ''{1}''):\n未設定自訂 iOS 套用描述符路徑
bc.0.module.1.custom.descriptor.not.set=建置設定 ''{0}'' (模組 ''{1}''):\n未設定自訂套用描述符路徑
bc.0.module.1.android.custom.descriptor.not.found=建置設定 ''{0}'' (模組 ''{1}''): \n找不到自訂 Android 套用描述符:\n{2}
bc.0.module.1.ios.custom.descriptor.not.found=建置設定 ''{0}'' (模組 ''{1}''): \n找不到自訂 iOS 套用描述符:\n{2}
bc.0.module.1.custom.descriptor.not.found=建置設定 ''{0}'' (模組 ''{1}''):\n找不到自訂套用描述符: \n{2}
bc.0.module.1.air.version.mismatch.warning=建置設定 ''{0}'' (模組 ''{1}''):<br>套用描述符中的 AIR 版本({2})與 AIR SDK 版本不符合: {3}。<br>{4}
custom.descriptor.not.set=未設定自訂 {0} 套用描述符路徑
custom.descriptor.not.found=找不到自訂 {0} 套用描述符: {1}
air.version.mismatch.warning=警告: {0} 套用描述符 {1} 中的 AIR 版本({2})與 AIR SDK 版本不符合: {3}
same.output.files=輸出檔案與建置設定 ''{0}'' (模組 ''{1}'')中的相同: {2}
same.output.files.as.in.bcs=輸出檔案與建置{0, choice, 1#設定|2#設定} {1} 相同: {2}
sdk.does.not.support.air.mobile=Flex SDK {0} 不支持 AIR 移動開發
sample.app.name.empty=未指定範例套用程序文件名
sample.app.incorrect.extension=範例套用程序必須具有 .mxml 或 .as 檔案副檔名
failed.to.create.folder=無法創建資料夾 {0}: \n{1}
create.html.wrapper.template.title=創建 HTML 包裝器模板
selected.path.not.folder=所選路徑不是資料夾: \n{0}
folder.not.empty.clear.or.overwrite=所選資料夾不為空。\n要移除其內容還是保留現有檔案(在後一種情況下，某些檔案可能會被覆蓋)?
folder.not.empty.clear.option=移除(&R)
folder.not.empty.keep.option=保持(&K)
folder.not.empty.cancel.option=取消(&C)
failed.to.delete=無法移除檔案: \n{0}
html.wrapper.in.sdk.not.found=在 SDK 安裝中找不到包含 HTML 包裝器模板的資料夾: \n{0}
create.air.descriptor.template.title=創建 AIR 描述符模板
use.same.descriptor.for.android.and.ios=要將創建的 AIR 描述符模板用於 Android 和 iOS 打包嗎?
file.exists.replace.question=要取代現有檔案({0})嗎?
default.compiler.options.for.module.title=模組 ''{0}'' 的預設編譯器選項
default.compiler.options.for.project.title=專案 ''{0}'' 的預設編譯器選項
overridden.in.config.file={0} 被其他編譯器設定檔案覆蓋。實際值: {1}
main.class.and.output.overridden.in.config.file=主類和輸出路徑在其他編譯器設定檔案中被覆蓋
actual.value.from.config.file.0=設定檔案中的實際值: {0}
set.up.sdk.title=設定建置設定 SDK
choose.build.configuration.popup.title=模組 ''{0}'' 的有效 Flash 建置設定
active.bc.widget.tooltip=Flash 建置設定 ''{0}'' 用於模組 ''{1}'' 中的原始碼高亮顯示和補全
active.bc.widget.empty.tooltip=<html>此窗格顯示了上下文中該模組的有效 Flash 建置設定。<br>有效建置設定用於高亮顯示和補全原始碼。</html>
active.bc.widget.empty.text=Flash 建置設定
flex.sdk.presentable.name=Flex/AIR SDK
add.build.configuration.title=添加建置設定(模組 ''{0}'')
copy.build.configuration=複製建置設定 ''{0}'' (模組 ''{1}'')
build.configurations.popup.separator.text=建置設定
module.sdk.label=模組 SDK(&S):
project.sdk.label=專案 SDK(&S):
bc.0.module.1.problem.2=建置設定 ''{0}'' (模組 ''{1}''): {2}
bc.tab.general.display.name=一般
bc.tab.dependencies.display.name=依賴項
bc.tab.compiler.options.display.name=編譯器選項
bc.tab.air.desktop.display.name=AIR 軟體套件
bc.tab.android.display.name=Android
bc.tab.ios.packaging.display.name=iOS
bc.problem.no.sdk=未定義 SDK。
bc.problem.sdk.not.found=找不到 Flex SDK ''{0}''。
bc.problem.dependency.module.not.found=缺少依賴項模組 ''{0}''。
bc.problem.dependency.bc.not.found=模組 ''{1}'' 中缺少依賴項建置設定 ''{0}''。
bc.structure.element.type.name=建置設定
can.not.package.bc=<html><b>{0}</b>: {1}</html>
package.bc.with.disabled.compilation=<html>為以下建置{0, choice, 1#設定|2＃設定} 禁用編譯: <br><br>{1}<br>現有 SWF {0, choice, 1#檔案|2#檔案} 可能已過時。<br><br>根據現有的SWF {0, choice, 1#檔案|2#檔案} 創建{0, choice, 1#軟體套件|2#軟體套件}?</html>
package.air.application.title=打包 AIR 套用程序
packaging.air.application=正在打包 AIR 套用程序: {0}
failed.to.create.air.package=<html>無法打包 AIR 套用程序 {0}: <br><br>{1}<br><br>[<a href="adt.command.line">ADT 命令行</a>]</html>
failed.to.create.air.package.truncated=<html>無法打包 AIR 套用程序 {0}: <br><br>{1}<br><br>[<a href="full.error.message">完整錯誤訊息</a>]<br>[<a href="adt.command.line">ADT 命令行</a>]</html>
copying.0=正在複製 {0}…
add.bc.dependency.dialog.title=添加依賴項
add.dependency.bc.dialog.label=選擇要依賴的建置設定:
no.applicable.bcs=找不到適用的建置設定
choose.bc.dialog.title=選擇 Flash 建置設定
choose.bc.dialog.label=庫 ''{0}'' 將添加到所選建置設定:
swc.libraries.root.detector.name=SWC 或 ANE 庫
docs.root.detector.name=文檔
as.libraries.root.detector.name=原始 ActionScript 庫
sources.root.detector.name=庫原始碼
swc.folders.root.detector.name=包含 SWC 或 ANE 的資料夾
add.module.library.action.text=新建庫…
documentation.order.root.type.name=文檔
items.to.include.in.swc.dialog.title=要包含在 SWC 中的檔案和資料夾
rlms.dialog.title=執行時載入的模組
choose.rlm.main.class.title=選擇執行時載入的模組的主類
css.files.to.compile.dialog.title=要編譯的 CSS 檔案
different.debug.settings=無法同時為  {0, choice, 1#Android |2#iOS} 創建可偵錯軟體套件，也無法同時為  {0, choice, 1#Android |2#iOS} 創建不可偵錯軟體套件
compilation.is.switched.off=編譯已關閉且輸出 SWF 不存在
main.class.is.not.a.subclass.of=主類 ''{0}'' 不是 {1} 的 public 子類。
change.bc.type.title=更改建置設定類型
bc.dialog.up.down.tooltip=使用上下鍵更改目標平台，按住 Shift 鍵更改輸出類型
check.flash.app.compiled.before.launch.notification.group=啟動前未編譯 Flash 套用
0.module.1=''{0}'' (模組 ''{1}'')
open.project.structure=專案結構…
autodetected.source.root.type=ActionScript/Flex
create.bc.action.text=Flash 建置設定
create.bc.action.description=新建 Flash 建置設定
library.editor.title.plural=庫
library.editor.title.singular=庫
make.before.launch.warning.disabled=已禁用有關跳過編譯的警告。\n要再次啟用，請使用“事件日誌”工具視窗中的“設定”按鈕。
sdk.version.unknown=無法讀取 SDK ''{0}'' 的版本。確保 [SDK 主頁]/flex-sdk-description.xml (或 [SDK 主頁]/air-sdk-description.xml)檔案未損壞，然後嘗試重新創建 SDK
air.sdk.requires.pure.as=建置設定應標記為“純 ActionScript”，因為 AIR SDK ''{0}'' 不包含 Flex 組件
html.wrapper.folder.clash=包含 HTML 包裝器模板的資料夾與 {0} 衝突: {1}
html.wrapper.folder.clash.for.dialog=路徑與 {0} 衝突: {1}
take.wrapper.template.from.sdk=從以下 Flex/AIR SDK 中獲取 HTML 包裝器模板(&T):
choose.library.files.description=<html>選擇 *.swc 或 *.ane 檔案和/或包含 *.swc、*.ane 或原始 ActionScript 檔案的資料夾。<br>{0} 將分析所選資料夾的內容，並自動將其中包含的檔案分配至適當的類別(類、原始碼和文檔)。</html>
add.shared.library.dependency.action.text=專案或全域類別庫…
add.dependency.popup.title=添加依賴關係:
add.dependency.action.name=添加依賴項
add.library.components.action.name=添加庫組件(&L)…
uml.calculating.dependencies.message=正在計算依賴項
uml.dependencies.one.to.one=一對一
uml.dependencies.one.to.many=一對多
uml.dependencies.usages=用法
uml.dependencies.self=自我鏈接
uml.dependencies.create=創建
own.lib.used.as.3rd.party=依賴於檢測到的檔案 {0}，即建置設定 ''{1}'' (模組 ''{2}'')的輸出。更為典型的情況是，一個建置設定依賴於另一個建置設定，而不是依賴於其輸出。
instead.setup.dependency.on.bc=取代為對建置設定 ''{0}'' (模組 ''{1}'')的依賴
uml.create.relationship.label=<html>&laquo;創建&raquo;</html>
ios.simulator.on.mac.only.warning=iOS 模擬器僅在 Mac OS 上可用
ios.simulator.on.mac.only.button.text=iOS 模擬器(僅限 Mac)
ios.simulator.sdk.not.set=未設定 iOS 模擬器 SDK 的路徑
ios.simulator.sdk.not.found=找不到 iOS 模擬器 SDK: {0}
cant.execute.flexunit1.for.pure.as.bc=無法為純 ActionScript 建置設定執行 FlexUnit 1 測試。請使用 FlexUnit 4 或更高版本。
locales.dialog.label=Flex SDK ''{0}'' 支援的區域設定:
new.flex.component.command.name=創建 MXML 組件
create.flex.component.intention.name=創建 MXML 組件 ''{0}''
new.flex.component.action.description=新建 MXML 組件
new.flex.component.dialog.title=新 MXML 組件
new.flex.component.uml.action.text=MXML 組件
parent.component.label.text=父組件(&C):
parallel.compilation.hint.title=提示
parallel.compilation.hint=獨立 Flash 建置設定的並行編譯<br/>可以提高編譯性能。<br/><br/><a href="enable">啟用並行編譯</a>    <a href="open">開啟編譯器設定 </a>
parallel.compilation.enabled=已啟用並行編譯
see.settings.compiler=要設定編譯器設定，請使用<a href="">設定->編譯器</a>頁面。
define.0=宣告條件編譯器定義 ''{0}''
failed.to.read.app.id=無法從以下檔案讀取應用程式 ID: \n{0}
add.as.library.title=添加為庫
bc.output.file.source.item={0}: 僅輸出檔案({1})
bc.output.file.and.wrapper.source.item={0}: 輸出檔案和 HTML 包裝器
bc.output.folder.source.item={0}: 整個輸出資料夾內容

# Annotator
javascript.validation.message.no.return.value.required.for.constructor=從構造函數中返回不需要返回值
configurable.FlexCompilerProjectConfigurable.display.name=ActionScript 和 Flex 編譯器
remove.annotation.from.class=從類中移除註解
this.will.remove.relationship.link.between.classes=這將移除類之間的關係
flash.builder.project.file=<b>Flash Builder</b> 專案檔案({0})

# used in FlashUmlVisibilityManager
javascript.uml.visibility.public=public
javascript.uml.visibility.protected=protected
javascript.uml.visibility.package_local=protected \\&\\& internal
javascript.uml.visibility.private=所有
javascript.uml.show.supers.header={0} 的超類
javascript.uml.show.implementations.header={0} 的實作

javascript.validation.message.static.method.in.interface=接口中不允許使用 static 方法
javascript.validation.message.static.method.with.override=static 函數不能包含覆寫修飾符
invalid.identifier.value=關鍵字值無效
class.0.does.not.have.default.constructor=類 {0} 沒有預設構造函數
javascript.validation.empty.component.type=組件標記不應為空
javascript.validation.tag.must.be.last.child.of.root.tag=<{0}> 標記必須是根文檔標記的最後一個子級
javascript.validation.tag.must.be.first.child.of.root.tag=<{0}> 標記必須是根文檔標記的第一個子級
javascript.validation.tag.must.be.direct.child.of.fx.library.tag=<{0}> 標記必須是 <{1}> 標記的直接子級
javascript.validation.tag.must.have.exactly.one.child.tag=<{0}> 標記必須只有一個子標記
javascript.validation.tag.must.have.attribute.includein.or.excludefrom=<{0}> 標記必須有特性 ''includeIn'' 或 ''excludeFrom''
javascript.validation.only.this.tag.is.allowed.here=此處僅允許使用 <{0}> 標記
asdoc=ASDoc
invalid.package=無效軟體套件: {0}
actionscript.template.context.type=ActionScript(&I)
to.indent.package.statement.children=縮排 package 語句子級(&I)
javascript.validation.message.file.should.be.under.source.root=物件位於源根目錄外的檔案中，某些功能不可用
javascript.validation.message.more.than.one.named.object.in.package=軟體套件中的非唯一物件
javascript.validation.message.constructor.in.mxml.is.not.allowed=MXML 類不允許使用構造函數
javascript.validation.message.nested.packages.are.not.allowed=不允許嵌套軟體套件
javascript.validation.message.package.shouldbe.first.statement=軟體套件應為檔案中的第一條語句
javascript.validation.message.incorrect.package.name=軟體套件名稱 ''{0}'' 與檔案路徑 ''{1}'' 不對應
javascript.fix.package.name=將軟體套件名稱設定為 ''{0}''
javascript.validation.message.more.than.one.externally.visible.symbol=檔案中定義了多個外部可見符號
javascript.validation.message.vector.without.parameters=無類型的矢量
javascript.validation.message.vector.without.parameters2=無類型的矢量無法實例化
javascript.validation.message.access.modifier.allowed.only.for.package.members=軟體套件成員僅允許使用 public/internal 修飾符
javascript.validation.message.access.modifier.allowed.only.for.class.members=僅類成員允許使用存取修飾符
javascript.validation.message.namespace.allowed.only.for.class.members=僅類成員允許使用命名空間
javascript.validation.message.embed.annotation.used.with.var.of.wrong.type=嵌入註解應與類或字串類型的變數一起使用
javascript.namespace.initializer.should.be.string.or.another.namespace.reference=命名空間初始設定式應為字串文字或其他命名空間引用
javascript.validation.message.class.should.be.in.file=應在檔案 ''{1}'' 中定義類 ''{0}''
javascript.validation.message.function.should.be.in.file=應在檔案 ''{1}'' 中定義函數 ''{0}''
javascript.validation.message.namespace.should.be.in.file=應在檔案 ''{1}'' 中定義命名空間 ''{0}''
javascript.validation.message.variable.should.be.in.file=應在檔案 ''{1}'' 中定義變數 ''{0}''
javascript.invalid.e4x.filter.query.receiver=e4x 篩選器查詢實參無效，應為 XML 或 XMLList 類型
javascript.callback.signature.mismatch=回調應只有一個事件類型的參數
javascript.callback.signature.mismatch.event.class=回調應只有一個{0}類型的參數
actionscript.binary.operand.type.mismatch=二元運算實參類型{0}與類型{1}不相容
top.level=頂層
js.uml.presentable.name=ActionScript/Flex
actionscript.create.constructor.intention.name=創建構造函數 ''{0}''
new.actionscript.class.uml.action.text=ActionScript 類
new.actionscript.class.command.name=創建 ActionScript 類
new.actionscript.class.action.description=創建新的 ActionScript 類
cannot.resolve.package.0=無法解析軟體套件 ''{0}''
cannot.resolve.class.0=無法解析類 ''{0}''
notification.group.air.packaging=AIR 打包
notification.group.flash.compiler=Flash 編譯器
notification.group.debugger=Flex 偵錯器啟動失敗
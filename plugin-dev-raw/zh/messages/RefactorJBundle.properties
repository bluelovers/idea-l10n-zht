cannot.perform.the.refactoring=不能執行重構。
case.value.can.not.be.replaced.with.enum={0} 不可被取代為枚舉
choose.destination.package.label=選擇目標軟體套件
codestyle.settings.extractor.command.name=CodeStyleSettings 提取程序
constructor.requires.moved.members=建構函式需要移動的成員
extract.class.as.enum.column.title=作為枚舉
extract.class.depends.on.0.from.1.tooltip=相依 {1} 的 {0}
extract.class.depends.on.0.from.new.class=依賴新類別 {1} 的 {0}
extract.class.from.label=從{0}提取委託
extract.class.title=提取委託
extracted.class.command.name=已提取類別 {0}
extracted.class.not.accessible.in.0=已提取類別無法在 {0} 中存取
extracting.from.class=正在從類別提取:
field.needs.getter=欄位 ''{0}'' 需要 getter
field.needs.setter=欄位 ''{0}'' 需要 setter
initializer.requires.moved.members=類別初始設定式需要移動的成員
introduce.parameter.object=引入參數物件
members.to.extract.label=要提取的成員(&B)
method.selected.has.no.parameters=選定方法沒有參數。
name.for.new.class.label=新類別的名稱(&N):
package.for.new.class.label=軟體套件名稱(&P):
referenced.element.out.of.project={0} 位於專案外
references.to.extract=要提取的參照( {0, choice, 0#(找不到)|1#{0} 個參照|2#{0} 個參照}{1, choice, 0#|1#位於 {1} 個檔案中|2#位於 {1} 個檔案中})
select.wrapper.class=選擇參數類別
the.caret.should.be.positioned.within.a.class.to.be.refactored=重構應在要重構的類別或成員上呼叫。
the.caret.should.be.positioned.within.a.method.declaration.to.be.refactored=文字游標應置於要重構的方法宣告內。
the.refactoring.is.not.supported.on.non.static.inner.classes=非 static 內部類別上不支持重構。
the.selected.class.has.no.members.to.extract=選定類別沒有要提取的成員。
the.selected.class.is.an.annotation.type=所選類別為註解接口。
the.selected.class.is.an.enumeration=所選類別為枚舉類別。
the.selected.class.is.an.interface=選定類別是接口。
the.selected.class.should.belong.to.project.sources=所選類別應屬於專案源
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=不能包裝選定方法，因為它在非專案類別中定義
there.already.exists.a.class.with.the.chosen.name=已存在一個具有所選名稱的類別。
unable.to.migrate.statement.to.enum=無法將語句遷移到枚舉常數。{0}
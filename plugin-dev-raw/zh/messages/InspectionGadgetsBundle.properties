cast.to.concrete.class.problem.descriptor=轉換為具體類 <code>{0}</code> #loc
class.references.subclass.display.name=類引用其子類之一
class.references.subclass.problem.descriptor=類 ''{0}'' 引用子類 <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=匿名類引用子類 <code>#ref</code> #loc
collection.declared.by.class.display.name=按類 (而不是接口) 宣告的集合
collection.declared.by.class.problem.descriptor=<code>#ref</code> 的宣告可能應當被削弱為 ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=忽略局部變數
collection.declared.by.class.ignore.private.members.option=忽略 'private' 欄位和方法
feature.envy.display.name=特性依戀
feature.envy.problem.descriptor=類 ''{0}'' 在方法 <code>#ref()</code> 中被重複存取 #loc
bounded.wildcard.display.name=可以使用有界萬用字元
bounded.wildcard.contravariant.descriptor=可以泛化為 <code>? super #ref</code> #loc
bounded.wildcard.covariant.descriptor=可以泛化為 <code>? extends #ref</code> #loc
bounded.wildcard.report.invariant.option=報告固定類
bounded.wildcard.report.private.option=報告 private 方法
bounded.wildcard.report.instance.option=報告實例方法
instance.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的實例欄位 ''{0}'' #loc
chain.of.instanceof.checks.display.name='instanceof' 檢查鏈
chain.of.instanceof.checks.problem.descriptor='instanceof' 檢查鏈指示抽象失敗 #loc
chain.of.class.equality.checks.problem.descriptor=類相等檢查鏈指示抽象失敗 #loc
instanceof.concrete.class.problem.descriptor='instanceof' 具體類 <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=與具體類 <code>#ref</code> 的類比較 #loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 檢查
instanceof.check.for.this.problem.descriptor=<code>#ref</code> 的 'instanceof' 檢查 #loc
instanceof.check.for.this.equality.problem.descriptor='this' 的類比較 #loc
local.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的局部變數 ''{0}'' #loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 <code>#ref</code> #loc
concrete.class.use.display.name=具體類的使用
method.return.concrete.class.problem.descriptor=方法返回一個具體類 <code>#ref</code> #loc
overly.strong.type.cast.display.name=過強的類型轉換
overly.strong.type.cast.weaken.quickfix=削弱過強的轉換
concrete.class.method.parameter.problem.descriptor=具體類 <code>#ref</code> 的參數 ''{0}'' #loc
public.method.not.in.interface.display.name='public' 方法在接口中未公開
public.method.not.in.interface.problem.descriptor='public' 方法 <code>#ref()</code> 未通過接口公開 #loc
public.method.not.in.interface.option=<html>如果包含類未實作非庫接口，則忽略</html>
static.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的 static 欄位 ''{0}'' #loc
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> 始終為 false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> 始終為 true #loc
pointless.bitwise.expression.display.name=無意義的按位表達式
pointless.bitwise.expression.simplify.quickfix=簡化
shift.operation.by.inappropriate.constant.display.name=按不當常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 過大 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 為負 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出範圍的值 {0} 進行移位運算 <code>#ref</code> #loc
equals.called.on.array.display.name=在陣列上調用了 'equals()'
equals.called.on.array.problem.descriptor=陣列之間的 <code>#ref()</code> 可能應當是 'Arrays.equals()' #loc
assignment.to.null.display.name='null' 賦值
assignment.to.null.problem.descriptor='null' 已賦值給變數 <code>#ref</code> #loc
assignment.to.null.option=忽略對欄位的賦值
assignment.to.static.field.from.instance.method.display.name=從實例上下文賦值給 static 欄位
assignment.to.static.field.from.instance.method.problem.descriptor=從實例上下文賦值給 static 欄位 <code>#ref</code> #loc
assignment.used.as.condition.display.name=用作條件的賦值
assignment.used.as.condition.problem.descriptor=賦值 <code>#ref</code> 作為條件使用 #loc
cast.conflicts.with.instanceof.display.name=轉換與 'instanceof' 衝突
cast.conflicts.with.instanceof.problem.descriptor=轉換為 ''{0}'' 類型將與前面的 ''instanceof {1}'' 檢查衝突
casting.to.incompatible.interface.display.name=轉換為不相容的接口
casting.to.incompatible.interface.problem.descriptor=轉換為不相容的接口 <code>#ref</code> #loc
collection.added.to.self.display.name=集合已添加到自身
collection.added.to.self.problem.descriptor=在以自身作為實參的集合 <code>#ref</code> 上調用了 ''{0}()'' #loc
non.final.field.compareto.display.name='compareTo()' 中引用了非最終欄位
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中存取了非 final 欄位 <code>#ref</code> #loc
covariant.equals.display.name=協變 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> 應當以 'Object' 作為其實參 #loc
empty.class.initializer.display.name=空類初始設定式
empty.class.initializer.problem.descriptor=空類初始設定式 #loc
empty.class.initializer.delete.quickfix=刪除空類初始設定式
statement.with.empty.body.display.name=帶空體的語句
statement.with.empty.body.problem.descriptor=<code>#ref</code> 語句具有空體 #loc
statement.with.empty.body.include.option=包含空程式碼塊語句正文
equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到屬於 ''{0}'' 和 ''{1}'' 這兩個子類型的類 #loc
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子類，則發出警告
equals.called.on.suspicious.object.display.name=在 'StringBuilder'上調用了 'equals()'
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 物件上存在可疑的 ''equals()'' 調用
non.final.field.in.equals.display.name='equals()' 中引用了非最終欄位
non.final.field.in.equals.problem.descriptor=在 'equals()' 中存取了非 final 欄位 <code>#ref</code> #loc
equals.doesnt.check.class.parameter.display.name=不檢查參數的類的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> 應當檢查其參數的類 #loc
non.final.field.in.hashcode.display.name='hashCode()' 中引用了非最終欄位
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中存取了非 final 欄位 <code>#ref</code> #loc
result.of.method.call.ignored.display.name=方法調用的結果已忽略
write.only.object.display.name=只寫入物件
write.only.object.option.ignore.impure.constructors=忽略不純的構造函數
result.of.method.call.ignored.problem.descriptor=<code>{0}.#ref()</code> 的結果已忽略 #loc
result.of.method.call.ignored.class.column.title=類名
result.of.method.call.ignored.method.column.title=方法名稱正則表達式
result.of.method.call.ignored.non.library.option=報告所有忽略的非庫調用
infinite.recursion.display.name=無限遞歸
infinite.recursion.problem.descriptor=方法 <code>#ref()</code> 無限遞歸，只能以拋出異常結束 #loc
instanceof.with.incompatible.interface.display.name=具有不相容接口的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=具有不相容接口 <code>#ref</code> 的 'instanceof' #loc
instantiation.utility.class.display.name=實用程序類的實例化
instantiation.utility.class.problem.descriptor=實用程序類 <code>#ref</code> 的實例化 #loc
iterator.hasnext.which.calls.next.display.name=調用 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''#ref()'' 調用 #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=無法拋出 'NoSuchElementException' 的 'Iterator.next()'
malformed.format.string.display.name=字串的格式錯誤
malformed.format.string.problem.descriptor.malformed=格式字串 <code>#ref</code> 的格式錯誤 #loc
malformed.format.string.problem.descriptor.illegal=非法格式字串指定符: {0} #loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字串的實參太多(實際: {0}，應為: {1}) #loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字串的實參太少(實際: {0}，應為: {1}) #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=實參類型 ''{0}'' 與格式說明符 ''{1}'' 的類型不符合 #loc
format.string.error.flags.not.allowed=''{1}'' 中不允許使用{2, choice, 1#標誌|1<標誌} ''{0}''
format.string.error.unexpected.flag=''{1}'' 中出現意外字符 ''{0}''
format.string.error.duplicate.flag=''{1}'' 中存在重複的標誌 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允許該寬度 (''{0}'')
format.string.error.precision.not.allowed=''{1}'' 中不允許該精度 (''{0}'')
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的實參位置說明符 ''{0}''
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置說明符 ''{0}''
format.string.error.previous.element.not.found=使用了以前的標誌 '<'，但沒有找到 ''{0}'' 以前的格式說明符
format.string.error.unknown.conversion=''{0}'' 中存在未知的轉換
format.string.error.invalid.precision=''{0}'' 中指定的精度無效
format.string.error.illegal.flag.combination=''{2}'' 中的標誌組合 ''{0}'' 和 ''{1}'' 非法
format.string.error.left.justify.no.width=使用了左對齊標誌 ''-''，但 ''{0}'' 中未指定寬度
format.string.error.zero.padding.no.width=使用了零填充標誌 ''0''，但 ''{0}'' 中未指定寬度
mismatched.read.write.array.display.name=陣列的讀取和寫入不符合
mismatched.read.write.array.problem.descriptor.write.not.read=陣列 <code>#ref</code> 的內容已寫入，但從未被讀取 #loc
mismatched.read.write.array.problem.descriptor.read.not.write=陣列 <code>#ref</code> 的內容已讀取，但從未被寫入 #loc
mismatched.update.collection.display.name=不符合的集合查詢和更新
mismatched.update.collection.problem.descriptor.updated.not.queried=集合 <code>#ref</code> 的內容已更新，但從未被查詢 #loc
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>#ref</code> 的內容已被查詢，但從未更新 #loc
rename.quickfix=重命名
renameto.quickfix=重命名為 ''{0}''
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> 方法可能應當是 'equals()' #loc
non.short.circuit.boolean.expression.display.name=非短路布爾表達式
non.short.circuit.boolean.expression.problem.descriptor=非短路布爾表達式 <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=取代為短路表達式
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法實參
null.argument.to.var.arg.method.problem.descriptor=引起混淆的實參 <code>#ref</code>，不清楚是否需要 vararg 或非 vararg 調用 #loc
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元陣列實參
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元陣列實參 #loc
object.comparison.display.name=使用 '==' 而不是 'equals()' 進行物件比較
object.comparison.enumerated.ignore.option=忽略枚舉變數之間的 '=='
object.comparison.klass.ignore.option=忽略沒有 'equals()' 實作的 final 類類型之間的 '=='
object.comparison.problem.description=使用 <code>#ref</code> 而不是 'equals()' 來比較物件值 #loc
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 取代 '=='
inequality.to.safe.not.equals.quickfix=用 null 安全 '!equals()' 取代 '!='
default.tostring.call.display.name=調用預設 'toString()'
default.tostring.call.problem.descriptor=調用 <code>#ref</code> 上的預設 'toString()' #loc
octal.and.decimal.integers.in.same.array.display.name=同一陣列中的八進制和十進制整數
octal.and.decimal.integers.in.same.array.problem.descriptor=同一陣列初始設定式中的八進制和十進制整數 #loc
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.problem.descriptor=<code>new #ref()</code> 的結果已忽略 #loc
result.of.object.allocation.ignored.options.chooserTitle=選擇可以忽略物件分配的類
result.of.object.allocation.fix.name=忽略類型 ''{0}'' 的物件的分配
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' #loc
return.of.null.display.name=返回 'null'
return.of.null.problem.descriptor=返回 <code>#ref</code> #loc
return.of.null.arrays.option=報告返回陣列的方法
return.of.null.objects.option=報告返回物件的方法
return.of.null.collections.option=報告返回集合物件的方法
return.of.null.ignore.private.option=忽略 'private' 方法、匿名類和 lambda
static.method.via.subclass.display.name=static 方法通過子類引用
static.method.via.subclass.problem.descriptor=static 方法 <code>#ref()</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
static.method.via.subclass.rationalize.quickfix=使 static 方法調用合理化
static.field.via.subclass.display.name=static 欄位通過子類引用
static.field.via.subclass.problem.descriptor=static 欄位 <code>#ref</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
static.field.via.subclass.rationalize.quickfix=使 static 欄位存取合理化
string.comparison.display.name=使用 '==' 而不是 'equals()' 進行字串比較
number.comparison.display.name=使用 '==' 而不是 'equals()' 進行數字比較
string.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較字串值 #loc
number.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較數字物件 #loc
subtraction.in.compareto.display.name='compareTo()' 中的減法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的減法 <code>#ref</code> 可能導致溢出或精度損失 #loc
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1#語句|2#表達式}中存在文本標籤 <code>#ref:</code> #loc
properties.object.as.hashtable.display.name=將屬性物件用作哈希表
properties.object.as.hashtable.problem.descriptor=在屬性物件上調用 <code>Hashtable.#ref()</code> #loc
assignment.replaceable.with.operator.assignment.display.name=賦值可取代為運算符賦值
unnecessary.code.block.display.name=不必要的程式碼塊
unnecessary.code.block.unwrap.quickfix=解開塊
redundant.local.variable.display.name=冗餘局部變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.local.variable.annotation.option=忽略具有註解的變數
static.collection.display.name=靜態集合
static.collection.problem.descriptor=靜態集合 <code>#ref</code> #loc
static.collection.ignore.option=忽略弱靜態集合或映射
stringbuffer.field.display.name='StringBuilder' 欄位
stringbuffer.field.problem.descriptor=''{0}'' 欄位 <code>#ref</code> #loc
gc.call.display.name=調用 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> 不應在生產程式碼中調用 #loc
array.allocation.zero.length.display.name=零長度陣列分配
array.allocation.zero.length.problem.descriptor=零長度陣列的分配 #loc
constant.for.zero.length.array.display.name=不必要的零長度陣列用法
constant.for.zero.length.array.problem.descriptor=零長度陣列可更改為常數 #loc
constant.for.zero.length.array.quickfix.family=取代為常數
multiple.loggers.display.name=具有多個記錄器的類
logger.name.option=記錄器類名(&C):
multiple.loggers.problem.descriptor=類 <code>#ref</code> 宣告多個記錄器 #loc
no.logger.display.name=不帶記錄器的類
no.logger.problem.descriptor=類 <code>#ref</code> 未宣告記錄器 #loc
non.constant.logger.display.name=非常數記錄器
non.constant.logger.problem.descriptor=非常數記錄器欄位 <code>#ref</code> #loc
public.method.without.logging.display.name='public' 方法沒有日誌記錄
public.method.without.logging.problem.descriptor='public' 方法 <code>#ref()</code> 沒有日誌調用 #loc
ignore.trivial.finalizers.option=對普通 'finalize()' 實作忽略
finalize.declaration.display.name='finalize()' 不應被覆寫
finalize.declaration.problem.descriptor='finalize()' 不應被覆寫 #loc
finalize.not.declared.protected.display.name='finalize()' 應為 protected，不應為 public
finalize.not.declared.protected.problem.descriptor='finalize()' 應具有 protected 存取權限，不應具有 public 存取權限 #loc
finalize.called.explicitly.display.name='finalize()' 被顯式調用
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> 被顯式調用 #loc
java.lang.import.display.name='java.lang' 軟體套件中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 軟體套件中有不必要的 import #loc
import.display.name='*' 匯入
import.problem.descriptor=軟體套件匯入 <code>#ref</code> #loc
import.from.same.package.display.name=相同軟體套件中的不必要 import
import.from.same.package.problem.descriptor=相同軟體套件 <code>#ref</code> 中有不必要的 import #loc
single.class.import.display.name=單個類匯入
single.class.import.problem.descriptor=單個類匯入 <code>#ref</code> #loc
static.import.display.name=靜態匯入
static.import.problem.descriptor=靜態匯入 <code>#ref</code>  #loc
static.import.replace.quickfix=取代為非靜態匯入
static.import.fix.ignore.class=允許類 ''{0}'' 的靜態匯入
static.import.options.border.title=靜態可匯入類:
static.import.options.chooserTitle=選擇靜態可匯入類
unused.import.problem.descriptor=未使用的 import <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用構造函數實例化物件
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 創建新的 <code>#ref</code> 實例 #loc
clone.instantiates.new.array.problem.descriptor=''clone()'' 創建新的 {0} 陣列 #loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=將 'CloneNotSupportedException' 添加到 throws 子句
clone.method.in.non.cloneable.class.display.name=不可克隆類中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> 在不可克隆類 ''{0}'' 中定義 #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名類中定義 #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> 在不可克隆接口 ''{0}'' 中定義 #loc
cloneable.class.without.clone.display.name=沒有 'clone()' 方法的可克隆類
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> 為 'Cloneable'，但未定義 'clone()' 方法 #loc
cloneable.class.without.clone.ignore.option=忽略由於繼承而可克隆的類
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
use.obsolete.collection.type.display.name=使用廢棄的集合類型
use.obsolete.collection.type.problem.descriptor=使用了廢棄的集合類型 <code>#ref</code> #loc
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略廢棄的集合類型
inspection.suppression.annotation.display.name=檢查禁止註解
inspection.suppression.annotation.problem.descriptor=檢查禁止註解 <code>#ref</code> #loc
use.system.out.err.display.name=使用 System.out 或 System.err
use.system.out.err.problem.descriptor=<code>#ref</code> 的使用可能應當取代為更可靠的日誌 #loc
dumpstack.call.display.name=調用 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=對 <code>Thread.#ref()</code> 的調用可能應當取代為更可靠的日誌 #loc
printstacktrace.call.display.name=調用 'printStackTrace()'
printstacktrace.call.problem.descriptor=對 <code>#ref()</code> 的調用可能應當取代為更可靠的日誌 #loc
abstract.method.call.in.constructor.display.name=物件構造期間調用的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=物件構造期間調用 'abstract' 方法 <code>#ref()</code> #loc
instance.variable.may.not.be.initialized.display.name=實例欄位可能無法初始化
instance.variable.may.not.be.initialized.problem.descriptor=實例欄位 <code>#ref</code> 在物件構造期間可能無法初始化 #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=實例欄位 <code>#ref</code> 在物件構造或 'setUp()' 調用期間可能無法初始化 #loc
primitive.fields.ignore.option=忽略原始欄位
instance.variable.used.before.initialized.display.name=實例欄位在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的實例欄位 <code>#ref</code> #loc
non.final.static.variable.initialization.display.name=在類初始化期間使用非 final static 欄位
non.final.static.variable.initialization.problem.descriptor=在類初始化期間使用非 final static 欄位 <code>#ref</code> #loc
overridable.method.call.in.constructor.display.name=物件構造期間調用的可覆寫方法
overridable.method.call.in.constructor.problem.descriptor=物件構造期間調用可覆寫方法 <code>#ref()</code> #loc
overridden.method.call.in.constructor.display.name=覆寫的方法在物件構造期間調用
overridden.method.call.in.constructor.problem.descriptor=物件構造期間調用已覆寫方法 <code>#ref()</code> #loc
static.variable.may.not.be.initialized.display.name=static 欄位可能無法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 欄位 <code>#ref</code> 在類初始化期間可能無法初始化 #loc
static.variable.used.before.initialization.display.name=static 欄位在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 欄位 <code>#ref</code> 在初始化前使用 #loc
this.reference.escaped.in.construction.display.name=物件構造中轉義的 'this' 引用
this.reference.escaped.in.construction.problem.descriptor=物件構造期間轉義 <code>#ref</code> #loc
assignment.to.catch.block.parameter.display.name=賦值給 catch 塊參數
extract.parameter.as.local.variable.quickfix=提取參數作為局部變數
assignment.to.for.loop.parameter.display.name=賦值給 'for' 迴圈參數
assignment.to.for.loop.parameter.check.foreach.option=檢查增強型 'for' 迴圈參數
assignment.to.for.loop.parameter.problem.descriptor=賦值給 for 迴圈參數 <code>#ref</code> #loc
assignment.to.method.parameter.display.name=賦值給方法參數
chained.equality.comparisons.display.name=鏈式相等比較
confusing.octal.escape.sequence.display.name=引起混淆的八進制轉義序列
increment.decrement.display.name=使用 '++' 或 '--' 的結果
nested.assignment.display.name=嵌套賦值
nested.assignment.problem.descriptor=使用的賦值表達式的結果 #loc
overloaded.methods.with.same.number.parameters.display.name=具有相同參數數量的多載方法
overloaded.vararg.method.display.name=多載 vararg 方法
refused.bequest.display.name=方法不調用 super 方法
reuse.of.local.variable.display.name=局部變數的重用
reuse.of.local.variable.split.quickfix=拆分局部變數
character.comparison.display.name=字符比較
character.comparison.problem.descriptor=國際化上下文中的字符比較 <code>#ref</code> #loc
package.visible.field.display.name=軟體套件可見欄位
package.visible.field.problem.descriptor=軟體套件可見欄位 <code>#ref</code> #loc
package.visible.inner.class.display.name=軟體套件可見的嵌套類
package.visible.inner.class.problem.descriptor=軟體套件可見的嵌套類 <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=忽略軟體套件可見的內部枚舉
package.visible.inner.class.ignore.interface.option=忽略軟體套件可見的內部接口
protected.field.display.name=protected 欄位
protected.field.problem.descriptor=protected 欄位 <code>#ref</code> #loc
protected.inner.class.display.name=protected 嵌套類
protected.inner.class.problem.descriptor=protected 嵌套類 <code>#ref</code> #loc
protected.inner.class.ignore.enum.option=忽略 'protected' 內部枚舉
protected.inner.class.ignore.interface.option=忽略 'protected' 內部接口
public.field.display.name='public' 欄位
public.field.problem.descriptor='public' 欄位 <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=忽略枚舉類型的 'public final' 欄位
public.inner.class.display.name='public' 嵌套類
public.inner.class.problem.descriptor='public' 嵌套類 <code>#ref</code> #loc
public.inner.class.ignore.enum.option=忽略 'public' 內部枚舉
public.inner.class.ignore.interface.option=忽略 'public' 內部接口
accessing.non.public.field.of.another.object.display.name=存取另一個物件的非 public 欄位
accessing.non.public.field.of.another.object.problem.descriptor=直接存取另一個物件的非 public 欄位 <code>#ref</code> #loc
call.to.date.tostring.display.name=調用 'Date.toString()'
call.to.date.tostring.problem.descriptor=國際化上下文中使用的 <code>Date.#ref()</code> #loc
magic.character.display.name=魔幻字符
magic.character.problem.descriptor=國際化上下文中使用的魔幻字符 <code>#ref</code> #loc
call.to.numeric.tostring.display.name=調用 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=國際化上下文中調用的 <code>Number.#ref()</code> #loc
instantiating.simpledateformat.without.locale.display.name=無區域設定的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下實例化 <code>#ref</code> #loc
string.concatenation.display.name=字串串聯
string.concatenation.problem.descriptor=國際化上下文中的字串串聯 <code>#ref</code> #loc
inspection.option.ignore.system.out=對 'System.out.print' 實參忽略
inspection.option.ignore.system.err=對 'System.err.print' 實參忽略
inspection.option.ignore.assert=對斷言語句描述實參忽略
inspection.option.ignore.exceptions=對 Throwable 子類的構造函數實參忽略
inspection.option.ignore.nonnls=通過 @NonNls 進行註解時忽略
inspection.option.ignore.constant.initializers=對常數欄位的初始設定式忽略
inspection.option.ignore.in.annotations=在註解中忽略
inspection.option.ignore.in.tostring=在 toString() 方法內部忽略
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常數
string.touppercase.tolowercase.without.locale.display.name=調用無區域設定的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用國際化字串指定區域設定的情況下調用 <code>String.#ref()</code> #loc
use.stringtokenizer.display.name=使用 StringTokenizer
use.stringtokenizer.problem.descriptor=國際化上下文中的 <code>#ref</code> #loc
time.tostring.call.display.name=調用 'Time.toString()'
time.tostring.call.problem.descriptor=國際化上下文中的 <code>Time.#ref()</code> #loc
class.escapes.defined.scope.display.name=公開不可存取的 'class'
class.escapes.defined.scope.display.module.option=模組的 API 公開未匯出的類(Java 9+)
class.escapes.defined.scope.display.public.option=公共 API 公開不可存取的類
class.escapes.defined.scope.display.package.option=Package-local API 公開 private 類
class.escapes.defined.scope.problem.descriptor=類 <code>#ref</code> 在其定義範圍之外公開 #loc
class.escapes.defined.scope.java9.modules.descriptor=類 <code>#ref</code> 未從模組 ''{0}'' 匯出
field.name.hides.in.superclass.display.name=子類欄位隱藏超類欄位
field.name.hides.in.superclass.problem.descriptor=欄位 <code>#ref</code> 隱藏超類中的欄位 #loc
field.name.hides.in.superclass.ignore.option=忽略不可存取欄位
field.name.hides.in.superclass.ignore.static.field.option=忽略隱藏 static 欄位的 static 欄位
inner.class.field.hides.outer.display.name=內部類欄位隱藏外部類欄位
inner.class.field.hides.outer.ignore.option=忽略從內部類不可見的外部欄位
inner.class.field.hides.outer.problem.descriptor=內部類欄位 <code>#ref</code> 隱藏外部類欄位 #loc
local.variable.hides.member.variable.display.name=局部變數隱藏欄位
local.variable.hides.member.variable.problem.descriptor=局部變數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
local.variable.hides.member.variable.ignore.option=忽略隱藏非 static 欄位的 static 上下文中的局部變數
method.overloads.display.name=可能是超類方法意外多載
method.overloads.problem.descriptor=當可能打算覆寫時，方法 <code>#ref()</code> 多載超類的相容方法 #loc
method.overloads.report.incompatible.option=即使參數類型不相容，也會報告
method.overrides.private.display.name.problem.descriptor=方法 <code>#ref()</code> 重寫了超類的 'private' 方法 #loc
method.overrides.static.display.name=方法嘗試覆寫超類的 static 方法
method.overrides.static.problem.descriptor=方法 <code>#ref()</code> 嘗試覆寫超類的 static 方法 #loc
parameter.hides.member.variable.display.name=參數隱藏欄位
parameter.hides.member.variable.problem.descriptor=參數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
parameter.hides.member.variable.ignore.setters.option=對屬性 setter 忽略
parameter.hides.member.variable.ignore.superclass.option=忽略從子類不可見的超類欄位
parameter.hides.member.variable.ignore.constructors.option=對構造函數忽略
parameter.hides.member.variable.ignore.abstract.methods.option=對 abstract 方法忽略
parameter.hides.member.variable.ignore.static.parameters.option=對隱藏實例欄位的 static 方法參數忽略
type.parameter.hides.visible.type.display.name=類型參數隱藏可見類型
type.parameter.hides.visible.type.problem.descriptor=類型參數 <code>#ref</code> 隱藏可見類型 ''{0}'' #loc
type.parameter.hides.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱藏類型參數 ''{0}'' #loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名類變數隱藏包含方法中的變數
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名類參數 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名類欄位 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名類局部變數 <code>#ref</code> 隱藏包含方法中的變數 #loc
channel.opened.not.closed.display.name=開啟了 'Channel'，但未安全關閉
drivermanager.call.display.name=使用 DriverManager 獲取 JDBC 連接
drivermanager.call.problem.descriptor=調用 <code>DriverManager.#ref()</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate 資源已開啟，但未安全關閉
i.o.resource.opened.not.closed.display.name=I/O 資源已開啟，但未安全關閉
resource.opened.not.closed.problem.descriptor=''{0}'' 應在 ''try'' 塊之前開啟，並在相應的 ''finally'' 塊中關閉 #loc
jdbc.resource.opened.not.closed.display.name=JDBC 資源已開啟，但未安全關閉
jndi.resource.opened.not.closed.display.name=JNDI 資源已開啟，但未安全關閉
socket.opened.not.closed.display.name=套接字已開啟，但未安全關閉
annotation.class.display.name=註解類
annotation.class.problem.descriptor=註解類 <code>#ref</code> #loc
annotation.display.name=註解
annotation.problem.descriptor=註解 <code>#ref</code> #loc
assert.statement.display.name='assert' 語句
statement.problem.descriptor=<code>#ref</code> 語句 #loc
auto.boxing.display.name=自動裝箱
auto.boxing.problem.descriptor=自動裝箱 <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=使裝箱顯式
auto.boxing.ignore.added.to.collection.option=忽略添加到集合的表達式
auto.unboxing.display.name=自動拆箱
auto.unboxing.problem.descriptor=自動拆箱 <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱顯式
enumerated.class.display.name=枚舉類
enumerated.class.problem.descriptor=枚舉類 <code>#ref</code> #loc
extended.for.statement.display.name=增強的 'for' 語句
extended.for.statement.replace.quickfix=取代為舊式 'for' 語句
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>#ref()</code> #loc
variable.argument.method.quickfix=將 vararg 參數轉換為數組
hardcoded.file.separator.display.name=硬編碼檔案分隔符
hardcoded.file.separator.problem.descriptor=硬編碼檔案分隔符 <code>#ref</code> #loc
hardcoded.file.separator.include.option=在已識別的 MIME 介質類型中包括 "example/*"
hardcoded.line.separator.display.name=硬編碼行分隔符
hardcoded.line.separator.problem.descriptor=硬編碼行分隔符 <code>#ref</code> #loc
native.method.display.name=本地方法
native.method.problem.descriptor=宣告為 <code>#ref</code> 的方法不可移植 #loc
runtime.exec.call.display.name=調用 'Runtime.exec()'
runtime.exec.call.problem.descriptor=對 <code>Runtime.#ref()</code> 的調用不可移植 #loc
system.exit.call.display.name=調用 'System.exit()' 或相關方法
system.exit.call.problem.descriptor=對 <code>{0}.#ref()</code> 的調用不可移植 #loc
system.exit.call.ignore.option=在主方法中忽略
system.getenv.call.display.name=調用 'System.getenv()'
system.getenv.call.problem.descriptor=對 <code>System.#ref()</code> 的調用不可移植 #loc
use.of.awt.peer.class.display.name=使用 AWT 對等類
use.of.awt.peer.class.problem.descriptor=AWT 對等類 <code>#ref</code> 的使用不可移植 #loc
use.of.concrete.jdbc.driver.class.display.name=使用具體的 JDBC 驅動程序類
use.of.concrete.jdbc.driver.class.problem.descriptor=具體 JDBC 驅動程序類 <code>#ref</code> 的使用不可移植 #loc
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 類
use.processbuilder.class.problem.descriptor=<code>#ref</code> 的使用不可移植 #loc
use.sun.classes.display.name=使用 'sun.*' 類
use.sun.classes.problem.descriptor=Sun 提供的類 <code>#ref</code> 的使用不可移植 #loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一個直接繼承者的 abstract 類
anonymous.inner.may.be.named.static.inner.class.display.name=匿名類可能是命名為 'static' 的內部類
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名類 <code>#ref</code> 可能是命名為 'static' 的內部類 #loc
array.length.in.loop.condition.display.name=迴圈條件下的 Array.length
array.length.in.loop.condition.problem.descriptor=檢查迴圈條件下的陣列 <code>#ref</code> #loc
large.array.allocation.no.outofmemoryerror.display.name=沒有 OutOfMemoryError 檢查的大型陣列分配
large.array.allocation.no.outofmemoryerror.problem.descriptor=未檢查記憶體不足情況的大型陣列分配 #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素數:
connection.opened.not.safely.closed.display.name=集合已開啟，但未安全關閉
interface.one.inheritor.display.name=只有一個直接繼承者的接口
interface.one.inheritor.problem.descriptor=只有一個直接繼承者的接口 <code>#ref</code> #loc
method.call.in.loop.condition.display.name=迴圈條件下的方法調用
method.call.in.loop.condition.problem.descriptor=迴圈條件下調用方法 <code>#ref()</code> #loc
large.initializer.primitive.type.array.display.name=原始類型陣列的過大初始設定式
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始陣列初始設定式 #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素數:
private.member.access.between.outer.and.inner.classes.display.name=合成存取器調用
private.member.access.between.outer.and.inner.classes.problem.descriptor=存取類 ''{0}'' 的 ''private'' 成員需要合成存取器 #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=將 ''{0}'' 設為 package-private
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=將 ''{0}'' 構造函數設為 package-private
recordstore.opened.not.safely.closed.display.name=開啟了 'RecordStore'，但未安全關閉
overly.complex.anonymous.inner.class.display.name=過度複雜的匿名類
cyclomatic.complexity.limit.option=迴圈復雜度限制:
overly.complex.anonymous.inner.class.problem.descriptor=過度複雜的匿名類 (迴圈復雜度 = {0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名內部類
method.count.limit.option=方法計數限制:
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名內部類 (方法計數 = {0}) #loc
overly.complex.class.display.name=過度複雜的類
overly.complex.class.problem.descriptor=過度複雜的類<code>#ref</code> (迴圈復雜度 = {0}) #loc
overly.coupled.class.display.name=過度耦合的類
overly.coupled.class.class.coupling.limit.option=類耦合限制:
include.java.system.classes.option=包括與 Java 系統類的耦合
include.library.classes.option=包括與庫類的耦合
overly.coupled.class.problem.descriptor=<code>#ref</code> 過度耦合 (依賴 = {0}) #loc
class.too.deep.display.name=類在繼承樹中太深
class.too.deep.inheritance.depth.limit.option=繼承深度限制:
class.too.deep.problem.descriptor=<code>#ref</code> 在繼承樹中太深 (繼承深度 = {0}) #loc
inner.class.too.deeply.nested.display.name=內部類嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> 嵌套太深 (嵌套級別 = {0}) #loc
too.many.constructors.display.name=構造函數過多的類
too.many.constructors.count.limit.option=構造函數計數限制:
too.many.constructors.ignore.deprecated.option=忽略棄用的構造函數
too.many.constructors.problem.descriptor=<code>#ref</code> 的構造函數過多 (構造函數計數 = {0}) #loc
too.many.fields.display.name=欄位過多的類
too.many.fields.count.limit.option=欄位計數限制:
too.many.fields.problem.descriptor=<code>#ref</code> 的欄位過多 (欄位計數 = {0}) #loc
too.many.methods.display.name=方法過多的類
too.many.methods.problem.descriptor=<code>#ref</code> 的方法過多 (方法計數 = {0}) #loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化類
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化類
non.serializable.class.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化類 <code>#ref</code> #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化接口 <code>#ref</code> #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化 @interface <code>#ref</code> #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>#ref</code> 的不可序列化匿名類定義 'serialVersionUID' 欄位 #loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化類
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被宣告為 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> 未被宣告為 'private' #loc
readobject.initialization.display.name=實例欄位可能無法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=實例欄位 <code>#ref</code> 在 'readObject()' 調用期間可能無法初始化 #loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被宣告為 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> 未被宣告為 'protected' #loc
missing.serial.annotation.display.name=可以使用 @Serial 註解
missing.serial.annotation.on.field.problem.descriptor=<code>#ref</code> 可以使用 @Serial 進行註解
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code> 可以使用 @Serial 進行註解
serial.annotation.used.on.wrong.member.display.name=對錯誤的成員使用了 '@Serial' 註解
serial.annotation.used.on.wrong.member.problem.descriptor=註解的成員不是序列化機制的一部分
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成員
serializable.record.contains.ignored.field.problem.descriptor=在記錄序列化期間將忽略 <code>#ref</code>
serializable.record.contains.ignored.method.problem.descriptor=在記錄序列化期間將忽略 <code>#ref()</code>
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 欄位未被宣告為 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化類的 <code>#ref</code> 欄位未被宣告為 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 欄位未被宣告為 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化類的 <code>#ref</code> 欄位未被宣告為 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=將 serialVersionUID 設為 'private static final'

#dynamic
non.protected.constructor.in.abstract.class.display.name=abstract 類中的 public 構造函數
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
multiple.declaration.display.name=一個宣告中的多個變數
thread.priority.display.name=調用 'Thread.setPriority()'
too.broad.scope.display.name=變數範圍過寬
infinite.loop.statement.display.name=無限迴圈語句
asserts.without.messages.display.name=斷言上缺少訊息
constant.naming.convention.element.description=常數
constant.with.mutable.field.naming.convention.element.description=具有可變欄位類型的常數
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 獲取隨機整數
test.method.without.assertion.display.name=沒有任何斷言的 JUnit 測試方法
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
comparison.of.short.and.char.display.name=比較 'short' 和 'char' 值
unnecessary.fully.qualified.name.display.name=不必要的完全限定名稱
ignore.in.module.statements.option=在 Java 9 模組語句中忽略
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
exception.name.doesnt.end.with.exception.display.name=異常類名不以 'Exception' 結尾
bad.exception.declared.display.name=已宣告禁止異常
pointless.boolean.expression.display.name=無意義的語句或布爾表達式
class.without.constructor.display.name=不帶構造函數的類
break.statement.display.name='break' 語句
unconditional.wait.display.name=無條件的 'wait()' 調用
cyclomatic.complexity.display.name=過度複雜的方法
final.class.display.name=類禁止繼承
labeled.statement.display.name=標記語句
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上調用了 'notify()' 或 'notifyAll()'
loop.statements.that.dont.loop.display.name=不迴圈的迴圈語句
ignore.enhanced.for.loop.statements=忽略增強型 for 迴圈
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法覆寫 synchronized 方法
synchronize.on.this.display.name=在 'this' 上同步
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
utility.class.without.private.constructor.display.name=實用程序類沒有 'private' 構造函數
throw.caught.locally.display.name=通過包含 'try' 語句捕獲 'throw'
exception.from.catch.which.doesnt.wrap.display.name='throw' 位於忽略已捕獲異常的 'catch' 塊內
type.parameter.naming.convention.element.description=類型參數
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的冪
multiply.or.divide.by.power.of.two.divide.option=還通過 2 的冪檢查除法
serializable.with.unconstructable.ancestor.display.name=具有不可構造上級的可序列化類
missorted.modifiers.display.name=錯位修飾符
sleep.while.holding.lock.display.name=同步時調用 'Thread.sleep()'
singleton.display.name=單例
thread.death.rethrown.display.name='java.lang.ThreadDeath' 未重新拋出
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
redundant.implements.display.name=冗餘接口宣告
nesting.depth.display.name=過度嵌套的方法
return.this.display.name=返回 'this'
busy.wait.display.name=忙等待
utility.class.display.name=實用程序類
instantiating.object.to.get.class.object.display.name=實例化物件以獲取類物件
abstract.class.extends.concrete.class.display.name=abstract 類擴展具體類
parameter.naming.convention.display.name=方法參數命名慣例
parameter.naming.convention.element.description=參數
integer.division.in.floating.point.context.display.name=浮點上下文中的整數除法
interface.naming.convention.element.description=接口
length.one.strings.in.concatenation.display.name=單字符字串串聯
length.one.string.in.indexof.display.name= 'String.indexOf()' 調用中的單字符字串實參
thread.yield.display.name=調用 'Thread.yield()'
confusing.floating.point.literal.display.name=浮點文字會引起混淆
wait.not.in.loop.display.name=未在迴圈中調用的 'wait()'
string.concatenation.inside.string.buffer.append.display.name=字串串聯作為 'StringBuilder.append()' 調用的實參
class.initializer.display.name=非 'static' 初始設定式
enumerated.class.naming.convention.element.description=枚舉
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 欄位延遲初始化
call.to.simple.setter.in.class.display.name=從類內調用簡單 setter
comparison.to.nan.display.name=與 Double.NaN 或 Float.NaN 比較
new.method.naming.convention.display.name=方法命名慣例
instance.method.naming.convention.element.description=實例
unnecessary.semicolon.display.name=不必要的分號
fallthru.in.switch.statement.display.name='switch' 語句中的直落
call.to.native.method.while.locked.display.name=鎖定時調用本地方法
switch.statement.display.name='switch' 語句
custom.classloader.display.name=宣告了自訂的 'ClassLoader'
nested.conditional.expression.display.name=嵌套條件表達式
duplicate.condition.display.name=條件重複
method.with.multiple.loops.display.name=具有多個迴圈的方法
non.comment.source.statements.display.name=過長的方法
local.variable.naming.convention.display.name=局部變數命名慣例
local.variable.naming.convention.element.description=局部變數
negated.if.else.display.name=具有否定條件的 'if' 語句
class.naming.convention.display.name=類命名慣例
class.naming.convention.element.description=類
abstract.class.naming.convention.element.description=abstract 類
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 內部類具有不可序列化外部類
pointless.arithmetic.expression.display.name=無意義的算術表達式
method.name.same.as.class.name.display.name=方法名稱與類名相同
unnecessary.temporary.on.conversion.to.string.display.name=轉換為 'String' 時有不必要的臨時物件
unnecessary.continue.display.name=不必要的 'continue' 語句
inner.class.on.interface.display.name=接口的內部類
unused.label.display.name=未使用的標籤
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
class.loader.instantiation.display.name=ClassLoader 實例化
return.from.finally.block.display.name='return' 位於 'finally' 塊內
unnecessary.boxing.display.name=不必要的裝箱
annotation.naming.convention.element.description=註解
checked.exception.class.display.name=已檢查的異常類
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用並宣告的局部變數
cast.that.loses.precision.display.name=損失精度的數字轉換
manual.array.copy.display.name=手動陣列複製
manual.array.to.collection.copy.display.name=手動陣列到集合複製
long.literals.ending.with.lowercase.l.display.name='long' 文字以 'l' 而不是 'L' 結尾
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
junit.abstract.test.class.naming.convention.element.description=abstract 測試
unnecessary.parentheses.display.name=不必要的圓括號
test.case.in.product.code.display.name=產品源中的 JUnit TestCase
test.method.in.product.code.display.name=產品源中的 JUnit 測試方法
serializable.class.in.secure.context.display.name=安全上下文中的可序列化類
static.variable.naming.convention.element.description='static' 欄位
nested.method.call.display.name=嵌套方法調用
throw.from.finally.block.display.name='throw' 位於 'finally' 塊內
field.accessed.synchronized.and.unsynchronized.display.name=同時在同步和未同步上下文中存取欄位
abstract.method.overrides.abstract.method.display.name=abstract 方法覆寫 abstract 方法
static.non.final.field.display.name='static' 非 'final' 欄位
static.non.final.field.option=僅報告 'public' 欄位
class.without.no.arg.constructor.display.name=沒有無實參構造函數的類
unnecessary.return.display.name=不必要的 'return' 語句
final.static.method.display.name='static' 方法被宣告為 'final'
constant.declared.in.abstract.class.display.name=在 abstract 類中宣告的常數
too.broad.catch.display.name=過寬的 'catch' 塊
floating.point.equality.display.name=浮點相等比較
thrown.exceptions.per.method.display.name=方法宣告的異常過多
public.static.array.field.display.name='public static' 陣列欄位
await.not.in.loop.display.name=未在迴圈中調用的 'await()'
method.names.differ.only.by.case.display.name=方法名稱僅大小寫不同
unsecure.random.number.generation.display.name=不安全的隨機數生成
parameters.per.method.display.name=參數過多的方法
parameters.per.constructor.display.name=參數過多的構造函數
unnecessary.unboxing.display.name=不必要的拆箱
extends.thread.display.name=類直接擴展 'java.lang.Thread'
test.case.with.constructor.display.name=具有非普通構造函數的 JUnit TestCase
parameter.name.differs.from.overridden.parameter.display.name=參數名稱與覆寫方法中的參數不同
final.private.method.display.name='private' 方法被宣告為 'final'
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚舉 'switch' 語句
enum.switch.statement.which.misses.cases.option=忽略具有預設分支的 switch 語句
unconstructable.test.case.display.name=不可構造的 JUnit TestCase
string.buffer.must.have.initial.capacity.display.name=沒有初始容量的 StringBuilder
method.may.be.static.display.name=方法可以為 'static'
class.initializer.may.be.static.display.name=類初始設定式可能為 'static'
class.initializer.option=僅在類具有一個或多個構造函數時警告
class.initializer.move.code.to.constructor.quickfix=將初始設定式程式碼移動到構造函數
nested.switch.statement.display.name=嵌套 'switch' 語句
c.style.array.declaration.display.name=C 樣式陣列宣告
final.method.in.final.class.display.name='final' 類位於 'final' 方法中
extends.annotation.display.name=類擴展註解接口
naked.notify.display.name=沒有相應狀態更改的 'notify()' 或 'notifyAll()'
switch.statement.density.display.name='switch' 語句的分支密度過低
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
upper.case.field.name.not.constant.display.name=具有大寫名稱的非常數欄位
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 調用具有非常數字串
synchronize.on.non.final.field.display.name=在非 final 欄位上同步
noop.method.in.abstract.class.display.name='abstract' 類中的無運算方法
non.final.field.of.exception.display.name=異常類的非 final 欄位
nested.try.statement.display.name=嵌套 'try' 語句
condition.signal.display.name=調用 'signal()' 而不是 'signalAll()'
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 調用具有非常數字串
system.set.security.manager.display.name=調用 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=對 <code>System.#ref()</code> 的調用可能造成安全問題 #loc
control.flow.statement.without.braces.display.name=不帶大括號的控制流語句
trivial.if.display.name=冗餘的 'if' 語句
trivial.if.fix.family.name=簡化 'if else'
trivial.if.option.ignore.chained=忽略鏈式 'if' 語句
thread.with.default.run.method.display.name=使用預設的 'run()' 方法實例化執行緒
while.loop.spins.on.field.display.name='while' 迴圈在欄位上自旋
while.loop.spins.on.field.fix.family.name=修復自旋迴圈
while.loop.spins.on.field.fix.volatile=將 ''{0}'' 設為 volatile
while.loop.spins.on.field.fix.spinwait=添加 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile.spinwait=將 ''{0}'' 設為 volatile 並添加 Thread.onSpinWait()
test.method.is.public.void.no.arg.display.name=測試方法的格式錯誤
if.statement.with.identical.branches.display.name='if' 語句的分支相同
inspection.common.if.parts.message.variables.only=從 ''if'' 中提取變數{0}
inspection.common.if.parts.message.with.variables.extract=從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同時移除分支{0}
inspection.common.if.parts.message.complete.duplicate=摺疊 ''if'' 語句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=摺疊 'if' 語句並提取副作用
inspection.common.if.parts.description.variables.only=可以從 ''if'' 中提取變數{0}
inspection.common.if.parts.description.with.variables.extract=可以從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同時移除分支{0}
inspection.common.if.parts.description.complete.duplicate=可以摺疊 ''if'' 語句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通過提取副作用摺疊 'if' 語句
inspection.note.may.change.semantics=可能更改語意
multiple.return.points.per.method.display.name=具有多個返回點的方法
break.statement.with.label.display.name=帶標籤的 'break' 語句
public.constructor.in.non.public.class.display.name='public' 構造函數位於非 public 類中
questionable.name.display.name=可疑名稱
empty.finally.block.display.name=空 'finally' 塊
abstract.method.overrides.concrete.method.display.name=abstract 方法覆寫具體方法
thread.stop.suspend.resume.display.name=調用 'Thread.stop()'、'suspend()' 或 'resume()'
constant.math.call.display.name=常數調用 'java.lang.Math'
volatile.array.field.display.name=volatile 陣列欄位
literal.as.arg.to.string.equals.display.name=字串文字可以為 'equals()' 限定符
inner.class.may.be.static.display.name=內部類可能為 'static'
static.suite.display.name='suite()' 方法未被宣告為 'static'
redundant.field.initialization.display.name=冗餘欄位初始化
string.buffer.to.string.in.concatenation.display.name=連接中的 'StringBuilder.toString()'
utility.class.with.public.constructor.display.name=實用程序類具有 'public' 構造函數
for.loop.replaceable.by.while.display.name='for' 迴圈可取代為 'while' 迴圈
missing.deprecated.annotation.display.name=缺少 @Deprecated 註解
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆類
static.inheritance.display.name=靜態繼承
class.name.prefixed.with.package.name.display.name=使用軟體套件名稱作為前綴的類名
call.to.simple.getter.in.class.display.name=從類內調用簡單 getter
class.name.differs.from.file.name.display.name=類名與文件名不同
protected.member.in.final.class.display.name='protected' 成員位於 'final' 類中
load.library.with.non.constant.string.display.name='System.loadLibrary()' 調用具有非常數字串
instanceof.catch.parameter.display.name='catch' 參數上的 'instanceof'
implicit.numeric.conversion.display.name=隱式數字轉換
unnecessary.interface.modifier.display.name=不必要的接口修飾符
confusing.main.method.display.name=引起混淆的 'main()' 方法
octal.literal.display.name=八進制整數
misordered.assert.equals.arguments.display.name=順序錯誤的 'assertEquals()' 實參
unnecessary.constructor.display.name=冗餘無實參構造函數
method.name.same.as.parent.name.display.name=方法名稱與父類名相同
while.can.be.foreach.display.name='while' 迴圈可取代為增強的 'for' 迴圈
big.decimal.equals.display.name=在 'java.math.BigDecimal' 上調用了 'equals()'
implicit.call.to.super.display.name=隱式調用 'super()'
unqualified.static.usage.display.name=非限定靜態存取
simplifiable.junit.assertion.display.name=可簡化斷言
object.notify.display.name=調用 'notify()' 而不是 'notifyAll()'
thread.start.in.construction.display.name=物件構造期間調用 'Thread.start()'
non.final.clone.display.name=非 final 'clone()' 位於安全上下文中
unnecessary.temporary.on.conversion.from.string.display.name=從字串轉換時的臨時物件不必要
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略欄位賦值
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 調用具有非常數字串
system.properties.display.name=系統屬性的存取
chained.method.call.display.name=鏈式方法調用
safe.lock.display.name=已獲取但未安全解鎖的鎖
system.run.finalizers.on.exit.display.name=調用 'System.runFinalizersOnExit()'
for.can.be.foreach.display.name='for' 迴圈可取代為增強的 'for' 迴圈
type.parameter.extends.object.display.name=類型參數顯式擴展 'java.lang.Object'
type.parameter.extends.object.ignore.annotated=註解 java.lang.Object 時忽略
marker.interface.display.name=標記接口
limited.scope.inner.class.display.name=局部類
switch.statements.without.default.display.name=不帶 'default' 分支的 'switch' 語句
unchecked.exception.class.display.name=未檢查的異常類
for.loop.with.missing.component.display.name=缺少組件的 'for' 迴圈
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
double.checked.locking.display.name=雙重檢查鎖定
double.checked.locking.problem.descriptor=雙重檢查鎖定 #loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可取代為 'String'
boolean.method.name.must.start.with.question.display.name=布爾方法名稱必須以疑問詞開頭
class.name.same.as.ancestor.name.display.name=類名與上級名稱相同
error.rethrown.display.name='java.lang.Error' 未重新拋出
serializable.has.serialization.methods.display.name=不帶 'readObject()' 和 'writeObject()' 的可序列化類
serializable.has.serialization.methods.ignore.option=忽略未定義實例欄位的類
missing.override.annotation.display.name=缺少 '@Override' 註解
wait.while.holding.two.locks.display.name=保持兩個鎖時 'wait()'
empty.class.display.name=冗餘空類
trivial.string.concatenation.display.name=與空字串串聯
empty.synchronized.statement.display.name=空 'synchronized' 語句
unnecessary.default.display.name=枚舉 'switch' 語句的 'default' 不必要
simplifiable.conditional.expression.display.name=可簡化的條件表達式
unnecessary.super.constructor.display.name=對 'super()' 的調用不必要
unnecessarily.qualified.static.usage.display.name=不必要的限定靜態存取
bad.exception.caught.display.name=已捕獲禁止異常
custom.security.manager.display.name=自訂 'SecurityManager'
string.concatenation.in.loops.display.name=字串串聯在迴圈中
boolean.constructor.display.name=布爾構造函數調用
continue.statement.display.name='continue' 語句
extends.object.display.name=類顯式擴展 'java.lang.Object'
serializable.inner.class.has.serial.version.uid.field.display.name=沒有 'serialVersionUID' 的可序列化非 static 內部類
static.method.naming.convention.element.description='static'
empty.try.block.display.name=空 'try' 塊
field.has.setter.but.no.getter.display.name=欄位具有 setter 但沒有 getter
three.negations.per.method.display.name=具有三個以上否定的方法
conditional.expression.display.name=條件表達式
unnecessary.enum.modifier.display.name=不必要的 enum' 修飾符
string.equals.empty.string.display.name='String.equals()' 可取代為 'String.isEmpty()'
synchronize.on.lock.display.name=在鎖定物件上同步
synchronized.on.literal.object.name=在使用文字初始化的物件上同步
field.may.be.static.display.name=欄位可以為 'static'
class.may.be.interface.display.name=abstract 類可能是接口
abstract.class.without.abstract.methods.display.name=沒有 abstract 方法的 abstract 類
divide.by.zero.display.name=除以零
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
nested.synchronized.statement.display.name=嵌套 'synchronized' 語句
constant.conditional.expression.display.name=恒定條件表達式
redundant.else.display.name=冗餘的 'else'
public.field.accessed.in.synchronized.context.display.name=在同步上下文中存取的非 private 欄位
string.replaceable.by.string.buffer.display.name=非常數字串可取代為 StringBuilder
junit.test.class.naming.convention.element.description=測試
junit.test.suite.naming.convention.element.description=測試套件
method.coupling.display.name=過度耦合的方法
collections.must.have.initial.capacity.display.name=沒有初始容量的集合
anonymous.inner.class.display.name=匿名內部類可取代為內部類
negated.conditional.display.name=具有否定條件的條件表達式
non.reproducible.math.call.display.name=不可重現調用 'java.lang.Math'
multiple.top.level.classes.in.file.display.name=單個檔案中的多個頂級類
set.replaceable.by.enum.set.display.name='Set' 可取代為 'EnumSet'
tail.recursion.display.name=尾遞歸
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 塊
non.atomic.operation.on.volatile.field.display.name=volatile 欄位上的非原子操作
public.static.collection.field.display.name='public static' 集合欄位
non.exception.name.ends.with.exception.display.name=非異常類名以 'Exception' 結尾
synchronized.method.display.name='synchronized' 方法
enumerated.constant.naming.convention.element.description=枚舉常數
final.method.display.name=不能覆寫方法
transient.field.in.non.serializable.class.display.name=不可序列化類中存在 transient 欄位
bad.exception.thrown.display.name=已拋出禁止異常
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.can.be.pushed.inside.expression.display.name=可以在分支表達式內推送條件
conditional.can.be.pushed.inside.expression.option=在條件將僅作為方法調用的實參時忽略
conditional.can.be.pushed.inside.expression.quickfix=在分支內推送條件表達式
raw.use.of.parameterized.type.display.name=參數化類的原始使用
standard.variable.names.display.name=標準變數名稱
field.naming.convention.display.name=欄位命名慣例
instance.variable.naming.convention.element.description=實例欄位
dollar.sign.in.name.display.name=在關鍵字中使用 '$'
map.replaceable.by.enum.map.display.name='Map' 可取代為 'EnumMap'
extends.concrete.collection.display.name=類顯式擴展 'Collection' 類
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
abstract.method.with.missing.implementations.display.name=缺少實作的 abstract 方法
object.allocation.in.loop.display.name=迴圈中的物件分配
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上調用了 'wait()'
test.case.with.no.test.methods.display.name=沒有測試的測試類
abstract.class.never.implemented.display.name=沒有具體子類的 abstract 類
interface.never.implemented.display.name=沒有具體子類的接口
constant.declared.in.interface.display.name=在接口中宣告的常數


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=異常類名 <code>#ref</code> 未以 'Exception' 結尾 #loc
non.exception.name.ends.with.exception.problem.descriptor=非異常類名 <code>#ref</code> 以 'Exception' 結尾 #loc
class.name.prefixed.with.package.name.problem.descriptor=類名 <code>#ref</code> 以其軟體套件名稱開始 #loc
class.name.same.as.ancestor.name.problem.descriptor=類名 <code>#ref</code> 與其超類的名稱之一相同 #loc
method.name.same.as.class.name.problem.descriptor=方法名稱 <code>#ref</code> 與其類名相同 #loc
method.name.same.as.parent.name.problem.descriptor=方法名稱 <code>#ref</code> 與其父類名相同 #loc
boolean.method.name.must.start.with.question.problem.descriptor=布爾方法名稱 <code>#ref</code> 未以疑問詞開頭 #loc
questionable.name.problem.descriptor=可疑名稱 <code>#ref</code> #loc
confusing.main.method.problem.descriptor=方法名稱 <code>#ref</code> 沒有簽名 'public static void main(String[])' #loc
upper.case.field.name.not.constant.problem.descriptor=帶常數樣式名稱的非常數欄位 <code>#ref</code> #loc
dollar.sign.in.name.problem.descriptor=關鍵字 <code>#ref</code> 包含 '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: 浮點上下文中的整數除法 #loc
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比較 <code>#ref</code> #loc
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>#ref()</code> 可能應當是 'compareTo()' #loc
divide.by.zero.problem.descriptor=除以零 #loc
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> 可能產生不可重現的結果 #loc
constant.math.call.problem.descriptor=對 <code>#ref()</code> 的常數調用可以簡化 #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: 比較浮點值以實作完全相等 #loc
fallthru.in.switch.statement.problem.descriptor='switch' 語句存在直落 #loc
switch.statements.without.default.problem.descriptor=沒有 'default' 分支的 <code>#ref</code> 語句 #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> 分支不是 ''switch'' {0} 中的最後一個 case #loc
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> 語句未迴圈 #loc
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的條件表達式 <code>#ref</code> #loc
conditional.can.be.pushed.inside.expression.problem.descriptor=條件表達式可以推送到分支內 #loc
duplicate.condition.problem.descriptor=重複條件 <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=忽略有副作用的條件
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=無法拋出 'NoSuchElementException' 的 <code>Iterator.#ref()</code> '#loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> 語句不能在未拋出異常的情況下完成 #loc
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點文字 <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=過於複雜的算術表達式 #loc
overly.complex.boolean.expression.problem.descriptor=過度複雜的布爾表達式 ({0} 項) #loc
labeled.statement.problem.descriptor=標記語句 <code>#ref:</code> #loc
break.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
continue.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
conditional.expression.problem.descriptor=條件表達式 <code>#ref</code> #loc
conditional.expression.option=對簡單賦值和返回值忽略
conditional.expression.expression.context.option=忽略無法使用 if 語句的位置
conditional.expression.quickfix=取代為 'if' 語句
nested.conditional.expression.problem.descriptor=嵌套條件表達式 <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' 文字 <code>#ref</code> 以小寫 'l' 結尾 #loc
nested.switch.statement.problem.descriptor=嵌套 <code>#ref</code> {0} #loc
chained.method.call.problem.descriptor=鏈式方法調用 <code>#ref()</code> #loc
nested.method.call.problem.descriptor=嵌套方法調用 <code>#ref()</code> #loc
octal.literal.problem.descriptor=八進制整數 <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=隱式調用 'super()' #loc
negated.if.else.problem.descriptor=帶嵌套條件的 <code>#ref</code> 語句 #loc
negated.conditional.problem.descriptor=具有否定條件的條件表達式 #loc
redundant.else.problem.descriptor=<code>#ref</code> 分支可以解開，因為 'if' 分支永遠不會正常完成 #loc
switch.statement.with.confusing.declaration.problem.descriptor=局部變數 <code>#ref</code> 在一個 'switch' 分支中宣告，並在另一個分支中使用 #loc
final.class.problem.descriptor=類被宣告為 <code>#ref</code> #loc
empty.class.problem.descriptor=類 <code>#ref</code> 為空 #loc
empty.enum.problem.descriptor=枚舉 <code>#ref</code> 為空 #loc
empty.class.file.without.class.problem.descriptor=Java 檔案未宣告任何類 #loc
empty.anonymous.class.problem.descriptor=匿名類為空 #loc
anonymous.inner.class.problem.descriptor=匿名內部類 <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=局部類 <code>#ref</code> #loc
final.method.problem.descriptor=方法被宣告為 <code>#ref</code> #loc
class.initializer.problem.descriptor=非 'static' 初始設定式 #loc
class.may.be.interface.problem.descriptor=abstract 類 <code>#ref</code> 可能是接口 #loc
non.protected.constructor.in.abstract.class.problem.descriptor=abstract 類的構造函數 <code>#ref()</code> 不應宣告為 'public' #loc
class.without.constructor.problem.descriptor=類 <code>#ref</code> 沒有構造函數 #loc
abstract.class.without.abstract.methods.problem.descriptor=類 <code>#ref</code> 被宣告為 'abstract'，並且沒有 'abstract' 方法 #loc
final.method.in.final.class.problem.descriptor=方法在 'final' 類中被宣告為 <code>#ref</code> #loc
protected.member.in.final.class.problem.descriptor=類成員在 'final' 類中被宣告為 <code>#ref</code> #loc
utility.class.with.public.constructor.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員和 'public' 構造函數 #loc
utility.class.without.private.constructor.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員，缺少 'private' 構造函數 #loc
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫具體方法 #loc
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>#ref()</code> 未在每個子類中實作 #loc
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫 abstract 方法 #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 與其 super 方法不同的方法
abstract.class.extends.concrete.class.problem.descriptor=類 <code>#ref</code> 被宣告為 'abstract'，並擴展一個具體類 #loc
static.non.final.field.problem.descriptor='static' 非 'final' 欄位 <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=常數 <code>#ref</code> 在 abstract 類中宣告 #loc
constant.declared.in.interface.problem.descriptor=常數 <code>#ref</code> 在接口中宣告 #loc
static.inheritance.problem.descriptor=接口 <code>#ref</code> 僅針對其 static 常數實作 #loc
utility.class.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員，指示程序構造 #loc
singleton.problem.descriptor=類 <code>#ref</code> 為單例 #loc
enum.singleton.problem.descriptor=枚舉 <code>#ref</code> 為單例 #loc
final.private.method.problem.descriptor='private' 方法被宣告為 <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=無操作方法 <code>#ref()</code> 應當設為 abstract #loc
final.static.method.problem.descriptor='static' 方法被宣告為 <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> 沒有無實參構造函數 #loc
multiple.top.level.classes.in.file.problem.descriptor=檔案中的多個頂級類
class.name.differs.from.file.name.problem.descriptor=類名 <code>#ref</code> 與文件名不同 #loc
marker.interface.problem.descriptor=標記接口 <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=欄位 <code>#ref</code> 有 setter 但沒有 getter #loc
abstract.class.never.implemented.problem.descriptor=abstract 類 <code>#ref</code> 沒有具體子類 #loc
interface.never.implemented.problem.descriptor=接口 <code>#ref</code> 沒有具體子類 #loc
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 註解 #loc
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 標記說明 #loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 標記說明
missing.override.annotation.problem.descriptor=缺少關於 <code>#ref()</code> 的 '@Override' 註解 #loc
missing.override.annotation.in.overriding.problem.descriptor=覆寫方法未使用 '@Override' 註解
non.thread.safe.lazy.initialization.problem.descriptor='static' 欄位 <code>#ref</code> 的延遲初始化不是執行緒安全 #loc
empty.finally.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> 塊無法正常完成 #loc
empty.try.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 塊內引發 #loc
throw,from.finally.block.everywhere.option=警告隨處都可能引發宣告的異常
throw.caught.locally.problem.descriptor=通過包含 'try' 語句捕獲 <code>#ref</code> #loc
throw.caught.locally.ignore.option=忽略重新拋出的異常
return.from.finally.block.problem.descriptor='return' 位於 'finally' 塊內 #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
bad.exception.declared.problem.descriptor=已宣告禁止異常 <code>#ref</code> #loc
bad.exception.caught.problem.descriptor=已捕獲禁止異常 <code>#ref</code> #loc
checked.exception.class.problem.descriptor=已檢查的異常類 <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=未檢查的異常類 <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> 未重新拋出 #loc
error.rethrown.problem.descriptor=錯誤 <code>#ref</code> 未重新拋出 #loc
nested.try.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 塊內的 <code>#ref</code> 忽略捕獲的異常 #loc
instanceof.catch.parameter.problem.descriptor='catch' 參數 <code>#ref</code> 上的 'instanceof' #loc
non.final.field.of.exception.problem.descriptor=異常類的非 final 欄位 <code>#ref</code> #loc
unnecessary.label.on.break.statement.problem.descriptor=<code>#ref</code> 語句上的標籤不必要 #loc
unnecessary.label.on.continue.statement.problem.descriptor=<code>#ref</code> 語句上的標籤不必要 #loc
trivial.if.problem.descriptor=<code>#ref</code> 語句可以簡化 #loc
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unnecessary.local.variable.problem.descriptor=局部變數 <code>#ref</code> 是冗餘的 #loc
unnecessary.this.problem.descriptor=<code>#ref</code> 在此上下文中不必要 #loc
unnecessary.block.statement.problem.descriptor=此語句周圍的大括號不必要 #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> 不必要，因為是迴圈中的最後一條語句 #loc
unnecessary.semicolon.problem.descriptor=不必要的分號 <code>#ref</code> #loc
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚舉常數後的不必要分號
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>#ref</code> 不必要，可取代為匯入 #loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>#ref</code> 不必要，可以移除 #loc
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unused.label.problem.descriptor=未使用的標籤 <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=<code>#ref</code> 的欄位初始化是冗餘的 #loc
redundant.implements.problem.descriptor=冗餘接口宣告 <code>#ref</code> #loc
extends.object.problem.descriptor=類 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor1=類型參數 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=萬用字元類型實參 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> 不必要 #loc
unnecessary.constructor.problem.descriptor=無實參構造函數 <code>#ref()</code> 是冗餘的 #loc
unnecessary.constructor.annotation.option=忽略有註解的構造函數
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> 迴圈語句可取代為 'while' 迴圈 #loc
unnecessary.default.problem.descriptor=<code>#ref</code> 分支不必要 #loc
unnecessary.default.expressions.option=僅報告 switch 表達式
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.boxing.problem.descriptor=不必要的裝箱 <code>#ref</code> #loc
unnecessary.boxing.inside.value.of.problem.descriptor=<code>#ref</code> 內的裝箱冗餘 #loc
unnecessary.unboxing.problem.descriptor=不必要的拆箱 <code>#ref</code> #loc
unnecessary.boxing.superfluous.option=僅報告真正多餘的裝箱表達式
unnecessary.unboxing.superfluous.option=僅報告真正多餘的拆箱表達式
for.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可取代為增強的 'for' #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可取代為增強的 'for' #loc
too.broad.scope.problem.descriptor=變數 <code>#ref</code> 的範圍過寬 #loc
return.this.problem.descriptor=返回 <code>#ref</code> #loc
constant.on.side.of.comparison.display.name=常數位於比較的錯誤一側
constant.on.lhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的左側 #loc
constant.on.rhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的右側 #loc
control.flow.statement.without.braces.problem.descriptor=不帶大括號的 <code>{0}</code> #loc
missorted.modifiers.problem.descriptor=錯位修飾符 <code>{0}</code> #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#欄位|2#參數|3#記錄組件|4#局部變數} <code>#ref</code> 的 C 樣式陣列宣告 #loc
cstyle.array.method.declaration.problem.descriptor=方法 <code>#ref()</code> 返回類型的 C 樣式陣列宣告 #loc
multiple.declaration.problem.descriptor=一個宣告中的多個變數 #loc
multiple.typed.declaration.problem.descriptor=在一個宣告中具有不同陣列維度的變數 #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=內部類 <code>#ref</code> 未定義 'serialVersionUID' 欄位 #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=內部類 <code>#ref</code> 可序列化，而其外部類不可序列化 #loc
busy.wait.problem.descriptor=在迴圈中調用 <code>Thread.#ref()</code>，可能處於忙等待 #loc
sleep.while.holding.lock.problem.descriptor=同步時調用 <code>Thread.#ref()</code> #loc
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 欄位 <code>#ref</code> 上的非原子操作 #loc
call.to.native.method.while.locked.problem.descriptor=在同步上下文中調用本地方法 <code>#ref()</code> #loc
object.notify.problem.descriptor=<code>#ref</code> 可能應當取代為 'notifyAll()' #loc
condition.signal.problem.descriptor=<code>#ref</code> 可能應當取代為 'signalAll()' #loc
thread.with.default.run.method.problem.descriptor=使用預設的 'run()' 方法實例化 <code>#ref</code> #loc
extends.thread.problem.descriptor=類 <code>#ref</code> 直接擴展 'java.lang.Thread' #loc
anonymous.extends.thread.problem.descriptor=匿名類直接擴展 'java.lang.Thread' #loc
naked.notify.problem.descriptor=在沒有相應狀態更改的情況下調用 <code>#ref()</code> #loc
unconditional.wait.problem.descriptor=無條件調用 <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=調用 <code>System.#ref()</code> #loc
thread.priority.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
thread.yield.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> 迴圈在欄位上自旋 #loc
wait.not.in.loop.problem.descriptor=<code>#ref()</code> 調用不在迴圈中 #loc
await.not.in.loop.problem.descriptor=<code>#ref()</code> 調用不在迴圈中 #loc
wait.called.on.condition.problem.descriptor=在條件物件上調用 <code>#ref()</code> #loc
notify.called.on.condition.problem.descriptor=在條件物件上調用 <code>#ref()</code> #loc
wait.while.holding.two.locks.problem.descriptor=在保持兩個鎖的情況下調用 <code>#ref()</code> #loc
thread.run.problem.descriptor=對 <code>#ref()</code> 的調用可能應當取代為 'start()' #loc
thread.start.in.construction.problem.descriptor=物件構造期間調用 <code>#ref()</code> #loc
synchronize.on.lock.problem.descriptor=在 ''{0}'' 物件上同步不太可能是故意的 #loc
synchronized.on.literal.object.problem.descriptor=在使用文字初始化的 {0} <code>#ref</code> 上同步 #loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 文字 <code>#ref</code> 上同步 #loc
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>#ref</code> 上同步 #loc
synchronize.on.non.final.field.problem.descriptor=在非 final 欄位 <code>#ref</code> 上同步 #loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的文字
synchronize.on.this.problem.descriptor=對 'this' 的鎖定操作可能會產生不可預見的副作用 #loc
synchronize.on.class.problem.descriptor=對類的鎖定操作可能會產生不可預見的副作用 #loc
nested.synchronized.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
empty.synchronized.statement.problem.descriptor=空 <code>#ref</code> 語句 #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>#ref()</code> 覆寫 synchronized 方法 #loc
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中存取非 private 欄位 <code>#ref</code> #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同時在同步和未同步上下文中存取欄位 <code>#ref</code> #loc
extended.for.statement.problem.descriptor=擴展 <code>#ref</code> 語句 #loc
object.allocation.in.loop.new.descriptor=迴圈中的物件分配 <code>new #ref()</code> #loc
object.allocation.in.loop.problem.array.initializer.descriptor=迴圈中的陣列分配 #loc
object.allocation.in.loop.problem.call.descriptor=物件分配通過迴圈中的 <code>#ref()</code> 調用完成 #loc
object.allocation.in.loop.problem.methodref.descriptor=物件分配通過迴圈中的實例綁定方法引用 <code>#ref()</code> 完成 #loc
object.allocation.in.loop.problem.lambda.descriptor=物件分配通過捕獲迴圈中的 lambda 完成 #loc
object.allocation.in.loop.problem.string.concat=物件分配通過迴圈中的字串串聯完成 #loc
instantiating.object.to.get.class.object.problem.descriptor=實例化物件以獲取類物件 #loc
field.may.be.static.problem.descriptor=欄位 <code>#ref</code> 可能為 'static' #loc
method.may.be.static.problem.descriptor=方法 <code>#ref()</code> 可能為 'static' #loc
class.initializer.may.be.static.problem.descriptor=類初始設定式可能為 'static' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> 可取代為 'EnumMap' #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> 可取代為 'EnumSet' #loc
inner.class.may.be.static.problem.descriptor=內部類 <code>#ref</code> 可能為 'static' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> 可能被宣告為 'StringBuilder' #loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> 可取代為 ''String'' #loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> 可取代為 'String' #loc
string.replaceable.by.string.buffer.problem.descriptor=非常數 <code>String #ref</code> 可能應被宣告為 'StringBuilder' #loc
collections.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
string.concatenation.in.loops.problem.descriptor=迴圈中的字串串聯 <code>#ref</code> #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=字串串聯作為 <code>{0}.#ref()</code> 調用的實參 #loc
boolean.constructor.problem.descriptor=布爾構造函數調用 #loc
string.buffer.to.string.in.concatenation.problem.descriptor=在串聯中調用 <code>{0}.#ref()</code> #loc
tail.recursion.problem.descriptor=尾部遞歸調用 <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> 可取代為 'length()==0' #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> 可取代為 'isEmpty()' #loc
random.double.for.random.integer.problem.descriptor=使用 <code>Random.#ref</code> 創建隨機整數 #loc
manual.array.copy.problem.descriptor=手動陣列複製 #loc
manual.array.to.collection.copy.problem.descriptor=手動陣列到集合複製 #loc
call.to.simple.getter.in.class.problem.descriptor=從類內調用簡單 getter <code>#ref()</code> #loc
call.to.simple.setter.in.class.problem.descriptor=從類內調用簡單 setter <code>#ref()</code> #loc
assert.without.message.problem.descriptor=沒有訊息的 <code>#ref()</code> #loc
assert.without.message.quick.fix.family.name=添加錯誤訊息
test.case.with.constructor.problem.descriptor=構造函數 <code>#ref()</code> 中的初始化邏輯，而不是 'setUp()' #loc
test.case.with.constructor.problem.descriptor.initializer=初始設定式中的初始化邏輯，而不是 'setUp()'
misordered.assert.equals.arguments.problem.descriptor=<code>#ref()</code> 的實參順序錯誤 #loc
static.suite.problem.descriptor=Junit <code>#ref()</code> 方法未被宣告為 'static' #loc
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> 可以簡化為 ''{0}'' #loc
test.method.without.assertion.problem.descriptor=JUnit 測試方法 <code>#ref()</code> 不包含斷言 #loc
test.case.with.no.test.methods.problem.descriptor=測試類 <code>#ref</code> 沒有測試 #loc
test.case.in.product.code.problem.descriptor=測試用例 <code>#ref</code> 可能應當放置在測試源樹中 #loc
test.method.in.product.code.problem.descriptor=測試方法 <code>#ref()</code> 可能應當放置在測試源樹中 #loc
unconstructable.test.case.problem.descriptor=測試用例 <code>#ref</code> 不能被大多數測試運行程序構造 #loc
deserializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被反序列化，影響安全性 #loc
serializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被序列化，影響安全性 #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被序列化和反序列化，影響安全性 #loc
cloneable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被克隆，影響安全性 #loc
cloneable.class.in.secure.context.quickfix=生成始終拋出異常的 'clone()' 方法
remove.cloneable.quickfix=從 'implements' 子句中移除 'Cloneable'
non.final.clone.problem.descriptor=非 final <code>#ref()</code> 方法，影響安全性 #loc
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.#ref()</code> 調用具有非常數實參 #loc
load.library.with.non.constant.string.problem.descriptor=<code>{0}.#ref()</code> 調用具有非常數實參 #loc
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.#ref()</code> 調用具有非常數實參 #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.#ref()</code> 調用具有非常數實參 #loc
custom.classloader.problem.descriptor=自訂 ClassLoader 類 <code>#ref</code> #loc
custom.security.manager.problem.descriptor=自訂 SecurityManager 類 <code>#ref</code> #loc
system.set.problem.descriptor=對 <code>System.#ref()</code> 的調用可能造成安全問題 #loc
class.loader.instantiation.problem.descriptor=實例化 <code>#ref</code> 可能造成安全問題 #loc
public.static.array.field.problem.descriptor='public static' 陣列欄位 <code>#ref</code>，影響安全性 #loc
public.static.collection.field.problem.descriptor='public static' 集合欄位 <code>#ref</code>，影響安全性 #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一個直接繼承者的 abstract 類 <code>#ref</code> #loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=移除冗餘 abstract 方法宣告
class.may.be.interface.convert.quickfix=將類轉換為接口
class.without.constructor.create.quickfix=生成空構造函數
class.without.no.arg.constructor.ignore.option=如果類具有預設構造函數，則忽略
extends.annotation.problem.descriptor=類 ''{0}'' 實作註解接口 <code>#ref</code> #loc
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 擴展註解接口 <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=類 <code>#ref</code> 顯式擴展 ''{0}'' #loc
anonymous.extends.concrete.collection.problem.descriptor=匿名類顯式擴展 ''{0}'' #loc
inner.class.on.interface.ignore.option=忽略接口的內部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有內部類 <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=添加 @Deprecated 註解
missing.add.deprecated.javadoc.tag.quickfix=添加 '@deprecated' Javadoc 標記
non.protected.constructor.in.abstract.class.ignore.option=對非 public 類忽略
public.constructor.in.non.public.class.problem.descriptor=構造函數在非 public 類 ''{0}'' 中被宣告為 <code>#ref</code> #loc
static.inheritance.replace.quickfix=將繼承取代為 {0} 中的限定引用
utility.class.with.public.constructor.make.quickfix=將{0, choice, 1#構造函數|2#構造函數}設為 'private'
utility.class.without.private.constructor.create.quickfix=生成空 'private' 構造函數
utility.class.without.private.constructor.make.quickfix=將構造函數設為 'private'
naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
local.variable.naming.convention.ignore.option=忽略 for 迴圈參數
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 塊參數
method.names.differ.only.by.case.problem.descriptor=方法名稱 <code>#ref</code> 和方法名稱 ''{0}'' 僅大小寫不同 #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果覆寫的參數僅包含一個字符，則忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果覆寫的參數來自庫，則忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=參數名稱 <code>#ref</code> 與覆寫的參數 ''{0}'' 不同 #loc
questionable.name.column.title=名稱
questionable.name.list.label=報告的名稱:
standard.variable.names.problem.descriptor=變數命名 <code>#ref</code> 沒有類型 ''{0}'' #loc
standard.variable.names.problem.descriptor2=變數命名 <code>#ref</code> 沒有類型 ''{0}'' 或 ''{1}'' #loc
standard.variable.names.ignore.override.option=對與 super 方法參數相同的參數名稱忽略
boolean.method.name.must.start.with.question.table.column.name=布爾方法名稱前綴
boolean.method.name.must.start.with.question.table.label=布爾方法名稱前綴:
conditional.expression.with.identical.branches.collapse.quickfix=摺疊條件表達式
redundant.else.unwrap.quickfix=移除冗餘的 'else'
constant.conditional.expression.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=簡化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用並簡化
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case ''{1}'' #loc
enum.switch.statement.which.misses.cases.problem.descriptor=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case: {1} #loc
for.loop.replaceable.by.while.ignore.option=忽略無條件的 'infinite' for 迴圈
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> 語句缺少初始設定式 #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> 語句缺少條件 #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> 語句缺少更新 #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> 語句缺少初始設定式和條件 #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> 語句缺少初始設定式和條件 #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> 語句缺少條件和更新 #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> 語句缺少初始設定式、條件和更新 #loc
foreach.replace.quickfix=取代為增強 'for'
unnecessary.boxing.remove.quickfix=移除裝箱
unnecessary.unboxing.remove.quickfix=移除拆箱
misordered.assert.equals.arguments.flip.quickfix=翻轉比較實參
simplify.junit.assertion.simplify.quickfix=簡化斷言
test.method.is.public.void.no.arg.problem.descriptor1=測試方法 <code>#ref()</code> 不應具有參數 #loc
test.method.is.public.void.no.arg.problem.descriptor2=測試方法 <code>#ref()</code> 未被宣告為 'public void' #loc
test.method.is.public.void.no.arg.problem.descriptor3=測試方法 <code>#ref()</code> 不應為 'static' #loc
system.properties.problem.descriptor=對 <code>Integer.#ref()</code> 的調用可能造成安全問題 #loc
system.properties.problem.descriptor1=對 <code>Boolean.#ref()</code> 的調用可能造成安全問題 #loc
unsecure.random.number.generation.problem.descriptor1=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=可序列化類 <code>#ref</code> 未定義 'readObject()' 或 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=可序列化類 <code>#ref</code> 未定義 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=可序列化類 <code>#ref</code> 未定義 'readObject()' #loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> 具有不帶無實參構造函數的不可序列化上級 ''{0}'' #loc
transient.field.in.non.serializable.class.problem.descriptor=欄位 ''{0}'' 已在不可序列化類中標記為 <code>#ref</code> #loc
safe.lock.problem.descriptor=''{0}'' 應在 ''try'' 塊之前鎖定，並在相應的 ''finally'' 塊中解鎖 #loc
synchronized.method.problem.descriptor=方法 ''{0}()'' 被宣告為 <code>#ref</code> #loc
synchronized.method.include.option=包含本地方法
synchronized.method.ignore.synchronized.super.option=忽略覆寫 synchronized 方法的方法
synchronized.method.move.quickfix=將同步移動到方法中
volatile.field.problem.descriptor=類型 ''{0}'' 的 volatile 欄位 <code>#ref</code> #loc
string.format.choose.class=選擇格式化程序類
string.format.class.column.name=附加格式化程序類
string.format.class.label=附加格式化程序類:
string.format.class.method.name=附加格式化程序方法
string.format.class.method.label=附加格式化程序方法:
exception.class.column.name=異常類
bad.exception.thrown.problem.descriptor=已拋出禁止異常 ''{0}'' #loc
too.broad.catch.problem.descriptor=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' #loc
too.broad.catch.problem.descriptor1=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
add.serialversionuidfield.quickfix=添加 'serialVersionUID' 欄位
delete.import.quickfix=刪除不必要的匯入
encapsulate.variable.quickfix=封裝欄位 ''{0}''
extract.method.quickfix=提取方法
inline.call.quickfix=內聯調用
inline.variable.quickfix=內聯變數
pointless.nullcheck.display.name=方法調用前出現不必要的 'null' 檢查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 調用之前的 ''null'' 檢查不必要
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 條件
remove.redundant.polyadic.operand.fix.family.name=移除不必要的條件
introduce.constant.quickfix=引入常數
make.initialization.explicit.quickfix=使初始化顯式
move.anonymous.to.inner.quickfix=轉換為命名內部類
anonymous.inner.may.be.named.static.inner.class.quickfix=轉換為命名 'static' 內部類
move.class.quickfix=移動類
normalize.declaration.quickfix=拆分為單獨的宣告
remove.modifier.quickfix=移除 ''{0}'' 修飾符
replace.inheritance.with.delegation.quickfix=將繼承取代為委託
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致精度損失 #loc
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致負實參的精度損失 #loc
comparison.to.nan.problem.descriptor1=與 <code>#ref</code> 的比較始終為 false #loc
comparison.to.nan.problem.descriptor2=與 <code>#ref</code> 的比較始終為 true #loc
confusing.floating.point.literal.change.quickfix=更改為規範形式
implicit.numeric.conversion.ignore.widening.conversion.option=忽略擴大轉換
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之間的轉換
implicit.numeric.conversion.ignore.constant.conversion.option=忽略從常數和文字的轉換
implicit.numeric.conversion.problem.descriptor=將 <code>#ref</code> 從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
implicit.numeric.conversion.assignment.problem.descriptor=將結果值從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
implicit.numeric.conversion.make.explicit.quickfix=使轉換顯式
non.reproducible.math.call.replace.quickfix=取代為 'StrictMath' 調用
overly.complex.arithmetic.expression.max.number.option=最大項數:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> 可取代為 ''{0}'' #loc
method.complexity.limit.option=方法復雜度限制:
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可取代為 {1}
cyclomatic.complexity.problem.descriptor=過度複雜的方法 <code>#ref()</code> (迴圈復雜度 = {0}) #loc
method.coupling.limit.option=方法耦合限制:
method.coupling.problem.descriptor=<code>#ref</code> 過度耦合 (# 引用的類 = {0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> 包含 {0} 個迴圈 #loc
return.point.limit.option=返回點限制(&R):
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> 具有 {0} 個返回點 #loc
nesting.depth.limit.option=嵌套深度限制:
nesting.depth.problem.descriptor=<code>#ref</code> 過度嵌套 (最大嵌套深度 = {0}) #loc
non.comment.source.statements.limit.option=非註釋源語句限制:
non.comment.source.statements.problem.descriptor=<code>#ref</code> 過長 (# 非註釋源語句 = {0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
parameter.limit.option=參數限制:
constructor.visibility.option=忽略具有以下可見性的構造函數:
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.ignore.assert.option=忽略 'assert' 語句中的否定
three.negations.per.method.problem.descriptor=<code>#ref</code> 包含 {0} 個否定 #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> 宣告的異常過多 (異常數量 = {0}) #loc
thrown.exceptions.per.method.limit.option=異常拋出限制:
call.to.simple.getter.in.class.ignore.option=忽略其他物件上的 getter 調用
call.to.private.simple.getter.in.class.option=僅在 getter 為 'private' 時報告
call.to.simple.getter.in.class.inline.quickfix=內聯調用 getter
call.to.simple.setter.in.class.ignore.option=忽略其他物件上的 setter 調用
call.to.private.setter.in.class.option=僅在 setter 為 'private' 時報告
call.to.simple.setter.in.class.inline.quickfix=內聯調用 setter
make.static.quickfix=設為 'static'
length.one.strings.in.concatenation.replace.quickfix=取代為字符
multiply.or.divide.by.power.of.two.replace.quickfix=取代為移位
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> 未修改 ''{0}'' 的值 #loc
boolean.expression.remove.compound.assignment.quickfix=移除無意義的複合賦值
trivial.string.concatenation.problem.descriptor=串聯中使用的空字串
string.replace.quickfix=將串聯取代為 ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=取代為直接類物件存取
method.may.be.static.only.option=僅檢查 'private' 或 'final' 方法
method.may.be.static.empty.option=忽略空方法
string.concatenation.inside.string.buffer.append.replace.quickfix=取代為鏈式 'append()' 調用
string.equals.empty.string.option.do.not.add.null.check=當有必要進行 null 檢查時，不必報告
tail.recursion.replace.quickfix=用迭代替換尾部遞歸
if.statement.with.too.many.branches.max.option=最大分支數:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> 的分支過多 ({0}) #loc
negated.conditional.invert.quickfix=反轉條件
negated.if.else.ignore.negated.null.option=忽略 '!= null' 比較
negated.if.else.ignore.negated.zero.option=忽略 '!= 0' 比較
negated.if.else.invert.quickfix=反轉 'if' 條件
overly.complex.boolean.expression.max.terms.option=最大項數:
pointless.boolean.expression.ignore.option=在確定無意義表達式時忽略命名常數
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
switch.statement.density.min.option=分支的最小密度: %
switch.statement.density.problem.descriptor=<code>#ref</code> 的分支密度過低 ({0}%) #loc
switch.statement.with.too.few.branches.min.option=最小分支數:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 語句的 case 標籤太少({0})，並且可能應當取代為 ''if'' 語句 #loc
switch.statement.with.single.default.message='switch' 語句只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表達式的 case 標籤太少 ({0})，並且可能應當取代為 ''if'' 語句或條件運算符 #loc
switch.expression.with.single.default.message='switch' 表達式只有 'default' case
switch.statement.without.default.ignore.option=忽略詳盡的 switch 語句
unnecessary.label.remove.quickfix=移除標籤
unnecessary.return.problem.descriptor=<code>#ref</code> 不必要，因為是 'void' 方法中的最後一條語句 #loc
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> 不必要，因為是構造函數中的最後一條語句 #loc
unused.label.remove.quickfix=移除未使用的標籤
unnecessarily.qualified.static.usage.problem.descriptor=不必要的限定 static 方法調用 <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=不必要的限定靜態存取 <code>{0}</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定欄位存取
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法調用
unnecessary.interface.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口是冗餘的 #loc
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor=修飾符 <code>#ref</code> 對於內部接口是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor2=修飾符 <code>#ref</code> 對於接口方法是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor3=修飾符 <code>#ref</code> 對於接口的內部類是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor4=修飾符 <code>#ref</code> 對於接口欄位是冗餘的 #loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
unqualified.static.usage.problem.descriptor=非限定 static 方法調用 <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=非限定 static 欄位存取 <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=忽略非限定欄位存取
unqualified.static.usage.ignore.method.option=忽略非限定方法調用
unqualified.static.usage.qualify.field.quickfix=限定 static 欄位存取
unqualified.static.usage.qualify.method.quickfix=限定 static 方法調用
too.broad.scope.allow.option=<html>報告使用新表達式作為初始設定式的變數<br>(可能不安全)</html>
too.broad.scope.only.blocks.option=僅報告可移入內部塊的變數
too.broad.scope.narrow.quickfix=將 ''{0}'' 的宣告移近用法
press.escape.to.remove.highlighting.message=按 Esc 移除高亮顯示
unnecessary.enum.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於枚舉構造函數是冗餘的 #loc
unnecessary.enum.modifier.problem.descriptor1=修飾符 <code>#ref</code> 對於內部枚舉是冗餘的 #loc
literal.as.arg.to.string.equals.problem.descriptor=文字 #ref 是 ''{0}()'' 的實參，而不是其限定符 #loc
literal.as.arg.to.string.equals.flip.quickfix=翻轉 ''{0}()''
c.style.array.declaration.replace.quickfix=取代為 Java 樣式陣列宣告
chained.method.call.ignore.option=忽略欄位初始設定式中的鏈式方法調用
chained.method.call.ignore.self.types.option=忽略對返回類型與其封閉類相同的方法的調用
introduce.variable.quickfix=引入變數
introduce.variable.may.change.semantics.quickfix=引入變數 (可能更改語意)
flip.comparison.quickfix=翻轉比較
control.flow.statement.without.braces.add.quickfix=將大括號添加到語句
control.flow.statement.without.braces.message=將大括號添加到 ''{0}'' 語句
extends.object.remove.quickfix=移除冗餘的 'extends Object'
implicit.call.to.super.ignore.option=對 'java.lang.Object' 的直接子類忽略
implicit.call.to.super.make.explicit.quickfix=使對 'super()' 的調用顯式
missorted.modifiers.require.option=檢查註解順序
missorted.modifiers.typeuse.before.type.option=目標 TYPE_USE 註解始終位於類型前
missorted.modifiers.sort.quickfix=對修飾符排序
nested.method.call.ignore.option=忽略欄位初始設定式中的嵌套方法調用
ignore.calls.to.static.methods=忽略對 static 方法的調用
ignore.calls.to.property.getters=忽略對屬性 getter 的調用
redundant.field.initialization.remove.quickfix=移除初始設定式
redundant.implements.remove.quickfix=移除冗餘接口宣告
unnecessary.constructor.remove.quickfix=移除冗餘構造函數
unnecessary.fully.qualified.name.replace.quickfix=將限定名稱取代為匯入
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} 個完全限定{0, choice, 1#名稱|2#名稱}取代為匯入 (按 Esc 移除高亮顯示)
unnecessary.parentheses.remove.quickfix=移除不必要的圓括號
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.semicolon.remove.quickfix=移除不必要的分號
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
overly.strong.type.cast.problem.descriptor=到 <code>#ref</code> 的轉換可以被削弱為 ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=在計數中包含常數欄位
field.count.inspection.static.final.fields.count.as.constant.checkbox=將 'static final' 欄位計為常數
field.count.inspection.include.enum.constants.in.count=在計數中包含枚舉常數
make.method.final.fix.name=將方法 ''{0}()'' 設為 ''final''
make.class.final.fix.name=將類 ''{0}'' 設為 ''final''
non.boolean.method.name.must.not.start.with.question.display.name=非布爾方法名稱不能以疑問詞開頭
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布爾方法名稱 <code>#ref</code> 以疑問詞開頭 #loc
boolean.constructor.simplify.quickfix=簡化
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code> #loc 可以簡化為 ''{0}''
only.report.qualified.static.usages.option=僅報告來自 static 上下文的限定靜態存取
unqualified,static.usage.only.report.static.usages.option=僅報告來自非 static 上下文的靜態存取
assignment.to.catch.block.parameter.problem.descriptor=賦值給 'catch' 塊參數 <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=賦值給方法參數 <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=使用後增量表達式 <code>#ref</code> 的值 #loc
value.of.post.decrement.problem.descriptor=使用後減量表達式 <code>#ref</code> 的值 #loc
value.of.pre.increment.problem.descriptor=使用前增量表達式 <code>#ref</code> 的值 #loc
value.of.pre.decrement.problem.descriptor=使用前減量表達式 <code>#ref</code> 的值 #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略條件運算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 運算符
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 構造函數的類型物件之間的 '=='
redundant.method.override.display.name=方法與其 super 方法相同
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>#ref()</code> 僅委託給 super 方法 #loc
redundant.method.override.problem.descriptor=方法 <code>#ref()</code> 與其 super 方法相同 #loc
redundant.method.override.quickfix=移除冗餘方法
redundant.method.override.option.check.library.methods=檢查覆寫庫方法的方法
refused.bequest.problem.descriptor=方法 <code>#ref()</code> 未調用 'super.#ref()' #loc
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
overly.complex.boolean.expression.ignore.option=忽略純合取和析取
pointless.indexof.comparison.display.name=無意義的 'indexOf()' 比較
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> 始終為 true #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> 始終為 false #loc
reuse.of.local.variable.problem.descriptor=局部變數 <code>#ref</code> 的重用 #loc
single.character.startswith.display.name=單個字符 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=單個字符 <code>#ref()</code> 可取代為 'charAt()' 表達式 #loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表達式可取代為 'contains()'
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表達式可取代為 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同數量參數的多個方法命名 <code>#ref</code> #loc
overloaded.vararg.method.problem.descriptor=多載 vararg 方法 <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=多載 vararg 構造函數 <code>#ref()</code> #loc
cached.number.constructor.call.display.name=數字構造函數調用具有基元實參
cached.number.constructor.call.problem.descriptor=數字構造函數調用具有基元實參 #loc
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字串實參的新數字表達式
cached.number.constructor.call.report.only.deprecated=僅在構造函數為 @Deprecated 時報告
chained.equality.comparisons.problem.descriptor=鏈式相等比較 <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=八進制轉義序列 <code>#ref</code> 後面緊跟數字 #loc
field.accessed.synchronized.and.unsynchronized.option=簡單的 getter 和 setter 也被視為欄位存取
method.overrides.inaccessible.method.display.name=方法覆寫了超類不可存取的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>#ref()</code> 覆寫了位於另一個軟體套件中的超類的 package-private 方法 #loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 調用
suspicious.to.array.call.problem.descriptor=應為類型 ''{0}[]'' 的陣列，找到的是 ''{1}[]'' #loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 調用
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor6=源參數類型 ''{0}'' 不可分配給類型為 ''{1}'' 的目標參數 <code>#ref</code> #loc
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=長度始終大於 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=長度始終大於 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=複製到具有相交範圍的同一陣列
method.only.used.from.inner.class.display.name=僅在內部類中使用 private 方法
method.only.used.from.inner.class.problem.descriptor=方法 <code>#ref()</code>#loc 只能從{0, choice, 1#內部|2#局部|3#}{1, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} ''{2}'' 使用 #loc
method.only.used.from.inner.class.ignore.option=忽略從匿名類或局部類調用的方法(&A)
only.report.static.methods=僅報告 'static' 方法(&O)
single.character.startswith.quickfix=取代為 'charAt()' 表達式
interface.never.implemented.option=忽略僅宣告常數的接口
size.replaceable.by.isempty.display.name='size() == 0' 可取代為 'isEmpty()'
size.replaceable.by.isempty.negation.ignore.option=忽略將取代為 '!isEmpty()' 的表達式
size.replaceable.by.isempty.fix.ignore.calls=忽略類型 ''{1}'' 上的 ''.{0}()'' 調用
choose.class.type.to.ignore=選擇要忽略的類
loop.condition.not.updated.inside.loop.display.name=迴圈變數未在迴圈內更新
loop.variable.not.updated.inside.loop.problem.descriptor=變數 '#ref' 未在迴圈內更新#loc
loop.condition.not.updated.inside.loop.problem.descriptor=條件 '#ref' 未在迴圈內更新#loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地變更
utility.class.without.private.constructor.option=忽略僅具有主方法的類
super.class.logger.option=在超類有可存取的記錄器時忽略
static.method.only.used.in.one.class.display.name=static 成員僅在其他一個類中使用
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在 ''{1}'' 類中使用 #loc
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在派生自 ''{1}'' 的匿名類中使用 #loc
static.method.only.used.in.one.class.quickfix=將 {0} 移至使用類
static.method.only.used.in.one.class.ignore.test.option=僅在測試類中使用時忽略
static.method.only.used.in.one.class.ignore.anonymous.option=僅在匿名類中使用時忽略
static.method.only.used.in.one.class.ignore.on.conflicts=當方法無法在不產生衝突的情況下移動時忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位於實用程序類中的成員
unary.plus.display.name=一元正號
unary.plus.problem.descriptor=一元 <code>#ref</code> 運算符 #loc
await.without.corresponding.signal.display.name=沒有相應 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在沒有相應 <code>signal()</code> 或 <code>signalAll()</code> 的情況下調用 <code>#ref()</code> #loc
signal.without.corresponding.await.display.name=沒有相應 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在沒有相應 <code>await()</code> 的情況下調用 <code>#ref()</code> #loc
wait.without.corresponding.notify.display.name=沒有相應 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在沒有相應 <code>notify()</code> 或 <code>notifyAll()</code> 的情況下調用 <code>#ref()</code> #loc
notify.without.corresponding.wait.display.name=沒有相應 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在沒有相應 <code>wait()</code> 的情況下調用 <code>#ref()</code> #loc
integer.multiplication.implicit.cast.to.long.display.name=整數乘法或移位隱式轉換為 long
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: 整數乘法隱式轉換為 long #loc
integer.multiplication.implicit.cast.to.long.quickfix=轉換為 long
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: 整數移位隱式轉換為 long #loc
integer.multiplication.implicit.cast.to.long.option=<html>忽略靜態證明不可能溢出的表達式</html>
wait.or.await.without.timeout.display.name=無超時的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=無超時的 <code>#ref</code> #loc
method.return.always.constant.display.name=方法返回類特定的常數
method.return.always.constant.problem.descriptor=方法 <code>#ref()</code> 及其所有派生方法始終返回常數
class.with.too.many.dependencies.display.name=依賴過多的類
class.with.too.many.dependencies.problem.descriptor=類 ''{0}'' 的依賴過多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可傳遞依賴項過多的類
class.with.too.many.transitive.dependencies.problem.descriptor=類 ''{0}'' 的可傳遞依賴項過多({1} > {2})
class.with.too.many.dependents.display.name=依賴項過多的類
class.with.too.many.dependents.problem.descriptor=類 ''{0}'' 的依賴項過多 ({1} > {2})
class.with.too.many.transitive.dependents.display.name=傳遞依賴項過多的類
class.with.too.many.transitive.dependents.problem.descriptor=類 ''{0}'' 的可傳遞依賴項過多({1} > {2})
class.with.too.many.dependencies.max.option=最大依賴項數
class.with.too.many.dependents.max.option=最大依賴項數
class.with.too.many.transitive.dependencies.max.option=最大可傳遞依賴項數
class.with.too.many.transitive.dependents.max.option=最大傳遞依賴項數
cyclic.class.dependency.display.name=迴圈類依賴
cyclic.class.dependency.problem.descriptor=類 ''{0}'' 迴圈依賴於其他 {1} 個類
cyclic.class.dependency.1.problem.descriptor=類 ''{0}'' 迴圈依賴於類 ''{1}''
cyclic.class.dependency.2.problem.descriptor=類 ''{0}'' 迴圈依賴於類 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=迴圈軟體套件依賴關係
cyclic.package.dependency.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於其他 {1} 個軟體套件
cyclic.package.dependency.1.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}''
cyclic.package.dependency.2.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}'' 和 ''{2}''
class.unconnected.to.package.display.name=獨立於其軟體套件的類
class.unconnected.to.package.problem.descriptor=類 <code>#ref</code> 在其軟體套件中沒有依賴或依賴項
exception.package.display.name=異常軟體套件
exception.package.problem.descriptor=軟體套件 ''{0}'' 僅包含異常類
package.with.too.many.classes.display.name=類過多的軟體套件
package.with.too.many.classes.problem.descriptor=軟體套件 ''{0}'' 包含過多的類 ({1} > {2})
package.with.too.many.classes.max.option=最大類數:
package.with.too.few.classes.display.name=軟體套件具有過少類
package.with.too.few.classes.problem.descriptor=軟體套件 ''{0}'' 包含過少的類 ({1} < {2})
package.with.too.few.classes.min.option=最小類數:
suspicious.package.private.access.display.name=可疑的 package-private 存取權限
groups.of.modules.loaded.together.label=一起載入的模組組:
groups.of.modules.loaded.together.description=每行指定以逗號分隔的模組名稱列表，已知這些模組名稱是由同一 ClassLoader 載入的，因此，不應報告對此類模組之間的 package-private 成員的存取。
module.with.too.many.classes.display.name=類過多的模組
module.with.too.many.classes.problem.descriptor=模組 ''{0}'' 包含過多的類 ({1} > {2})
module.with.too.many.classes.max.option=最大類數:
module.with.too.few.classes.display.name=類過少的模組
module.with.too.few.classes.problem.descriptor=模組 ''{0}'' 包含過少的類 ({1} < {2})
module.with.too.few.classes.min.option=最小類數:
package.in.multiple.modules.display.name=具有多個模組中的類的軟體套件
disjoint.package.display.name=具有不相交依賴關係圖的軟體套件
disjoint.package.problem.descriptor=軟體套件 {0} 可以分解為 {1} 個獨立軟體套件
package.naming.convention.display.name=軟體套件命名慣例
package.naming.convention.problem.descriptor.short=軟體套件名稱 <code>{0}</code> 過短
package.naming.convention.problem.descriptor.long=軟體套件名稱 <code>{0}</code> 過長
package.naming.convention.problem.descriptor.regex.mismatch=軟體套件名稱 <code>{0}</code> 與正則表達式 ''{1}'' 不符合
before.or.after.is.public.void.no.arg.display.name=@Before 或 @After 方法的格式錯誤
before.or.after.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> 的 @Before 或 @After 方法的簽名不正確 #loc
before.class.or.after.class.is.public.static.void.no.arg.display.name=@BeforeClass/@BeforeAll 或 @AfterClass/@AfterAll 方法的格式錯誤
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor=<code>#ref()</code> 的 @{0} 方法的簽名不正確 #loc
design.for.extension.display.name=為擴展設計
design.for.extension.problem.descriptor=方法 <code>#ref()</code> 可能被覆寫，其功能會被忽略 #loc
bad.oddness.display.name=可疑的奇數檢查
bad.oddness.problem.descriptor=對負值進行奇數檢查將會失敗 #loc
comparator.not.serializable.display.name=比較器類未被宣告為可序列化
comparator.not.serializable.problem.descriptor=比較器類 <code>#ref</code> 未被宣告為可序列化 #loc
non.serializable.field.in.serializable.class.display.name=可序列化類中的不可序列化欄位
non.serializable.field.in.serializable.class.problem.descriptor=可序列化類中不可序列化的欄位 '#ref' #loc
non.serializable.object.passed.to.object.stream.display.name=傳遞給 ObjectOutputStream 的不可序列化物件
non.serializable.object.passed.to.object.stream.problem.descriptor=傳遞給 ObjectOutputStream 的不可序列化物件 #loc
non.serializable.object.bound.to.http.session.display.name=傳遞給 HttpSession 的不可序列化物件
non.serializable.object.bound.to.http.session.problem.descriptor=傳遞給 HttpSession 的不可序列化物件 #loc
reflection.for.unavailable.annotation.display.name=對僅源註解的反射存取
reflection.for.unavailable.annotation.problem.descriptor=註解 '#ref' 不保留用於反射存取 #loc
access.to.static.field.locked.on.instance.display.name=存取實例資料上鎖定的 static 欄位
access.to.static.field.locked.on.instance.problem.descriptor=存取實例資料上鎖定的 static 欄位 <code>#ref</code> #loc
access.to.static.field.locked.on.instance.fix.name=忽略類型 ''{0}'' 的 static 欄位
make.method.ctr.quickfix=使方法成為構造函數
replace.all.dot.display.name=可疑的正則表達式實參
replace.all.dot.problem.descriptor=''{0}()'' 調用中存在可疑的正則表達式 #ref #loc
replace.all.dot.quickfix=轉義正則表達式元字符
class.extends.utility.class.display.name=類擴展實用程序類
class.extends.utility.class.problem.descriptor=類 <code>#ref</code> 擴展實用程序類 ''{0}'' #loc
class.extends.utility.class.ignore.utility.class.option=如果覆寫類為實用程序類，則忽略
public.constructor.in.non.public.class.quickfix=將構造函數設為 private
assignment.to.method.parameter.ignore.transformation.option=<html>如果賦值是原始參數的轉換，則忽略</html>
type.parameter.extends.final.class.display.name=類型參數擴展 final 類
type.parameter.extends.final.class.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 擴展 ''final'' 類{0} #loc
type.parameter.extends.enum.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱式擴展 final 枚舉 ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 擴展了 ''final'' 類 ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 隱式擴展了 final 枚舉 ''{0}'' #loc
type.parameter.extends.final.class.quickfix=將類型參數取代為實際類
double.negation.display.name=雙重否定
double.negation.problem.descriptor=<code>#ref</code> 中的雙重否定 #loc
double.negation.quickfix=移除雙重否定
exception.from.catch.which.doesntwrap.ignore.option=如果使用異常方法調用的結果，則忽略
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果拋出的異常無法包裝異常，則忽略
comparable.implemented.but.equals.not.overridden.display.name=已實作可比較物件，但 'equals()' 未被覆寫
comparable.implemented.but.equals.not.overridden.problem.descriptor=類 <code>#ref</code> 實作 'java.lang.Comparable'，但未覆寫 'equals()' #loc
comparable.implemented.but.equals.not.overridden.fix.add.note.name=添加 'ordering inconsistent with equals' JavaDoc 記錄
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
unqualified.field.access.display.name=未使用 'this' 限定的實例欄位存取
unqualified.field.access.problem.descriptor=未使用 'this' 限定的實例欄位存取 <code>#ref</code> #loc
unqualified.method.access.display.name=未使用 'this' 限定的實例方法調用
unqualified.method.access.problem.descriptor=未使用 'this' 限定實例方法調用 <code>#ref()</code> #loc
add.this.qualifier.quickfix=添加 'this' 限定符
while.loop.spins.on.field.ignore.non.empty.loops.option=僅當迴圈為空時才發出警告
method.may.be.synchronized.problem.descriptor=帶 synchronized 塊的方法 <code>#ref()</code> 可以是 synchronized 方法 #loc
method.may.be.synchronized.display.name=只有一個同步塊的方法可取代為同步方法
method.may.be.synchronized.quickfix=將方法設為 synchronized 並移除 synchronized 塊
fallthru.in.switch.statement.quickfix=添加 ''{0}''
law.of.demeter.display.name=方法調用違反迪米特法則
law.of.demeter.problem.descriptor=<code>#ref()</code> 調用違反迪米特法則 #loc
law.of.demeter.ignore.library.calls.option=忽略庫方法上的調用
assertequals.between.inconvertible.types.display.name='assertEquals()' 位於不可轉換類型的物件之間
assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
assertnotsame.between.inconvertible.types.problem.descriptor=冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
masked.assertion.display.name=斷言通過 'catch' 屏蔽
masked.assertion.problem.description=''{0}'' 不能失敗，因為它通過 ''catch'' 屏蔽
enumeration.can.be.iteration.display.name=枚舉可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> 可取代為 ''{0}'' 結構 #loc
enumeration.can.be.iteration.quickfix=取代為 'Iterator' 結構
equals.hashcode.called.on.url.display.name=在 'java.net.URL' 物件上調用了 'equals()' 或 'hashCode()'
equals.hashcode.called.on.url.problem.descriptor=在 URL 物件上調用 <code>#ref()</code> #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code> 可能包含 URL 物件 #loc
collection.contains.url.display.name='Map' 或 'Set' 可能包含 'URL' 物件
implicit.array.to.string.problem.descriptor=隱式調用陣列 <code>#ref</code> 上的 'toString()' #loc
explicit.array.to.string.problem.descriptor=調用陣列上的 '#ref()' #loc
implicit.array.to.string.method.call.problem.descriptor=隱式調用調用 <code>#ref</code> 返回的陣列上的 'toString()' #loc
implicit.array.to.string.display.name=調用陣列上的 'toString()'
implicit.array.to.string.quickfix=使用 ''{0}'' 表達式包裝
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 語句後存在可疑縮排 #loc
suspicious.indent.after.control.statement.display.name=沒有大括號的控制語句後存在可疑縮排
unpredictable.big.decimal.constructor.call.display.name=不可預知的 BigDecimal 構造函數調用
unpredictable.big.decimal.constructor.call.problem.descriptor=不可預知的 <code>new #ref()</code> 調用 #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有變量或方法調用實參的構造函數調用
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多個文字的構造函數調用 (例如 0.1 + 0.2)
unnecessary.unary.minus.display.name=不必要的一元負號
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>#ref</code> 運算符 #loc
unnecessary.unary.minus.quickfix=移除一元負號並反轉父運算符號
unnecessary.unary.minus.remove.quickfix=移除雙一元減號
make.field.final.quickfix=將 ''{0}'' 設為 ''final''
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分離語句
ignore.classes.in.hierarchy.column.name=忽略以下物件的子類:
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有符合 instanceof 表達式的轉換
access.to.non.thread.safe.static.field.from.instance.display.name=非執行緒安全的 static 欄位存取
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=存取類型為 ''{0}'' 的非執行緒安全 static 欄位 <code>#ref</code> #loc
access.to.non.thread.safe.static.field.from.instance.option.title=非執行緒安全類:
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=選擇非執行緒安全類
transient.field.not.initialized.display.name=transient 欄位在反序列化時未初始化
transient.field.not.initialized.problem.descriptor=transient 欄位 <code>#ref</code> 在反序列化時未初始化 #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=對 'String.concat()' 的調用可取代為 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=對 <code>#ref()</code> 的調用可取代為 '+' 表達式 #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 取代 'concat()'
new.string.buffer.with.char.argument.display.name=StringBuilder 構造函數調用具有 'char' 實參
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> 具有 'char' 類型的實參 #loc
new.string.buffer.with.char.argument.quickfix=將字符實參取代為字串文字
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 實作
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 'compare()' 參數 <code>#ref</code> #loc
suspicious.comparator.compare.descriptor.non.reflexive=對於相等的元素，比較器不返回 0
to.array.call.style.display.name='Collection.toArray()' 調用樣式
to.array.call.style.problem.descriptor.zero=<code>#ref()</code> 調用具有空陣列實參 ''{0}'' #loc
to.array.call.style.problem.descriptor.presized=<code>#ref()</code> 調用具有預設大小的陣列實參 ''{0}'' #loc
to.array.call.style.quickfix.family.name=修復傳遞到 'toArray()' 調用的陣列的大小
to.array.call.style.quickfix.make.presized=將實參取代為預設大小的陣列
to.array.call.style.quickfix.make.zero=將實參取代為空陣列
throwable.instance.never.thrown.runtime.exception.problem.descriptor=執行時異常實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已檢查的異常實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.error.problem.descriptor=錯誤實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.problem.descriptor=Throwable 實例 <code>#ref</code> 未拋出 #loc
ignore.guard.clauses.option=忽略臨界子句(&G)
ignore.for.equals.methods.option=對 'equals()' 方法忽略(&E)
caught.exception.immediately.rethrown.display.name=捕獲的異常被立即重新拋出
caught.exception.immediately.rethrown.problem.descriptor=捕獲的異常 <code>#ref</code> 被立即重新拋出 #loc
delete.catch.section.quickfix=刪除 'catch' 部分
loop.with.implicit.termination.condition.display.name=具有隱式終止條件的迴圈
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隱式終止條件的 <code>#ref-while</code> 迴圈 #loc
loop.with.implicit.termination.condition.problem.descriptor=具有隱式終止條件的 <code>#ref</code> 迴圈 #loc
loop.with.implicit.termination.condition.quickfix=使條件顯式
rename.catch.parameter.to.ignored=將 ''catch'' 參數重命名為 ''{0}''
inspection.empty.catch.block.generate.body=從模板生成 'catch' 正文
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
collections.field.access.replaceable.by.method.call.display.name=對空集合欄位的引用可取代為方法調用
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> 可取代為 ''Collections.{0}'' #loc
synchronization.on.local.variable.or.method.parameter.display.name=在局部變數或方法參數上同步
synchronization.on.local.variable.problem.descriptor=在局部變數 <code>#ref</code> 上同步 #loc
synchronization.on.method.parameter.problem.descriptor=在方法參數 <code>#ref</code> 上同步 #loc
too.broad.catch.quickfix=向 ''{0}'' 添加 ''catch'' 子句
replace.with.catch.clause.for.runtime.exception.quickfix=針對 'RuntimeException' 取代為 'catch' 子句
too.broad.catch.option=僅對 RuntimeException、異常、錯誤或 Throwable 發出警告(&O)
unnecessary.conversion.to.string.display.name=轉換為字串不必要
unnecessary.tostring.call.display.name=對 'toString()' 的調用不必要
unnecessary.tostring.call.problem.descriptor=不必要的 <code>#ref()</code> 調用 #loc
throwable.not.thrown.display.name=Throwable 未拋出
throwable.result.of.method.call.ignored.problem.descriptor=<code>#ref()</code> 的結果未拋出 #loc
char.used.in.arithmetic.context.display.name=在算術上下文中使用 'char' 表達式
char.used.in.arithmetic.context.problem.descriptor=算術上下文中使用了 'char' #loc
char.used.in.arithmetic.context.quickfix=轉換為字串文字
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的轉換
unnecessary.constant.array.creation.expression.display.name=常數陣列創建中的冗餘 'new' 表達式
unnecessary.constant.array.creation.expression.problem.descriptor=可從新陣列表達式中移除 <code>#ref</code> #loc
unnecessary.constant.array.creation.expression.family.quickfix=從新陣列表達式中移除類型規範
ambiguous.method.call.display.name=對繼承方法的調用類似於對本地方法的調用
ambiguous.method.call.problem.descriptor=對來自超類 ''{0}'' 的方法 <code>#ref()</code> 的調用類似於對來自類 ''{1}'' 的方法的調用 #loc
ambiguous.method.call.quickfix=向方法調用中添加 'super' 限定符
change.modifier.quickfix=設為 ''{0}''
the.whole.project=整個專案
this.class=此類
assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> 可能是 'assertSame()' #loc
logger.initialized.with.foreign.class.problem.descriptor=使用外類 <code>#ref</code> 初始化記錄器 #loc
logger.initialized.with.foreign.class.display.name=使用外類初始化記錄器
logger.factory.method.name=記錄器工廠方法名稱
logger.factory.class.name=記錄器工廠類名
make.static.final.quickfix=將 ''{0}'' 設為 static final
logging.condition.disagrees.with.log.statement.display.name=日誌條件與日誌記錄調用不符合
logging.condition.disagrees.with.log.statement.problem.descriptor=日誌條件 <code>#ref()</code> 與 ''{0}()'' 日誌調用不符合 #loc
log.statement.guarded.by.log.condition.display.name=日誌調用不受日誌條件保護
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> 日誌調用不受日誌條件保護 #loc
log.statement.guarded.by.log.condition.quickfix=用日誌條件環繞
log.statement.guarded.by.log.condition.flag.all.unguarded.option=標記所有不受保護的日誌調用
key.set.iteration.may.use.entry.set.display.name=可以最佳化對 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>#ref</code> 上的迭代可取代為 ''{0}'' 迭代 #loc
key.set.iteration.may.use.entry.set.quickfix=最佳化 Map 迭代
string.replaceable.by.string.buffer.in.loop.option=僅在迴圈中追加時發出警告
declare.collection.as.interface.quickfix=削弱為 ''{0}''
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 擴展 ''java.lang.Exception''
constant.value.variable.use.display.name=使用已知值為常數的變數
constant.value.variable.use.problem.descriptor=<code>#ref</code> 的值已知為常數 #loc
unnecessary.parentheses.option=忽略澄清圓括號
unnecessary.parentheses.conditional.option=忽略條件表達式條件周圍的圓括號
field.may.be.final.display.name=欄位可能為 'final'
field.may.be.final.problem.descriptor=欄位 <code>#ref</code> 可能為 'final' #loc
cast.that.loses.precision.option=忽略從 int 到 char 的轉換
ignore.overflowing.byte.casts.option=忽略從 int 128-255 到字節的轉換
variable.not.used.inside.if.display.name='if' 內未使用檢查為 'null' 的引用
variable.not.used.inside.if.problem.descriptor='if' 內未使用檢查為 'null' 的 <code>#ref</code> #loc
variable.not.used.inside.conditional.problem.descriptor=條件內未使用檢查為 'null' 的 <code>#ref</code> #loc
boolean.expression.may.be.conditional.display.name=布爾表達式可取代為條件表達式
if.may.be.conditional.problem.descriptor=<code>#ref</code> 可取代為條件表達式 #loc
if.may.be.conditional.quickfix=取代為條件表達式
redundant.string.format.call.display.name=冗餘調用 'String.format()'
redundant.call.problem.descriptor=冗餘調用 <code>#ref()</code> #loc
redundant.string.format.call.quickfix=移除對 'String.format()' 的冗餘調用
redundant.string.formatted.call.quickfix=移除對 'String.formatted()' 的冗餘調用
junit4.test.method.in.class.extending.junit3.testcase.display.name=擴展 JUnit 3 TestCase 中的 JUnit 4 測試方法
convert.junit3.test.case.error.string=<code>#ref</code> 可以轉換為 JUnit4 測試用例
convert.junit3.test.case.family.name=轉換為 JUnit 4 測試用例
convert.junit3.test.case.display.name=JUnit 3 測試可以是 JUnit 4
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=方法 <code>#ref()</code> 在擴展 JUnit 3 TestCase 的類內使用 '@Test' 註解 #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor=使用 '@Ignore' 註解的 JUnit 3 測試方法 <code>#ref()</code> 不會被忽略 #loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=移除 ''@Ignore'' 並將方法重命名為 ''{0}''
convert.junit3.test.class.quickfix=將 JUnit 3 類 ''{0}'' 轉換為 JUnit 4
remove.junit4.test.annotation.quickfix=移除 '@Test' 註解
remove.junit4.test.annotation.and.rename.quickfix=移除 ''@Test'' 註解並重命名為 ''{0}''
equals.called.on.enum.constant.display.name=對枚舉值調用了 'equals()'
equals.called.on.enum.constant.problem.descriptor=對枚舉值調用了 <code>#ref()</code> #loc
int.literal.may.be.long.literal.display.name=轉換為 'long' 可以是 'long' 文字
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> 可取代為 ''{0}'' #loc
constant.assert.condition.display.name='assert' 語句中的常數條件
constant.assert.condition.problem.descriptor=斷言條件 <code>#ref</code> 是常數 #loc
assert.with.side.effects.display.name=具有副作用的 'assert' 語句
assert.with.side.effects.problem.descriptor=<code>#ref</code> 具有副作用: {0} #loc
method.count.ignore.getters.setters.option=忽略簡單的 getter 和 setter 方法(&I)
class.new.instance.display.name=對 'Class.newInstance()' 的調用不安全
class.new.instance.problem.descriptor=對 <code>#ref()</code> 的調用可能會拋出未宣告的已檢查的異常 #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=動態正則表達式可取代為已編譯的模式
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> 可取代為已編譯的 'java.util.regex.Pattern' 結構 #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=取代為對已編譯 'Pattern' 常數的方法的調用
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.cloneable.option=忽略 'java.lang.Cloneable'
listener.may.use.adapter.display.name=類可以會擴展適配器而不是實作偵聽器
listener.may.use.adapter.problem.descriptor=類 ''{0}'' 可以擴展 ''{1}'' 而不是實作 <code>#ref</code> #loc
listener.may.use.adapter.emtpy.methods.option=僅在找到空實作方法時發出警告(&O)
unnecessary.inherit.doc.display.name=不必要的 {@inheritDoc} Javadoc 註釋
unnecessary.inherit.doc.problem.descriptor=僅包含 <code>#ref</code> 的 Javadoc 註釋不必要 #loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> 在欄位上無效 #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> 在構造函數上無效 #loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> 在類上無效 #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> 在模組宣告上無效 #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到繼承 Javadoc 的 super 方法 #loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
multiple.exceptions.declared.on.test.method.display.name=在測試方法上宣告的多個異常
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> 可取代為 'throws Exception' #loc
unnecessary.javadoc.link.display.name=不必要的 Javadoc 鏈接
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含類的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
thread.local.not.static.final.display.name=ThreadLocal 欄位未被宣告為 static final
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> 未被宣告為 'static final' #loc
remove.try.finally.block.quickfix=移除 'try-finally' 塊
remove.finally.block.quickfix=移除 'finally' 塊
remove.leading.zero.to.make.decimal.quickfix=移除前導零以變為十進制
remove.leading.zeroes.to.make.decimals.quickfix=移除前導零以變為十進制
convert.octal.literal.to.decimal.literal.quickfix=將八進制文字轉換為十進制文字
convert.octal.literals.to.decimal.literals.quickfix=將八進制文字轉換為十進制文字
ignore.single.field.static.imports.option=忽略單欄位靜態匯入(&F)
ignore.single.method.static.imports.option=忽略單方法靜態匯入(&M)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回類型的方法(&B)
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布爾方法
ignore.methods.overriding.super.method=忽略覆寫/實作 super 方法的方法(O&)
ignored.io.resource.types=已忽略的 I/O 資源類型
ignored.io.resource.types.label=已忽略的 I/O 資源類型:
choose.io.resource.type.to.ignore=選擇要忽略的 I/O 資源類型
ignore.accesses.from.the.same.class=忽略來自同一類的存取
ignore.accesses.from.equals.method=忽略來自 'equals()' 方法的存取
ignore.branches.of.switch.statements=忽略 'switch' 語句的分支
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.methods.in.anonymous.classes=忽略匿名類中的方法
class.name=類名
method.name.regex=方法名稱正則表達式
column.assertion.class.name=斷言類名
choose.class=選擇類
query.column.name=查詢名稱開頭
query.label=查詢名稱開頭:
update.column.name=更新名稱開頭
update.label=更新名稱開頭:
assert.keyword.is.considered.an.assertion='assert' 關鍵字被視為斷言
expected.exception.never.thrown.display.name=從未在測試方法正文中拋出預期異常
expected.exception.never.thrown.problem.descriptor=從未在 ''{0}()'' 的正文中拋出預期 <code>#ref</code> #loc
choose.logger.class=選擇記錄器類
logger.class.name=記錄器類名:
ignore.exceptions.declared.on.library.override.option=忽略在覆寫庫方法的方法上宣告的異常(&L)
allow.resource.to.be.opened.inside.a.try.block=允許在 'try' 塊內開啟資源
any.method.may.close.resource.argument=任何方法都可能關閉作為實參傳遞的資源
ignore.constructor.method.references=忽略產生 AutoCloseable 的構造函數方法引用
ignore.getters.returning.resource=忽略返回源的 getter
log.method.name=記錄方法名稱
log.condition.text=日誌條件文本
ignore.if.annotated.by=有註解時忽略:
ignore.parameter.if.annotated.by=有註解時忽略參數:
ignore.classes.annotated.by=由以下物件註解時忽略類:
ignored.class.hierarchies.border.title=忽略以下物件的子類:
choose.class.hierarchy.to.ignore.title=選擇要忽略的類層次結構
unqualified.inner.class.access.display.name=非限定內部類存取
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> 未使用外部類限定 #loc
unqualified.inner.class.access.quickfix=使用外部類限定
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>#ref</code> 限定 ''{0}'' 不必要 #loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定內部類存取
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
synchronization.on.static.field.display.name=在 'static' 欄位上同步
synchronization.on.static.field.problem.descriptor=在 'static' 欄位 <code>#ref</code> 上同步 #loc
assertequals.called.on.arrays.display.name=在陣列上調用了 'assertEquals()'
assertequals.called.on.arrays.problem.descriptor=在陣列上調用了 <code>#ref()</code> #loc
overly.broad.throws.clause.display.name=過寬的 'throws' 子句
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
overly.broad.throws.clause.quickfix1=添加特定異常
overly.broad.throws.clause.quickfix2=取代為特定異常
overly.broad.throws.clause.ignore.thrown.option=忽略隱藏其他異常但自身被拋出的異常(&H)
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定靜態匯入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=靜態匯入元素 ''{0}'' 使用 <code>#ref</code> 不必要限定 #loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
ignore.instanceof.on.library.classes=忽略庫類上的 instanceof
for.can.be.foreach.option=報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option2=不報告無類型集合上的迭代
cast.conflicts.with.instanceof.quickfix1=在轉換中將 ''{0}'' 取代為 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中將 ''{0}'' 取代為 ''{1}''
double.checked.locking.quickfix=將 ''{0}'' 設為 volatile
double.literal.may.be.float.literal.display.name=轉換為 'float' 可以是 'float' 文字
multiple.declaration.ignore.for.option=忽略 'for' 迴圈宣告
multiple.declaration.array.only.option=僅在單個宣告中對不同的陣列維度發出警告
simplifiable.annotation.display.name=可簡化註解
simplifiable.annotation.problem.descriptor=註解中有不必要的 <code>#ref</code> #loc
simplifiable.annotation.whitespace.problem.descriptor=註解中有不必要的空格 #loc
simplifiable.annotation.quickfix=簡化註解
overloaded.methods.with.same.number.parameters.option=<html>忽略參數類型絕對不相容的多載方法</html>
string.concatenation.in.format.call.display.name=字串串聯作為 'format()' 調用的實參
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 調用包含字串串聯實參
string.concatenation.in.format.call.quickfix=將串聯取代為單獨的實參
string.concatenation.in.message.format.call.display.name=字串串聯作為 'MessageFormat.format()' 調用的實參
string.concatenation.in.message.format.call.problem.descriptor=字串串聯作為 'MessageFormat.format()' 調用的實參 #loc
boxing.boxed.value.display.name=裝箱已裝箱的值
boxing.boxed.value.problem.descriptor=裝箱已裝箱的 <code>#ref</code> #loc
boxing.boxed.value.quickfix=移除不必要的裝箱
unnecessary.javadoc.link.option=忽略 super 方法的內聯鏈接
constant.junit.assert.argument.display.name=常數斷言實參
constant.junit.assert.argument.problem.descriptor=實參 <code>#ref</code> 是常數 #loc
test.case.with.no.test.methods.option=忽略具有帶測試方法的超類的測試用例
package.dot.html.may.be.package.info.display.name='package.html' 可以轉換為 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因為 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以轉換為 <code>package-info.java</code>
package.dot.html.may.be.package.info.delete.quickfix=刪除 'package.html'
package.dot.html.may.be.package.info.convert.quickfix=轉換為 'package-info.java'
ignore.anonymous.inner.classes=忽略匿名內部類
try.with.identical.catches.display.name='try' 語句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支與 ''{0}'' 分支相同 #loc
if.can.be.switch.display.name='if' 可取代為 'switch'
if.can.be.switch.problem.descriptor=<code>#ref</code> 語句可取代為 'switch' 語句 #loc
if.can.be.switch.minimum.branch.option='if' 條件分支的最小數量:
if.can.be.switch.int.option=對數字啟用 switch 建議
if.can.be.switch.enum.option=對枚舉啟用 switch 建議
if.can.be.switch.null.safe.option=僅對 null-safe 表達式啟用建議
unnecessarily.qualified.inner.class.access.option=忽略需要匯入的引用
unqualified.inner.class.access.option=忽略對本地內部類的引用
try.with.identical.catches.quickfix=摺疊 'catch' 塊
confusing.else.option=當 'if' 語句之後沒有其他語句時報告
html.tag.can.be.javadoc.tag.display.name=<code>...</code> 可取代為 {@code ...}
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\&lt;/code\\&gt;</code> 可取代為 '{@code ...}' #loc
try.finally.can.be.try.with.resources.display.name='try finally' 可取代為 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> 可以使用自動資源管理 #loc
try.finally.can.be.try.with.resources.quickfix=取代為 'try-with-resources'
array.comparison.display.name=使用 '==' 而不是 'Arrays.equals()' 進行陣列比較
array.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'Arrays.equals()' 來比較陣列物件 #loc
array.hash.code.display.name=在陣列上調用了 'hashCode()'
array.hash.code.problem.descriptor=陣列上調用的 <code>#ref()</code> 可能應當是 'Arrays.hashCode()' #loc
objects.hash.problem.descriptor=傳遞給 'Objects.hash()' 的陣列應包裝在 'Arrays.hashcode()' 中
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包裝
method.can.be.variable.arity.method.display.name=方法可以是 vararg 方法
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> 可以轉換為 vararg 方法 #loc
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具類型為 byte[] 或 short[] 的參數
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始陣列類型
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多個陣列參數的方法
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多維陣列參數
convert.to.variable.arity.method.quickfix=轉換為 vararg 方法
mismatched.string.builder.query.update.display.name='StringBuilder' 的查詢和更新不符合
mismatched.string.builder.updated.problem.descriptor=<code>{0} #ref</code> 的內容已更新，但從未被查詢 #loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} #ref</code> 的內容已查詢，但從未更新 #loc
math.random.cast.to.int.display.name='Math.random()' 轉換為 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> 轉換為 ''{0}'' 時始終向下舍入為 ''0'' #loc
math.random.cast.to.int.quickfix=添加括號以在轉換前執行乘法
boolean.variable.always.inverted.display.name=布爾變數始終反轉
boolean.field.always.inverted.problem.descriptor=布爾欄位 <code>#ref</code> 始終反轉 #loc
boolean.variable.always.inverted.problem.descriptor=布爾變數 <code>#ref</code> 始終反轉 #loc
unnecessary.explicit.numeric.cast.display.name=不必要的顯式數字轉換
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要轉換為 <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=移除轉換
null.thrown.display.name=已拋出 'null'
null.thrown.problem.descriptor=已引發 <code>#ref</code> #loc
unnecessary.final.on.local.variable.or.parameter.display.name=局部變數或參數上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=變數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.on.parameter.problem.descriptor=參數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.report.local.variables.option=報告局部變數
unnecessary.final.report.parameters.option=報告參數
unnecessary.final.on.parameter.only.interface.option=僅對 abstract 或接口方法發出警告
choose.exception.class=選擇異常類
choose.exception.label=被禁止的異常:
class.independent.of.module.display.name=獨立於其模組的類
class.independent.of.module.problem.descriptor=類 <code>#ref</code> 在其模組中沒有依賴或依賴項 #loc
class.only.used.in.one.module.display.name=僅在其他模組中使用的類
class.only.used.in.one.module.problem.descriptor=類 <code>#ref</code> 在其模組 ''{0}'' 中只有依賴和/或依賴性 #loc
empty.directory.display.name=空目錄
empty.directories.problem.descriptor=空目錄 <code>{0}</code>
empty.directories.only.under.source.roots.option=僅報告位於源資料夾下的空目錄
empty.directories.delete.quickfix=刪除空目錄 ''{0}''
simplifiable.equals.expression.option.non.constant=報告具有非常數非空實參的等於
simplifiable.equals.expression.display.name='equals()' 調用之前的 'null' 檢查不必要
simplifiable.equals.expression.problem.descriptor=''{0}()'' 調用之前的 ''null'' 檢查不必要 #loc
simplifiable.equals.expression.quickfix=翻轉 ''.{0}()'' 並移除不必要的 ''null'' 檢查
use.of.concrete.class.option.ignore.abstract=忽略抽象類類型
use.of.concrete.class.option.report.method.returns=報告方法返回類型
use.of.concrete.class.option.report.local.variable=報告局部變數類型
use.of.concrete.class.option.report.parameter=報告方法參數類型
use.of.concrete.class.option.report.static.fields=報告 static 欄位類型
use.of.concrete.class.option.report.instance.fields=報告實例欄位類型
use.of.concrete.class.option.report.instanceof=報告 instanceof、patterns 或 getClass() 比較中使用的類型
use.of.concrete.class.option.report.cast=報告轉換表達式中使用的類型
class.only.used.in.one.package.display.name=僅在其他軟體套件中使用的類
class.only.used.in.one.package.problem.descriptor=類 <code>#ref</code> 在其軟體套件 ''{0}'' 中只有依賴和/或依賴項 #loc
unnecessary.return.option=在具有 'else' 分支的 'if' 語句的 then 分支中忽略
usage.of.obsolete.assert.display.name=使用廢棄的 'junit.framework.Assert' 方法
use.of.obsolete.assert.problem.descriptor=對來自 ''{0}'' 的 <code>#ref()</code> 的調用應取代為對來自 ''org.junit.Assert'' 的方法的調用 #loc
use.of.obsolete.assert.quickfix=取代為 'org.junit.Assert' 方法調用
ignored.junit.test.display.name=使用 '@Ignore'/'@Disabled' 註解的 JUnit 測試
ignored.junit.test.classproblem.descriptor=使用 <code>#ref</code> 註解的測試類 ''{0}'' #loc
ignored.junit.test.method.problem.descriptor=使用 <code>#ref</code> 註解的測試方法 ''{0}()'' #loc
ignored.junit.test.ignore.reason.option=只報告沒有原因的註解
unclear.binary.expression.display.name=具有不同優先級的多個運算符
unclear.binary.expression.problem.descriptor=表達式可以使用澄清括號 #loc
unclear.binary.expression.quickfix=添加澄清括號
new.exception.without.arguments.display.name=未使用實參調用異常構造函數
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> 沒有實參 #loc
absolute.alignment.in.user.interface.display.name=AWT/Swing 程式碼中的絕對對齊
absolute.alignment.in.user.interface.problem.descriptor=使用了絕對對齊常數 <code>{0}.#ref</code> #loc
throws.runtime.exception.display.name=在 'throws' 子句中宣告的未檢查的異常
throws.runtime.exception.problem.descriptor=在 'throws' 子句中宣告的未檢查的異常 <code>#ref</code> #loc
throws.runtime.exception.quickfix=從 ''throws'' 子句中移除 ''{0}''
throws.runtime.exception.move.quickfix=將 ''{0}'' 移動到 Javadoc ''@throws'' 標記中
empty.class.ignore.parameterization.option=如果類是父類型的參數化，則將其忽略
ambiguous.field.access.display.name=對繼承欄位的存取類似於對周圍程式碼中元素的存取
ambiguous.field.access.hides.local.variable.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取局部變數 #loc
ambiguous.field.access.hides.parameter.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取參數 #loc
ambiguous.field.access.hides.field.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取周圍類中的欄位 #loc
ambiguous.field.access.quickfix=將 'super' 限定符添加到欄位存取
add.0.to.ignore.if.annotated.by.list.quickfix=將 ''{0}'' 添加到“有註解時忽略”列表中
non.final.field.in.enum.display.name='enum' 中的非 final 欄位
non.final.field.in.enum.problem.descriptor=枚舉 ''{0}'' 中存在非 final 欄位 <code>#ref</code> #loc
externalizable.without.public.no.arg.constructor.display.name=可外部化類沒有 'public' 無實參構造函數
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化類 <code>#ref</code> 沒有 'public' 無實參構造函數 #loc
make.constructor.public=將構造函數設為 'public'
string.concatenation.missing.whitespace.display.name=字串串聯中可能缺少空格
string.concatenation.missing.whitespace.problem.descriptor=字串串聯中可能缺少空格 #loc
string.concatenation.missing.whitespace.option=忽略具有變量字串的串聯
negated.equality.expression.display.name=否定相等表達式
negated.equality.expression.problem.descriptor=否定 ''{0}'' #loc
negated.equality.expression.quickfix=移除否定
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.problem.descriptor=否定條件表達式 #loc
negated.conditional.expression.quickfix=移除否定
suspicious.array.cast.display.name=可疑的陣列轉換
suspicious.array.cast.problem.descriptor=可疑轉換為 <code>#ref</code> #loc
public.constructor.display.name='public' 構造函數可取代為工廠方法
public.default.constructor.problem.descriptor=類 <code>#ref</code> 具有 'public' 預設構造函數
public.constructor.problem.descriptor=public 構造函數 <code>#ref()</code> #loc
public.constructor.quickfix=將構造函數取代為工廠方法
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 類中的舊樣式 JUnit 測試方法
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 類中的舊樣式 JUnit 測試方法 <code>#ref()</code> #loc
none=無
private=private
package.local.private=package-private 與 private
protected.package.local.private=protected、package-private 和 private
non.final.utility.class.display.name=實用程序類不為 'final'
non.final.utility.class.problem.descriptor=實用程序類 <code>#ref</code> 不為 'final' #loc
0.will.no.longer.be.overridable.by.1={0} 將不再可被 {1} 覆寫
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 調用的實參過少
arrays.as.list.with.one.argument.problem.descriptor=僅使用一個實參調用 <code>#ref()</code> #loc
arrays.as.list.with.zero.arguments.problem.descriptor=調用 <code>#ref()</code> 以創建空列表 #loc
string.concatenation.argument.to.log.call.display.name=非常數字串串聯作為日誌調用的實參
string.concatenation.argument.to.log.call.problem.descriptor=非常數字串串聯作為 <code>#ref()</code> 日誌調用的實參 #loc
string.concatenation.argument.to.log.call.quickfix=將串聯取代為參數化的日誌訊息
placeholder.count.matches.argument.count.display.name=佔位符數量與日誌調用中的實參數量不符合
placeholder.count.matches.argument.count.more.problem.descriptor=提供的實參數量({0})多於指定的佔位符({1}) #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的實參數量({0})少於指定的佔位符數({1}) #loc
assignment.to.superclass.field.display.name=構造函數將值賦給在超類中定義的欄位
assignment.to.superclass.field.problem.descriptor=賦值給在超類 ''{1}'' 中定義的欄位 ''{0}'' #loc
junit.datapoint.display.name=@DataPoint 欄位的格式錯誤
junit.datapoint.problem.descriptor=使用 @DataPoint 註解的 {1} 應當為 {0}
inner.class.referenced.via.subclass.display.name=通過子類引用的內部類
inner.class.referenced.via.subclass.problem.descriptor=內部類 <code>#ref</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
inner.class.referenced.via.subclass.quickfix=使內部類存取合理化
boolean.parameter.display.name='public' 方法具有 'boolean' 參數
boolean.parameter.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameter.constructor.problem.descriptor='public' 構造函數 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.constructor.problem.descriptor='public' 構造函數 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameter.only.report.multiple.option=僅報告具有多個布爾參數的方法
unnecessary.unicode.escape.display.name=不必要的 Unicode 轉義序列
unnecessary.unicode.escape.problem.descriptor=Unicode 轉義序列 <code>#ref</code> 可取代為 ''{0}'' #loc
unnecessary.unicode.escape.problem.tab.descriptor=Unicode 轉義序列 <code>#ref</code> 可取代為制表符 #loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 轉義序列 <code>#ref</code> 可取代為換行字符 #loc
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package-info.java</code> 檔案
missing.package.html.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package.html</code> 檔案
package.info.java.without.package.display.name=不帶 'package' 語句的 'package-info.java'
package.info.without.package.problem.descriptor='package-info.java' 沒有 'package' 語句
package.info.without.package.quickfix=添加 ''package {0};''
package.info.without.package.family.quickfix=添加 package 語句
auto.closeable.resource.display.name=在沒有 'try-with-resources' 的情況下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在沒有 ''try-with-resources'' 語句的情況下使用 ''{0}'' #loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.returned.option=忽略從所有方法調用返回的 AutoCloseable 實例
problematic.varargs.method.display.name=非 vararg 方法覆寫 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>#ref()</code> 覆寫 vararg 方法 #loc
negatively.named.boolean.variable.problem.descriptor=布爾變數 <code>#ref</code> 已否定命名 #loc
negatively.named.boolean.variable.display.name=否定命名的布爾變數
invert.quickfix.family.name=反轉布爾
invert.method.quickfix=反轉方法
invert.quickfix=反轉 ''{0}''
throwable.printed.to.system.out.display.name='Throwable' 列印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 實參 <code>#ref</code> 到 ''System.{0}.{1}()'' 調用
suppress.for.tests.scope.quickfix=對 'Tests' 範圍禁止
implicit.default.charset.usage.display.name=隱式平台預設字符集
implicit.default.charset.usage.problem.descriptor=對 <code>#ref()</code> 的調用使用平台的預設字符集
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> 調用使用平台的預設字符集
interface.may.be.annotated.functional.display.name=接口可以註解為 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>#ref</code> 可以使用 @FunctionalInterface 註解
only.report.public.methods.option=僅報告 'public' 方法
lambda.parameter.hides.member.variable.display.name=lambda 參數隱藏欄位
static.initializer.references.subclass.display.name=static 初始設定式引用子類
lambda.parameter.hides.member.variable.problem.descriptor=lambda 參數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略從 lambda 實際不可見的欄位
shared.thread.local.random.display.name='ThreadLocalRandom' 實例可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 實例可能在線程之間共享
native.method.naming.convention.element.description='原生'
use.of.obsolete.date.time.api.display.name=使用廢棄的日期時間 API
use.of.obsolete.date.time.api.problem.descriptor=使用了廢棄的日期時間類型 <code>#ref</code> #loc
warn.on.label=警告物件:
all.levels.option=所有日誌級別
warn.level.and.lower.option=警告級別和更低
info.level.and.lower.option=資訊級別和更低
debug.level.and.lower.option=偵錯級別和更低
trace.level.option=跟踪級別
ignored.autocloseable.types.column.label=已忽略 AutoCloseable 資源類型
ignored.autocloseable.types.label=已忽略的 AutoCloseable 資源類型:
choose.autocloseable.type.to.ignore.title=選擇要忽略的 AutoCloseable 資源類型
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法調用沒有舍入模式實參
big.decimal.method.without.rounding.called.problem.descriptor=在沒有舍入模式實參的情況下調用了 'BigDecimal.#ref()'
bigdecimal.legacy.method.display.name=調用了 'BigDecimal' 遺留方法
bigdecimal.legacy.method.problem.descriptor=對 'BigDecimal.#ref()' 的調用可以使用 'RoundingMode' 枚舉常數
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚舉常數
serializable.stores.non.serializable.display.name='Serializable' 物件隱式存儲非 'Serializable' 物件
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化局部類 ''{1}'' 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名類隱式存儲類型為 ''{0}'' 的不可序列化物件
assignment.to.lambda.parameter.display.name=賦值給 lambda 參數
assignment.to.lambda.parameter.problem.descriptor=賦值給 lambda 參數 <code>#ref</code> #loc
class.with.only.private.constructors.display.name=僅包含 'private' 構造函數的類應被宣告為 'final'
class.with.only.private.constructors.problem.descriptor=僅包含 'private' 構造函數的類 <code>#ref</code> 應被宣告為 'final'
property.value.set.to.itself.display.name=屬性值設定為自身
equals.with.itself.display.name=在自身上調用了 'equals()'
equals.with.itself.problem.descriptor=在自身上調用了 <code>#ref()</code>
junit4.method.naming.convention.element.description=JUnit 4+ 測試
junit3.method.naming.convention.element.description=JUnit 3 測試
introduce.holder.class.quickfix=引入 holder 類
double.brace.initialization.display.name=雙大括號初始化
double.brace.initialization.quickfix=取代為正則初始化
return.of.inner.class.display.name=返回匿名、局部或內部類的實例
return.of.anonymous.class.problem.descriptor=返回匿名類的實例 #loc
return.of.local.class.problem.descriptor=返回局部類 <code>{0}</code> 的實例 #loc
return.of.inner.class.problem.descriptor=返回非 static 內部類 <code>{0}</code> 的實例 #loc
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
parameter.type.prevents.overriding.display.name=參數類型阻止覆寫
parameter.type.prevents.overriding.problem.descriptor=參數類型 <code>#ref</code> 位於 ''{0}''，而 super 方法參數類型位於 ''{1}''，可防止覆寫 #loc
parameter.type.prevents.overriding.quickfix=將參數類型更改為 ''{0}''
parameter.type.prevents.overriding.family.quickfix=更改參數類型
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.setter.problem.descriptor=setter <code>#ref()</code> 對欄位 ''{0}'' 賦值 #loc
suspicious.getter.problem.descriptor=getter <code>#ref()</code> 返回欄位 ''{0}'' #loc
unnecessary.break.display.name=不必要的 'break' 語句
unnecessary.break.problem.descriptor=<code>#ref</code> 語句不必要 #loc
utility.class.can.be.enum.display.name=實用程序類可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=實用程序類 <code>#ref</code> 可以是 'enum' #loc
utility.class.code.can.be.enum.quickfix=轉換為 'enum'
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>#ref()</code> 方法不是 'public' #loc
only.warn.on.public.clone.methods=僅對 'public' 克隆方法發出警告
only.warn.on.protected.clone.methods=僅對 'protected' 克隆方法發出警告
clone.returns.class.type.display.name='clone()' 應當具有等於其所包含類的返回類型
clone.returns.class.type.problem.descriptor=''clone()'' 應當具有返回類型 ''{0}'' #loc
clone.returns.class.type.quickfix=將返回類型更改為 ''{0}''
clone.returns.class.type.family.quickfix=將返回類型更改為類類型
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.call.problem.descriptor=調用 <code>#ref()</code>
use.of.clone.call.method.problem.descriptor=實作 <code>#ref()</code>
use.of.clone.reference.problem.descriptor=使用 <code>#ref</code>
dangling.javadoc.display.name=懸空的 Javadoc 註釋
dangling.javadoc.problem.descriptor=懸空的 Javadoc 註釋 #loc
dangling.javadoc.convert.quickfix=取代為塊註釋
dangling.javadoc.delete.quickfix=移除懸空的註釋
equals.replaceable.by.objects.call.display.name='equals()' 表達式可取代為 'Objects.equals()' 表達式
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> 可取代為 'Objects.equals()' 表達式 #loc
equals.replaceable.by.objects.check.not.null.option=高亮顯示與 'a != null \\&\\& a.equals(b)' 類似的表達式
array.objects.equals.display.name=對陣列使用淺層方法或 'Objects' 方法
array.equals.problem.descriptor=或許應當使用 ''{0}'' 完成陣列比較''
array.hashcode.problem.descriptor=或許應當使用 ''{0}'' 完成陣列哈希程式碼計算
extends.throwable.display.name=類直接擴展 'java.lang.Throwable'
anonymous.extends.throwable.problem.descriptor=匿名類直接擴展 'java.lang.Throwable' #loc
extends.throwable.problem.descriptor=類 <code>#ref</code> 直接擴展 'java.lang.Throwable' #loc
lambda.parameter.naming.convention.display.name=lambda 參數命名慣例
lambda.parameter.naming.convention.element.description=lambda 參數
assert.message.not.string.display.name='assert' 訊息不是字串
assert.message.of.type.boolean.problem.descriptor=類型為 ''{0}'' 的 ''assert'' 訊息 #loc
assert.message.not.string.only.warn.boolean.option=僅當 'assert' 訊息為 'boolean' 或 'java.lang.Boolean' 時發出警告
suspicious.literal.underscore.display.name=數字文字中的可疑下劃線
suspicious.literal.underscore.problem.descriptor=帶下劃線的數字文字中的組沒有長度 3 #loc
unary.plus.quickfix=移除一元 '+'
convert.double.unary.quickfix=取代為 ''{0}{1}''
prefix.operation.quickfix.family.name=取代為前綴運算符
super.tear.down.in.finally.display.name=未從 'finally' 塊調用 'super.tearDown()'
super.tear.down.in.finally.problem.descriptor=未從 'finally' 塊調用 <code>#ref()</code> #loc
confusing.floating.point.literal.option=忽略科學記數法中的浮點文字
class.may.be.interface.java8.option=使用 Java 8 時報告包含非 abstract 方法的類
simplifiable.boolean.expression.display.name=可簡化的布爾表達式
unnecessary.initcause.display.name=對 'Throwable.initCause()' 的調用不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.#ref()</code> 調用
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 調用
consider.static.final.fields.constant.option=考慮 'static final' 欄位常數
atomic.field.updater.not.static.final.display.name=AtomicFieldUpdater 欄位未被宣告為 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 欄位 <code>#ref</code> 未被宣告為 ''static final'' #loc
atomic.field.updater.issues.display.name=不一致的 AtomicFieldUpdater 宣告
field.not.found.in.class.problem.descriptor=類 ''{1}'' 中未找到命名為 ''{0}'' 的欄位
field.incorrect.type.problem.descriptor=欄位 ''{0}'' 沒有類型 ''{1}''
field.missing.volatile.modifier.problem.descriptor=欄位 ''{0}'' 沒有 ''volatile'' 修飾符
field.has.static.modifier.problem.descriptor=欄位 ''{0}'' 具有 ''static'' 修飾符
private.field.not.accessible.problem.descriptor=''private'' 欄位 ''{0}'' 無法從此處存取
package.local.field.not.accessible=package-private 欄位 ''{0}'' 無法從此處存取
protected.field.not.accessible.problem.descriptor=''protected'' 欄位 ''{0}'' 無法從此處存取
interface.clashes.with.object.class.display.name=接口方法與 'java.lang.Object' 中的方法衝突
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> 與 'java.lang.Object' 中的方法衝突
optional.used.as.field.or.parameter.type.display.name=用作欄位或參數類型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>#ref</code> 用作欄位 ''{0}'' 的類型
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> 用作參數 ''{0}'' 的類型
lambda.unfriendly.method.overload.display.name=方法多載對 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>#ref()</code> 的多載對 lambda 不友好
lambda.unfriendly.constructor.overload.problem.descriptor=構造函數 <code>#ref()</code> 的多載對 lambda 不友好
optional.contains.collection.display.name='Optional' 包含陣列或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>#ref</code>
optional.contains.array.problem.descriptor='Optional' 包含陣列 <code>#ref</code>
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>#ref()</code> 上同步 #loc
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 內部的物件實例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 內部的物件實例化 #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 內部的物件實例化 #loc
lambda.body.can.be.code.block.name=lambda 體可以是程式碼塊
lambda.body.can.be.code.block.quickfix=將 lambda 體擴展為 {...}
lambda.parameter.type.can.be.specified.name=可以指定 lambda 參數類型
lambda.parameter.type.can.be.specified.descriptor=Lambda 參數類型可以擴展為{0}
lambda.parameter.type.can.be.specified.quickfix=將參數類型擴展為{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 參數類型
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可取代為顯式類型實參
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=將 '<>' 取代為顯式類型實參
lambda.can.be.replaced.with.anonymous.name=lambda 可取代為匿名類
lambda.can.be.replaced.with.anonymous.quickfix=將 lambda 取代為匿名類
method.ref.can.be.replaced.with.lambda.name=方法引用可取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix=將方法引用取代為 lambda
try.statement.with.multiple.resources.name=可以拆分具有多個資源的 'try' 語句
try.statement.with.multiple.resources.quickfix=拆分具有多個資源的 'try' 語句
multi.catch.can.be.split.name=多 catch 可拆分為單獨的 catch 塊
multi.catch.can.be.split.quickfix=將多 catch 拆分為單獨的 'catch' 塊
assertion.can.be.if.name=斷言可取代為 'if' 語句
assert.can.be.if.quickfix=將 'assert' 取代為 'if' 語句
if.can.be.assertion.name=語句可取代為 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=將語句取代為 'assert' 語句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=將語句取代為 'Objects.requireNonNull()'
single.statement.in.block.name=程式碼塊包含單條語句
single.statement.in.block.descriptor=''{0}'' 包含單條語句
single.statement.in.block.quickfix=從 ''{0}'' 語句中移除大括號
single.statement.in.block.family.quickfix=從語句中移除大括號
single.element.annotation.name=非規范化註解
single.element.annotation.quickfix=添加 'value='
single.element.annotation.family.quickfix=將註解擴展為標準形式
array.creation.without.new.keyword.name=創建不帶 'new' 表達式的陣列
array.creation.without.new.keyword.quickfix=添加 ''new {0}''
array.creation.without.new.keyword.family.quickfix=添加 'new' 表達式
malformed.set.up.tear.down.display.name='setUp()' 或 'tearDown()' 方法的格式錯誤 
malformed.set.up.tear.down.problem.descriptor='#ref()' 的簽名不正確 #loc
overly.long.lambda.display.name=過長的 lambda 表達式
overly.long.lambda.problem.descriptor=lambda 表達式過長 (# 非註釋源語句 = {0}) #loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步時調用 <code>#ref</code> #loc
call.to.suspicious.string.method.display.name=調用可疑的字串方法
call.to.suspicious.string.method.problem.descriptor=國際化上下文中調用的 <code>String.#ref()</code> #loc
unnecessary.string.escape.display.name=不必要的轉義字符
unnecessary.string.escape.problem.descriptor=<code>#ref</code> 進行了不必要的轉義
unnecessary.string.escape.quickfix=將不必要的轉義字符取代為未轉義字符

array.can.be.replaced.with.enum.values = 可以將陣列取代為枚舉值
array.can.be.replaced.with.enum.values.quickfix = 將陣列取代為 {0}.values()
array.can.be.replaced.with.enum.values.family.quickfix = 將陣列取代為 EnumType.values()

string.concatenation.replace.fix=取代為 StringBuilder
string.concatenation.replace.fix.name=將變數 ''{0}'' 從字串轉換為 {1}
string.concatenation.replace.fix.name.null.safe=將變數 ''{0}'' 從字串轉換為 {1} (null 安全)
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新變數 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新變數 ''{0}'' (null 安全)

ignored.class.names=忽略類(包括子類)
ignored.class.label=已忽略類(包括子類):
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 註解的測試註解
string.equals.char.sequence.display.name=使用 'CharSequence' 實參調用了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 實參調用了 <code>String.equals()</code> #loc
object.equals.can.be.equality.display.name='equals()' 調用可取代為 '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> 可取代為 '=='
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> 可取代為 '!='
redundant.explicit.var.type.display.name=可以省略局部變數類型
variable.type.can.be.explicit.display.name=變數類型可以是顯式的
assignment.or.return.of.field.with.mutable.type.display.name=具有可變類型的欄位的賦值或返回
assignment.of.field.with.mutable.type.problem.descriptor=賦值給參數 <code>#ref</code> 中的 {0} 欄位 ''{1}'' #loc
return.of.field.with.mutable.type.problem.descriptor=返回 {0} 欄位 <code>{1}</code> #loc
ignore.private.methods.option=忽略 private 方法中的賦值和返回值

inspection.redundant.string.operation.display.name=冗餘字串操作
inspection.redundant.string.remove.fix.name=移除冗餘的 ''{0}()'' 調用
inspection.redundant.string.fix.family.name=移除冗餘調用
inspection.redundant.string.call.message=<code>#ref()</code> 的調用冗餘 #loc
inspection.redundant.empty.string.argument.message=不必要的空字串實參
inspection.redundant.string.length.argument.message=不必要的字串長度實參
inspection.redundant.zero.argument.message=不必要的零實參
inspection.redundant.string.remove.argument.fix.name=移除實參
inspection.redundant.string.intern.on.constant.message=編譯時常量上 <code>#ref()</code> 的調用不必要 #loc
inspection.redundant.string.constructor.message=<code>#ref</code> 是冗餘的 #loc
inspection.redundant.string.replace.with.arg.fix.name=取代為實參
inspection.redundant.string.replace.with.empty.fix.name=取代為空字串
inspection.redundant.string.option.do.not.report.string.constructors=不報告字串構造函數
inspection.x.call.can.be.replaced.with.y=''{0}'' 調用可取代為 ''{1}''

inspection.type.may.be.weakened.display.name=類型可能被削弱
inspection.type.may.be.weakened.problem.descriptor=變數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>#ref()</code> 的返回類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.parameter.problem.descriptor=參數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.field.problem.descriptor=欄位 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.quickfix=將類型削弱為 ''{0}''
inspection.type.may.be.weakened.ignore.option=在賦值中使用右手類型作為最弱的類型(&R)
inspection.type.may.be.weakened.collection.method.option=對方法調用實參使用參數化集合類型(&P)
inspection.type.may.be.weakened.do.not.weaken.to.object.option=不削弱為 'java.lang.Object'(&W)
inspection.type.may.be.weakened.add.stopper=作為停止類添加以減弱
inspection.type.may.be.weakened.add.stopper.single=添加 {0} 作為停止類以削弱
inspection.type.may.be.weakened.only.weaken.to.an.interface=僅削弱為接口
inspection.type.may.be.weakened.do.not.weaken.return.type=不削弱返回類型
inspection.type.may.be.weakened.add.stop.class.family=添加停止類
inspection.type.may.be.weakened.weaken.type.family=削弱類型
inspection.type.may.be.weakened.add.stop.class.selection.table=停止類
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止類:
inspection.type.may.be.weakened.add.stop.class.selection.popup=選擇停止類
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建議削弱宣告為 'var' 的變數

inspection.commented.out.code.display.name=註釋掉的程式碼
inspection.commented.out.code.problem.descriptor=註釋掉的程式碼 ({0} {0, choice, 1#行|1<行})
commented.out.code.delete.quickfix=刪除註釋
commented.out.code.uncomment.quickfix=撤消程式碼註釋
inspection.commented.out.code.min.lines.options=最少程式碼行數

inspection.catch.ignores.exception.display.name=catch 塊可能會忽略異常
inspection.catch.ignores.exception.option.comments=當 'catch' 塊包含註釋時不發出警告
inspection.catch.ignores.exception.option.nonempty=當 'catch' 塊不為空時不發出警告
inspection.catch.ignores.exception.option.ignored.used=當名稱為 'ignore(d)' 的異常實際上未被忽略時不發出警告
inspection.catch.ignores.exception.used.message=已使用命名為 <code>#ref</code> 的 'catch' 參數 #loc
inspection.catch.ignores.exception.empty.message=空 <code>#ref</code> 塊 #loc
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 參數 <code>#ref</code> #loc
inspection.catch.ignores.exception.vm.ignored.message=<code>#ref</code> 塊中可能會忽略 ''{0}'' 之類的意外虛擬機異常 #loc

inspection.redundant.collection.operation.display.name=冗餘集合操作
inspection.redundant.collection.operation.fix.family.name=簡化集合操作
inspection.redundant.collection.operation.problem.arraycopy=為複製陣列而創建的集合不必要
inspection.redundant.collection.removal.by.index.problem=按索引移除可取代為按物件移除
inspection.redundant.collection.removal.by.index.fix=使用按物件移除
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 檢查
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 檢查

comments.as.content.option=註釋計為內容
copy.constructor.misses.field.display.name=複製缺少欄位的構造函數
copy.constructor.misses.field.problem.descriptor.1=複製未複製欄位 ''{0}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.2=複製未複製欄位 ''{0}'' 和 ''{1}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.3=複製未複製欄位 ''{0}''、''{1}'' 和 ''{2}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.many=複製未複製 {0} 個欄位的構造函數

fix.add.argument.family.name=添加實參
fix.add.argument.name=添加 ''{0}'' 實參

inspection.constant.expression.display.name=可以計算常數表達式
inspection.constant.expression.message=常數表達式可以計算為 ''{0}''
inspection.constant.expression.fix.name=計算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.with.value=將 ''{0}'' 取代為常量值 ''{1}''
inspection.constant.expression.fix.family.name=計算常量值

inspection.redundant.compare.call.display.name=冗餘的 'compare()' 方法調用
inspection.redundant.compare.call.fix.name=內聯 'compare()' 調用

inspection.simplifiable.if.statement.display.name='if' 語句可取代為條件或布爾表達式
inspection.simplifiable.if.statement.message=If 語句可取代為 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建議使用 '?:' 運算符
inspection.simplifiable.if.statement.fix.name=將 ''if else'' 取代為 ''{0}''
inspection.simplifiable.if.statement.fix.family.name=將 'if else' 取代為條件運算符

inspection.list.remove.in.loop.display.name=在迴圈中調用了 'List.remove()'
inspection.list.remove.in.loop.message=可取代為 'List.subList().clear()'

implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集

inspection.redundant.class.call.display.name=冗餘的 'isInstance()' 或 'cast()' 調用
inspection.new.object.equality.display.name=使用 '==' 比較新物件
inspection.new.object.equality.message=使用 ''{0}'' 比較新物件
inspection.excessive.range.check.message=可取代為 ''{0}''
inspection.excessive.range.check.fix.family.name=簡化過度範圍檢查
suspicious.integer.div.assignment.problem.descriptor=除法結果被截斷為整數
suspicious.integer.div.assignment.display.name=可疑的整數除法賦值
suspicious.integer.div.assignment.quickfix=轉換為 double
inspection.if.statement.missing.break.in.loop.name=在 'if' 條件下提前退出迴圈
inspection.if.statement.missing.break.in.loop.description=滿足條件後，可以終止迴圈
inspection.if.statement.missing.break.in.loop.quickfix=添加 'break'

inspection.case.mismatch.display.name='String' 操作中不符合的大小寫
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始終返回 {1}: 實參包含小寫符號，而限定符僅為大寫
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始終返回 {1}: 實參包含大寫符號，而限定符僅為小寫

inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.upper=使用了大寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})
inspection.suspicious.date.format.message.lower=使用了小寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})

fix.replace.map.with.flat.map.description='map()' 可取代為 'flatMap()'

fix.eliminate.folded.if.present.name=移除折疊的 'ifPresent()' 調用
fix.eliminate.folded.if.present.description=可以消除折疊的 'ifPresent()' 調用

inspection.pattern.variable.can.be.used.display.name=可以使用模式變數
inspection.pattern.variable.can.be.used.message=變數 ''{0}'' 可取代為模式變數
inspection.pattern.variable.can.be.used.fix.family.name=取代為模式變數
inspection.pattern.variable.can.be.used.fix.name=將 ''{0}'' 取代為模式變數
inspection.pattern.variable.can.be.used.existing.message=可以使用現有模式變數 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.existing.fix.family.name=取代為現有模式變數
inspection.pattern.variable.can.be.used.existing.fix.name=將 ''{0}'' 取代為現有模式變數 ''{1}''

array.hash.code.fix.family.name=取代為隱式 'hashCode'
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包裝
unqualified.static.access.fix.family.name=限定靜態存取
replace.field.reference.fix.family.name=取代欄位引用
replace.field.reference.fix.text=將欄位引用取代為 {0}
replace.method.call.fix.family.name=取代方法調用
replace.method.call.fix.text=將方法調用取代為 {0}
delete.unnecessary.statement.fix.family.name=移除冗餘語句
increment.decrement.used.as.expression.fix.family.name=提取到分離語句中
use.of.properties.as.hashtable.fix.family.name=修復屬性存取
unnecessary.java.doc.link.fix.family.name=移除冗餘標記
swap.equals.fix.family.name=翻轉方法調用
remove.modifier.fix.family.name=移除修飾符
shift.out.of.range.fix.family.name=修復移位值
unnecessary.unicode.escape.fix.family.name=取代為字符
unnecessary.unicode.escape.fix.text=取代為換行字符
absolute.alignment.in.user.interface.fix.family.name=取代為常數
static.inheritance.fix.family.name=將繼承取代為限定引用
suspicious.to.array.call.fix.family.name=取代為正確陣列
incorrect.date.format.fix.family.name=修復不正確的日期格式
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=從超類 {1} 初始設定式引用子類 {0} 可能會導致類載入死鎖
collections.field.access.replaceable.by.method.call.fix.family.name=將 Collections.EMPTY_* 取代為調用
delete.catch.section.fix.family.name=刪除 catch 語句
make.field.static.final.fix.family.name=設為 static final
string.concatenation.in.format.call.fix.family.name=將串聯取代為實參
implicit.array.to.string.fix.family.name=將 Array.toString() 設為隱式
listener.may.use.adapter.fix.family.name=取代為適配器
unnecessary.temporary.object.fix.family.name=取代串聯
make.public.static.fix.family.name=設為 public/static
utility.class.with.public.constructor.fix.family.name=將構造函數設為 private
change.modifier.fix.family.name=更改修飾符
unnecessary.interface.modifiers.fix.family.name=移除不必要的修飾符
make.field.final.fix.family.name=設為 final
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
replace.instanceof.fix.family.name=取代 instanceOf 類型
replace.cast.fix.family.name=取代轉換類型
make.package.private.fix.family.name=設為 package-private
make.method.final.fix.family.name=將方法設為 'final'
replace.casted.literal.with.just.literal.fix.family.name=取代為 {0} 文字
char.used.in.arithmetic.content.cast.fix.family.name=插入轉換
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略單個非正式類型 lambda 參數周圍的括號
double.checked.locking.fix.family.name=將欄位設為 volatile
declare.collection.as.interface.fix.family.name=削弱類型
string.equals.empty.string.fix.family.name=簡化空字串檢查
class.without.logger.annotations.tab=註解
class.without.logger.loggers.tab=記錄器
options.title.ignored.classes=已忽略的類
options.label.ignored.classes=已忽略的類:
add.catch.section.fix.family.name=添加 'catch' 子句
inspection.autocloseable.resource.ignored.methods.title=忽略從這些方法返回的 AutoCloseable 實例:
logger.initialized.with.foreign.class.fix.family.name=取代外類
extend.exception.fix.family.name=使類擴展 'Exception'
inspection.use.of.private.field.inner.classes.option=忽略來自內部類的存取
refused.bequest.fix.family.name=將調用插入 super 方法
mark.modules.as.loaded.together.fix.family.name=將模組標記為一起載入
mark.modules.as.loaded.together.fix.text=將 ''{0}'' 和 ''{1}'' 模組標記為一起載入
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模組 ''{2}'' 中宣告
ignore.class.fix.family.name=對這些類型忽略
create.default.branch.fix.family.name=插入 'default' 分支
unnecessary.fully.qualified.name.fix.family.name=取代完全限定名稱
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
remove.redundant.substring.fix.family.name=移除冗餘的 'substring()' 調用
remove.redundant.string.fix.text=使用 ''{0}()'' 並移除冗餘的 ''{1}()'' 調用
use.equalsignorecase.for.case.insensitive.comparison=為不區分大小寫的比較使用 equalsIgnoreCase()
make.class.final.fix.family.name=將類設為 final
side.effects.method.ref.to.lambda.fix.family.name={0} (副作用)
encapsulate.variable.fix.family.name=封裝欄位
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修復可將實例限定符取代為類引用
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
make.public.static.void.fix.family.name=修復修飾符
make.public.static.void.fix.name=將 ''{0}'' 的簽名更改為 ''{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
replace.method.ref.with.qualifier.fix.family.name=取代為限定符
replace.method.ref.with.qualifier.problem.method=方法引用可取代為限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可取代為調用限定符
add.throws.clause.fix.family.name=修復 'throws' 子句
prefer.empty.array.options.title=首選空陣列:
prefer.empty.array.options.mode.always=始終
prefer.empty.array.options.mode.by.level=根據語言級別
prefer.empty.array.options.mode.always.never=從不(首選預設大小的陣列)
too.broad.scope.inspection.fix.family.name=限縮範圍
replace.with.cast.fix.family.name=取代為轉換
replace.anonymous.with.lambda.body.fix.family.name=將調用取代為方法體
replace.with.method.reference.fix.family.name=將方法引用上的方法調用取代為相應的方法調用
replace.with.lambda.body.fix.family.name=將 lambda 上的方法調用取代為 lambda 體
inspection.trivial.functional.expression.usage.description=可以簡化方法調用
replace.with.var.fix.family.name=將顯式類型取代為 'var'
inspection.redundant.explicit.variable.type.description=可以省略局部變數的顯式類型
add.read.write.object.methods.fix.family.name=添加始終拋出異常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=添加始終拋出異常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=添加始終拋出異常的 'readObject()' 方法
replace.with.method.ref.fix.family.name=將 lambda 取代為方法引用
replace.with.method.ref.fix.name.may.change.semantics=將 lambda 取代為方法引用(可能更改語意)
qualify.call.fix.family.name=限定調用
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法簡化比較器
inspection.comparator.combinators.description=可取代為 'Comparator' 鏈
inspection.comparator.combinators.description2=可取代為 ''{0}''
inspection.unnecessary.string.escape.report.char.literals.option=報告字符文字
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
fix.data.provider.signature.family.name=修正資料提供程序方法簽名
allow.suppressions.fix.family.name=允許禁止
allow.suppressions.fix.text=允許這些禁止
remove.suppress.comment.fix.family.name=移除 //{0}
convert.to.j.unit.4.fix.family.name=將 JUnit 3 類轉換為 JUnit 4
throws.runtime.exception.fix.family.name=從 'throws' 子句中移除
move.exception.to.javadoc.fix.family.name=移動到 Javadoc '@throws'
create.package.info.java.family.name=創建 'package-info.java'
remove.loop.fix.family.name=移除迴圈
remove.call.fix.family.name=移除調用
inspection.meta.annotation.without.runtime.description={0} 應具有 @Retention(RetentionPolicy.RUNTIME)
inspection.refused.bequest.super.annotated.option=僅在通過以下方式註解 super 方法時報告:
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子類
inspection.test.method.without.assertions.exceptions.option=忽略宣告異常的測試方法
inspection.collection.must.have.initial.capacity.initializers.option=不報告欄位初始設定式
utility.class.without.private.constructor.cant.generate.constructor.title=無法生成構造函數
utility.class.without.private.constructor.cant.generate.constructor.message=實用程序類具有實例化，將不會創建 private 構造函數
inspection.suspicious.package.private.access.problem={0} 重寫了來自在不同模組 ''{2}'' 中宣告的 {1} 的 package-private 方法
inspection.condition.covered.by.further.condition.descr=條件 ''{0}'' 由後面的{1, choice, 1#條件 ''''{2}''''|2#條件}覆蓋
inspection.parameterized.parameters.static.collection.display.name=沒有資料提供程序方法的參數化測試類
create.missing.switch.branch=創建缺少的 switch 分支 ''{0}''
create.missing.switch.branches=創建缺少的分支: {0}
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 調用
redundant.as.list.for.iteration.fix.name=解開
assert.with.side.effects.call.mutates.expression=調用 ''{0}()'' 會改變 ''{1}''
assert.with.side.effects.call.mutates.field=調用 ''{0}()'' 會改變欄位 ''{1}''
inspection.comparator.combinators.fix.chain=取代為 'Comparator' 鏈
logger.initialized.with.foreign.options.title=選擇記錄器工廠類
test.without.assertion.options.choose.class=選擇斷言類
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
convert.junit3.test.fix.conflict.semantics=如果 {1} 轉換為 JUnit 4，方法調用 {0} 可能會更改語意
convert.junit3.test.fix.conflict.compile=如果 {1} 轉換為 JUnit 4，方法調用 {0} 將不編譯
convert.junit3.test.fix.conflict.compile.2=如果 {1} 轉換為 JUnit 4，引用 {0} 將不編譯
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 轉換低效

fix.data.provider.signature.fix.name=將方法簽名更改為 ''{0}''
fix.data.provider.create.method.fix.name=創建資料提供程序方法 '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.signature.missing.method.problem=參數化測試類 <code>#ref</code> 缺少用 '@Parameters' 註解的資料提供程序方法
fix.data.provider.signature.incorrect.problem=資料提供程序方法 <code>#ref()</code> 的簽名不正確
fix.data.provider.multiple.methods.problem=類 <code>#ref</code> 中存在多個 @Parameters 資料提供程序方法
cloneable.class.without.clone.todo.message=TODO: 複製此處的可變狀態，這樣此克隆就不能更改初始克隆的內部
cloneable.class.without.clone.ignore.when.clone.called.option=如果調用超類的 clone() 方法需要 Cloneable，則忽略
trivial.if.option.ignore.assert.statements=忽略 'assert' 語句
if.may.be.factorized.problem.descriptor=<code>#ref</code> 可以因式分解 #loc
if.may.be.factorized.quickfix=取代為因式分解表達式
weaken.visibility.quickfix=削弱可見性
non.final.field.in.enum.quickfix.option=在快速修復不可用時忽略欄位
checkbox.ignore.null.on.wrong.side=<html>忽略錯誤側的 <code>null</code></html>
cyclic.class.dependency.ignore.in.same.file=忽略位於同一檔案中的類之間的迴圈
ambiguous.field.access.navigate.quickfix=導航到明顯存取過的{0, choice, 1#局部變數|2#參數|3#欄位}
unnecessary.record.modifier.display.name=不必要的 'record' 修飾符
unnecessary.redundant.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於記錄是冗餘的
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超類初始化的記錄器
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 類中的記錄器
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的檔案頭註釋
package.in.multiple.modules.problem.descriptor2=軟體套件 ''{0}'' 具有模組 ''{1}'' 和 ''{2}'' 中的類
package.in.multiple.modules.problem.descriptor3=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 和 ''{3}'' 中的類
package.in.multiple.modules.problem.descriptor.many=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 以及其他 {3} 個模組中的類
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 檢查字串是否為空或者僅包含空格
expression.may.be.factorized.display.name=表達式可以因式分解
create.missing.enum.switch.branches.fix.family.name=創建缺少的枚舉 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=創建缺少的密封類 switch 分支
inspection.case.mismatch.message.label.is.lower=無法存取 switch 分支: 標籤包含小寫符號，而選擇器僅支援大寫
inspection.case.mismatch.message.label.is.upper=無法存取 switch 分支: 標籤包含大寫符號，而選擇器僅支援小寫
for.can.be.foreach.fix.no.indexed=不報告索引的 'java.util.List' 迴圈
use.of.concrete.class.option.ignore.records=忽略 Java 記錄
create.null.branch.fix.family.name=插入 'null' 分支
instanceof.concrete.class.pattern.problem.descriptor=針對具體類 <code>#ref</code> 的模式測試 #loc
remove.annotation.parameter.0.fix.name=移除註解參數 ''{0}''
set.annotation.parameter.0.1.fix.name=將註解參數 {0} 設定為 "{1}"
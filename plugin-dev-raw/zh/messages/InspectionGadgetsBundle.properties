0.will.no.longer.be.overridable.by.1={0} 將不再可被 {1} 覆寫
absolute.alignment.in.user.interface.display.name=AWT/Swing 程式碼中的絕對對齊
absolute.alignment.in.user.interface.fix.family.name=取代為常數
absolute.alignment.in.user.interface.problem.descriptor=使用了絕對對齊常數 <code>{0}.\#ref</code> \#loc
abstract.class.extends.concrete.class.display.name=抽象類別擴展具體類別
abstract.class.extends.concrete.class.problem.descriptor=類別 <code>\#ref</code> 被宣告為 'abstract'，並擴展一個具體類別 \#loc
abstract.class.naming.convention.element.description=抽象類別
abstract.class.never.implemented.display.name=沒有具體子類別的抽象類別
abstract.class.never.implemented.problem.descriptor=抽象類別 <code>\#ref</code> 沒有具體子類別 \#loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一個直接繼承者的抽象類別
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一個直接繼承者的抽象類別 <code>\#ref</code> \#loc
abstract.class.without.abstract.methods.display.name=沒有 'abstract' 方法的抽象類別
abstract.class.without.abstract.methods.ignore.utility.class.option=忽略實用程序類別
abstract.class.without.abstract.methods.problem.descriptor=類別 <code>\#ref</code> 被宣告為 'abstract'，並且沒有 'abstract' 方法 \#loc
abstract.method.call.in.constructor.display.name=物件建構期間呼叫的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=物件建構期間呼叫 'abstract' 方法 <code>\#ref()</code> \#loc
abstract.method.overrides.abstract.method.display.name=abstract 方法覆寫 abstract 方法
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 與其 super 方法不同的方法
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>\#ref()</code> 覆寫 abstract 方法 \#loc
abstract.method.overrides.abstract.method.remove.quickfix=移除冗餘 abstract 方法宣告
abstract.method.overrides.concrete.method.display.name=abstract 方法覆寫具體方法
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>\#ref()</code> 覆寫具體方法 \#loc
abstract.method.with.missing.implementations.display.name=缺少實作的 abstract 方法
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>\#ref()</code> 未在每個子類別中實作 \#loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=選擇非執行緒安全類別
access.to.non.thread.safe.static.field.from.instance.display.name=非執行緒安全的 'static' 欄位存取
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=存取類型為 ''{0}'' 的非執行緒安全 static 欄位 <code>\#ref</code> \#loc
access.to.non.thread.safe.static.field.from.instance.option.title=非執行緒安全類別\:
access.to.static.field.locked.on.instance.display.name=存取實例資料上鎖定的 'static' 欄位
access.to.static.field.locked.on.instance.fix.name=忽略類型 ''{0}'' 的 static 欄位
access.to.static.field.locked.on.instance.problem.descriptor=存取實例資料上鎖定的 static 欄位 <code>\#ref</code> \#loc
accessing.non.public.field.of.another.object.display.name=存取另一個物件的非 public 欄位
accessing.non.public.field.of.another.object.problem.descriptor=直接存取另一個物件的非 public 欄位 <code>\#ref</code> \#loc
add.0.to.ignore.if.annotated.by.list.quickfix=將 ''{0}'' 新增到“由以下物件註解時忽略”列表中
add.catch.section.fix.family.name=新增 'catch' 子句
add.read.write.object.methods.fix.family.name=新增始終拋出異常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=新增始終拋出異常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=新增始終拋出異常的 'readObject()' 方法
add.serialversionuidfield.quickfix=新增 'serialVersionUID' 欄位
add.this.qualifier.quickfix=新增 'this' 限定符
add.throws.clause.fix.family.name=修復 'throws' 子句
all.levels.option=所有日誌級別
allow.resource.to.be.opened.inside.a.try.block=允許在 'try' 塊內開啟資源
ambiguous.field.access.display.name=對繼承欄位的存取類似於對周圍程式碼中元素的存取
ambiguous.field.access.hides.field.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\#ref</code> 欄位類似於存取周圍類別中的欄位 \#loc
ambiguous.field.access.hides.local.variable.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\#ref</code> 欄位類似於存取區域變數 \#loc
ambiguous.field.access.hides.parameter.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\#ref</code> 欄位類似於存取參數 \#loc
ambiguous.field.access.navigate.quickfix=導覽到明顯存取過的{0, choice, 1\#區域變數|2\#參數|3\#欄位}
ambiguous.field.access.quickfix=將 'super' 限定符新增到欄位存取
ambiguous.method.call.display.name=對繼承方法的呼叫類似於對本地方法的呼叫
ambiguous.method.call.problem.descriptor=對來自超類別 ''{0}'' 的方法 <code>\#ref()</code> 的呼叫類似於對來自類別 ''{1}'' 的方法的呼叫 \#loc
ambiguous.method.call.quickfix=向方法呼叫中新增 'super' 限定符
annotation.class.display.name=註解接口
annotation.class.problem.descriptor=註解接口 <code>\#ref</code> \#loc
annotation.display.name=註解
annotation.naming.convention.element.description=註解接口
annotation.problem.descriptor=註解 <code>\#ref</code> \#loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名類別欄位 <code>\#ref</code> 隱藏包含方法中的變數 \#loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名類別參數 <code>\#ref</code> 隱藏包含方法中的變數 \#loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名類別變數隱藏包含方法中的變數
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名類別區域變數 <code>\#ref</code> 隱藏包含方法中的變數 \#loc
anonymous.extends.concrete.collection.problem.descriptor=匿名類別顯式擴展 ''{0}'' \#loc
anonymous.extends.thread.problem.descriptor=匿名類別直接擴展 'java.lang.Thread' \#loc
anonymous.extends.throwable.problem.descriptor=匿名類別直接擴展 'java.lang.Throwable' \#loc
anonymous.inner.class.display.name=匿名類別可被取代為內部類別
anonymous.inner.class.problem.descriptor=匿名類別 <code>\#ref</code> \#loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名類別
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名類別 (方法計數 \= {0}) \#loc
anonymous.inner.may.be.named.static.inner.class.display.name=匿名類別可能是命名為 'static' 的內部類別
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名類別 <code>\#ref</code> 可能是命名為 'static' 的內部類別 \#loc
anonymous.inner.may.be.named.static.inner.class.quickfix=轉換為命名 'static' 內部類別
any.method.may.close.resource.argument=任何方法都可能關閉作為實參傳遞的資源
array.allocation.zero.length.display.name=零長度陣列分配
array.allocation.zero.length.problem.descriptor=零長度陣列的分配 \#loc
array.can.be.replaced.with.enum.values=可以將陣列取代為枚舉值
array.can.be.replaced.with.enum.values.family.quickfix=將陣列取代為 EnumType.values()
array.can.be.replaced.with.enum.values.quickfix=將陣列取代為 {0}.values()
array.comparison.display.name=使用 '\=\=' 而不是 'Arrays.equals()' 進行陣列比較
array.comparison.problem.descriptor=使用 <code>\#ref</code> 而不是 'Arrays.equals()' 來比較陣列物件 \#loc
array.creation.without.new.keyword.family.quickfix=新增 'new' 表達式
array.creation.without.new.keyword.name=建立不帶 'new' 表達式的陣列
array.creation.without.new.keyword.quickfix=新增 ''new {0}''
array.equals.problem.descriptor=或許應當使用 ''{0}'' 完成陣列比較''
array.hash.code.display.name=在陣列上呼叫了 'hashCode()'
array.hash.code.fix.family.name=取代為 'Arrays.hashCode()' 呼叫
array.hash.code.problem.descriptor=陣列上呼叫的 <code>\#ref()</code> 可能應當是 'Arrays.hashCode()' \#loc
array.hashcode.problem.descriptor=或許應當使用 ''{0}'' 完成陣列雜湊程式碼計算
array.length.in.loop.condition.display.name=迴圈條件下的 Array.length
array.length.in.loop.condition.problem.descriptor=檢查迴圈條件下的陣列 <code>\#ref</code> \#loc
array.objects.equals.display.name=對陣列使用淺層方法或 'Objects' 方法
arrays.as.list.with.one.argument.problem.descriptor=僅使用一個實參呼叫 <code>\#ref()</code> \#loc
arrays.as.list.with.zero.arguments.problem.descriptor=呼叫 <code>\#ref()</code> 以建立空列表 \#loc
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 呼叫的實參過少
assert.can.be.if.quickfix=將 'assert' 取代為 'if' 語句
assert.keyword.is.considered.an.assertion='assert' 關鍵字被視為斷言
assert.message.not.string.display.name='assert' 訊息不是字串
assert.message.not.string.only.warn.boolean.option=僅當 'assert' 訊息為 'boolean' 或 'java.lang.Boolean' 時發出警告
assert.message.of.type.boolean.problem.descriptor=類型為 ''{0}'' 的 ''assert'' 訊息 \#loc
assert.statement.display.name='assert' 語句
assert.with.side.effects.call.mutates.expression=呼叫 ''{0}()'' 會改變 ''{1}''
assert.with.side.effects.call.mutates.field=呼叫 ''{0}()'' 會改變欄位 ''{1}''
assert.with.side.effects.call.performs.io=呼叫 ''{0}()'' 會執行輸入/輸出動作
assert.with.side.effects.display.name=具有副作用的 'assert' 語句
assert.with.side.effects.problem.descriptor=<code>\#ref</code> 具有副作用\: {0} \#loc
assert.without.message.problem.descriptor=沒有訊息的 <code>\#ref()</code> \#loc
assert.without.message.quick.fix.family.name=新增錯誤訊息
assertion.can.be.if.name=斷言可被取代為 'if' 語句
asserts.without.messages.display.name=斷言上缺少訊息
assignment.and.return.of.mutable.record.component={1} 記錄組件的隱式{0, choice, 1\#賦值|2\#返回|3\#賦值和返回} <code>\#ref</code> \#loc
assignment.of.field.with.mutable.type.problem.descriptor=賦值給參數 <code>\#ref</code> 中的 {0} 欄位 ''{1}'' \#loc
assignment.or.return.of.field.with.mutable.type.display.name=具有可變類型的欄位的賦值或返回
assignment.replaceable.with.operator.assignment.display.name=賦值可被取代為運算符賦值
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略條件運算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 運算符
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>\#ref</code> 可以簡化為 ''{0}'' \#loc
assignment.to.catch.block.parameter.display.name=賦值給 'catch' 塊參數
assignment.to.catch.block.parameter.problem.descriptor=賦值給 'catch' 塊參數 <code>\#ref</code> \#loc
assignment.to.for.loop.parameter.check.foreach.option=檢查增強型 'for' 迴圈參數
assignment.to.for.loop.parameter.display.name=賦值給 'for' 迴圈參數
assignment.to.for.loop.parameter.problem.descriptor=賦值給 for 迴圈參數 <code>\#ref</code> \#loc
assignment.to.lambda.parameter.display.name=賦值給 lambda 參數
assignment.to.lambda.parameter.problem.descriptor=賦值給 lambda 參數 <code>\#ref</code> \#loc
assignment.to.method.parameter.display.name=賦值給方法參數
assignment.to.method.parameter.ignore.transformation.option=<html>如果賦值是原始參數的轉換，則忽略</html>
assignment.to.method.parameter.problem.descriptor=賦值給方法參數 <code>\#ref</code> \#loc
assignment.to.null.display.name='null' 賦值
assignment.to.null.option=忽略對欄位的賦值
assignment.to.null.problem.descriptor='null' 已賦值給變數 <code>\#ref</code> \#loc
assignment.to.static.field.from.instance.method.display.name=從實例上下文賦值給 static 欄位
assignment.to.static.field.from.instance.method.problem.descriptor=從實例上下文賦值給 static 欄位 <code>\#ref</code> \#loc
assignment.to.superclass.field.display.name=建構函式將值賦給在超類別中定義的欄位
assignment.to.superclass.field.problem.descriptor=賦值給在超類別 ''{1}'' 中定義的欄位 ''{0}'' \#loc
assignment.used.as.condition.display.name=用作條件的賦值
assignment.used.as.condition.problem.descriptor=賦值 <code>\#ref</code> 作為條件使用 \#loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 宣告不一致
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 欄位未被宣告為 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 欄位 <code>\#ref</code> 未被宣告為 ''static final'' \#loc
auto.boxing.display.name=自動裝箱
auto.boxing.ignore.added.to.collection.option=忽略新增到集合的表達式
auto.boxing.make.boxing.explicit.quickfix=使裝箱顯式
auto.boxing.problem.descriptor=自動裝箱 <code>\#ref</code> \#loc
auto.closeable.resource.display.name=在沒有 'try-with-resources' 的情況下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在沒有 ''try-with-resources'' 語句的情況下使用 ''{0}'' \#loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.quickfix.preview=將方法 <code>{0}</code> 新增到忽略方法列表中
auto.closeable.resource.returned.option=忽略從所有方法呼叫返回的 AutoCloseable 實例
auto.unboxing.display.name=自動拆箱
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱顯式
auto.unboxing.problem.descriptor=自動拆箱 <code>\#ref</code> \#loc
await.not.in.loop.display.name=未在迴圈中呼叫的 'await()'
await.not.in.loop.problem.descriptor=<code>\#ref()</code> 呼叫不在迴圈中 \#loc
await.without.corresponding.signal.display.name=沒有相應 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在沒有相應 <code>signal()</code> 或 <code>signalAll()</code> 的情況下呼叫 <code>\#ref()</code> \#loc
bad.exception.caught.display.name=已捕獲禁止的 'Exception'
bad.exception.caught.problem.descriptor=已捕獲禁止異常 <code>\#ref</code> \#loc
bad.exception.declared.display.name=已宣告禁止異常
bad.exception.declared.problem.descriptor=已宣告禁止異常 <code>\#ref</code> \#loc
bad.exception.thrown.display.name=已拋出禁止異常
bad.exception.thrown.problem.descriptor=已拋出禁止異常 ''{0}'' \#loc
bad.oddness.display.name=可疑的奇數檢查
bad.oddness.problem.descriptor=對負值進行奇數檢查將會失敗 \#loc
big.decimal.equals.display.name=在 'BigDecimal' 上調用了 'equals()'
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>\#ref()</code> 可能應當是 'compareTo()' \#loc
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法呼叫沒有舍入模式實參
big.decimal.method.without.rounding.called.problem.descriptor=在沒有舍入模式實參的情況下呼叫了 'BigDecimal.\#ref()'
bigdecimal.legacy.method.display.name=呼叫了 'BigDecimal' 遺留方法
bigdecimal.legacy.method.problem.descriptor=對 'BigDecimal.\#ref()' 的呼叫可以使用 'RoundingMode' 枚舉常數
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚舉常數
boolean.constructor.display.name=布爾建構函式呼叫
boolean.constructor.problem.descriptor=布爾建構函式呼叫 \#loc
boolean.constructor.simplify.quickfix=簡化
boolean.expression.can.be.simplified.problem.descriptor=<code>\#ref</code> 可以簡化為 ''{0}'' \#loc
boolean.expression.does.not.modify.problem.descriptor=<code>\#ref</code> 未修改 ''{0}'' 的值 \#loc
boolean.expression.may.be.conditional.display.name=布爾表達式可被取代為條件表達式
boolean.expression.remove.compound.assignment.quickfix=移除無意義的複合賦值
boolean.field.always.inverted.problem.descriptor=布爾欄位 <code>\#ref</code> 始終反轉 \#loc
boolean.method.name.must.start.with.question.display.name=布爾方法名稱必須以疑問詞開頭
boolean.method.name.must.start.with.question.problem.descriptor=布爾方法名稱 <code>\#ref</code> 未以疑問詞開頭 \#loc
boolean.method.name.must.start.with.question.table.label=布爾方法名稱前綴\:
boolean.parameter.constructor.problem.descriptor='public' 建構函式 <code>\#ref()</code> 具有 'boolean' 參數 \#loc
boolean.parameter.display.name='public' 方法具有 'boolean' 參數
boolean.parameter.only.report.multiple.option=僅報告具有多個布爾參數的方法
boolean.parameter.problem.descriptor='public' 方法 <code>\#ref()</code> 具有 'boolean' 參數 \#loc
boolean.parameters.constructor.problem.descriptor='public' 建構函式 <code>\#ref()</code> 具有 'boolean' 參數 \#loc
boolean.parameters.problem.descriptor='public' 方法 <code>\#ref()</code> 具有 'boolean' 參數 \#loc
boolean.variable.always.inverted.display.name=布爾變數始終反轉
boolean.variable.always.inverted.problem.descriptor=布爾變數 <code>\#ref</code> 始終反轉 \#loc
bounded.wildcard.contravariant.descriptor=可以泛化為 <code>? super \#ref</code> \#loc
bounded.wildcard.covariant.descriptor=可以泛化為 <code>? extends \#ref</code> \#loc
bounded.wildcard.display.name=可以使用有界萬用字元
bounded.wildcard.report.instance.option=報告實例方法
bounded.wildcard.report.invariant.option=報告固定類別
bounded.wildcard.report.private.option=報告 private 方法
boxing.boxed.value.display.name=裝箱已裝箱的值
boxing.boxed.value.problem.descriptor=裝箱已裝箱的 <code>\#ref</code> \#loc
boxing.boxed.value.quickfix=移除不必要的裝箱
break.statement.display.name='break' 語句
break.statement.with.label.display.name=帶標籤的 'break' 語句
break.statement.with.label.problem.descriptor=帶標籤的 <code>\#ref</code> 語句 \#loc
busy.wait.display.name=忙等待
busy.wait.problem.descriptor=在迴圈中呼叫 <code>Thread.\#ref()</code>，可能處於忙等待 \#loc
c.style.array.declaration.display.name=C 樣式陣列宣告
c.style.array.declaration.replace.quickfix=取代為 Java 樣式陣列宣告
cached.number.constructor.call.display.name=數字建構函式呼叫具有基元實參
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字串實參的新數字表達式
cached.number.constructor.call.problem.descriptor=數字建構函式呼叫具有基元實參 \#loc
cached.number.constructor.call.report.only.deprecated=僅在建構函式為 @Deprecated 時報告
call.to.date.tostring.display.name=呼叫 'Date.toString()'
call.to.date.tostring.problem.descriptor=國際化上下文中使用的 <code>Date.\#ref()</code> \#loc
call.to.native.method.while.locked.display.name=鎖定時呼叫 'native' 方法
call.to.native.method.while.locked.problem.descriptor=在同步上下文中呼叫本地方法 <code>\#ref()</code> \#loc
call.to.numeric.tostring.display.name=呼叫 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=國際化上下文中呼叫的 <code>Number.\#ref()</code> \#loc
call.to.private.setter.in.class.option=僅在 setter 為 'private' 時報告
call.to.private.simple.getter.in.class.option=僅在 getter 為 'private' 時報告
call.to.simple.getter.in.class.display.name=從類別內呼叫簡單 getter
call.to.simple.getter.in.class.ignore.option=忽略其他物件上的 getter 呼叫
call.to.simple.getter.in.class.inline.quickfix=內聯呼叫 getter
call.to.simple.getter.in.class.problem.descriptor=從類別內呼叫簡單 getter <code>\#ref()</code> \#loc
call.to.simple.setter.in.class.display.name=從類別內呼叫簡單 setter
call.to.simple.setter.in.class.ignore.option=忽略其他物件上的 setter 呼叫
call.to.simple.setter.in.class.inline.quickfix=內聯呼叫 setter
call.to.simple.setter.in.class.problem.descriptor=從類別內呼叫簡單 setter <code>\#ref()</code> \#loc
call.to.string.concat.can.be.replaced.by.operator.display.name=對 'String.concat()' 的呼叫可被取代為 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=對 <code>\#ref()</code> 的呼叫可被取代為 '+' 表達式 \#loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 取代 'concat()'
call.to.suspicious.string.method.display.name=呼叫可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=國際化上下文中呼叫的 <code>String.\#ref()</code> \#loc
cast.conflicts.with.instanceof.display.name=轉換與 'instanceof' 衝突
cast.conflicts.with.instanceof.problem.descriptor=轉換為 ''{0}'' 類型將與前面的 ''instanceof {1}'' 檢查衝突
cast.conflicts.with.instanceof.quickfix1=在轉換中將 ''{0}'' 取代為 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中將 ''{0}'' 取代為 ''{1}''
cast.that.loses.precision.display.name=損失精度的數字轉換
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>\#ref</code> 的轉換可能導致負實參的精度損失 \#loc
cast.that.loses.precision.option=忽略從 int 到 char 的轉換
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>\#ref</code> 的轉換可能導致精度損失 \#loc
cast.to.concrete.class.problem.descriptor=轉換為具體類別 <code>{0}</code> \#loc
casting.to.incompatible.interface.display.name=轉換為不相容的類型
casting.to.incompatible.interface.problem.descriptor=將類型為 ''{1}'' 的表達式轉換為不相容的{0, choice, 1\#接口|2\#類別} <code>\#ref</code> \#loc
caught.exception.immediately.rethrown.display.name=捕獲的異常被立即重新拋出
caught.exception.immediately.rethrown.problem.descriptor=捕獲的異常 <code>\#ref</code> 被立即重新拋出 \#loc
chain.of.class.equality.checks.problem.descriptor=類別相等檢查鏈指示抽象失敗 \#loc
chain.of.instanceof.checks.display.name='instanceof' 檢查鏈
chain.of.instanceof.checks.problem.descriptor='instanceof' 檢查鏈指示抽象失敗 \#loc
chained.equality.comparisons.display.name=鏈式相等比較
chained.equality.comparisons.problem.descriptor=鏈式相等比較 <code>\#ref</code> \#loc
chained.method.call.display.name=鏈式方法呼叫
chained.method.call.ignore.option=忽略欄位初始設定式中的鏈式方法呼叫
chained.method.call.ignore.self.types.option=忽略對返回類型與其封閉類別相同的方法的呼叫
chained.method.call.problem.descriptor=鏈式方法呼叫 <code>\#ref()</code> \#loc
change.modifier.fix.family.name=更改修飾符
change.modifier.package.private.quickfix=設為 package-private
change.modifier.quickfix=設為 ''{0}''
channel.opened.not.closed.display.name=開啟了 'Channel'，但未安全關閉
char.used.in.arithmetic.content.cast.fix.family.name=插入轉換
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的轉換
char.used.in.arithmetic.context.display.name=在算術上下文中使用 'char' 表達式
char.used.in.arithmetic.context.problem.descriptor=算術上下文中使用了 'char' \#loc
char.used.in.arithmetic.context.quickfix=轉換為字串字面量
character.comparison.display.name=字元比較
character.comparison.problem.descriptor=國際化上下文中的字元比較 <code>\#ref</code> \#loc
checkbox.ignore.null.on.wrong.side=忽略錯誤側的 'null'
checked.exception.class.display.name=已檢查的異常類別
checked.exception.class.problem.descriptor=已檢查的異常類別 <code>\#ref</code> \#loc
choose.autocloseable.type.to.ignore.title=選擇要忽略的 AutoCloseable 資源類型
choose.class=選擇類別
choose.class.hierarchy.to.ignore.title=選擇要忽略的類別層次結構
choose.class.type.to.ignore=選擇要忽略的類別
choose.exception.class=選擇異常類別
choose.exception.label=被禁止的異常\:
choose.io.resource.type.to.ignore=選擇要忽略的 I/O 資源類型
choose.logger.class=選擇記錄器類別
class.escapes.defined.scope.display.module.option=報告在模組 API 中公開的非匯出類別(Java 9+)
class.escapes.defined.scope.display.name=類別在其可見性作用域之外公開
class.escapes.defined.scope.display.package.option=報告在 package-local API 中公開的 private 類別
class.escapes.defined.scope.display.public.option=報告在公開 API 中公開的不可存取類別
class.escapes.defined.scope.java9.modules.descriptor=類別 <code>\#ref</code> 未從模組 ''{0}'' 匯出
class.escapes.defined.scope.problem.descriptor=類別 <code>\#ref</code> 在其定義的可見性作用域之外公開 \#loc
class.extends.utility.class.display.name=類別擴展實用程序類別
class.extends.utility.class.ignore.utility.class.option=如果覆寫類別為實用程序類別，則忽略
class.extends.utility.class.problem.descriptor=類別 <code>\#ref</code> 擴展實用程序類別 ''{0}'' \#loc
class.independent.of.module.display.name=獨立於其模組的類別
class.independent.of.module.problem.descriptor=類別 <code>\#ref</code> 在其模組中沒有相依或相依項 \#loc
class.initializer.display.name=非 'static' 初始設定式
class.initializer.may.be.static.display.name=實例初始設定式可以設為 'static'
class.initializer.may.be.static.problem.descriptor=類別初始設定式可能為 'static' \#loc
class.initializer.move.code.to.constructor.quickfix=將初始設定式程式碼移至建構函式
class.initializer.option=僅在類別具有一個或多個建構函式時警告
class.initializer.problem.descriptor=非 'static' 初始設定式 \#loc
class.loader.instantiation.display.name='ClassLoader' 實例化
class.loader.instantiation.problem.descriptor=實例化 <code>\#ref</code> 可能造成安全問題 \#loc
class.may.be.interface.convert.quickfix=將類別轉換為接口
class.may.be.interface.display.name='abstract' 類別可以是 'interface'
class.may.be.interface.java8.option=使用 Java 8 時報告包含非 abstract 方法的類別
class.may.be.interface.problem.descriptor=抽象類別 <code>\#ref</code> 可能是接口 \#loc
class.name=類別名
class.name.differs.from.file.name.display.name=類別名與檔名不同
class.name.differs.from.file.name.problem.descriptor=類別名 <code>\#ref</code> 與檔名不同 \#loc
class.name.prefixed.with.package.name.display.name=使用軟體套件名稱作為前綴的類別名
class.name.prefixed.with.package.name.problem.descriptor=類別名 <code>\#ref</code> 以其軟體套件名稱開始 \#loc
class.name.same.as.ancestor.name.display.name=類別名與上級名稱相同
class.name.same.as.ancestor.name.problem.descriptor=類別名 <code>\#ref</code> 與其超類別的名稱之一相同 \#loc
class.naming.convention.display.name=類別命名約定
class.naming.convention.element.description=類別
class.new.instance.display.name=對 'Class.newInstance()' 的呼叫不安全
class.new.instance.problem.descriptor=對 <code>\#ref()</code> 的呼叫可能會拋出未宣告的已檢查的異常 \#loc
class.only.used.in.one.module.display.name=僅在其他模組中使用的類別
class.only.used.in.one.module.problem.descriptor=類別 <code>\#ref</code> 在其模組 ''{0}'' 中只有相依和/或相依性 \#loc
class.only.used.in.one.package.display.name=僅在其他軟體套件中使用的類別
class.only.used.in.one.package.problem.descriptor=類別 <code>\#ref</code> 在其軟體套件 ''{0}'' 中只有相依和/或相依項 \#loc
class.references.subclass.display.name=類別參照其子類別之一
class.references.subclass.problem.descriptor=類別 ''{0}'' 參照子類別 <code>\#ref</code> \#loc
class.references.subclass.problem.descriptor.anonymous=匿名類別參照子類別 <code>\#ref</code> \#loc
class.too.deep.display.name=類別在繼承樹中太深
class.too.deep.inheritance.depth.limit.option=繼承深度限制\:
class.too.deep.problem.descriptor=<code>\#ref</code> 在繼承樹中太深 (繼承深度 \= {0}) \#loc
class.unconnected.to.package.display.name=獨立於其軟體套件的類別
class.unconnected.to.package.problem.descriptor=類別 <code>\#ref</code> 在其軟體套件中沒有相依或相依項
class.with.only.private.constructors.display.name=僅包含 'private' 建構函式的類別應被宣告為 'final'
class.with.only.private.constructors.problem.descriptor=僅包含 'private' 建構函式的類別 <code>\#ref</code> 應被宣告為 'final'
class.with.too.many.dependencies.display.name=相依過多的類別
class.with.too.many.dependencies.max.option=最大相依項數
class.with.too.many.dependencies.problem.descriptor=類別 ''{0}'' 的相依過多 ({1} > {2})
class.with.too.many.dependents.display.name=相依項過多的類別
class.with.too.many.dependents.max.option=最大相依項數
class.with.too.many.dependents.problem.descriptor=類別 ''{0}'' 的相依項過多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可傳遞相依項過多的類別
class.with.too.many.transitive.dependencies.max.option=最大可傳遞相依項數
class.with.too.many.transitive.dependencies.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.with.too.many.transitive.dependents.display.name=傳遞相依項過多的類別
class.with.too.many.transitive.dependents.max.option=最大傳遞相依項數
class.with.too.many.transitive.dependents.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.without.constructor.create.quickfix=生成空建構函式
class.without.constructor.display.name=不帶建構函式的類別
class.without.constructor.problem.descriptor=類別 <code>\#ref</code> 沒有建構函式 \#loc
class.without.logger.annotations.tab=註解
class.without.logger.loggers.tab=記錄器
class.without.no.arg.constructor.display.name=沒有無實參建構函式的類別
class.without.no.arg.constructor.ignore.option=如果類別具有預設建構函式，則忽略
class.without.no.arg.constructor.problem.descriptor=類別 <code>\#ref</code> 缺少無實參建構函式 \#loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=將 'CloneNotSupportedException' 新增到 throws 子句
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>\#ref()</code> \#loc 未宣告 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' 建立新的 {0} 陣列 \#loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用建構函式實例化物件
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 建立新的 <code>\#ref</code> 實例 \#loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>\#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名類別中定義 \#loc
clone.method.in.non.cloneable.class.display.name=不可克隆類別中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>\#ref()</code> 在不可克隆類別 ''{0}'' 中定義 \#loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>\#ref()</code> 在不可克隆接口 ''{0}'' 中定義 \#loc
clone.returns.class.type.display.name='clone()' 應當具有等於其所包含類別的返回值類型
clone.returns.class.type.family.quickfix=將返回值類型更改為類別類型
clone.returns.class.type.problem.descriptor=''clone()'' 應當具有返回值類型 ''{0}'' \#loc
clone.returns.class.type.quickfix=將返回值類型更改為 ''{0}''
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆類別
cloneable.class.in.secure.context.problem.descriptor=類別 <code>\#ref</code> 可能被克隆，影響安全性 \#loc
cloneable.class.in.secure.context.quickfix=生成始終拋出異常的 'clone()' 方法
cloneable.class.without.clone.display.name=沒有 'clone()' 方法的可克隆類別
cloneable.class.without.clone.ignore.option=忽略由於繼承而可克隆的類別
cloneable.class.without.clone.ignore.when.clone.called.option=如果呼叫超類別的 clone() 方法需要 Cloneable，則忽略
cloneable.class.without.clone.problem.descriptor=<code>\#ref</code> 為 'Cloneable'，但未定義 'clone()' 方法 \#loc
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
cloneable.class.without.clone.todo.message=TODO\: 複製此處的可變狀態，這樣此克隆就不能更改初始克隆的內部項
collection.added.to.self.display.name=集合已新增到自身
collection.added.to.self.problem.descriptor=在以自身作為實參的集合 <code>\#ref</code> 上調用了 ''{0}()'' \#loc
collection.declared.by.class.display.name=按類別 (而不是接口) 宣告的集合
collection.declared.by.class.ignore.locals.option=忽略區域變數
collection.declared.by.class.ignore.private.members.option=忽略 'private' 欄位和方法
collection.declared.by.class.problem.descriptor=<code>\#ref</code> 的宣告可能應當被削弱為 ''{0}'' \#loc
collections.field.access.replaceable.by.method.call.display.name=對空集合欄位的參照可被取代為方法呼叫
collections.field.access.replaceable.by.method.call.fix.family.name=將 Collections.EMPTY_* 取代為呼叫
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>\#ref</code> 可被取代為 ''Collections.{0}'' \#loc
collections.must.have.initial.capacity.display.name=沒有初始容量的集合
collections.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new \#ref()</code> \#loc
commented.out.code.delete.quickfix=刪除註釋
commented.out.code.uncomment.quickfix=撤消程式碼註釋
comments.as.content.option=註釋計為內容
comparable.implemented.but.equals.not.overridden.display.name=已實作 'Comparable'，但 'equals()' 未被覆寫
comparable.implemented.but.equals.not.overridden.fix.add.note.name=新增 'ordering inconsistent with equals' JavaDoc 記錄
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
comparable.implemented.but.equals.not.overridden.problem.descriptor=類別 <code>\#ref</code> 實作 'java.lang.Comparable'，但未覆寫 'equals()' \#loc
comparator.not.serializable.display.name='Comparator' 類別未被宣告為 'Serializable'
comparator.not.serializable.problem.descriptor=比較器類別 <code>\#ref</code> 未被宣告為可序列化 \#loc
comparison.of.short.and.char.display.name=比較 'short' 和 'char' 值
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比較 <code>\#ref</code> \#loc
comparison.to.nan.display.name=與 'Double.NaN' 或 'Float.NaN' 比較
comparison.to.nan.problem.descriptor1=與 <code>\#ref</code> 的比較始終為 false \#loc
comparison.to.nan.problem.descriptor2=與 <code>\#ref</code> 的比較始終為 true \#loc
concrete.class.method.parameter.problem.descriptor=具體類別 <code>\#ref</code> 的參數 ''{0}'' \#loc
concrete.class.use.display.name=具體類別的使用
condition.signal.display.name=呼叫 'signal()' 而不是 'signalAll()'
condition.signal.problem.descriptor=<code>\#ref</code> 可能應當取代為 'signalAll()' \#loc
conditional.can.be.pushed.inside.expression.display.name=可以將條件推送到分支表達式內部
conditional.can.be.pushed.inside.expression.option=在條件將僅作為方法呼叫的實參時忽略
conditional.can.be.pushed.inside.expression.problem.descriptor=條件表達式可以推送到分支內 \#loc
conditional.can.be.pushed.inside.expression.quickfix=在分支內推送條件表達式
conditional.expression.display.name=條件表達式
conditional.expression.expression.context.option=忽略無法使用 if 語句的位置
conditional.expression.option=對簡單賦值和返回值忽略
conditional.expression.problem.descriptor=條件表達式 <code>\#ref</code> \#loc
conditional.expression.quickfix=取代為 'if' 語句
conditional.expression.with.identical.branches.collapse.quickfix=摺疊條件表達式
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的條件表達式 <code>\#ref</code> \#loc
confusing.else.option=當 'if' 語句之後沒有其他語句時報告
confusing.floating.point.literal.change.quickfix=更改為規範形式
confusing.floating.point.literal.display.name=引起混淆的浮點字面量
confusing.floating.point.literal.option=在科學記數法中忽略浮點字面量
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點字面量 <code>\#ref</code> \#loc
confusing.main.method.display.name=引起混淆的 'main()' 方法
confusing.main.method.problem.descriptor=方法 <code>\#ref</code> 沒有簽名 'public static void main(String[])' \#loc
confusing.octal.escape.sequence.display.name=引起混淆的八進制轉義序列
confusing.octal.escape.sequence.problem.descriptor=八進制轉義序列 <code>\#ref</code> 後面緊跟數字 \#loc
connection.opened.not.safely.closed.display.name=集合已開啟，但未安全關閉
consider.static.final.fields.constant.option=考慮 'static final' 欄位常數
constant.assert.condition.display.name='assert' 語句中的常數條件
constant.assert.condition.problem.descriptor=斷言條件 <code>\#ref</code> 是常數 \#loc
constant.conditional.expression.display.name=常數條件表達式
constant.conditional.expression.problem.descriptor=<code>\#ref</code> 可以簡化為 ''{0}'' \#loc
constant.conditional.expression.simplify.quickfix=簡化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用並簡化
constant.declared.in.abstract.class.display.name=在 'abstract' 類別中宣告的常數
constant.declared.in.abstract.class.problem.descriptor=常數 <code>\#ref</code> 在抽象類別中宣告 \#loc
constant.declared.in.interface.display.name=在接口中宣告的常數
constant.declared.in.interface.problem.descriptor=常數 <code>\#ref</code> 在接口中宣告 \#loc
constant.for.zero.length.array.display.name=不必要的零長度陣列用法
constant.for.zero.length.array.problem.descriptor=零長度陣列可更改為常數 \#loc
constant.for.zero.length.array.quickfix.family=取代為常數
constant.junit.assert.argument.display.name=常數斷言實參
constant.junit.assert.argument.problem.descriptor=實參 <code>\#ref</code> 是常數 \#loc
constant.math.call.display.name=對 'Math' 的常數呼叫
constant.math.call.problem.descriptor=對 <code>\#ref()</code> 的常數呼叫可以簡化 \#loc
constant.naming.convention.element.description=常數
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
constant.on.lhs.of.comparison.problem.descriptor=常數 <code>\#ref</code> 位於比較的左側 \#loc
constant.on.rhs.of.comparison.problem.descriptor=常數 <code>\#ref</code> 位於比較的右側 \#loc
constant.on.side.of.comparison.display.name=常數位於比較的錯誤一側
constant.value.variable.use.display.name=使用已知值為常數的變數
constant.value.variable.use.problem.descriptor=<code>\#ref</code> 的值已知為常數 \#loc
constant.with.mutable.field.naming.convention.element.description=具有可變類型的常數
constructor.visibility.option=忽略具有以下可見性的建構函式\:
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
continue.or.break.from.finally.block.problem.descriptor=<code>\#ref</code> 位於 'finally' 塊內 \#loc
continue.statement.display.name='continue' 語句
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
continue.statement.with.label.problem.descriptor=帶標籤的 <code>\#ref</code> 語句 \#loc
control.flow.statement.without.braces.add.quickfix=將大括號新增到語句
control.flow.statement.without.braces.display.name=不帶大括號的控制流語句
control.flow.statement.without.braces.message=將大括號新增到 ''{0}'' 語句
control.flow.statement.without.braces.problem.descriptor=不帶大括號的 <code>{0}</code> \#loc
convert.double.unary.quickfix=取代為 ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
convert.octal.literal.to.decimal.literal.quickfix=將八進制字面量轉換為十進制字面量
convert.octal.literals.to.decimal.literals.quickfix=將八進制字面量轉換為十進制字面量
convert.system.out.to.log.call.family.name=將 'System.out' 呼叫轉換為日誌呼叫
convert.system.out.to.log.call.name=將 ''System.out'' 呼叫轉換為對 ''{0}'' 的呼叫
convert.to.variable.arity.method.quickfix=轉換為 vararg 方法
copy.constructor.misses.field.display.name=複製缺少欄位的建構函式
copy.constructor.misses.field.problem.descriptor.1=複製未複製欄位 ''{0}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.2=複製未複製欄位 ''{0}'' 和 ''{1}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.3=複製未複製欄位 ''{0}''、''{1}'' 和 ''{2}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.many=複製未複製 {0} 個欄位的建構函式
covariant.equals.display.name=協變 'equals()'
covariant.equals.problem.descriptor=<code>\#ref()</code> 應當以 'Object' 作為其實參 \#loc
create.default.branch.fix.family.name=建立 'default' 分支
create.missing.boolean.switch.branches.fix.family.name=建立缺少的布爾 switch 分支
create.missing.branches.with.null.branch.fix.family.name=建立缺少的分支和 'null' 分支
create.missing.enum.switch.branches.fix.family.name=建立缺少的枚舉 switch 分支
create.missing.record.deconstructions.switch.branches.fix.family.name=建立缺失記錄解構 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=建立缺少的密封類別 switch 分支
create.missing.switch.branch=建立缺少的分支 {0}
create.missing.switch.branches=建立缺少的分支 {0}
create.null.branch.fix.family.name=建立 'null' 分支
create.package.info.java.family.name=建立 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=方法 <code>{0}()</code> 具有 C 樣式陣列返回值類型宣告 \#loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1\#欄位|2\#參數|3\#記錄組件|4\#區域變數} <code>{1}</code> 具有 C 樣式陣列類型宣告 \#loc
custom.classloader.display.name=宣告了自訂的 'ClassLoader'
custom.classloader.problem.descriptor=自訂 ClassLoader 類別 <code>\#ref</code> \#loc
custom.security.manager.display.name=自訂 'SecurityManager'
custom.security.manager.problem.descriptor=自訂 SecurityManager 類別 <code>\#ref</code> \#loc
cyclic.class.dependency.1.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}''
cyclic.class.dependency.2.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}'' 和 ''{2}''
cyclic.class.dependency.display.name=迴圈類別相依
cyclic.class.dependency.ignore.in.same.file=忽略位於同一檔案中的類別之間的迴圈
cyclic.class.dependency.problem.descriptor=類別 ''{0}'' 迴圈依賴於其他 {1} 個類別
cyclic.package.dependency.1.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}''
cyclic.package.dependency.2.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=迴圈軟體套件相依關係
cyclic.package.dependency.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於其他 {1} 個軟體套件
cyclomatic.complexity.display.name=過度複雜的方法
cyclomatic.complexity.limit.option=迴圈復雜度限制\:
cyclomatic.complexity.problem.descriptor=過度複雜的方法 <code>\#ref()</code> (迴圈復雜度 \= {0}) \#loc
dangling.javadoc.convert.line.comment.quickfix=取代為行註釋
dangling.javadoc.convert.quickfix=取代為塊註釋
dangling.javadoc.delete.quickfix=移除懸空的註釋
dangling.javadoc.display.name=懸空的 Javadoc 註釋
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的檔案頭註釋
dangling.javadoc.problem.descriptor=懸空的 Javadoc 註釋 \#loc
debug.level.and.lower.option=偵錯級別和更低
declare.collection.as.interface.fix.family.name=削弱類型
declare.collection.as.interface.quickfix=削弱為 ''{0}''
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
default.not.last.case.in.switch.problem.descriptor=''default'' 分支不是 ''switch'' {0} 中的最後一個 case \#loc
default.tostring.call.display.name=呼叫預設 'toString()'
default.tostring.call.problem.descriptor=呼叫 <code>\#ref</code> 上的預設 'toString()' \#loc
delete.catch.section.fix.family.name=刪除 catch 語句
delete.catch.section.quickfix=刪除 'catch' 部分
delete.import.quickfix=刪除不必要的匯入
delete.unnecessary.statement.fix.family.name=移除冗餘語句
deserializable.class.in.secure.context.problem.descriptor=類別 <code>\#ref</code> 可能被反序列化，影響安全性 \#loc
design.for.extension.display.name=為擴展設計
design.for.extension.problem.descriptor=方法 <code>\#ref()</code> 可能被覆寫，其功能會被忽略 \#loc
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可被取代為顯式類型實參
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=將 '<>' 取代為顯式類型實參
disjoint.package.display.name=具有不相交相依關係圖的軟體套件
disjoint.package.problem.descriptor=軟體套件 {0} 可以分解為 {1} 個獨立軟體套件
divide.by.zero.display.name=除以零
divide.by.zero.problem.descriptor=除以零 \#loc
dollar.sign.in.name.display.name=在關鍵字中使用 '$'
dollar.sign.in.name.problem.descriptor=關鍵字 <code>\#ref</code> 包含 '$' \#loc
double.brace.initialization.display.name=雙大括號初始化
double.brace.initialization.quickfix=取代為正則初始化
double.checked.locking.display.name=雙重檢查鎖定
double.checked.locking.fix.family.name=將欄位設為 volatile
double.checked.locking.problem.descriptor=雙重檢查鎖定 \#loc
double.checked.locking.quickfix=將 ''{0}'' 設為 volatile
double.literal.may.be.float.literal.display.name=轉換為 'float' 可以是 'float' 字面量
double.negation.display.name=雙重否定
double.negation.problem.descriptor=<code>\#ref</code> 中的雙重否定 \#loc
double.negation.quickfix=移除雙重否定
drivermanager.call.display.name=使用 'DriverManager' 獲取 JDBC 連線
drivermanager.call.problem.descriptor=呼叫 <code>DriverManager.\#ref()</code> \#loc
dumpstack.call.display.name=呼叫 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=對 <code>Thread.\#ref()</code> 的呼叫可能應當取代為更可靠的日誌 \#loc
duplicate.condition.display.name=條件重複
duplicate.condition.ignore.method.calls.option=忽略可能有副作用的條件
duplicate.condition.ignore.method.calls.option.description=如果選中，則不會報告具有潛在副作用的條件(例如，未知的方法呼叫)。已知會產生副作用的方法在任何情況下都不會被報告。
duplicate.condition.problem.descriptor=重複條件 <code>\#ref</code> \#loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=動態正則表達式可被取代為已編譯的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>\#ref()</code> 可被取代為已編譯的 'java.util.regex.Pattern' 結構 \#loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=取代為對已編譯 'Pattern' 常數的方法的呼叫
empty.anonymous.class.problem.descriptor=匿名類別為空 \#loc
empty.class.display.name=空類別
empty.class.file.without.class.problem.descriptor=Java 檔案未宣告任何類別 \#loc
empty.class.ignore.parameterization.option=如果類別是父類型的參數化，則將其忽略
empty.class.initializer.delete.quickfix=刪除空類別初始設定式
empty.class.initializer.display.name=空類別初始設定式
empty.class.initializer.problem.descriptor=空類別初始設定式 \#loc
empty.class.problem.descriptor=類別 <code>\#ref</code> 為空 \#loc
empty.enum.problem.descriptor=枚舉 <code>\#ref</code> 為空 \#loc
empty.finally.block.display.name=空 'finally' 塊
empty.finally.block.problem.descriptor=空 <code>\#ref</code> 塊 \#loc
empty.synchronized.statement.display.name=空 'synchronized' 語句
empty.synchronized.statement.problem.descriptor=空 <code>\#ref</code> 語句 \#loc
empty.try.block.display.name=空 'try' 塊
empty.try.block.problem.descriptor=空 <code>\#ref</code> 塊 \#loc
encapsulate.variable.fix.family.name=封裝欄位
encapsulate.variable.quickfix=封裝欄位 ''{0}''
enum.singleton.problem.descriptor=枚舉 <code>\#ref</code> 為單例 \#loc
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚舉 'switch' 語句
enum.switch.statement.which.misses.cases.option=忽略具有預設分支的 switch 語句
enum.switch.statement.which.misses.cases.problem.descriptor=枚舉類型 ''{0}'' 上的 <code>\#ref</code> 語句缺少 case {1} \#loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚舉類型 ''{0}'' 上的 <code>\#ref</code> 語句缺少 case ''{1}'' \#loc
enumerated.class.display.name=枚舉類別
enumerated.class.naming.convention.element.description=枚舉類別
enumerated.class.problem.descriptor=枚舉類別 <code>\#ref</code> \#loc
enumerated.constant.naming.convention.element.description=枚舉常數
enumeration.can.be.iteration.display.name=枚舉可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>\#ref()</code> 可被取代為 ''{0}'' 結構 \#loc
enumeration.can.be.iteration.quickfix=取代為 'Iterator' 結構
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 取代 '\=\='
equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子類別，則發出警告
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到屬於 ''{0}'' 和 ''{1}'' 這兩個子類型的類別 \#loc
equals.between.inconvertible.types.problem.descriptor=<code>\#ref</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 \#loc
equals.called.on.array.display.name=在陣列上呼叫了 'equals()'
equals.called.on.array.problem.descriptor=陣列之間的 <code>\#ref()</code> 可能應當是 'Arrays.equals()' \#loc
equals.called.on.enum.constant.display.name=對枚舉值呼叫了 'equals()'
equals.called.on.enum.constant.problem.descriptor=對枚舉值呼叫了 <code>\#ref()</code> \#loc
equals.called.on.suspicious.object.display.name=在不對其進行覆寫的類別上呼叫了 'equals()'
equals.called.on.suspicious.object.fix.family.name=取代為代表值的比較
equals.called.on.suspicious.object.fix.name=取代為 ''{0}()'' 呼叫結果的比較
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 物件上存在可疑的 ''equals()'' 呼叫
equals.doesnt.check.class.parameter.display.name=不檢查其參數的類別的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>\#ref()</code> 應當檢查其參數的類別 \#loc
equals.replaceable.by.objects.call.display.name='equals()' 表達式可被取代為 'Objects.equals()' 表達式
equals.replaceable.by.objects.call.problem.descriptor=<code>\#ref</code> 可被取代為 'Objects.equals()' 表達式 \#loc
equals.replaceable.by.objects.check.not.null.option=醒目提示與 'a \!\= null \\&\\& a.equals(b)' 類似的表達式
equals.with.itself.display.name=在自身上呼叫了 'equals()'
equals.with.itself.option=忽略可能的約定測試
equals.with.itself.option.description=選中後，某些情況(如 <code>assertEquals(myObj, myObj)</code>)將不會被報告，以避免在檢查 <code>equals()</code> 方法正確性的測試中出現警告。
equals.with.itself.problem.descriptor=在自身上呼叫了 <code>\#ref()</code>
error.rethrown.display.name='Error' 未重新拋出
error.rethrown.problem.descriptor=錯誤 <code>\#ref</code> 未重新拋出 \#loc
exception.from.catch.which.doesnt.wrap.display.name='throw' 位於忽略已捕獲異常的 'catch' 塊內
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 塊內的 <code>\#ref</code> 忽略捕獲的異常 \#loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果拋出的異常無法包裝異常，則忽略
exception.from.catch.which.doesntwrap.ignore.option=如果使用異常方法呼叫的結果，則忽略
exception.name.doesnt.end.with.exception.display.name=異常類別名不以 'Exception' 結尾
exception.name.doesnt.end.with.exception.problem.descriptor=異常類別名 <code>\#ref</code> 未以 'Exception' 結尾 \#loc
exception.package.display.name=異常軟體套件
exception.package.problem.descriptor=軟體套件 ''{0}'' 僅包含異常類別
explicit.array.to.string.problem.descriptor=呼叫陣列上的 '\#ref()' \#loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可被取代為 {1}
expression.can.be.replaced.problem.descriptor=<code>\#ref</code> 可被取代為 ''{0}'' \#loc
expression.may.be.factorized.display.name=表達式可以因式分解
extend.exception.fix.family.name=使類別擴展 'Exception'
extended.for.statement.display.name=增強的 'for' 語句
extended.for.statement.problem.descriptor=擴展 <code>\#ref</code> 語句 \#loc
extended.for.statement.replace.quickfix=取代為舊式 'for' 語句
extends.annotation.display.name=類別擴展註解接口
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 擴展註解接口 <code>\#ref</code> \#loc
extends.annotation.problem.descriptor=類別 ''{0}'' 實作註解接口 <code>\#ref</code> \#loc
extends.concrete.collection.display.name=類別顯式擴展 'Collection' 類別
extends.concrete.collection.problem.descriptor=類別 <code>\#ref</code> 顯式擴展 ''{0}'' \#loc
extends.object.display.name=類別顯式擴展 'Object'
extends.object.problem.descriptor=類別 <code>\#ref</code> 顯式擴展 'java.lang.Object' \#loc
extends.object.remove.quickfix=移除冗餘的 'extends Object'
extends.thread.display.name=類別直接擴展 'Thread'
extends.thread.problem.descriptor=類別 <code>\#ref</code> 直接擴展 'java.lang.Thread' \#loc
extends.throwable.display.name=類別直接擴展 'Throwable'
extends.throwable.problem.descriptor=類別 <code>\#ref</code> 直接擴展 'java.lang.Throwable' \#loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化類別
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1\#類別|2\#接口|3\#派生的匿名類別|4\#註解類型|5\#枚舉|6\#記錄} <code>\#ref</code> 定義 'readObject()' 和 'writeObject()' \#loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1\#類別|2\#接口|3\#派生的匿名類別|4\#註解類型|5\#枚舉|6\#記錄} <code>\#ref</code> 定義 'readObject()' \#loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1\#類別|2\#接口|3\#派生的匿名類別|4\#註解類型|5\#枚舉|6\#記錄} <code>\#ref</code> 定義 'writeObject()' \#loc
externalizable.without.public.no.arg.constructor.display.name=沒有 'public' 無實參建構函式的 'Externalizable' 類別
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化類別 <code>\#ref</code> 沒有 'public' 無實參建構函式 \#loc
extract.method.quickfix=提取方法
extract.parameter.as.local.variable.quickfix=提取參數作為區域變數
fallthru.in.switch.statement.display.name='switch' 語句中的直落
fallthru.in.switch.statement.problem.descriptor='switch' 語句存在直落 \#loc
fallthru.in.switch.statement.quickfix=新增 ''{0}''
feature.envy.display.name=特性依戀
feature.envy.problem.descriptor=類別 ''{0}'' 在方法 <code>\#ref()</code> 中被重複存取 \#loc
field.accessed.synchronized.and.unsynchronized.display.name=同時在 'synchronized' 和未同步上下文中存取欄位
field.accessed.synchronized.and.unsynchronized.option=簡單的 getter 和 setter 也被視為欄位存取
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同時在同步和未同步上下文中存取欄位 <code>\#ref</code> \#loc
field.count.inspection.include.constant.fields.in.count.checkbox=在計數中包含常數欄位
field.count.inspection.include.enum.constants.in.count=在計數中包含枚舉常數
field.count.inspection.static.final.fields.count.as.constant.checkbox=將 'static final' 欄位計為常數
field.has.setter.but.no.getter.display.name=欄位具有 setter 但沒有 getter
field.has.setter.but.no.getter.problem.descriptor=欄位 <code>\#ref</code> 有 setter 但沒有 getter \#loc
field.has.static.modifier.problem.descriptor=欄位 ''{0}'' 具有 ''static'' 修飾符
field.incorrect.type.problem.descriptor=欄位 ''{0}'' 沒有類型 ''{1}''
field.may.be.final.display.name=欄位可能為 'final'
field.may.be.final.problem.descriptor=欄位 <code>\#ref</code> 可能為 'final' \#loc
field.may.be.static.display.name=欄位可以為 'static'
field.may.be.static.problem.descriptor=欄位 <code>\#ref</code> 可能為 'static' \#loc
field.missing.volatile.modifier.problem.descriptor=欄位 ''{0}'' 沒有 ''volatile'' 修飾符
field.name.hides.in.superclass.display.name=子類別欄位隱藏超類別欄位
field.name.hides.in.superclass.ignore.option=忽略不可存取欄位
field.name.hides.in.superclass.ignore.static.field.option=忽略隱藏 static 欄位的 static 欄位
field.name.hides.in.superclass.problem.descriptor=欄位 <code>\#ref</code> 隱藏超類別中的欄位 \#loc
field.naming.convention.display.name=欄位命名約定
field.not.found.in.class.problem.descriptor=類別 ''{1}'' 中未找到命名為 ''{0}'' 的欄位
final.class.display.name=類別禁止繼承
final.class.problem.descriptor=類別 ''{0}'' 宣告了 <code>\#ref</code> \#loc
final.method.display.name=不能覆寫方法
final.method.in.final.class.display.name='final' 類別位於 'final' 方法中
final.method.in.final.class.problem.descriptor=方法在 'final' 類別中被宣告為 <code>\#ref</code> \#loc
final.method.problem.descriptor=方法被宣告為 <code>\#ref</code> \#loc
final.private.method.display.name='private' 方法被宣告為 'final'
final.private.method.problem.descriptor='private' 方法被宣告為 <code>\#ref</code> \#loc
final.static.method.display.name='static' 方法被宣告為 'final'
final.static.method.problem.descriptor='static' 方法被宣告為 <code>\#ref</code> \#loc
finalize.called.explicitly.display.name='finalize()' 被顯式呼叫
finalize.called.explicitly.problem.descriptor=<code>\#ref()</code> 被顯式呼叫 \#loc
finalize.declaration.display.name='finalize()' 不應被覆寫
finalize.declaration.problem.descriptor='finalize()' 不應被覆寫 \#loc
finalize.not.declared.protected.display.name='finalize()' 應為 protected，不應為 public
finalize.not.declared.protected.problem.descriptor='finalize()' 應具有 protected 存取權限，不應具有 public 存取權限 \#loc
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 塊
finally.block.cannot.complete.normally.problem.descriptor=<code>\#ref</code> 塊無法正常完成 \#loc
fix.add.argument.family.name=新增實參
fix.add.argument.name=新增 ''{0}'' 實參
fix.eliminate.folded.if.present.description=可以消除折疊的 'ifPresent()' 呼叫
fix.eliminate.folded.if.present.name=移除折疊的 'ifPresent()' 呼叫
fix.replace.map.with.flat.map.description='map()' 可被取代為 'flatMap()'
flip.comparison.quickfix=翻轉比較
floating.point.equality.display.name=浮點相等比較
floating.point.equality.problem.descriptor=<code>\#ref</code>\: 比較浮點值以實作完全相等 \#loc
for.can.be.foreach.display.name='for' 迴圈可被取代為增強的 for 迴圈
for.can.be.foreach.fix.no.indexed=不報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option=報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option2=不報告無類型集合上的迭代
for.can.be.foreach.problem.descriptor=<code>\#ref</code> 迴圈可被取代為增強的 'for' \#loc
for.loop.replaceable.by.while.display.name='for' 迴圈可被取代為 'while' 迴圈
for.loop.replaceable.by.while.ignore.option=忽略無條件迴圈的 'infinite'
for.loop.replaceable.by.while.problem.descriptor=<code>\#ref</code> 迴圈語句可被取代為 'while' 迴圈 \#loc
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
for.loop.with.missing.component.display.name=缺少組件的 'for' 迴圈
for.loop.with.missing.component.problem.descriptor1=<code>\#ref</code> 語句缺少初始設定式 \#loc
for.loop.with.missing.component.problem.descriptor2=<code>\#ref</code> 語句缺少條件 \#loc
for.loop.with.missing.component.problem.descriptor3=<code>\#ref</code> 語句缺少更新 \#loc
for.loop.with.missing.component.problem.descriptor4=<code>\#ref</code> 語句缺少初始設定式和條件 \#loc
for.loop.with.missing.component.problem.descriptor5=<code>\#ref</code> 語句缺少初始設定式和條件 \#loc
for.loop.with.missing.component.problem.descriptor6=<code>\#ref</code> 語句缺少條件和更新 \#loc
for.loop.with.missing.component.problem.descriptor7=<code>\#ref</code> 語句缺少初始設定式、條件和更新 \#loc
foreach.replace.quickfix=取代為增強 'for'
format.string.error.duplicate.flag=''{1}'' 中存在重複的標誌 ''{0}''
format.string.error.flags.not.allowed=''{1}'' 中不允許使用{2, choice, 1\#標誌|1<標誌} ''{0}''
format.string.error.illegal.flag.combination=''{2}'' 中的標誌組合 ''{0}'' 和 ''{1}'' 非法
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置說明符 ''{0}''
format.string.error.invalid.precision=''{0}'' 中指定的精度無效
format.string.error.left.justify.no.width=使用了左對齊標誌 ''-''，但 ''{0}'' 中未指定寬度
format.string.error.precision.not.allowed=''{1}'' 中不允許該精度 (''{0}'')
format.string.error.previous.element.not.found=使用了以前的標誌 '<'，但沒有找到 ''{0}'' 以前的格式說明符
format.string.error.unexpected.flag=''{1}'' 中出現意外字元 ''{0}''
format.string.error.unknown.conversion=''{0}'' 中存在未知的轉換
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的實參位置說明符 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允許該寬度 (''{0}'')
format.string.error.zero.padding.no.width=使用了零填充標誌 ''0''，但 ''{0}'' 中未指定寬度
gc.call.display.name=呼叫 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>\#ref</code> 不應在生產程式碼中呼叫 \#loc
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
hardcoded.file.separator.display.name=硬編碼檔案分隔符
hardcoded.file.separator.ignore.methods.option=忽略以下方法的實參\:
hardcoded.file.separator.include.option=在已識別的 MIME 媒體類型中包括 'example/*'
hardcoded.file.separator.problem.descriptor=硬編碼檔案分隔符 <code>\#ref</code> \#loc
hardcoded.line.separator.display.name=硬編碼行分隔符
hardcoded.line.separator.problem.descriptor=硬編碼行分隔符 <code>\#ref</code> \#loc
hibernate.resource.opened.not.closed.display.name=Hibernate 資源已開啟，但未安全關閉
html.tag.can.be.javadoc.tag.display.name='<code>…</code>' 可被取代為 '{@code …}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\#ref...\\&lt;/code\\&gt;</code> 可被取代為 '{@code …}' \#loc
i.o.resource.opened.not.closed.display.name=I/O 資源已開啟，但未安全關閉
if.can.be.assertion.name=語句可被取代為 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=將語句取代為 'assert' 語句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=將語句取代為 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' 可被取代為 'switch'
if.can.be.switch.enum.option=對枚舉啟用 switch 建議
if.can.be.switch.int.option=對數字啟用 switch 建議
if.can.be.switch.minimum.branch.option='if' 條件分支的最小數量\:
if.can.be.switch.null.safe.option=僅對 null-safe 表達式啟用建議
if.can.be.switch.problem.descriptor=<code>\#ref</code> 語句可被取代為 'switch' 語句 \#loc
if.may.be.conditional.problem.descriptor=<code>\#ref</code> 可被取代為條件表達式 \#loc
if.may.be.conditional.quickfix=取代為條件表達式
if.may.be.factorized.problem.descriptor=<code>\#ref</code> 可以因式分解 \#loc
if.may.be.factorized.quickfix=取代為因式分解表達式
if.statement.with.identical.branches.display.name=具有相同分支或通用部分的 'if' 語句
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
if.statement.with.too.many.branches.max.option=最大分支數\:
if.statement.with.too.many.branches.problem.descriptor=<code>\#ref</code> 的分支過多 ({0}) \#loc
ignore.accesses.from.equals.method=忽略來自 'equals()' 方法的存取
ignore.accesses.from.the.same.class=忽略來自同一類的存取
ignore.anonymous.inner.classes=忽略匿名類別
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布爾方法
ignore.branches.of.switch.statements=忽略 'switch' 語句的分支
ignore.calls.to.property.getters=忽略對屬性 getter 的呼叫
ignore.calls.to.static.methods=忽略對 static 方法的呼叫
ignore.classes.annotated.by=由以下物件註解時忽略類別\:
ignore.classes.in.hierarchy.column.name=忽略以下物件的子類別\:
ignore.cloneable.option=忽略 'java.lang.Cloneable'
ignore.constructor.method.references=忽略產生 AutoCloseable 的建構函式方法參照
ignore.enhanced.for.loop.statements=忽略增強型 for 迴圈
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.exceptions.declared.on.library.override.option=忽略在覆寫庫方法的方法上宣告的異常(&L)
ignore.for.equals.methods.option=對 'equals()' 方法忽略(&E)
ignore.getters.returning.resource=忽略返回源的 getter
ignore.guard.clauses.option=忽略 guard 子句(&G)
ignore.if.annotated.by=由以下物件註解時忽略\:
ignore.in.module.statements.option=在 Java 9 模組語句中忽略
ignore.instanceof.on.library.classes=忽略庫類別上的 instanceof
ignore.methods.in.anonymous.classes=忽略匿名類別中的方法
ignore.methods.overriding.super.method=忽略覆寫/實作 super 方法的方法(O&)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回值類型的方法(&B)
ignore.overflowing.byte.casts.option=忽略從 int 128-255 到位元組的轉換
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略單個非正式類型 lambda 參數周圍的括號
ignore.private.methods.option=忽略 private 方法中的賦值和返回值
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.single.field.static.imports.option=忽略單欄位 static import(&F)
ignore.single.method.static.imports.option=忽略單方法 static import(&M)
ignore.trivial.finalizers.option=對普通 'finalize()' 實作忽略
ignored.autocloseable.types.label=已忽略的 AutoCloseable 資源類型\:
ignored.class.hierarchies.border.title=忽略以下物件的子類別\:
ignored.class.label=已忽略類別(包括子類別)\:
ignored.class.names=忽略類別(包括子類別)
ignored.io.resource.types.label=已忽略的 I/O 資源類型\:
implicit.array.to.string.display.name=呼叫陣列上的 'toString()'
implicit.array.to.string.fix.family.name=將 Array.toString() 設為隱式
implicit.array.to.string.method.call.problem.descriptor=隱式呼叫呼叫 <code>\#ref</code> 返回的陣列上的 'toString()' \#loc
implicit.array.to.string.problem.descriptor=隱式呼叫陣列 <code>\#ref</code> 上的 'toString()' \#loc
implicit.array.to.string.quickfix=使用 ''{0}'' 表達式包裝
implicit.call.to.super.display.name=隱式呼叫 'super()'
implicit.call.to.super.ignore.option=對 'java.lang.Object' 的直接子類別忽略
implicit.call.to.super.make.explicit.quickfix=使對 'super()' 的呼叫顯式
implicit.call.to.super.problem.descriptor=隱式呼叫 'super()' \#loc
implicit.default.charset.usage.constructor.problem.descriptor=<code>new \#ref()</code> 呼叫使用平台的預設字符集
implicit.default.charset.usage.display.name=隱式平台預設字符集
implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集
implicit.default.charset.usage.problem.descriptor=對 <code>\#ref()</code> 的呼叫使用平台的預設字符集
implicit.numeric.conversion.assignment.problem.descriptor=將結果值從 ''{0}'' 隱式數字轉換為 ''{1}'' \#loc
implicit.numeric.conversion.display.name=隱式數字轉換
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之間的轉換
implicit.numeric.conversion.ignore.constant.conversion.option=忽略從常數和字面量的轉換
implicit.numeric.conversion.ignore.widening.conversion.option=忽略擴大轉換
implicit.numeric.conversion.make.explicit.quickfix=使轉換顯式
implicit.numeric.conversion.problem.descriptor=將 <code>\#ref</code> 從 ''{0}'' 隱式數字轉換為 ''{1}'' \#loc
import.display.name='*' 匯入
import.from.same.package.display.name=相同軟體套件中的不必要 import
import.from.same.package.problem.descriptor=相同軟體套件 <code>\#ref</code> 中有不必要的 import \#loc
import.problem.descriptor=軟體套件匯入 <code>\#ref</code> \#loc
include.java.system.classes.option=包括與 Java 系統類別的耦合
include.library.classes.option=包括與庫類別的耦合
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code> 始終為 false \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code> 始終為 true \#loc
incorrect.date.format.fix.family.name=修復不正確的日期格式
increment.decrement.display.name=使用 '++' 或 '--' 的結果
increment.decrement.used.as.expression.fix.family.name=提取到分離語句中
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分離語句
inequality.to.safe.not.equals.quickfix=用 null 安全 '\!equals()' 取代 '\!\='
infinite.loop.statement.display.name=無限迴圈語句
infinite.loop.statement.problem.descriptor=<code>\#ref</code> 語句不能在未拋出異常的情況下完成 \#loc
infinite.recursion.display.name=無限遞迴
infinite.recursion.problem.descriptor=方法 <code>\#ref()</code> 無限遞迴，只能以拋出異常結束 \#loc
info.level.and.lower.option=資訊級別和更低
inline.call.quickfix=內聯呼叫
inline.variable.quickfix=內聯變數
inner.class.field.hides.outer.display.name=內部類別欄位隱藏外部類別欄位
inner.class.field.hides.outer.ignore.option=忽略從內部類別不可見的外部欄位
inner.class.field.hides.outer.problem.descriptor=內部類別欄位 <code>\#ref</code> 隱藏外部類別欄位 \#loc
inner.class.may.be.static.display.name=內部類別可能為 'static'
inner.class.may.be.static.problem.descriptor=內部類別 <code>\#ref</code> 可能為 'static' \#loc
inner.class.on.interface.display.name=接口的內部類別
inner.class.on.interface.ignore.option=忽略接口的內部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有內部類別 <code>\#ref</code> \#loc
inner.class.referenced.via.subclass.display.name=通過子類別參照的內部類別
inner.class.referenced.via.subclass.problem.descriptor=內部類別 <code>\#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \#loc
inner.class.referenced.via.subclass.quickfix=使內部類別存取合理化
inner.class.too.deeply.nested.display.name=內部類別嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制\:
inner.class.too.deeply.nested.problem.descriptor=<code>\#ref</code> 嵌套太深 (嵌套級別 \= {0}) \#loc
inspection.autocloseable.resource.ignored.methods.title=忽略從這些方法返回的 AutoCloseable 實例\:
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 轉換低效
inspection.case.mismatch.display.name='String' 動作中不符合的大小寫
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始終返回 {1}\: 實參包含小寫符號，而限定符不包含小寫符號
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始終返回 {1}\: 實參包含大寫符號，而限定符不包含大寫符號
inspection.case.mismatch.message.label.is.lower=無法存取 switch 分支\: 標籤包含小寫符號，而選擇器僅支援大寫
inspection.case.mismatch.message.label.is.upper=無法存取 switch 分支\: 標籤包含大寫符號，而選擇器僅支援小寫
inspection.cast.can.be.replaced.with.variable.display.name=轉換可被取代為變數
inspection.cast.can.be.replaced.with.variable.family.name=用變數取代轉換
inspection.cast.can.be.replaced.with.variable.message=可以使用變數 ''{0}'' 替代 ''{1}''
inspection.catch.ignores.exception.display.name=catch 塊可能會忽略異常
inspection.catch.ignores.exception.empty.message=空 <code>\#ref</code> 塊 \#loc
inspection.catch.ignores.exception.option.comments=當 'catch' 塊包含註釋時不發出警告
inspection.catch.ignores.exception.option.ignored.used=當名稱為 'ignore(d)' 的異常實際上未被忽略時不發出警告
inspection.catch.ignores.exception.option.nonempty=當 'catch' 塊不為空時不發出警告
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 參數 <code>\#ref</code> \#loc
inspection.catch.ignores.exception.used.message=已使用命名為 <code>\#ref</code> 的 'catch' 參數 \#loc
inspection.catch.ignores.exception.vm.ignored.message=<code>\#ref</code> 塊中可能會忽略 ''{0}'' 之類的意外虛擬機異常 \#loc
inspection.collection.must.have.initial.capacity.initializers.option=不報告欄位初始設定式
inspection.commented.out.code.disable.short.fragments=不報告此類別短片段
inspection.commented.out.code.display.name=註釋掉的程式碼
inspection.commented.out.code.min.lines.options=最少程式碼行數
inspection.commented.out.code.problem.descriptor=註釋掉的程式碼 ({0} {0, choice, 1\#行|1<行})
inspection.common.if.parts.description.complete.duplicate=可以摺疊 ''if'' 語句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通過提取副作用摺疊 'if' 語句
inspection.common.if.parts.description.variables.only=可以從 ''if'' 中提取變數{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同時移除分支{0}
inspection.common.if.parts.description.with.variables.extract=可以從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.complete.duplicate=摺疊 ''if'' 語句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=摺疊 'if' 語句並提取副作用
inspection.common.if.parts.message.variables.only=從 ''if'' 中提取變數{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同時移除分支{0}
inspection.common.if.parts.message.with.variables.extract=從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=從 ''if'' 中提取通用部分{0}
inspection.common.subexpression.in.switch.display.name=可以從 'switch' 中提取通用子表達式
inspection.common.subexpression.in.switch.fix.family.name=向下推送 'switch' 表達式
inspection.comparator.combinators.description=可被取代為 'Comparator' 鏈
inspection.comparator.combinators.description2=可被取代為 ''{0}''
inspection.comparator.combinators.fix.chain=取代為 'Comparator' 鏈
inspection.condition.covered.by.further.condition.descr=條件 ''{0}'' 由後面的{1, choice, 1\#條件 ''''{2}''''|2\#條件}覆蓋
inspection.constant.expression.display.name=可以對常數表達式求值
inspection.constant.expression.fix.family.name=計算常量值
inspection.constant.expression.fix.name=計算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.short=取代為常量值
inspection.constant.expression.message=常數表達式的求值結果可以為 ''{0}''
inspection.constant.expression.report.compile.time=僅報告編譯時常量
inspection.constant.expression.report.compile.time.description=預設情況下，該檢查可以評估一些涉及庫方法呼叫的常數，甚至可以根據周圍程式碼推斷常量值。選中此選項可以根據 Java 語言規範僅報告編譯時常量。
inspection.constant.expression.skip.non.literal=不報告包含對已定義常數的參照的表達式
inspection.constant.expression.skip.non.literal.description=忽略包含對非字面量動作數(例如欄位和變數)參照的表達式。
inspection.deconstruction.can.be.used.display.name=可以使用記錄模式
inspection.deconstruction.can.be.used.fix.family.name=取代為記錄模式
inspection.deconstruction.can.be.used.message=可被取代為記錄模式
inspection.empty.catch.block.generate.body=從模板生成 'catch' 正文
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子類別
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=要解構的記錄組件的最大數量\:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=可以使用帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=取代為記錄模式
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=嵌套深度限制\:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=不建議帶有 {0} 種和更多嵌套模式的模式
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=不建議帶有 {0} 個或更多組件的記錄
inspection.enhanced.for.with.record.pattern.can.be.used.message=可被取代為帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=未使用的記錄組件的最大數量\:
inspection.excessive.range.check.fix.family.name=簡化過度範圍檢查
inspection.excessive.range.check.message=可被取代為 ''{0}''
inspection.if.statement.missing.break.in.loop.description=滿足條件後，可以終止迴圈
inspection.if.statement.missing.break.in.loop.name=在 'if' 條件下提前離開迴圈
inspection.if.statement.missing.break.in.loop.quickfix=新增 'break'
inspection.incorrect.date.format.display.name=不正確的 'DateTimeFormat' 模式
inspection.incorrect.date.format.message.literal=左單引號({0})後未跟隨右單引號
inspection.incorrect.date.format.message.padding=沒有連續模式字母的填充修飾符 ''{0}''
inspection.incorrect.date.format.message.reserved.character=使用保留字元 ''{0}''
inspection.incorrect.date.format.message.unpaired=在沒有事先開啟 ''{0}'' 的情況下關閉 <code>\#ref</code>
inspection.incorrect.date.format.message.unsupported=非法模式字母 ''{0}''
inspection.incorrect.date.format.too.few.letters=連續模式字母 ''{0}'' 過少；最小\: {1}；指定\: {2}
inspection.incorrect.date.format.too.many.letters=連續模式字母 ''{0}'' 過多；最大\: {1}；指定\: {2}
inspection.incorrect.date.format.wrong.number.of.letters=連續模式字母 ''{0}'' 的數量錯誤；允許\: {1}；指定\: {2}
inspection.incorrect.message.custom.classes.methods=自訂 MessageFormat 方法\:
inspection.incorrect.message.format.choice.limit.incorrect=選擇模式中的下限 ''{0}'' 不正確
inspection.incorrect.message.format.choice.limit.not.found=選擇模式中的下限為空
inspection.incorrect.message.format.display.name='MessageFormat' 模式不正確
inspection.incorrect.message.format.incorrect.index=索引 ''{0}'' 不正確
inspection.incorrect.message.format.incorrect.order.choice=選擇模式中的下限未按升序排列
inspection.incorrect.message.format.incorrect.quotes.number=引號的數量可能不正確，將列印超過 1 個引號
inspection.incorrect.message.format.not.found.argument=索引 ''{0}'' 沒有實參''
inspection.incorrect.message.format.not.found.arguments=索引沒有實參\: {0}
inspection.incorrect.message.format.not.used.argument=模式中未使用索引為 ''{0}'' 的實參
inspection.incorrect.message.format.pattern=訊息格式模式 ''{1}'' 中的 {0}
inspection.incorrect.message.format.quotes.around.parameter=佔位符 ''{0}'' 不會被取代，因為它包含在引號中
inspection.incorrect.message.format.unclosed.brace=未閉合的大括號
inspection.incorrect.message.format.unknown.format.type=未知格式類型 ''{0}''
inspection.incorrect.message.format.unmatched.brace=不符合的大括號
inspection.incorrect.message.format.unpaired.quote=訊息模式中不成對的引號
inspection.list.remove.in.loop.display.name=在迴圈中呼叫了 'List.remove()'
inspection.list.remove.in.loop.message=可被取代為 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=複合賦值中從 ''{0}'' 到 ''{1}'' 的隱式轉換可能是有損的
inspection.lossy.conversion.compound.assignment.name=複合賦值中可能存在有損隱式轉換
inspection.meta.annotation.without.runtime.description={0} 應具有 @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
inspection.new.object.equality.display.name=使用 '\=\=' 比較新物件
inspection.new.object.equality.message=使用 ''{0}'' 比較新物件
inspection.non.strict.comparison.equality.display.name=非嚴格不等式 '>\=' 或 '<\=' 可被取代為 '\=\='
inspection.non.strict.comparison.equality.message=可被取代為等式
inspection.note.may.change.semantics=可能更改語意
inspection.only.one.element.used.array=僅使用了一個陣列元素
inspection.only.one.element.used.display.name=僅使用了一個元素
inspection.only.one.element.used.fix.family=取代為已存取的元素
inspection.only.one.element.used.list=僅使用了一個列表元素
inspection.only.one.element.used.string=僅使用了一個字串字元
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.assert=對斷言語句描述實參忽略
inspection.option.ignore.constant.initializers=對常數欄位的初始設定式忽略
inspection.option.ignore.exceptions=對 Throwable 子類別的建構函式實參忽略
inspection.option.ignore.in.annotations=在註解中忽略
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常數
inspection.option.ignore.in.tostring=在 toString() 方法內部忽略
inspection.option.ignore.nonnls=通過 @NonNls 進行註解時忽略
inspection.option.ignore.system.err=對 'System.err.print' 實參忽略
inspection.option.ignore.system.out=對 'System.out.print' 實參忽略
inspection.pattern.variable.can.be.used.display.name=可以使用模式變數
inspection.pattern.variable.can.be.used.existing.cast.message=可以使用現有模式變數 ''{0}'' 代替轉換表達式
inspection.pattern.variable.can.be.used.existing.fix.family.name=取代為現有模式變數
inspection.pattern.variable.can.be.used.existing.fix.name=將 ''{0}'' 取代為現有模式變數 ''{1}''
inspection.pattern.variable.can.be.used.existing.message=可以使用現有模式變數 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=取代為模式變數
inspection.pattern.variable.can.be.used.fix.name=將 ''{0}'' 取代為模式變數
inspection.pattern.variable.can.be.used.instead.of.cast.message=轉換表達式可被取代為模式變數
inspection.pattern.variable.can.be.used.message=變數 ''{0}'' 可被取代為模式變數
inspection.pattern.variable.can.be.used.report.cast.only=報告可被取代為新引入的模式變數的轉換表達式
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=將轉換表達式取代為現有模式變數 ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=將轉換表達式取代為模式變數
inspection.redundant.arguments.message=不必要的實參
inspection.redundant.class.call.display.name=冗餘的 'isInstance()' 或 'cast()' 呼叫
inspection.redundant.collection.operation.display.name=冗餘的 'Collection' 動作
inspection.redundant.collection.operation.fix.family.name=簡化集合動作
inspection.redundant.collection.operation.problem.arraycopy=為複製陣列而建立的集合不必要
inspection.redundant.collection.removal.by.index.fix=使用按物件移除
inspection.redundant.collection.removal.by.index.problem=按索引移除可被取代為按物件移除
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 檢查
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 檢查
inspection.redundant.compare.call.display.name=冗餘的 'compare()' 方法呼叫
inspection.redundant.compare.call.fix.name=內聯 'compare()' 呼叫
inspection.redundant.embedded.expression.display.name=字串模板中的冗餘嵌入式表達式
inspection.redundant.embedded.expression.fix.family.name=內聯嵌入式表達式
inspection.redundant.embedded.expression.message.empty=冗餘的空嵌入式表達式
inspection.redundant.embedded.expression.message.literal=冗餘的嵌入式字面量
inspection.redundant.empty.string.argument.message=不必要的空字串實參
inspection.redundant.explicit.variable.type.description=可以省略區域變數的顯式類型
inspection.redundant.java.time.operation.compare.java.time.family.name=使用 'java.time' 'compareTo()' 呼叫簡化表達式
inspection.redundant.java.time.operation.compare.java.time.problem.descriptor=帶有 'java.time' <code>\#ref()</code> 呼叫的表達式可以簡化
inspection.redundant.java.time.operation.creation.java.time.error.message=''{0}'' 物件的冗餘建立
inspection.redundant.java.time.operation.creation.java.time.error.remove.fix.message=移除 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.error.replace.fix.message=取代為 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.family.name=簡化 'java.time' 物件的建立
inspection.redundant.java.time.operation.creation.java.time.redundant.call.message=冗餘的 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.remove.family.name=移除不必要的呼叫
inspection.redundant.java.time.operation.display.name='java.time' 物件上的冗餘動作
inspection.redundant.java.time.operation.explicit.chrono.field.family.name=簡化帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的呼叫
inspection.redundant.java.time.operation.explicit.chrono.field.problem.descriptor=帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的呼叫可以簡化
inspection.redundant.length.check.display.name=冗餘的陣列長度檢查
inspection.redundant.string.call.message=<code>\#ref()</code> 的呼叫冗餘 \#loc
inspection.redundant.string.constructor.message=<code>new \#ref()</code> 冗餘 \#loc
inspection.redundant.string.fix.family.name=移除冗餘呼叫
inspection.redundant.string.fix.remove.str.processor.description=字串模板可以轉換為普通字串字面量
inspection.redundant.string.intern.on.constant.message=編譯時常量上 <code>\#ref()</code> 的呼叫不必要 \#loc
inspection.redundant.string.length.argument.message=不必要的字串長度實參
inspection.redundant.string.new.array.message=<code>\#ref</code> 冗餘 \#loc
inspection.redundant.string.operation.display.name=冗餘的 'String' 動作
inspection.redundant.string.option.do.not.report.single.argument.substring=不報告冗餘的單實參 substring() 呼叫
inspection.redundant.string.option.do.not.report.string.constructors=不報告 String 建構函式呼叫
inspection.redundant.string.remove.argument.fix.name=移除實參
inspection.redundant.string.replace.with.arg.fix.name=取代為實參
inspection.redundant.string.replace.with.empty.fix.name=取代為空字串
inspection.redundant.zero.argument.message=不必要的零實參
inspection.refused.bequest.super.annotated.option=僅在通過以下方式註解 super 方法時報告\:
inspection.remove.redundant.call.fix.name=移除冗餘的 ''{0}()'' 呼叫
inspection.replace.on.literal.display.name=取代動作不起任何作用
inspection.simplifiable.if.statement.display.name='if' 語句可被取代為條件或布爾表達式
inspection.simplifiable.if.statement.fix.family.name=將 'if else' 取代為條件運算符
inspection.simplifiable.if.statement.fix.name=將 ''if else'' 取代為 ''{0}''
inspection.simplifiable.if.statement.message=If 語句可被取代為 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建議使用 '?\:' 運算符
inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.lower=使用了小寫 ''{0}'' ({1}) 模式\: 預期可能為 ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=使用了大寫 ''{0}'' ({1}) 模式\: 預期可能為 ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模組 ''{2}'' 中宣告
inspection.suspicious.package.private.access.from.tests.description={0} 是 {1} 且在測試中使用，但在生產源中宣告
inspection.suspicious.package.private.access.from.tests.problem=測試中的 {0} 重寫了生產源中宣告的 {1} 中的 package-private 方法
inspection.suspicious.package.private.access.problem={0} 重寫了來自在不同模組 ''{2}'' 中宣告的 {1} 的 package-private 方法
inspection.test.method.without.assertion.list.name=斷言方法\:
inspection.test.method.without.assertions.exceptions.option=忽略宣告異常的測試方法
inspection.trivial.functional.expression.usage.description=可以簡化方法呼叫
inspection.type.may.be.weakened.add.stop.class.family=新增停止類別
inspection.type.may.be.weakened.add.stop.class.selection.popup=選擇停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table=停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止類別\:
inspection.type.may.be.weakened.add.stopper=作為停止類別添加以減弱
inspection.type.may.be.weakened.add.stopper.preview=停止類別將被新增到此檢查的停止類別列表中。
inspection.type.may.be.weakened.add.stopper.single=新增 {0} 作為停止類別以削弱
inspection.type.may.be.weakened.display.name=類型可能被削弱
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建議削弱宣告為 'var' 的變數
inspection.type.may.be.weakened.field.problem.descriptor=欄位 <code>\#ref</code> 的類型可能被削弱為 {0} \#loc
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>\#ref()</code> 的返回值類型可能被削弱為 {0} \#loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=僅削弱為接口
inspection.type.may.be.weakened.parameter.problem.descriptor=參數 <code>\#ref</code> 的類型可能被削弱為 {0} \#loc
inspection.type.may.be.weakened.problem.descriptor=變數 <code>\#ref</code> 的類型可能被削弱為 {0} \#loc
inspection.type.may.be.weakened.quickfix=將類型削弱為 ''{0}''
inspection.type.may.be.weakened.weaken.type.family=削弱類型
inspection.unnecessary.string.escape.report.char.literals.option=報告字元字面量
inspection.unsupported.chrono.field.unit.call.display.name=使用不受支援的 'java.time.temporal.ChronoUnit' 和 'java.time.temporal.ChronoField' 呼叫方法
inspection.unsupported.chrono.value.message=不支持的實參值\: {0}
inspection.unsupported.chrono.values.message=不支持的實參值\: {0}
inspection.use.of.private.field.inner.classes.option=忽略來自內部類別的存取
inspection.use.of.slash.s.display.name='\\s' 轉義序列的非終止使用
inspection.use.of.slash.s.fix.family=將 '\\s' 序列取代為空格
inspection.use.of.slash.s.message=使用轉義序列 '\\s' 作為非尾隨空格
inspection.use.of.slash.s.non.text.block.message=在文本塊之外使用轉義序列 '\\s'
inspection.while.can.be.replaced.with.do.while.display.name='while' 可被取代為 'do while'
inspection.while.can.be.replaced.with.do.while.family.name=將 'while' 取代為 'do while'
inspection.while.can.be.replaced.with.do.while.message=將 'while' 取代為 'do while'
inspection.x.call.can.be.replaced.with.y=<code>\#ref()</code> 呼叫可被取代為 ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=實例欄位 <code>\#ref</code> 在物件建構或 'setUp()' 呼叫期間可能無法初始化 \#loc
instance.method.naming.convention.element.description=實例方法
instance.variable.may.not.be.initialized.display.name=實例欄位可能無法初始化
instance.variable.may.not.be.initialized.problem.descriptor=實例欄位 <code>\#ref</code> 在物件建構期間可能無法初始化 \#loc
instance.variable.naming.convention.element.description=實例欄位
instance.variable.of.concrete.class.problem.descriptor=具體類別 <code>\#ref</code> 的實例欄位 ''{0}'' \#loc
instance.variable.used.before.initialized.display.name=實例欄位在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的實例欄位 <code>\#ref</code> \#loc
instanceof.catch.parameter.display.name='catch' 參數上的 'instanceof'
instanceof.catch.parameter.problem.descriptor='catch' 參數 <code>\#ref</code> 上的 'instanceof' \#loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 檢查
instanceof.check.for.this.equality.problem.descriptor='this' 的類別比較 \#loc
instanceof.check.for.this.problem.descriptor=<code>\#ref</code> 的 'instanceof' 檢查 \#loc
instanceof.concrete.class.equality.problem.descriptor=與具體類別 <code>\#ref</code> 的類別比較 \#loc
instanceof.concrete.class.pattern.problem.descriptor=針對具體類別 <code>\#ref</code> 的模式測試 \#loc
instanceof.concrete.class.problem.descriptor='instanceof' 具體類別 <code>\#ref</code> \#loc
instanceof.with.incompatible.interface.display.name=具有不相容類型的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=類型為 ''{1}'' 的表達式中具有不相容{0, choice, 1\#接口|2\#類別}的 ''instanceof'' <code>\#ref</code> \#loc
instantiating.datetimeformatter.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下呼叫 <code>DateTimeFormatter.\#ref()</code> \#loc
instantiating.object.to.get.class.object.display.name=實例化物件以獲取 'Class' 物件
instantiating.object.to.get.class.object.problem.descriptor=實例化物件以獲取類別物件 \#loc
instantiating.object.to.get.class.object.replace.quickfix=取代為直接類別物件存取
instantiating.simpledateformat.without.locale.display.name=無區域設定的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下實例化 <code>\#ref</code> \#loc
instantiation.utility.class.display.name=實用程序類別的實例化
instantiation.utility.class.problem.descriptor=實用程序類別 <code>\#ref</code> 的實例化 \#loc
int.literal.may.be.long.literal.display.name=轉換為 'long' 可以是 'long' 字面量
int.literal.may.be.long.literal.problem.descriptor=<code>\#ref</code> 可被取代為 ''{0}'' \#loc
integer.division.in.floating.point.context.display.name=浮點上下文中的整數除法
integer.division.in.floating.point.context.fix.family.name=將分子轉換為浮點類型
integer.division.in.floating.point.context.fix.name=將分子轉換為 ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>\#ref</code>\: 浮點上下文中的整數除法 \#loc
integer.multiplication.implicit.cast.to.long.display.name=整數乘法或移位隱式轉換為 'long'
integer.multiplication.implicit.cast.to.long.option=<html>忽略靜態證明不可能溢出的表達式</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=\#ref\: 整數乘法隱式轉換為 long \#loc
integer.multiplication.implicit.cast.to.long.quickfix=轉換為 long
integer.shift.implicit.cast.to.long.problem.descriptor=\#ref\: 整數移位隱式轉換為 long \#loc
interface.clashes.with.object.class.display.name=接口方法與 'Object' 中的方法衝突
interface.clashes.with.object.class.problem.descriptor=<code>\#ref()</code> 與 'java.lang.Object' 中的方法衝突
interface.may.be.annotated.functional.display.name=接口可以註解為 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>\#ref</code> 可以使用 @FunctionalInterface 註解
interface.naming.convention.element.description=接口
interface.never.implemented.display.name=沒有具體子類別的接口
interface.never.implemented.option=忽略僅宣告常數的接口
interface.never.implemented.problem.descriptor=接口 <code>\#ref</code> 沒有具體子類別 \#loc
interface.one.inheritor.display.name=只有一個直接繼承者的接口
interface.one.inheritor.problem.descriptor=只有一個直接繼承者的接口 <code>\#ref</code> \#loc
introduce.holder.class.quickfix=引入 holder 類別
introduce.variable.may.change.semantics.quickfix=引入變數 (可能更改語意)
introduce.variable.quickfix=引入變數
invert.method.quickfix=反轉方法
invert.quickfix=反轉 ''{0}''
invert.quickfix.family.name=反轉布爾
iterator.hasnext.which.calls.next.display.name=呼叫 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''\#ref()'' 呼叫 \#loc
iterator.next.does.not.throw.nosuchelementexception.display.name=無法拋出 'NoSuchElementException' 的 'Iterator.next()'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=無法拋出 'NoSuchElementException' 的 <code>Iterator.\#ref()</code> '\#loc
java.lang.import.display.name='java.lang' 軟體套件中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 軟體套件中有不必要的 import \#loc
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 呼叫具有非常數字串
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.\#ref()</code> 呼叫具有非常數實參 \#loc
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 呼叫具有非常數字串
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.\#ref()</code> 呼叫具有非常數實參 \#loc
jdbc.resource.opened.not.closed.display.name=JDBC 資源已開啟，但未安全關閉
jndi.resource.opened.not.closed.display.name=JNDI 資源已開啟，但未安全關閉
junit.abstract.test.class.naming.convention.element.description=抽象測試類別
junit.test.class.naming.convention.element.description=測試類別
junit.test.suite.naming.convention.element.description=測試套件
junit3.method.naming.convention.element.description=JUnit 3 測試方法
junit4.method.naming.convention.element.description=JUnit 4+ 測試方法
key.set.iteration.may.use.entry.set.display.name=可以最佳化對 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>\#ref</code> 上的迭代可被取代為 ''{0}'' 迭代 \#loc
key.set.iteration.may.use.entry.set.quickfix=最佳化 Map 迭代
labeled.statement.display.name=標記語句
labeled.statement.problem.descriptor=標記語句 <code>\#ref\:</code> \#loc
lambda.body.can.be.code.block.name=lambda 體可以是程式碼塊
lambda.body.can.be.code.block.quickfix=將 lambda 體擴展為 {...}
lambda.can.be.replaced.with.anonymous.name=lambda 可被取代為匿名類別
lambda.can.be.replaced.with.anonymous.quickfix=將 lambda 取代為匿名類別
lambda.parameter.hides.member.variable.display.name=lambda 參數隱藏欄位
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略從 lambda 實際不可見的欄位
lambda.parameter.hides.member.variable.problem.descriptor=lambda 參數 <code>\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \#loc
lambda.parameter.naming.convention.display.name=lambda 參數命名約定
lambda.parameter.naming.convention.element.description=lambda 參數
lambda.parameter.type.can.be.specified.descriptor=Lambda 參數類型可以擴展為{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 參數類型
lambda.parameter.type.can.be.specified.name=可以指定 lambda 參數類型
lambda.parameter.type.can.be.specified.quickfix=將參數類型擴展為{0}
lambda.unfriendly.constructor.overload.problem.descriptor=建構函式 <code>\#ref()</code> 的多載對 lambda 不友好
lambda.unfriendly.method.overload.display.name=方法多載對 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>\#ref()</code> 的多載對 lambda 不友好
large.array.allocation.no.outofmemoryerror.display.name=沒有 OutOfMemoryError 檢查的大型陣列分配
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素數\:
large.array.allocation.no.outofmemoryerror.problem.descriptor=未檢查記憶體不足情況的大型陣列分配 \#loc
large.initializer.primitive.type.array.display.name=原始類型陣列的過大初始設定式
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素數\:
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始陣列初始設定式 \#loc
law.of.demeter.display.name=迪米特法則
law.of.demeter.field.problem.descriptor=對 <code>\#ref()</code> 的存取違反迪米特法則 \#loc
law.of.demeter.ignore.library.calls.option=忽略對庫方法的呼叫和對庫欄位的存取
law.of.demeter.problem.descriptor=對 <code>\#ref()</code> 的呼叫違反迪米特法則 \#loc
length.one.string.in.indexof.display.name='String.indexOf()' 呼叫中的單字元字串實參
length.one.strings.in.concatenation.display.name=單字元字串串聯
length.one.strings.in.concatenation.replace.quickfix=取代為字元
limited.scope.inner.class.display.name=區域類別
limited.scope.inner.class.problem.descriptor=區域類別 <code>\#ref</code> \#loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表達式可被取代為 'contains()'
listener.may.use.adapter.display.name=類別可以擴展適配器而不是實作偵聽器
listener.may.use.adapter.emtpy.methods.option=僅在找到空實作方法時發出警告(&O)
listener.may.use.adapter.fix.family.name=取代為適配器
listener.may.use.adapter.problem.descriptor=類別 ''{0}'' 可以擴展 ''{1}'' 而不是實作 <code>\#ref</code> \#loc
literal.as.arg.to.string.equals.display.name=字串字面量可以為 'equals()' 限定符
literal.as.arg.to.string.equals.flip.quickfix=翻轉 ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=字面量 \#ref 是 ''{0}()'' 的實參，而不是其限定符 \#loc
load.library.with.non.constant.string.display.name='System.loadLibrary()' 呼叫具有非常數字串
load.library.with.non.constant.string.problem.descriptor=<code>{0}.\#ref()</code> 呼叫具有非常數實參 \#loc
local.variable.hides.member.variable.display.name=區域變數隱藏欄位
local.variable.hides.member.variable.ignore.option=忽略隱藏非 static 欄位的 static 上下文中的區域變數
local.variable.hides.member.variable.problem.descriptor=區域變數 <code>\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \#loc
local.variable.naming.convention.display.name=區域變數命名約定
local.variable.naming.convention.element.description=區域變數
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 塊參數
local.variable.naming.convention.ignore.option=忽略 for 迴圈參數
local.variable.of.concrete.class.problem.descriptor=具體類別 <code>\#ref</code> 的區域變數 ''{0}'' \#loc
log.condition.text=日誌條件文本
log.method.name=記錄方法名稱
log.statement.guarded.by.log.condition.display.name=日誌呼叫不受日誌條件保護
log.statement.guarded.by.log.condition.flag.all.unguarded.option=標記所有不受保護的日誌呼叫
log.statement.guarded.by.log.condition.problem.descriptor=<code>\#ref()</code> 日誌呼叫不受日誌條件保護 \#loc
log.statement.guarded.by.log.condition.quickfix=使用日誌條件包圍
log4j.use.parameterized.logger=對於 Log4j 2，請使用與參數化記錄器相同的修正
log4j.use.parameterized.logger.description=對於 Log4j 2，如果類型無法推斷，請使用與參數化記錄器相同的修正；否則，將不會建議修正
logger.class.name=記錄器類別名\:
logger.factory.class.name=記錄器工廠類別名
logger.factory.method.name=記錄器工廠方法名稱
logger.initialized.with.foreign.class.display.name=使用外類別初始化記錄器
logger.initialized.with.foreign.class.fix.family.name=取代外類別
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 類別中的記錄器
logger.initialized.with.foreign.class.ignore.not.final.field=忽略未在 final 欄位中初始化的記錄器
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超類別初始化的記錄器
logger.initialized.with.foreign.class.problem.descriptor=使用外類別 <code>\#ref</code> 初始化記錄器 \#loc
logger.name.option=記錄器類別名(&C)\:
long.literals.ending.with.lowercase.l.display.name='long' 字面量以 'l' 而不是 'L' 結尾
long.literals.ending.with.lowercase.l.problem.descriptor='long' 字面量 <code>\#ref</code> 以小寫 'l' 結尾 \#loc
loop.condition.not.updated.inside.loop.display.name=迴圈變數未在迴圈內更新
loop.condition.not.updated.inside.loop.problem.descriptor=條件 '\#ref' 未在迴圈內更新\#loc
loop.statements.that.dont.loop.display.name=不迴圈的迴圈語句
loop.statements.that.dont.loop.problem.descriptor=<code>\#ref</code> 語句未迴圈 \#loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地更改
loop.variable.not.updated.inside.loop.problem.descriptor=變數 '\#ref' 未在迴圈內更新\#loc
loop.with.implicit.termination.condition.display.name=具有隱式終止條件的迴圈
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隱式終止條件的 <code>\#ref-while</code> 迴圈 \#loc
loop.with.implicit.termination.condition.problem.descriptor=具有隱式終止條件的 <code>\#ref</code> 迴圈 \#loc
loop.with.implicit.termination.condition.quickfix=使條件顯式
magic.character.display.name=魔幻字元
magic.character.problem.descriptor=國際化上下文中使用的魔幻字元 <code>\#ref</code> \#loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 <code>\#ref</code> \#loc
make.class.final.fix.family.name=將類別設為 final
make.class.final.fix.name=將類別 ''{0}'' 設為 ''final''
make.constructor.public=將建構函式設為 'public'
make.field.final.fix.family.name=設為 final
make.field.final.quickfix=將 ''{0}'' 設為 ''final''
make.field.static.final.fix.family.name=設為 static final
make.initialization.explicit.quickfix=使初始化顯式
make.method.ctr.quickfix=使方法成為建構函式
make.method.final.fix.family.name=將方法設為 'final'
make.method.final.fix.name=將方法 ''{0}()'' 設為 ''final''
make.package.private.fix.family.name=設為 package-private
make.static.final.quickfix=將 ''{0}'' 設為 static final
make.static.quickfix=設為 'static'
malformed.format.string.display.name=字串的格式錯誤
malformed.format.string.problem.descriptor.arguments.do.not.match.type=實參類型 ''{0}'' 與格式說明符 ''{1}'' 的類型不符合 \#loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=格式字串的實參過少(實際\: {0}，至少應為\: {1}) \#loc
malformed.format.string.problem.descriptor.illegal=非法格式字串指定符\: {0} \#loc
malformed.format.string.problem.descriptor.malformed=格式字串 <code>\#ref</code> 的格式錯誤 \#loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字串的實參太少(實際\: {0}，應為\: {1}) \#loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字串的實參太多(實際\: {0}，應為\: {1}) \#loc
manual.array.copy.display.name=手動陣列複製
manual.array.copy.problem.descriptor=手動陣列複製 \#loc
manual.array.to.collection.copy.display.name=手動陣列到集合複製
manual.array.to.collection.copy.problem.descriptor=手動陣列到集合複製 \#loc
map.replaceable.by.enum.map.display.name='Map' 可被取代為 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>\#ref</code> 可被取代為 'EnumMap' \#loc
markdown.documentation.comments.migration.display.name=Javadoc 註釋可以是 Markdown 文檔註釋
markdown.documentation.comments.migration.fix=轉換為 Markdown 文檔註釋
marker.interface.display.name=標記接口
marker.interface.problem.descriptor=標記接口 <code>\#ref</code> \#loc
masked.assertion.display.name=斷言通過 'catch' 禁止
masked.assertion.problem.description=''{0}'' 不能失敗，因為它被包圍 ''catch'' 禁止
math.random.cast.to.int.display.name='Math.random()' 轉換為 'int'
math.random.cast.to.int.problem.descriptor=<code>\#ref</code> 轉換為 ''{0}'' 時始終向下舍入為 ''0'' \#loc
math.random.cast.to.int.quickfix=新增括號以在轉換前執行乘法
math.rounding.with.int.argument.display.name=使用 'int' 實參呼叫數學舍入
math.rounding.with.int.argument.family.name=簡化舍入呼叫
math.rounding.with.int.argument.problem.descriptor=帶有 'int' 類型實參的 <code>\#ref()</code> \#loc
math.rounding.with.int.argument.quickfix=簡化 ''{0}()'' 呼叫
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 註解的測試註解
method.call.in.loop.condition.display.name=迴圈條件下的方法呼叫
method.call.in.loop.condition.problem.descriptor=迴圈條件下呼叫方法 <code>\#ref()</code> \#loc
method.can.be.variable.arity.method.display.name=方法可以有 varargs 參數
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始陣列類型
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具類型為 byte[] 或 short[] 的參數
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多維陣列參數
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多個陣列參數的方法
method.can.be.variable.arity.method.problem.descriptor=<code>\#ref()</code> 可以轉換為 vararg 方法 \#loc
method.complexity.limit.option=方法復雜度限制\:
method.count.ignore.getters.setters.option=忽略簡單的 getter 和 setter 方法(&I)
method.count.limit.option=方法計數限制\:
method.coupling.display.name=過度耦合的方法
method.coupling.limit.option=方法耦合限制\:
method.coupling.problem.descriptor=<code>\#ref</code> 過度耦合 (\# 參照的類別 \= {0}) \#loc
method.may.be.static.display.name=方法可以為 'static'
method.may.be.static.empty.option=忽略空方法
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
method.may.be.static.only.option=僅檢查 'private' 或 'final' 方法
method.may.be.static.problem.descriptor=方法 <code>\#ref()</code> 可能為 'static' \#loc
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修復可將實例限定符取代為類別參照
method.may.be.synchronized.display.name=只有一個 'synchronized' 塊的方法可被取代為 'synchronized' 方法
method.may.be.synchronized.problem.descriptor=帶 synchronized 塊的方法 <code>\#ref()</code> 可以是 synchronized 方法 \#loc
method.may.be.synchronized.quickfix=將方法設為 synchronized 並移除 synchronized 塊
method.name.regex=方法名稱正則表達式
method.name.same.as.class.name.display.name=方法名稱與類別名相同
method.name.same.as.class.name.problem.descriptor=方法名稱 <code>\#ref</code> 與其類別名相同 \#loc
method.name.same.as.parent.name.display.name=方法名稱與父類別名相同
method.name.same.as.parent.name.problem.descriptor=方法名稱 <code>\#ref</code> 與其父類別名相同 \#loc
method.names.differ.only.by.case.display.name=方法名稱僅大小寫不同
method.names.differ.only.by.case.problem.descriptor=方法名稱 <code>\#ref</code> 和方法名稱 ''{0}'' 僅大小寫不同 \#loc
method.only.used.from.inner.class.display.name=僅在內部類中使用 private 方法
method.only.used.from.inner.class.ignore.option=忽略從匿名類別或區域類別呼叫的方法(&A)
method.only.used.from.inner.class.problem.descriptor=方法 <code>\#ref()</code>\#loc 只能從{0, choice, 1\#內部|2\#區域|3\#}{1, choice, 1\#類別|2\#接口|3\#派生的匿名類別|4\#註解類型|5\#枚舉|6\#記錄} ''{2}'' 使用 \#loc
method.overloads.display.name=可能是超類別方法意外多載
method.overloads.problem.descriptor=當可能打算覆寫時，方法 <code>\#ref()</code> 多載超類別的相容方法 \#loc
method.overloads.report.incompatible.option=即使參數類型不相容，也會報告
method.overrides.inaccessible.method.display.name=方法覆寫了超類別不可存取的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>\#ref()</code> 覆寫了位於另一個軟體套件中的超類別的 package-private 方法 \#loc
method.overrides.private.display.name.problem.descriptor=方法 <code>\#ref()</code> 重寫了超類別的 'private' 方法 \#loc
method.overrides.static.display.name=方法嘗試覆寫超類別的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>\#ref()</code> 嘗試覆寫超類別的 static 方法 \#loc
method.ref.can.be.replaced.with.lambda.name=方法參照可被取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix=將方法參照取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix.no.side.effects=將可能的副作用保留在 lambda 內部
method.ref.can.be.replaced.with.lambda.quickfix.side.effects=將可能的副作用提取到變數中
method.return.always.constant.display.name=方法返回類別特定的常數
method.return.always.constant.problem.descriptor=方法 <code>\#ref()</code> 及其所有派生方法始終返回常數
method.return.concrete.class.problem.descriptor=方法返回一個具體類別 <code>\#ref</code> \#loc
method.with.multiple.loops.display.name=具有多個迴圈的方法
method.with.multiple.loops.problem.descriptor=<code>\#ref</code> 包含 {0} 個迴圈 \#loc
mismatched.read.write.array.display.name=陣列的讀取和寫入不符合
mismatched.read.write.array.problem.descriptor.read.not.write=陣列 <code>\#ref</code> 的內容已讀取，但從未被寫入 \#loc
mismatched.read.write.array.problem.descriptor.write.not.read=陣列 <code>\#ref</code> 的內容已寫入，但從未被讀取 \#loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} \#ref</code> 的內容已查詢，但從未更新 \#loc
mismatched.string.builder.query.update.display.name='StringBuilder' 的查詢和更新不符合
mismatched.string.builder.updated.problem.descriptor=<code>{0} \#ref</code> 的內容已更新，但從未被查詢 \#loc
mismatched.update.collection.display.name=不符合的集合查詢和更新
mismatched.update.collection.problem.description.no.effect.updates=對空集合 <code>\#ref</code> 進行的更新動作無效 \#loc
mismatched.update.collection.problem.description.queried.empty=空集合 <code>\#ref</code> 的內容已被查詢，但從未填充 \#loc
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>\#ref</code> 的內容已被查詢，但從未更新 \#loc
mismatched.update.collection.problem.description.updated.not.queried=集合 <code>\#ref</code> 的內容已更新，但從未被查詢 \#loc
misordered.assert.equals.arguments.display.name=順序錯誤的 'assertEquals()' 實參
misordered.assert.equals.arguments.flip.quickfix=翻轉比較實參
misordered.assert.equals.arguments.problem.descriptor=<code>\#ref()</code> 的實參順序錯誤 \#loc
missing.add.deprecated.javadoc.tag.quickfix=新增 '@deprecated' Javadoc 標記說明
missing.deprecated.annotation.add.quickfix=新增 '@Deprecated' 註解
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 註解
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 註解 \#loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 標記說明
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 標記說明 \#loc
missing.override.annotation.display.name=缺少 '@Override' 註解
missing.override.annotation.in.overriding.problem.descriptor=覆寫方法未使用 '@Override' 註解
missing.override.annotation.problem.descriptor=缺少關於 <code>\#ref()</code> 的 '@Override' 註解 \#loc
missing.override.warn.on.super.option=當方法的覆寫方法並非全部具有 '@Override' 註解時，醒目提示該方法
missing.package.html.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package.html</code> 檔案
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package-info.java</code> 檔案
missing.serial.annotation.display.name=可以使用 '@Serial' 註解
missing.serial.annotation.on.field.problem.descriptor=<code>\#ref</code> 可以使用 '@Serial' 進行註解
missing.serial.annotation.on.method.problem.descriptor=<code>\#ref()</code> 可以使用 '@Serial' 進行註解
missorted.modifiers.allowed.place=TYPE_USE 註解遵循生成選項
missorted.modifiers.allowed.place.description=啟用此選項時，如果目標 TYPE_USE 註解的位置不符合<pre>設定 | 編輯器 | 程式碼樣式 | Java | 程式碼生成</pre>中的 <pre>{0}</pre> 選項，將報告目標 TYPE_USE 註解。停用此選項時，目標 TYPE_USE 註解可以直接位於類型之前或修飾符關鍵字之前。
missorted.modifiers.display.name=錯位修飾符
missorted.modifiers.problem.descriptor=錯位修飾符 <code>{0}</code> \#loc
missorted.modifiers.require.option=檢查註解順序
missorted.modifiers.require.option.description=使用此選項可以報告錯誤位置的註解\: 帶有 <code>ElementType.TYPE_USE</code> 的註解<em>不</em>直接位於類型之前且位於修飾符關鍵字之後，或者其他註解<em>不</em>位於修飾符關鍵字之前。停用此選項時，註解可以位於修飾符關鍵字之前或之後。將始終報告位於修飾符關鍵字之間的註解。
missorted.modifiers.sort.quickfix=對修飾符排序
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>\#ref()</code> 方法可能應當是 'equals()' \#loc
module.with.too.few.classes.display.name=類別過少的模組
module.with.too.few.classes.min.option=最小類別數\:
module.with.too.few.classes.problem.descriptor=模組 ''{0}'' 包含過少的類別 ({1} < {2})
module.with.too.many.classes.display.name=類別過多的模組
module.with.too.many.classes.max.option=最大類別數\:
module.with.too.many.classes.problem.descriptor=模組 ''{0}'' 包含過多的類別 ({1} > {2})
move.anonymous.to.inner.quickfix=轉換為命名內部類別
move.class.quickfix=移動類別
move.exception.to.javadoc.fix.family.name=移至 Javadoc '@throws'
move.local.to.inner.quickfix=轉換為內部類別
multi.catch.can.be.split.name=多 catch 可拆分為單獨的 catch 塊
multi.catch.can.be.split.quickfix=將多 catch 拆分為單獨的 'catch' 塊
multiple.declaration.array.only.option=僅在單個宣告中對不同的陣列維度發出警告
multiple.declaration.display.name=一個宣告中的多個變數
multiple.declaration.ignore.for.option=忽略 'for' 迴圈宣告
multiple.declaration.problem.descriptor=一個宣告中的多個變數 \#loc
multiple.loggers.display.name=具有多個記錄器的類別
multiple.loggers.problem.descriptor=類別 <code>\#ref</code> 宣告多個記錄器 \#loc
multiple.return.points.per.method.display.name=具有多個返回點的方法
multiple.return.points.per.method.problem.descriptor=<code>\#ref</code> 具有 {0} 個返回點 \#loc
multiple.top.level.classes.in.file.display.name=單個檔案中的多個頂級類別
multiple.top.level.classes.in.file.problem.descriptor=檔案中的多個頂級類別
multiple.typed.declaration.problem.descriptor=在一個宣告中具有不同陣列維度的變數 \#loc
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的冪
multiply.or.divide.by.power.of.two.divide.option=還通過 2 的冪檢查除法
multiply.or.divide.by.power.of.two.replace.quickfix=取代為移位
naked.notify.display.name=沒有相應狀態更改的 'notify()' 或 'notifyAll()'
naked.notify.problem.descriptor=在沒有相應狀態更改的情況下呼叫 <code>\#ref()</code> \#loc
naming.convention.problem.descriptor.long={0} 名稱 <code>\#ref</code> 過長({1} > {2}) \#loc
naming.convention.problem.descriptor.regex.mismatch={0} 名稱 <code>\#ref</code> 不符合正則表達式 ''{1}'' \#loc
naming.convention.problem.descriptor.short={0} 名稱 <code>\#ref</code> 過短({1} < {2}) \#loc
native.method.display.name=本地方法
native.method.naming.convention.element.description='native' 方法
native.method.problem.descriptor=宣告為 <code>\#ref</code> 的方法不可移植 \#loc
negated.conditional.display.name=具有否定條件的條件表達式
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.problem.descriptor=否定條件表達式 \#loc
negated.conditional.expression.quickfix=移除否定
negated.conditional.invert.quickfix=反轉條件
negated.conditional.problem.descriptor=具有否定條件的條件表達式 \#loc
negated.equality.expression.display.name=否定相等表達式
negated.equality.expression.problem.descriptor=否定 ''{0}'' \#loc
negated.equality.expression.quickfix=移除否定
negated.if.else.display.name=具有否定條件的 'if' 語句
negated.if.else.ignore.negated.null.option=忽略 '\!\= null' 比較
negated.if.else.ignore.negated.zero.option=忽略 '\!\= 0' 比較
negated.if.else.invert.quickfix=反轉 'if' 條件
negated.if.else.problem.descriptor=帶嵌套條件的 <code>\#ref</code> 語句 \#loc
negative.int.constant.in.long.context.display.name=長整數型上下文中的負整數型十六進制常數
negative.int.constant.in.long.context.fix.add.suffix=新增 'L' 後綴(更改語意)
negative.int.constant.in.long.context.fix.convert=轉換為長整數型常數(保留語意)
negatively.named.boolean.variable.display.name=否定命名的布爾變數
negatively.named.boolean.variable.problem.descriptor=布爾變數 <code>\#ref</code> 已否定命名 \#loc
nested.assignment.display.name=嵌套賦值
nested.assignment.problem.descriptor=使用的賦值表達式的結果 \#loc
nested.conditional.expression.display.name=嵌套條件表達式
nested.conditional.expression.problem.descriptor=嵌套條件表達式 <code>\#ref</code> \#loc
nested.method.call.display.name=嵌套方法呼叫
nested.method.call.ignore.option=忽略欄位初始設定式中的嵌套方法呼叫
nested.method.call.problem.descriptor=嵌套方法呼叫 <code>\#ref()</code> \#loc
nested.switch.statement.display.name=嵌套 'switch' 語句
nested.switch.statement.problem.descriptor=嵌套 <code>\#ref</code> {0} \#loc
nested.synchronized.statement.display.name=嵌套 'synchronized' 語句
nested.synchronized.statement.problem.descriptor=嵌套 <code>\#ref</code> 語句 \#loc
nested.try.statement.display.name=嵌套 'try' 語句
nested.try.statement.problem.descriptor=嵌套 <code>\#ref</code> 語句 \#loc
nesting.depth.display.name=過度嵌套的方法
nesting.depth.limit.option=嵌套深度限制\:
nesting.depth.problem.descriptor=<code>\#ref</code> 過度嵌套 (最大嵌套深度 \= {0}) \#loc
new.exception.without.arguments.display.name=未使用實參呼叫異常建構函式
new.exception.without.arguments.problem.descriptor=<code>new \#ref()</code> 沒有實參 \#loc
new.method.naming.convention.display.name=方法命名約定
new.string.buffer.replaceable.by.string.problem.descriptor=<code>\#ref</code> 可被取代為 'String' \#loc
new.string.buffer.with.char.argument.display.name=StringBuilder 建構函式呼叫具有 'char' 實參
new.string.buffer.with.char.argument.problem.descriptor=<code>new \#ref()</code> 具有 'char' 類型的實參 \#loc
new.string.buffer.with.char.argument.quickfix=將字元實參取代為字串字面量
no.logger.display.name=不帶記錄器的類別
no.logger.problem.descriptor=類別 <code>\#ref</code> 未宣告記錄器 \#loc
non.atomic.operation.on.volatile.field.display.name='volatile' 欄位上的非原子動作
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 欄位 <code>\#ref</code> 上的非原子動作 \#loc
non.boolean.method.name.must.not.start.with.question.display.name=非布爾方法名稱不能以疑問詞開頭
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布爾方法名稱 <code>\#ref</code> 以疑問詞開頭 \#loc
non.comment.source.statements.display.name=過長的方法
non.comment.source.statements.limit.option=非註釋源語句限制\:
non.comment.source.statements.problem.descriptor=<code>\#ref</code> 過長 (\# 非註釋源語句 \= {0}) \#loc
non.constant.logger.display.name=非常數記錄器
non.constant.logger.problem.descriptor=非常數記錄器欄位 <code>\#ref</code> \#loc
non.exception.name.ends.with.exception.display.name=非異常類別名以 'Exception' 結尾
non.exception.name.ends.with.exception.problem.descriptor=非異常類別名 <code>\#ref</code> 以 'Exception' 結尾 \#loc
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 擴展 ''java.lang.Exception''
non.final.clone.display.name=非 final 'clone()' 位於安全上下文中
non.final.clone.problem.descriptor=非 final <code>\#ref()</code> 方法，影響安全性 \#loc
non.final.field.compareto.display.name='compareTo()' 中參照了非 final 欄位
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中存取了非 final 欄位 <code>\#ref</code> \#loc
non.final.field.in.enum.display.name='enum' 中的非 final 欄位
non.final.field.in.enum.problem.descriptor=枚舉 ''{0}'' 中存在非 final 欄位 <code>\#ref</code> \#loc
non.final.field.in.enum.quickfix.option=忽略無法成為 'final' 的欄位
non.final.field.in.equals.display.name='equals()' 中參照了非 final 欄位
non.final.field.in.equals.problem.descriptor=在 'equals()' 中存取了非 final 欄位 <code>\#ref</code> \#loc
non.final.field.in.hashcode.display.name='hashCode()' 中參照了非 final 欄位
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中存取了非 final 欄位 <code>\#ref</code> \#loc
non.final.field.of.exception.display.name='Exception' 類別的非 final 欄位
non.final.field.of.exception.problem.descriptor=異常類別的非 final 欄位 <code>\#ref</code> \#loc
non.final.static.variable.initialization.display.name=在類別初始化期間使用非 final static 欄位
non.final.static.variable.initialization.problem.descriptor=在類別初始化期間使用非 final static 欄位 <code>\#ref</code> \#loc
non.final.utility.class.display.name=實用程序類別不為 'final'
non.final.utility.class.problem.descriptor=實用程序類別 <code>\#ref</code> 不為 'final' \#loc
non.protected.constructor.in.abstract.class.display.name=抽象類別中的 public 建構函式
non.protected.constructor.in.abstract.class.ignore.option=對非 public 類別忽略
non.protected.constructor.in.abstract.class.problem.descriptor=抽象類別的建構函式 <code>\#ref()</code> 不應宣告為 'public' \#loc
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>\#ref()</code> 方法不是 'public' \#loc
non.reproducible.math.call.display.name=對 'Math' 的不可重現呼叫
non.reproducible.math.call.problem.descriptor=<code>Math.\#ref()</code> 可能產生不可重現的結果 \#loc
non.reproducible.math.call.replace.quickfix=取代為 'StrictMath' 呼叫
non.serializable.@interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化 @interface <code>\#ref</code> \#loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>\#ref</code> 的不可序列化匿名類別定義 'serialVersionUID' 欄位 \#loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化類別
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1\#類別|2\#接口|3\#派生的匿名類別|4\#註解類型|5\#枚舉|6\#記錄} <code>\#ref</code> 定義 'readObject()' 和 'writeObject()' \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1\#類別|2\#接口|3\#派生的匿名類別|4\#註解類型|5\#枚舉|6\#記錄} <code>\#ref</code> 定義 'readObject()' \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1\#類別|2\#接口|3\#派生的匿名類別|4\#註解類型|5\#枚舉|6\#記錄} <code>\#ref</code> 定義 'writeObject()' \#loc
non.serializable.class.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化類別 <code>\#ref</code> \#loc
non.serializable.component.in.serializable.record.problem.descriptor=Serializable 記錄中存在非 Serializable 組件 '\#ref' \#loc
non.serializable.field.in.serializable.class.display.name='Serializable' 類別中有不可序列化的欄位
non.serializable.field.in.serializable.class.problem.descriptor=Serializable 類別中存在非 Serializable 欄位 '\#ref' \#loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化接口 <code>\#ref</code> \#loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的物件被綁定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=傳遞給 HttpSession 的不可序列化物件 \#loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的物件被傳遞給了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=傳遞給 ObjectOutputStream 的不可序列化物件 \#loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化類別
non.short.circuit.boolean.expression.display.name=非短路布爾表達式
non.short.circuit.boolean.expression.problem.descriptor=非短路布爾表達式 <code>\#ref</code> \#loc
non.short.circuit.boolean.expression.replace.quickfix=取代為短路表達式
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法覆寫 'synchronized' 方法
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>\#ref()</code> 覆寫 synchronized 方法 \#loc
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 欄位延遲初始化
non.thread.safe.lazy.initialization.problem.descriptor='static' 欄位 <code>\#ref</code> 的延遲初始化不是執行緒安全 \#loc
none=無
noop.method.in.abstract.class.display.name='abstract' 類別中的無運算方法
noop.method.in.abstract.class.problem.descriptor=無動作方法 <code>\#ref()</code> 應當設為 abstract \#loc
normalize.declaration.quickfix=拆分為單獨的宣告
not.object.equals.can.be.equality.problem.descriptor=<code>\!\#ref()</code> 可被取代為 '\!\='
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'notify()' 或 'notifyAll()'
notify.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>\#ref()</code> \#loc
notify.without.corresponding.wait.display.name=沒有相應 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在沒有相應 <code>wait()</code> 的情況下呼叫 <code>\#ref()</code> \#loc
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法實參
null.argument.to.var.arg.method.problem.descriptor=引起混淆的實參 <code>\#ref</code>，不清楚是否需要 vararg 或非 vararg 呼叫 \#loc
null.thrown.display.name=已拋出 'null'
null.thrown.problem.descriptor=已拋出 <code>\#ref</code> \#loc
number.comparison.display.name=使用 '\=\=' 而不是 'equals()' 進行數字比較
number.comparison.problem.descriptor=使用 <code>\#ref</code> 而不是 'equals()' 來比較數字物件 \#loc
object.allocation.in.loop.display.name=迴圈中的物件分配
object.allocation.in.loop.new.descriptor=迴圈中的物件分配 <code>new \#ref()</code> \#loc
object.allocation.in.loop.problem.array.initializer.descriptor=迴圈中的陣列分配 \#loc
object.allocation.in.loop.problem.call.descriptor=物件分配通過迴圈中的 <code>\#ref()</code> 呼叫完成 \#loc
object.allocation.in.loop.problem.lambda.descriptor=物件分配通過捕獲迴圈中的 lambda 完成 \#loc
object.allocation.in.loop.problem.methodref.descriptor=物件分配通過迴圈中的實例綁定方法參照 <code>\#ref()</code> 完成 \#loc
object.allocation.in.loop.problem.string.concat=物件分配通過迴圈中的字串串聯完成 \#loc
object.comparison.display.name=使用 '\=\=' 而不是 'equals()' 進行物件比較
object.comparison.enumerated.ignore.option=忽略枚舉變數之間的 '\=\='
object.comparison.klass.ignore.option=忽略沒有 'equals()' 實作的 final 類別類型之間的 '\=\='
object.comparison.problem.description=使用 <code>\#ref</code> 而不是 'equals()' 來比較物件值 \#loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 建構函式的類型物件之間的 '\=\='
object.equals.can.be.equality.display.name='equals()' 呼叫可被取代為 '\=\='
object.equals.can.be.equality.problem.descriptor=<code>\#ref()</code> 可被取代為 '\=\='
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 內部的物件實例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 內部的物件實例化 \#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 內部的物件實例化 \#loc
object.notify.display.name=呼叫 'notify()' 而不是 'notifyAll()'
object.notify.problem.descriptor=<code>\#ref</code> 可能應當取代為 'notifyAll()' \#loc
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包裝
objects.hash.problem.descriptor=傳遞給 'Objects.hash()' 的陣列應包裝在 'Arrays.hashcode()' 中
octal.and.decimal.integers.in.same.array.display.name=同一陣列中的八進制和十進制整數
octal.and.decimal.integers.in.same.array.problem.descriptor=同一陣列初始設定式中的八進制和十進制整數 \#loc
octal.literal.display.name=八進制整數
octal.literal.problem.descriptor=八進制整數 <code>\#ref</code> \#loc
only.report.public.methods.option=僅報告 'public' 方法
only.report.qualified.static.usages.option=僅報告來自 static 上下文的限定靜態存取
only.report.static.methods=僅報告 'static' 方法(&O)
only.warn.on.protected.clone.methods=僅對 'protected' 克隆方法發出警告
only.warn.on.public.clone.methods=僅對 'public' 克隆方法發出警告
optional.contains.array.problem.descriptor='Optional' 包含陣列 <code>\#ref</code>
optional.contains.collection.display.name='Optional' 包含陣列或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>\#ref</code>
optional.used.as.field.or.parameter.type.display.name=用作欄位或參數類型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>\#ref</code> 用作欄位 ''{0}'' 的類型
optional.used.as.parameter.type.problem.descriptor=<code>\#ref</code> 用作參數 ''{0}'' 的類型
options.label.ignored.classes=已忽略的類別\:
options.title.ignored.classes=已忽略的類別
overloaded.methods.with.same.number.parameters.display.name=具有相同參數數量的多載方法
overloaded.methods.with.same.number.parameters.option=<html>忽略參數類型絕對不相容的多載方法</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同數量參數的多個方法命名 <code>\#ref</code> \#loc
overloaded.vararg.constructor.problem.descriptor=多載 vararg 建構函式 <code>\#ref()</code> \#loc
overloaded.vararg.method.display.name=多載 vararg 方法
overloaded.vararg.method.problem.descriptor=多載 vararg 方法 <code>\#ref()</code> \#loc
overloaded.vararg.method.problem.option=忽略參數類型絕對不相容的多載方法
overly.broad.throws.clause.display.name=過寬的 'throws' 子句
overly.broad.throws.clause.ignore.thrown.option=忽略隱藏其他異常但自身被拋出的異常(&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws \#ref</code> 過寬，遮罩異常 ''{0}'' \#loc
overly.broad.throws.clause.problem.descriptor2=<code>throws \#ref</code> 過寬，遮罩異常 ''{0}'' 和 ''{1}'' \#loc
overly.broad.throws.clause.quickfix1=新增特定異常
overly.broad.throws.clause.quickfix2=取代為特定異常
overly.broad.throws.clause.threshold.option=要報告的最大隱藏異常數\:
overly.complex.anonymous.inner.class.display.name=過度複雜的匿名類別
overly.complex.anonymous.inner.class.problem.descriptor=過度複雜的匿名類別 (迴圈復雜度 \= {0}) \#loc
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
overly.complex.arithmetic.expression.max.number.option=最大項數\:
overly.complex.arithmetic.expression.problem.descriptor=過於複雜的算術表達式 \#loc
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
overly.complex.boolean.expression.ignore.option=忽略純合取和析取
overly.complex.boolean.expression.max.terms.option=最大項數\:
overly.complex.boolean.expression.problem.descriptor=過度複雜的布爾表達式 ({0} 項) \#loc
overly.complex.class.display.name=過度複雜的類別
overly.complex.class.problem.descriptor=過度複雜的類別<code>\#ref</code> (迴圈復雜度 \= {0}) \#loc
overly.coupled.class.class.coupling.limit.option=類別耦合限制\:
overly.coupled.class.display.name=過度耦合的類別
overly.coupled.class.problem.descriptor=<code>\#ref</code> 過度耦合 (相依 \= {0}) \#loc
overly.long.lambda.display.name=過長的 lambda 表達式
overly.long.lambda.problem.descriptor=lambda 表達式過長 (\# 非註釋源語句 \= {0}) \#loc
overly.strong.type.cast.display.name=過強的類型轉換
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有符合 instanceof 表達式的轉換
overly.strong.type.cast.problem.descriptor=到 <code>\#ref</code> 的轉換可以被削弱為 ''{0}'' \#loc
overly.strong.type.cast.weaken.quickfix=削弱過強的轉換
overridable.method.call.in.constructor.display.name=物件建構期間呼叫的可覆寫方法
overridable.method.call.in.constructor.problem.descriptor=物件建構期間呼叫可覆寫方法 <code>\#ref()</code> \#loc
overridden.method.call.in.constructor.display.name=覆寫的方法在物件建構期間呼叫
overridden.method.call.in.constructor.problem.descriptor=物件建構期間呼叫已覆寫方法 <code>\#ref()</code> \#loc
package.dot.html.may.be.package.info.convert.quickfix=轉換為 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=刪除 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' 可以轉換為 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因為 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以轉換為 <code>package-info.java</code>
package.in.multiple.modules.display.name=具有多個模組中的類別的軟體套件
package.in.multiple.modules.problem.descriptor.many=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 以及其他 {3} 個模組中的類別
package.in.multiple.modules.problem.descriptor2=軟體套件 ''{0}'' 具有模組 ''{1}'' 和 ''{2}'' 中的類別
package.in.multiple.modules.problem.descriptor3=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 和 ''{3}'' 中的類別
package.info.java.without.package.display.name=不帶 'package' 語句的 'package-info.java'
package.info.without.package.family.quickfix=新增 package 語句
package.info.without.package.problem.descriptor='package-info.java' 沒有 'package' 語句
package.info.without.package.quickfix=新增 ''package {0};''
package.local.field.not.accessible=package-private 欄位 ''{0}'' 無法從此處存取
package.local.private=package-private 與 private
package.naming.convention.display.name=軟體套件命名約定
package.naming.convention.problem.descriptor.long=軟體套件名稱 <code>{0}</code> 過長
package.naming.convention.problem.descriptor.regex.mismatch=軟體套件名稱 <code>{0}</code> 與正則表達式 ''{1}'' 不符合
package.naming.convention.problem.descriptor.short=軟體套件名稱 <code>{0}</code> 過短
package.visible.field.display.name=軟體套件可見欄位
package.visible.field.problem.descriptor=軟體套件可見欄位 <code>\#ref</code> \#loc
package.visible.inner.class.display.name=軟體套件可見的嵌套類別
package.visible.inner.class.ignore.enum.option=忽略軟體套件可見的內部枚舉
package.visible.inner.class.ignore.interface.option=忽略軟體套件可見的內部接口
package.visible.inner.class.problem.descriptor=軟體套件可見的嵌套類別 <code>\#ref</code> \#loc
package.with.too.few.classes.display.name=軟體套件具有過少類別
package.with.too.few.classes.min.option=最小類別數\:
package.with.too.few.classes.problem.descriptor=軟體套件 ''{0}'' 包含過少的類別 ({1} < {2})
package.with.too.many.classes.display.name=類別過多的軟體套件
package.with.too.many.classes.max.option=最大類別數\:
package.with.too.many.classes.problem.descriptor=軟體套件 ''{0}'' 包含過多的類別 ({1} > {2})
parameter.hides.member.variable.display.name=參數隱藏欄位
parameter.hides.member.variable.ignore.abstract.methods.option=對 abstract 方法忽略
parameter.hides.member.variable.ignore.constructors.option=對建構函式忽略
parameter.hides.member.variable.ignore.setters.option=對屬性 setter 忽略
parameter.hides.member.variable.ignore.static.parameters.option=對隱藏實例欄位的 static 方法參數忽略
parameter.hides.member.variable.ignore.superclass.option=忽略從子類別不可見的超類別欄位
parameter.hides.member.variable.problem.descriptor=參數 <code>\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \#loc
parameter.limit.option=參數限制\:
parameter.name.differs.from.overridden.parameter.display.name=參數名稱與覆寫或多載方法中的參數不同
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果覆寫的參數僅包含一個字元，則忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果覆寫的參數來自庫，則忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=參數名 <code>\#ref</code> 不同於{1, choice, 1\#super 方法|2\#多載方法|3\#super 建構函式|4\#多載建構函式}中的參數 ''{0}'' \#loc
parameter.naming.convention.display.name=方法參數命名約定
parameter.naming.convention.element.description=參數
parameter.type.prevents.overriding.display.name=參數類型阻止覆寫
parameter.type.prevents.overriding.family.quickfix=更改參數類型
parameter.type.prevents.overriding.problem.descriptor=參數類型 <code>\#ref</code> 位於 ''{0}''，而 super 方法參數類型位於 ''{1}''，可防止覆寫 \#loc
parameter.type.prevents.overriding.quickfix=將參數類型更改為 ''{0}''
parameters.per.constructor.display.name=參數過多的建構函式
parameters.per.constructor.problem.descriptor=<code>\#ref()</code> 的參數過多(參數數量 \= {0}) \#loc
parameters.per.method.display.name=參數過多的方法
parameters.per.method.problem.descriptor=<code>\#ref()</code> 的參數過多(參數數量 \= {0}) \#loc
pattern.variable.hides.field.display.name=模式變數隱藏欄位
pattern.variable.hides.field.problem.descriptor=模式變數 <code>\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \#loc
pointless.arithmetic.expression.display.name=無意義的算術表達式
pointless.bitwise.expression.display.name=無意義的按位表達式
pointless.bitwise.expression.simplify.quickfix=簡化
pointless.boolean.expression.display.name=無意義的布爾表達式
pointless.boolean.expression.ignore.option=在確定無意義表達式時忽略命名常數
pointless.indexof.comparison.always.false.problem.descriptor=<code>\#ref</code> 始終為 false \#loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>\#ref</code> 始終為 true \#loc
pointless.indexof.comparison.display.name=無意義的 'indexOf()' 比較
pointless.nullcheck.display.name=方法呼叫前出現不必要的 'null' 檢查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 呼叫之前的 ''null'' 檢查不必要
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 塊內拋出 \#loc
prefer.empty.array.options.mode.always=始終
prefer.empty.array.options.mode.always.never=從不(首選預設大小的陣列)
prefer.empty.array.options.mode.by.level=根據語言級別
prefer.empty.array.options.title=首選空陣列\:
prefix.operation.quickfix.family.name=取代為前綴運算符
press.escape.to.remove.highlighting.message=按 Esc 移除醒目提示
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元陣列實參
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元陣列實參 \#loc
primitive.fields.ignore.option=忽略原始欄位
printstacktrace.call.display.name=呼叫 'printStackTrace()'
printstacktrace.call.problem.descriptor=對 <code>\#ref()</code> 的呼叫可能應當取代為更可靠的日誌 \#loc
private=private
private.field.not.accessible.problem.descriptor=''private'' 欄位 ''{0}'' 無法從此處存取
private.member.access.between.outer.and.inner.classes.display.name=合成存取器呼叫
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=將 ''{0}'' 建構函式設為 package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=將 ''{0}'' 設為 package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=存取類別 ''{0}'' 的 ''private'' 成員需要合成存取器 \#loc
problematic.varargs.method.display.name=非 vararg 方法覆寫 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>\#ref()</code> 覆寫 vararg 方法 \#loc
progress.text.analyzing.package.0=正在分析軟體套件 {0}
properties.object.as.hashtable.display.name=將 'Properties' 物件用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在屬性物件上呼叫 <code>Hashtable.\#ref()</code> \#loc
property.value.set.to.itself.display.name=屬性值設定為自身
protected.field.display.name=protected 欄位
protected.field.not.accessible.problem.descriptor=''protected'' 欄位 ''{0}'' 無法從此處存取
protected.field.problem.descriptor=protected 欄位 <code>\#ref</code> \#loc
protected.inner.class.display.name=protected 嵌套類別
protected.inner.class.ignore.enum.option=忽略 'protected' 內部枚舉
protected.inner.class.ignore.interface.option=忽略 'protected' 內部接口
protected.inner.class.problem.descriptor=protected 嵌套類別 <code>\#ref</code> \#loc
protected.member.in.final.class.display.name='protected' 成員位於 'final' 類別中
protected.member.in.final.class.problem.descriptor=類別成員在 'final' 類別中被宣告為 <code>\#ref</code> \#loc
protected.package.local.private=protected、package-private 和 private
public.constructor.display.name='public' 建構函式可被取代為工廠方法
public.constructor.in.non.public.class.display.name='public' 建構函式位於非 public 類別中
public.constructor.in.non.public.class.problem.descriptor=建構函式在非 public 類別 ''{0}'' 中被宣告為 <code>\#ref</code> \#loc
public.constructor.in.non.public.class.quickfix=將建構函式設為 private
public.constructor.problem.descriptor=public 建構函式 <code>\#ref()</code> \#loc
public.constructor.quickfix=將建構函式取代為工廠方法
public.default.constructor.problem.descriptor=類別 <code>\#ref</code> 具有 'public' 預設建構函式
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中存取d了非 private 欄位
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中存取非 private 欄位 <code>\#ref</code> \#loc
public.field.display.name='public' 欄位
public.field.ignore.enum.type.fields.option=忽略枚舉類型的 'public final' 欄位
public.field.problem.descriptor='public' 欄位 <code>\#ref</code> \#loc
public.inner.class.display.name='public' 嵌套類別
public.inner.class.ignore.enum.option=忽略 'public' 內部枚舉
public.inner.class.ignore.interface.option=忽略 'public' 內部接口
public.inner.class.problem.descriptor='public' 嵌套類別 <code>\#ref</code> \#loc
public.method.not.in.interface.display.name='public' 方法在接口中未公開
public.method.not.in.interface.option=<html>如果包含類別未實作非庫接口，則忽略</html>
public.method.not.in.interface.problem.descriptor='public' 方法 <code>\#ref()</code> 未通過接口公開 \#loc
public.method.without.logging.display.name='public' 方法沒有日誌記錄
public.method.without.logging.problem.descriptor='public' 方法 <code>\#ref()</code> 沒有日誌呼叫 \#loc
public.static.array.field.display.name='public static' 陣列欄位
public.static.array.field.problem.descriptor='public static' 陣列欄位 <code>\#ref</code>，影響安全性 \#loc
public.static.collection.field.display.name='public static' 集合欄位
public.static.collection.field.problem.descriptor='public static' 集合欄位 <code>\#ref</code>，影響安全性 \#loc
qualify.call.fix.family.name=限定呼叫
query.label=查詢名稱開頭\:
questionable.name.display.name=可疑名稱
questionable.name.list.label=報告的名稱\:
questionable.name.problem.descriptor=可疑名稱 <code>\#ref</code> \#loc
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 獲取隨機整數
random.double.for.random.integer.problem.descriptor=使用 <code>Random.\#ref</code> 建立隨機整數 \#loc
raw.use.of.parameterized.type.display.name=參數化類別的原始使用
readobject.initialization.display.name=實例欄位可能無法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=實例欄位 <code>\#ref</code> 在 'readObject()' 呼叫期間可能無法初始化 \#loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被宣告為 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>\#ref()</code> 未被宣告為 'protected' \#loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被宣告為 'private'
readwriteobject.private.problem.descriptor=<code>\#ref</code> 未被宣告為 'private' \#loc
recordstore.opened.not.safely.closed.display.name=開啟了 'RecordStore'，但未安全關閉
redundant.as.list.for.iteration.fix.name=解包
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 呼叫
redundant.call.problem.descriptor=冗餘呼叫 <code>\#ref()</code> \#loc
redundant.else.display.name=冗餘的 'else'
redundant.else.problem.descriptor=<code>\#ref</code> 分支可以解包，因為 'if' 分支永遠不會正常完成 \#loc
redundant.else.unwrap.quickfix=移除冗餘的 'else'
redundant.escape.in.regex.replacement.display.name=正則表達式取代字串中的冗餘轉義
redundant.escape.in.regex.replacement.problem.descriptor=''{0}'' 的冗餘轉義
redundant.escape.in.regex.replacement.quickfix=移除冗餘轉義
redundant.explicit.var.type.display.name=可以省略區域變數類型
redundant.field.initialization.display.name=冗餘欄位初始化
redundant.field.initialization.problem.descriptor=<code>\#ref</code> 的欄位初始化是冗餘的 \#loc
redundant.field.initialization.remove.quickfix=移除初始設定式
redundant.implements.display.name=冗餘接口宣告
redundant.implements.problem.descriptor=冗餘接口宣告 <code>\#ref</code> \#loc
redundant.implements.remove.quickfix=移除冗餘接口宣告
redundant.local.variable.annotation.option=忽略具有註解的變數
redundant.local.variable.display.name=冗餘區域變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.method.override.delegate.quickfix=將方法取代為到 super 的委託
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>\#ref()</code> 僅委託給 super 方法 \#loc
redundant.method.override.display.name=方法與其 super 方法相同
redundant.method.override.option.check.library.methods=檢查覆寫庫方法的方法
redundant.method.override.option.ignore.delegates=忽略到 super 方法的委託
redundant.method.override.problem.descriptor=方法 <code>\#ref()</code> 與其 super 方法相同 \#loc
redundant.method.override.quickfix=移除冗餘方法
redundant.string.format.call.display.name=冗餘呼叫 'String.format()'
redundant.string.format.call.quickfix=移除對 'String.format()' 的冗餘呼叫
redundant.string.formatted.call.quickfix=移除對 'String.formatted()' 的冗餘呼叫
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=從超類別 {1} 初始設定式參照子類別 {0} 可能會導致類別載入死鎖
reflection.for.unavailable.annotation.display.name=對僅源註解的反射存取
reflection.for.unavailable.annotation.problem.descriptor=註解 '\#ref' 不保留用於反射存取 \#loc
refused.bequest.display.name=方法不呼叫 super 方法
refused.bequest.fix.family.name=將呼叫插入 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.problem.descriptor=方法 <code>\#ref()</code> 未呼叫 'super.\#ref()' \#loc
remove.annotation.parameter.0.fix.name=移除註解參數 ''{0}''
remove.call.fix.family.name=移除呼叫
remove.cloneable.quickfix=從 'implements' 子句中移除 'Cloneable'
remove.finally.block.quickfix=移除 'finally' 塊
remove.leading.zero.to.make.decimal.quickfix=移除前導零以變為十進制
remove.leading.zeroes.to.make.decimals.quickfix=移除前導零以變為十進制
remove.loop.fix.family.name=移除迴圈
remove.modifier.fix.family.name=移除修飾符
remove.modifier.quickfix=移除 ''{0}'' 修飾符
remove.redundant.polyadic.operand.fix.family.name=移除不必要的條件
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 條件
remove.redundant.string.fix.text=使用 ''{0}()'' 並移除冗餘的 ''{1}()'' 呼叫
remove.redundant.substring.fix.family.name=移除冗餘的 'substring()' 呼叫
remove.try.finally.block.quickfix=移除 'try-finally' 塊
remove.unnecessary.0.call.quickfix=移除不必要的 ''{0}()'' 呼叫
rename.quickfix=重新命名
renameto.quickfix=重命名為 ''{0}''
replace.all.dot.display.name=可疑的正則表達式實參
replace.all.dot.problem.descriptor=''{0}()'' 呼叫中存在可疑的正則表達式 \#ref \#loc
replace.all.dot.quickfix=轉義正則表達式元字元
replace.all.file.separator.problem.descriptor=File.separator 用作正則表達式；無法在 Windows 上工作
replace.anonymous.with.lambda.body.fix.family.name=將呼叫取代為方法體
replace.case.default.null.with.null.default=將 'case default, null' 取代為 'case null, default'
replace.case.default.with.default=將 'case default' 取代為 'default'
replace.cast.fix.family.name=取代轉換類型
replace.casted.literal.with.just.literal.fix.family.name=取代為 {0} 字面量
replace.field.reference.fix.family.name=取代欄位參照
replace.field.reference.fix.text=將欄位參照取代為 ''{0}''
replace.inheritance.with.delegation.quickfix=將繼承取代為委託
replace.instanceof.fix.family.name=取代 instanceOf 類型
replace.method.call.fix.family.name=取代方法呼叫
replace.method.call.fix.text=將方法呼叫取代為 ''{0}''
replace.method.ref.with.qualifier.fix.family.name=取代為限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可被取代為呼叫限定符
replace.method.ref.with.qualifier.problem.method=方法參照可被取代為限定符
replace.with.cast.fix.family.name=取代為轉換
replace.with.catch.clause.for.runtime.exception.quickfix=針對 'RuntimeException' 取代為 'catch' 子句
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法簡化比較器
replace.with.lambda.body.fix.family.name=將 lambda 上的方法呼叫取代為 lambda 體
replace.with.method.ref.fix.family.name=將 lambda 取代為方法參照
replace.with.method.ref.fix.name.may.change.semantics=將 lambda 取代為方法參照(可能更改語意)
replace.with.method.reference.fix.family.name=將方法參照上的方法呼叫取代為相應的方法呼叫
replace.with.var.fix.family.name=將顯式類型取代為 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' 應在 ''try'' 塊之前開啟，並在相應的 ''finally'' 塊中關閉 \#loc
result.of.method.call.ignored.class.column.title=類別名
result.of.method.call.ignored.display.name=方法呼叫的結果已忽略
result.of.method.call.ignored.non.library.option=報告所有忽略的非庫呼叫
result.of.method.call.ignored.problem.descriptor=<code>{0}.\#ref()</code> 的結果已忽略 \#loc
result.of.object.allocation.fix.name=忽略類型 ''{0}'' 的物件的分配
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.options.chooserTitle=選擇可以忽略物件分配的類別
result.of.object.allocation.ignored.problem.descriptor=<code>new \#ref()</code> 的結果已忽略 \#loc
result.of.object.allocation.ignored.problem.descriptor.methodRef=在 <code>\#ref</code> 內部分配的物件已被捨棄 \#loc
return.from.finally.block.display.name='return' 位於 'finally' 塊內
return.from.finally.block.problem.descriptor='return' 位於 'finally' 塊內 \#loc
return.of.anonymous.class.problem.descriptor=返回匿名類別的實例 \#loc
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor={0} 欄位 <code>\#ref</code> 的返回值 \#loc
return.of.inner.class.display.name=返回匿名、區域或內部類別的實例
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
return.of.inner.class.problem.descriptor=返回非 static 內部類別 <code>{0}</code> 的實例 \#loc
return.of.local.class.problem.descriptor=返回區域類別 <code>{0}</code> 的實例 \#loc
return.of.null.arrays.option=報告返回陣列的方法
return.of.null.collections.option=報告返回集合物件的方法
return.of.null.display.name=返回 'null'
return.of.null.ignore.private.option=忽略 'private' 方法、匿名類別和 lambda
return.of.null.objects.option=報告返回物件的方法
return.of.null.problem.descriptor=返回 <code>\#ref</code> \#loc
return.point.limit.option=返回點限制(&R)\:
return.this.display.name=返回 'this'
return.this.problem.descriptor=返回 <code>\#ref</code> \#loc
reuse.of.local.variable.display.name=區域變數的重用
reuse.of.local.variable.problem.descriptor=區域變數 <code>\#ref</code> 的重用 \#loc
reuse.of.local.variable.split.quickfix=拆分區域變數
runtime.exec.call.display.name=呼叫 'Runtime.exec()'
runtime.exec.call.problem.descriptor=對 <code>Runtime.\#ref()</code> 的呼叫不可移植 \#loc
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 呼叫具有非常數字串
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.\#ref()</code> 呼叫具有非常數實參 \#loc
safe.lock.display.name=已獲取但未安全解鎖的鎖
safe.lock.problem.descriptor=''{0}'' 應在 ''try'' 塊之前鎖定，並在相應的 ''finally'' 塊中解鎖 \#loc
sequenced.collection.method.can.be.used.ignore.option=忽略用作實參的命名常數
serial.annotation.used.on.wrong.member.display.name=對錯誤的成員使用了 '@Serial' 註解
serial.annotation.used.on.wrong.member.problem.descriptor=註解的成員不是序列化機制的一部分
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名類別隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.class.in.secure.context.display.name=安全上下文中的可序列化類別
serializable.class.in.secure.context.problem.descriptor=類別 <code>\#ref</code> 可能被序列化，影響安全性 \#loc
serializable.deserializable.class.in.secure.context.problem.descriptor=類別 <code>\#ref</code> 可能被序列化和反序列化，影響安全性 \#loc
serializable.has.serialization.methods.display.name=不帶 'readObject()' 和 'writeObject()' 的可序列化類別
serializable.has.serialization.methods.ignore.option=忽略未定義實例欄位的類別
serializable.has.serialization.methods.problem.descriptor=可序列化類別 <code>\#ref</code> 未定義 'readObject()' 或 'writeObject()' \#loc
serializable.has.serialization.methods.problem.descriptor1=可序列化類別 <code>\#ref</code> 未定義 'writeObject()' \#loc
serializable.has.serialization.methods.problem.descriptor2=可序列化類別 <code>\#ref</code> 未定義 'readObject()' \#loc
serializable.inner.class.has.serial.version.uid.field.display.name=沒有 'serialVersionUID' 的可序列化非 static 內部類別
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=內部類別 <code>\#ref</code> 未定義 'serialVersionUID' 欄位 \#loc
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 內部類別具有不可序列化外部類
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=內部類別 <code>\#ref</code> 可序列化，而其外部類別不可序列化 \#loc
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化區域類別 ''{1}'' 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.record.contains.ignored.field.problem.descriptor=在記錄序列化期間將忽略 <code>\#ref</code>
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成員
serializable.record.contains.ignored.method.problem.descriptor=在記錄序列化期間將忽略 <code>\#ref()</code>
serializable.stores.non.serializable.display.name='Serializable' 物件隱式存儲非 'Serializable' 物件
serializable.with.unconstructable.ancestor.display.name=具有不可建構上級的可序列化類別
serializable.with.unconstructable.ancestor.problem.descriptor=<code>\#ref</code> 具有不帶無實參建構函式的不可序列化上級 ''{0}'' \#loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 欄位未被宣告為 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化類別的 <code>\#ref</code> 欄位未被宣告為 'private static final ObjectStreamField[]' \#loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 欄位未被宣告為 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化類別的 <code>\#ref</code> 欄位未被宣告為 'private static final long' \#loc
serialversionuid.private.static.final.long.quickfix=將 serialVersionUID 設為 'private static final'
set.annotation.parameter.0.1.fix.name=將註解參數 {0} 設定為“{1}”
set.replaceable.by.enum.set.display.name='Set' 可被取代為 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>\#ref</code> 可被取代為 'EnumSet' \#loc
shared.thread.local.random.display.name='ThreadLocalRandom' 實例可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 實例可能在線程之間共享
shift.operation.by.inappropriate.constant.display.name=按不當常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>\#ref</code> 進行移位運算時使用的常量值 {0} 為負 \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出範圍的值 {0} 進行移位運算 <code>\#ref</code> \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>\#ref</code> 進行移位運算時使用的常量值 {0} 過大 \#loc
shift.out.of.range.fix.family.name=修復移位值
signal.without.corresponding.await.display.name=沒有相應 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在沒有相應 <code>await()</code> 的情況下呼叫 <code>\#ref()</code> \#loc
simplifiable.annotation.braces.problem.descriptor=註解中 <code>{0}</code> 周圍不必要的圓括號 \#loc
simplifiable.annotation.display.name=可簡化註解
simplifiable.annotation.problem.descriptor=註解中有不必要的 <code>\#ref</code> \#loc
simplifiable.annotation.quickfix=簡化註解
simplifiable.annotation.whitespace.problem.descriptor=註解中有不必要的空格 \#loc
simplifiable.boolean.expression.display.name=可簡化的布爾表達式
simplifiable.conditional.expression.display.name=可簡化的條件表達式
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> 可以簡化為 ''{0}'' \#loc
simplifiable.equals.expression.display.name='equals()' 呼叫之前的 'null' 檢查不必要
simplifiable.equals.expression.option.non.constant=Report equals with non-constant non-null argument
simplifiable.equals.expression.problem.descriptor=''{0}()'' 呼叫之前的 ''null'' 檢查不必要 \#loc
simplifiable.equals.expression.quickfix=翻轉 ''.{0}()'' 並移除不必要的 ''null'' 檢查
simplifiable.junit.assertion.display.name=可簡化斷言
simplifiable.junit.assertion.problem.descriptor=<code>\#ref()</code> 可以簡化為 ''{0}'' \#loc
simplify.junit.assertion.simplify.quickfix=簡化斷言
single.character.startswith.display.name=單個字元 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=單個字元 <code>\#ref()</code> 可被取代為 'charAt()' 表達式 \#loc
single.character.startswith.quickfix=取代為 'charAt()' 表達式
single.class.import.display.name=單個類別匯入
single.class.import.problem.descriptor=單個類別匯入 <code>\#ref</code> \#loc
single.element.annotation.family.quickfix=將註解擴展為標準形式
single.element.annotation.name=非規范化註解
single.element.annotation.quickfix=新增 'value\='
single.statement.in.block.descriptor=''{0}'' 包含單條語句
single.statement.in.block.family.quickfix=從語句中移除大括號
single.statement.in.block.name=程式碼塊包含單條語句
single.statement.in.block.quickfix=從 ''{0}'' 語句中移除大括號
singleton.display.name=單例
singleton.problem.descriptor=類別 <code>\#ref</code> 為單例 \#loc
size.replaceable.by.isempty.display.name='size() \=\= 0' 可被取代為 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=忽略類型 ''{1}'' 上的 ''.{0}()'' 呼叫
size.replaceable.by.isempty.negation.ignore.option=忽略將取代為 '\!isEmpty()' 的表達式
sleep.while.holding.lock.display.name=同步時呼叫 'Thread.sleep()'
sleep.while.holding.lock.problem.descriptor=同步時呼叫 <code>Thread.\#ref()</code> \#loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
socket.opened.not.closed.display.name=套接字已開啟，但未安全關閉
standard.variable.names.display.name=標準變數名稱
standard.variable.names.ignore.override.option=對與 super 方法參數相同的參數名稱忽略
standard.variable.names.problem.descriptor=變數命名 <code>\#ref</code> 沒有類型 ''{0}'' \#loc
standard.variable.names.problem.descriptor2=變數命名 <code>\#ref</code> 沒有類型 ''{0}'' 或 ''{1}'' \#loc
statement.problem.descriptor=<code>\#ref</code> 語句 \#loc
statement.with.empty.body.display.name=帶空體的語句
statement.with.empty.body.include.option=包含空程式碼塊語句正文
statement.with.empty.body.problem.descriptor=<code>\#ref</code> 語句具有空體 \#loc
static.collection.display.name=靜態集合
static.collection.ignore.option=忽略弱靜態集合或映射
static.collection.problem.descriptor=靜態集合 <code>\#ref</code> \#loc
static.field.via.subclass.display.name=static 欄位通過子類別參照
static.field.via.subclass.problem.descriptor=static 欄位 <code>\#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \#loc
static.field.via.subclass.rationalize.quickfix=使 static 欄位存取合理化
static.import.display.name=static import
static.import.fix.ignore.class=允許類別 ''{0}'' 的 static import
static.import.options.border.title=靜態可匯入類別\:
static.import.options.chooserTitle=選擇靜態可匯入類別
static.import.problem.descriptor=static import <code>\#ref</code>  \#loc
static.import.replace.quickfix=取代為非 static import
static.inheritance.display.name=靜態繼承
static.inheritance.fix.family.name=將繼承取代為限定參照
static.inheritance.problem.descriptor=接口 <code>\#ref</code> 僅針對其 static 常數實作 \#loc
static.inheritance.replace.quickfix=將繼承取代為 {0} 中的限定參照
static.initializer.references.subclass.display.name=static 初始設定式參照子類別
static.method.naming.convention.element.description='static' 方法
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1\#方法|2\#欄位} <code>\#ref{0, choice, 1\#()|2\#}</code> 僅在派生自 ''{1}'' 的匿名類別中使用 \#loc
static.method.only.used.in.one.class.display.name=static 成員僅在其他一個類別中使用
static.method.only.used.in.one.class.ignore.anonymous.option=僅在匿名類別中使用時忽略
static.method.only.used.in.one.class.ignore.on.conflicts=當方法無法在不產生衝突的情況下移動時忽略
static.method.only.used.in.one.class.ignore.test.option=僅在測試類別中使用時忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位於實用程序類別中的成員
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1\#方法|2\#欄位} <code>\#ref{0, choice, 1\#()|2\#}</code> 僅在 ''{1}'' 類別中使用 \#loc
static.method.only.used.in.one.class.quickfix=將 {0} 移至使用類別
static.method.only.used.in.one.class.quickfix.preview=將 static 成員移至使用它的類別。
static.method.via.subclass.display.name=static 方法通過子類別參照
static.method.via.subclass.problem.descriptor=static 方法 <code>\#ref()</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \#loc
static.method.via.subclass.rationalize.quickfix=使 static 方法呼叫合理化
static.non.final.field.display.name='static' 非 'final' 欄位
static.non.final.field.option=僅報告 'public' 欄位
static.non.final.field.problem.descriptor='static' 非 'final' 欄位 <code>\#ref</code> \#loc
static.variable.may.not.be.initialized.display.name=static 欄位可能無法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 欄位 <code>\#ref</code> 在類別初始化期間可能無法初始化 \#loc
static.variable.naming.convention.element.description='static' 欄位
static.variable.of.concrete.class.problem.descriptor=具體類別 <code>\#ref</code> 的 static 欄位 ''{0}'' \#loc
static.variable.used.before.initialization.display.name=static 欄位在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 欄位 <code>\#ref</code> 在初始化前使用 \#loc
string.buffer.must.have.initial.capacity.display.name=沒有初始容量的 'StringBuilder'
string.buffer.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new \#ref()</code> \#loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer \#ref</code> 可能被宣告為 'StringBuilder' \#loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可被取代為 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} \#ref</code> 可被取代為 ''String'' \#loc
string.comparison.display.name=使用 '\=\=' 而不是 'equals()' 進行字串比較
string.comparison.problem.descriptor=使用 <code>\#ref</code> 而不是 'equals()' 來比較字串值 \#loc
string.concatenation.argument.to.log.call.display.name=非常數字串串聯作為日誌呼叫的實參
string.concatenation.argument.to.log.call.problem.descriptor=非常數字串作為 <code>\#ref()</code> 日誌記錄呼叫的實參 \#loc
string.concatenation.argument.to.log.call.quickfix=將串聯取代為參數化的日誌訊息
string.concatenation.argument.to.log.message.format.call.quickfix=將 'Message.format()' 取代為參數化日誌訊息
string.concatenation.argument.to.log.string.format.call.quickfix=將 'String.format()' 取代為參數化日誌訊息
string.concatenation.display.name=字串串聯
string.concatenation.in.format.call.display.name=字串串聯作為 'format()' 呼叫的實參
string.concatenation.in.format.call.fix.family.name=將串聯取代為實參
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 呼叫包含字串串聯實參
string.concatenation.in.format.call.quickfix=將串聯取代為單獨的實參
string.concatenation.in.loops.display.name=字串串聯在迴圈中
string.concatenation.in.loops.problem.descriptor=迴圈中的字串串聯 <code>\#ref</code> \#loc
string.concatenation.in.message.format.call.display.name=字串串聯作為 'MessageFormat.format()' 呼叫的實參
string.concatenation.in.message.format.call.problem.descriptor=字串串聯作為 'MessageFormat.format()' 呼叫的實參 \#loc
string.concatenation.inside.string.buffer.append.display.name=字串串聯作為 'StringBuilder.append()' 呼叫的實參
string.concatenation.inside.string.buffer.append.problem.descriptor=字串串聯作為 <code>{0}.\#ref()</code> 呼叫的實參 \#loc
string.concatenation.inside.string.buffer.append.replace.quickfix=取代為鏈式 'append()' 呼叫
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新變數 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新變數 ''{0}'' (null 安全)
string.concatenation.missing.whitespace.display.name=字串串聯中可能缺少空格
string.concatenation.missing.whitespace.option=忽略具有變量字串的串聯
string.concatenation.missing.whitespace.problem.descriptor=字串串聯中可能缺少空格 \#loc
string.concatenation.problem.descriptor=國際化上下文中的字串串聯 <code>\#ref</code> \#loc
string.concatenation.replace.fix=取代為 StringBuilder
string.concatenation.replace.fix.name=將變數 ''{0}'' 從字串轉換為 {1}
string.concatenation.replace.fix.name.null.safe=將變數 ''{0}'' 從字串轉換為 {1} (null 安全)
string.equals.char.sequence.display.name=使用 'CharSequence' 實參呼叫了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 實參呼叫了 <code>String.equals()</code> \#loc
string.equals.empty.string.display.name='String.equals()' 可被取代為 'String.isEmpty()'
string.equals.empty.string.fix.family.name=簡化空字串檢查
string.equals.empty.string.is.empty.problem.descriptor=<code>\#ref("")</code> 可被取代為 'isEmpty()' \#loc
string.equals.empty.string.option.do.not.add.null.check=當有必要進行 null 檢查時，不必報告
string.equals.empty.string.problem.descriptor=<code>\#ref("")</code> 可被取代為 'length()\=\=0' \#loc
string.format.choose.class=選擇格式化程序類別
string.format.class.label=附加格式化程序類別\:
string.format.class.method.label=附加格式化程序方法\:
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表達式可被取代為 'contains()'
string.replace.quickfix=移除空字串動作數
string.replaceable.by.string.buffer.display.name=非常數 'String' 可被取代為 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=僅在迴圈中追加時發出警告
string.replaceable.by.string.buffer.problem.descriptor=非常數字串 <code>\#ref</code> 可能應被宣告為 'StringBuilder' \#loc
string.touppercase.tolowercase.without.locale.display.name=呼叫無區域設定的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用國際化字串指定區域設定的情況下呼叫 <code>String.\#ref()</code> \#loc
stringbuffer.field.display.name='StringBuilder' 欄位
stringbuffer.field.problem.descriptor=''{0}'' 欄位 <code>\#ref</code> \#loc
subtraction.in.compareto.display.name='compareTo()' 中的減法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的減法 <code>\#ref</code> 可能導致溢出或精度損失 \#loc
super.class.logger.option=在超類別有可存取的記錄器時忽略
suppress.for.tests.scope.quickfix=對 'Tests' 作用域禁止
suspicious.array.cast.display.name=可疑的陣列轉換
suspicious.array.cast.problem.descriptor=可疑轉換為 <code>\#ref</code> \#loc
suspicious.comparator.compare.descriptor.min.value=不建議從比較函式返回 Integer.MIN_VALUE
suspicious.comparator.compare.descriptor.non.negative=比較器從不返回負值
suspicious.comparator.compare.descriptor.non.positive=比較器從不返回正值
suspicious.comparator.compare.descriptor.non.reflexive=對於相等的元素，比較器不返回 0
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 ''{0}()'' 參數 <code>\#ref</code> \#loc
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 實作
suspicious.getter.problem.descriptor=getter <code>\#ref()</code> 返回欄位 ''{0}'' \#loc
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.indent.after.control.statement.display.name=沒有大括號的控制語句後存在可疑縮排
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 語句後存在可疑縮排 \#loc
suspicious.integer.div.assignment.display.name=可疑的整數除法賦值
suspicious.integer.div.assignment.problem.descriptor=除法結果被截斷為整數
suspicious.integer.div.assignment.quickfix=轉換為 double
suspicious.literal.underscore.display.name=數字字面量中的可疑下劃線
suspicious.literal.underscore.problem.descriptor=帶下劃線的數字字面量中的組沒有長度 3 \#loc
suspicious.package.private.access.display.name=可疑的 package-private 存取權限
suspicious.setter.problem.descriptor=setter <code>\#ref()</code> 對欄位 ''{0}'' 賦值 \#loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 呼叫
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=長度始終大於 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=長度始終大於 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=複製到具有相交範圍的同一陣列
suspicious.system.arraycopy.problem.descriptor4=<code>\#ref</code> 不是陣列類型 \#loc
suspicious.system.arraycopy.problem.descriptor5=<code>\#ref</code> 不是陣列類型 \#loc
suspicious.system.arraycopy.problem.descriptor6=源參數類型 ''{0}'' 不可分配給類型為 ''{1}'' 的目標參數 <code>\#ref</code> \#loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 呼叫
suspicious.to.array.call.fix.family.name=取代為正確陣列
suspicious.to.array.call.problem.descriptor=應為類型 ''{0}[]'' 的陣列，找到的是 ''{1}[]'' \#loc
swap.equals.fix.family.name=翻轉方法呼叫
switch.expression.with.single.default.message='switch' 表達式只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表達式的 case 標籤太少 ({0})，並且可能應當取代為 ''if'' 語句或條件運算符 \#loc
switch.statement.density.display.name='switch' 語句的分支密度過低
switch.statement.density.min.option=分支的最小密度\: %
switch.statement.density.problem.descriptor=<code>\#ref</code> 分支密度過低({0}%) \#loc
switch.statement.display.name='switch' 語句
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用並宣告的區域變數
switch.statement.with.confusing.declaration.problem.descriptor=區域變數 <code>\#ref</code> 在一個 'switch' 分支中宣告，並在另一個分支中使用 \#loc
switch.statement.with.single.default.message='switch' 語句只有 'default' case
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
switch.statement.with.too.few.branches.ignore.pattern.option=不報告模式 switch 語句
switch.statement.with.too.few.branches.min.option=最小分支數\:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 語句的 case 標籤太少({0})，並且可能應當取代為 ''if'' 語句 \#loc
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
switch.statement.without.default.ignore.option=忽略詳盡的 switch 語句
switch.statements.without.default.display.name=不帶 'default' 分支的 'switch' 語句
switch.statements.without.default.problem.descriptor=沒有 'default' 分支的 <code>\#ref</code> 語句 \#loc
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>\#ref()</code> 上同步 \#loc
synchronization.on.local.variable.or.method.parameter.display.name=在區域變數或方法參數上同步
synchronization.on.local.variable.problem.descriptor=在區域變數 <code>\#ref</code> 上同步 \#loc
synchronization.on.method.parameter.problem.descriptor=在方法參數 <code>\#ref</code> 上同步 \#loc
synchronization.on.static.field.display.name=在 'static' 欄位上同步
synchronization.on.static.field.problem.descriptor=在 'static' 欄位 <code>\#ref</code> 上同步 \#loc
synchronize.on.class.problem.descriptor=對類別的鎖定動作可能會產生不可預見的副作用 \#loc
synchronize.on.lock.display.name=在 'Lock' 物件上同步
synchronize.on.lock.problem.descriptor=在 ''{0}'' 物件上同步不太可能是故意的 \#loc
synchronize.on.non.final.field.display.name=在非 final 欄位上同步
synchronize.on.non.final.field.problem.descriptor=在非 final 欄位 <code>\#ref</code> 上同步 \#loc
synchronize.on.this.display.name=在 'this' 上同步
synchronize.on.this.problem.descriptor=對 'this' 的鎖定動作可能會產生不可預見的副作用 \#loc
synchronized.method.display.name='synchronized' 方法
synchronized.method.ignore.synchronized.super.option=忽略覆寫 synchronized 方法的方法
synchronized.method.include.option=包含本地方法
synchronized.method.move.quickfix=將同步移至方法中
synchronized.method.problem.descriptor=方法 ''{0}()'' 被宣告為 <code>\#ref</code> \#loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 字面量 <code>\#ref</code> 上同步 \#loc
synchronized.on.literal.object.name=在使用字面量初始化的物件上同步
synchronized.on.literal.object.problem.descriptor=在使用字面量初始化的 {0} <code>\#ref</code> 上同步 \#loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的字面量
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>\#ref</code> 上同步 \#loc
system.exit.call.display.name=呼叫 'System.exit()' 或相關方法
system.exit.call.ignore.option=在 main 方法中忽略
system.exit.call.problem.descriptor=對 <code>{0}.\#ref()</code> 的呼叫不可移植 \#loc
system.getenv.call.display.name=呼叫 'System.getenv()'
system.getenv.call.problem.descriptor=對 <code>System.\#ref()</code> 的呼叫不可移植 \#loc
system.properties.display.name=系統屬性的存取
system.properties.problem.descriptor=對 <code>Integer.\#ref()</code> 的呼叫可能造成安全問題 \#loc
system.properties.problem.descriptor1=對 <code>Boolean.\#ref()</code> 的呼叫可能造成安全問題 \#loc
system.run.finalizers.on.exit.display.name=呼叫 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=呼叫 <code>System.\#ref()</code> \#loc
system.set.problem.descriptor=對 <code>System.\#ref()</code> 的呼叫可能造成安全問題 \#loc
system.set.security.manager.display.name=呼叫 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=對 <code>System.\#ref()</code> 的呼叫可能造成安全問題 \#loc
tail.recursion.display.name=尾遞迴
tail.recursion.problem.descriptor=尾部遞迴呼叫 <code>\#ref()</code> \#loc
tail.recursion.replace.quickfix=用迭代替換尾部遞迴
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1\#語句|2\#表達式}中存在文本標籤 <code>\#ref\:</code> \#loc
the.whole.project=整個專案
this.class=此類別
this.reference.escaped.in.construction.display.name=物件建構中轉義的 'this' 參照
this.reference.escaped.in.construction.problem.descriptor=物件建構期間轉義 <code>\#ref</code> \#loc
thread.death.rethrown.display.name='ThreadDeath' 未重新拋出
thread.death.rethrown.problem.descriptor=ThreadDeath <code>\#ref</code> 未重新拋出 \#loc
thread.local.not.static.final.display.name='ThreadLocal' 欄位未被宣告為 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>\#ref</code> 未被宣告為 'static final' \#loc
thread.local.set.with.null.display.name=以 null 作為實參的 'ThreadLocal.set()'
thread.local.set.with.null.problem.descriptor=使用 null 作為實參的 'ThreadLocal.set()' 可能會導致記憶體泄漏
thread.local.set.with.null.quickfix=取代為 'ThreadLocal.remove()' 呼叫
thread.priority.display.name=呼叫 'Thread.setPriority()'
thread.priority.problem.descriptor=呼叫 <code>Thread.\#ref()</code> \#loc
thread.run.problem.descriptor=對 <code>\#ref()</code> 的呼叫可能應當取代為 'start()' \#loc
thread.start.in.construction.display.name=物件建構期間呼叫 'Thread.start()'
thread.start.in.construction.problem.descriptor=物件建構期間呼叫 <code>\#ref()</code> \#loc
thread.stop.suspend.resume.display.name=呼叫 'Thread.stop()'、'suspend()' 或 'resume()'
thread.stop.suspend.resume.problem.descriptor=呼叫 <code>Thread.\#ref()</code> \#loc
thread.with.default.run.method.display.name=使用預設的 'run()' 方法實例化 'Thread'
thread.with.default.run.method.problem.descriptor=使用預設的 'run()' 方法實例化 <code>\#ref</code> \#loc
thread.yield.display.name=呼叫 'Thread.yield()'
thread.yield.problem.descriptor=呼叫 <code>Thread.\#ref()</code> \#loc
three.negations.per.method.display.name=具有三個以上否定的方法
three.negations.per.method.ignore.assert.option=忽略 'assert' 語句中的否定
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.problem.descriptor=<code>\#ref</code> 包含 {0} 個否定 \#loc
throw,from.finally.block.everywhere.option=在可能拋出已宣告異常的每一處發出警告
throw.caught.locally.display.name=通過包含 'try' 語句捕獲 'throw'
throw.caught.locally.ignore.option=忽略重新拋出的異常
throw.caught.locally.problem.descriptor=通過包含 'try' 語句捕獲 <code>\#ref</code> \#loc
throw.from.finally.block.display.name='throw' 位於 'finally' 塊內
throw.from.finally.block.problem.descriptor=<code>\#ref</code> 位於 'finally' 塊內 \#loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已檢查的異常實例 <code>\#ref</code> 未拋出 \#loc
throwable.instance.never.thrown.error.problem.descriptor=錯誤實例 <code>\#ref</code> 未拋出 \#loc
throwable.instance.never.thrown.problem.descriptor=Throwable 實例 <code>\#ref</code> 未拋出 \#loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=執行時異常實例 <code>new \#ref()</code> 未拋出 \#loc
throwable.not.thrown.display.name='Throwable' 未拋出
throwable.printed.to.system.out.display.name='Throwable' 列印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 實參 <code>\#ref</code> 到 ''System.{0}.{1}()'' 呼叫
throwable.printed.to.system.out.problem.fix.level.option=修正的日誌方法\:
throwable.result.of.method.call.ignored.problem.descriptor=<code>\#ref()</code> 的結果未拋出 \#loc
throwable.supplier.only.throw.exception.name=Throwable 供應商從不返回值
throwable.supplier.only.throw.exception.problem.descriptor=Throwable 供應商不返回任何異常
throwable.supplier.only.throw.exception.quickfix=將 lambda 中的 'throw' 取代為 'return'
thrown.exceptions.per.method.display.name=方法宣告的異常過多
thrown.exceptions.per.method.limit.option=異常拋出限制\:
thrown.exceptions.per.method.problem.descriptor=<code>\#ref</code> 宣告的異常過多 (異常數量 \= {0}) \#loc
throws.runtime.exception.display.name=在 'throws' 子句中宣告的未檢查的異常
throws.runtime.exception.fix.family.name=從 'throws' 子句中移除
throws.runtime.exception.move.quickfix=將 ''{0}'' 移至 Javadoc ''@throws'' 標記中
throws.runtime.exception.problem.descriptor=在 'throws' 子句中宣告的未檢查的異常 <code>\#ref</code> \#loc
throws.runtime.exception.quickfix=從 ''throws'' 子句中移除 ''{0}''
time.tostring.call.display.name=呼叫 'Time.toString()'
time.tostring.call.problem.descriptor=國際化上下文中的 <code>Time.\#ref()</code> \#loc
to.array.call.style.display.name='Collection.toArray()' 呼叫樣式
to.array.call.style.problem.descriptor.presized=<code>\#ref()</code> 呼叫具有預設大小的陣列實參 ''{0}'' \#loc
to.array.call.style.problem.descriptor.zero=<code>\#ref()</code> 呼叫具有空陣列實參 ''{0}'' \#loc
to.array.call.style.quickfix.family.name=修復傳遞到 'toArray()' 呼叫的陣列的大小
to.array.call.style.quickfix.make.presized=將實參取代為預設大小的陣列
to.array.call.style.quickfix.make.zero=將實參取代為空陣列
too.broad.catch.display.name=過寬的 'catch' 塊
too.broad.catch.option=僅對 RuntimeException、異常、錯誤或 Throwable 發出警告(&O)
too.broad.catch.problem.descriptor=<code>\#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' \#loc
too.broad.catch.problem.descriptor1=<code>\#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' 和 ''{1}'' \#loc
too.broad.catch.quickfix=向 ''{0}'' 新增 ''catch'' 子句
too.broad.scope.allow.option=<html>報告使用新表達式作為初始設定式的變數<br>(可能不安全)</html>
too.broad.scope.display.name=變數作用域過寬
too.broad.scope.inspection.fix.family.name=限縮作用域
too.broad.scope.narrow.quickfix=將 ''{0}'' 的宣告移近用法
too.broad.scope.only.blocks.option=僅報告可移入內部塊的變數
too.broad.scope.problem.descriptor=變數 <code>\#ref</code> 的作用域過寬 \#loc
too.many.constructors.count.limit.option=建構函式計數限制\:
too.many.constructors.display.name=建構函式過多的類別
too.many.constructors.ignore.deprecated.option=忽略棄用的建構函式
too.many.constructors.problem.descriptor=<code>\#ref</code> 的建構函式過多 (建構函式計數 \= {0}) \#loc
too.many.fields.count.limit.option=欄位計數限制\:
too.many.fields.display.name=欄位過多的類別
too.many.fields.problem.descriptor=<code>\#ref</code> 的欄位過多 (欄位計數 \= {0}) \#loc
too.many.methods.display.name=方法過多的類別
too.many.methods.problem.descriptor=<code>\#ref</code> 的方法過多 (方法計數 \= {0}) \#loc
trace.level.option=追蹤級別
transient.field.in.non.serializable.class.display.name=不可序列化類別中存在 transient 欄位
transient.field.in.non.serializable.class.problem.descriptor=欄位 ''{0}'' 已在不可序列化類別中標記為 <code>\#ref</code> \#loc
transient.field.not.initialized.display.name=transient 欄位在反序列化時未初始化
transient.field.not.initialized.problem.descriptor=transient 欄位 <code>\#ref</code> 在反序列化時未初始化 \#loc
trivial.if.display.name=冗餘的 'if' 語句
trivial.if.fix.family.name=簡化 'if else'
trivial.if.option.ignore.assert.statements=忽略帶有簡單 'assert' 的 'if' 語句
trivial.if.option.ignore.chained=忽略鏈式 'if' 語句
trivial.if.problem.descriptor=<code>\#ref</code> 語句可以簡化 \#loc
trivial.string.concatenation.display.name=與空字串串聯
trivial.string.concatenation.option.only.necessary=僅報告無需其他更改即可移除空字串的情況
trivial.string.concatenation.problem.descriptor=串聯中存在空字串
try.finally.can.be.try.with.resources.display.name='try finally' 可被取代為 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>\#ref</code> 可以使用自動資源管理 \#loc
try.finally.can.be.try.with.resources.quickfix=取代為 'try-with-resources'
try.statement.with.multiple.resources.name=可以拆分具有多個資源的 'try' 語句
try.statement.with.multiple.resources.quickfix=拆分具有多個資源的 'try' 語句
try.with.identical.catches.checkbox.different.comments=不報告帶有不同註釋的 catch 塊
try.with.identical.catches.display.name='try' 語句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支與 ''{0}'' 分支相同 \#loc
try.with.identical.catches.quickfix=摺疊 'catch' 塊
type.parameter.extends.enum.type.parameter.problem.descriptor=類型參數 <code>\#ref</code> 隱式擴展 final 枚舉 ''{0}'' \#loc
type.parameter.extends.enum.wildcard.problem.descriptor=萬用字元類型實參 <code>\#ref</code> 隱式擴展了 final 枚舉 ''{0}'' \#loc
type.parameter.extends.final.class.display.name=類型參數擴展 'final' 類別
type.parameter.extends.final.class.quickfix=將類型參數取代為實際類別
type.parameter.extends.final.class.type.parameter.problem.descriptor=類型參數 <code>\#ref</code> 擴展 ''final'' 類別{0} \#loc
type.parameter.extends.final.class.wildcard.problem.descriptor=萬用字元類型實參 <code>\#ref</code> 擴展了 ''final'' 類別 ''{0}'' \#loc
type.parameter.extends.object.display.name=類型參數顯式擴展 'Object'
type.parameter.extends.object.ignore.annotated=註解 java.lang.Object 時忽略
type.parameter.extends.object.problem.descriptor1=類型參數 <code>\#ref</code> 顯式擴展 'java.lang.Object' \#loc
type.parameter.extends.object.problem.descriptor2=萬用字元類型實參 <code>\#ref</code> 顯式擴展 'java.lang.Object' \#loc
type.parameter.hides.type.parameter.problem.descriptor=類型參數 <code>\#ref</code> 隱藏類型參數 ''{0}'' \#loc
type.parameter.hides.visible.type.display.name=類型參數隱藏可見類型
type.parameter.hides.visible.type.problem.descriptor=類型參數 <code>\#ref</code> 隱藏可見類型 ''{0}'' \#loc
type.parameter.naming.convention.element.description=類型參數
unary.plus.display.name=一元正號
unary.plus.problem.descriptor=一元 <code>\#ref</code> 運算符 \#loc
unary.plus.quickfix=移除一元 '+'
unchecked.exception.class.display.name=未檢查的 'Exception' 類別
unchecked.exception.class.problem.descriptor=未檢查的異常類別 <code>\#ref</code> \#loc
unclear.binary.expression.display.name=具有不同優先級的多個運算符
unclear.binary.expression.problem.descriptor=表達式可以使用澄清括號 \#loc
unclear.binary.expression.quickfix=新增澄清括號
unconditional.wait.display.name=無條件的 'wait()' 呼叫
unconditional.wait.problem.descriptor=無條件呼叫 <code>\#ref()</code> \#loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定內部類別存取
unnecessarily.qualified.inner.class.access.option=忽略需要匯入的參照
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>\#ref</code> 限定 ''{0}'' 不必要 \#loc
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
unnecessarily.qualified.static.usage.display.name=不必要的限定靜態存取
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定欄位存取
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法呼叫
unnecessarily.qualified.static.usage.problem.descriptor=對 static 方法 <code>{0}()</code> 不必要的限定呼叫 \#loc
unnecessarily.qualified.static.usage.problem.descriptor1=對 static 欄位 <code>{0}</code> 不必要的限定存取 \#loc
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定靜態匯入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=靜態匯入元素 ''{0}'' 使用 <code>\#ref</code> 不必要限定 \#loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
unnecessary.block.statement.problem.descriptor=此語句周圍的大括號不必要 \#loc
unnecessary.boxing.display.name=不必要的裝箱
unnecessary.boxing.inside.value.of.problem.descriptor=冗餘裝箱，可以改用 <code>{0}.{1}()</code> 呼叫 \#loc
unnecessary.boxing.problem.descriptor=不必要的裝箱 \#loc
unnecessary.boxing.remove.quickfix=移除裝箱
unnecessary.boxing.superfluous.option=僅報告真正多餘的裝箱表達式
unnecessary.break.display.name=不必要的 'break' 語句
unnecessary.break.problem.descriptor=<code>\#ref</code> 語句不必要 \#loc
unnecessary.code.block.display.name=不必要的程式碼塊
unnecessary.code.block.unwrap.quickfix=解包塊
unnecessary.constant.array.creation.expression.display.name=常數陣列建立中的冗餘 'new' 表達式
unnecessary.constant.array.creation.expression.family.quickfix=從新陣列表達式中移除類型規範
unnecessary.constant.array.creation.expression.problem.descriptor=可從新陣列表達式中移除 <code>\#ref</code> \#loc
unnecessary.constructor.annotation.option=忽略有註解的建構函式
unnecessary.constructor.display.name=冗餘無實參建構函式
unnecessary.constructor.problem.descriptor=無實參建構函式 <code>\#ref()</code> 是冗餘的 \#loc
unnecessary.constructor.remove.quickfix=移除冗餘建構函式
unnecessary.continue.display.name=不必要的 'continue' 語句
unnecessary.continue.problem.descriptor=<code>\#ref</code> 不必要，因為是迴圈中的最後一條語句 \#loc
unnecessary.conversion.to.string.display.name=到 'String' 的不必要轉換
unnecessary.default.display.name=枚舉 'switch' 語句的 'default' 不必要
unnecessary.default.expressions.option=僅報告 switch 表達式
unnecessary.default.problem.descriptor=<code>\#ref</code> 分支不必要 \#loc
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.enum.constructor.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於枚舉建構函式是冗餘的 \#loc
unnecessary.explicit.numeric.cast.display.name=不必要的顯式數字轉換
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要轉換為 <code>\#ref</code> \#loc
unnecessary.explicit.numeric.cast.quickfix=移除轉換
unnecessary.final.on.local.variable.or.parameter.display.name=區域變數或參數上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=變數 ''{0}'' 上存在不必要的 <code>\#ref</code> \#loc
unnecessary.final.on.parameter.only.interface.option=僅對 abstract 或接口方法發出警告
unnecessary.final.on.parameter.problem.descriptor=參數 ''{0}'' 上存在不必要的 <code>\#ref</code> \#loc
unnecessary.final.report.local.variables.option=報告區域變數
unnecessary.final.report.parameters.option=報告參數
unnecessary.final.report.pattern.variables.option=報告模式變數
unnecessary.fully.qualified.name.display.name=不必要的完全限定名稱
unnecessary.fully.qualified.name.fix.family.name=取代完全限定名稱
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>\#ref</code> 不必要，可被取代為匯入 \#loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>\#ref</code> 不必要，可以移除 \#loc
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.replace.quickfix=將限定名稱取代為匯入
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>\#ref</code> 在類別上無效 \#loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>\#ref</code> 在建構函式上無效 \#loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到繼承 Javadoc 的 super 方法 \#loc
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 註釋
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>\#ref</code> 在欄位上無效 \#loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>\#ref</code> 在模組宣告上無效 \#loc
unnecessary.inherit.doc.problem.descriptor=僅包含 <code>\#ref</code> 的 Javadoc 註釋不必要 \#loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
unnecessary.initcause.display.name=對 'Throwable.initCause()' 的呼叫不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.\#ref()</code> 呼叫
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 呼叫
unnecessary.inner.enum.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於內部枚舉是冗餘的 \#loc
unnecessary.inner.interface.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於內部接口是冗餘的 \#loc
unnecessary.inner.record.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於內部記錄是冗餘的
unnecessary.interface.field.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於接口欄位是冗餘的 \#loc
unnecessary.interface.inner.class.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於接口的內部類別是冗餘的 \#loc
unnecessary.interface.member.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於接口成員是冗餘的 \#loc
unnecessary.interface.method.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於接口方法是冗餘的 \#loc
unnecessary.interface.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於接口是冗餘的 \#loc
unnecessary.java.doc.link.fix.family.name=移除冗餘標記
unnecessary.javadoc.link.display.name=不必要的 Javadoc 鏈接
unnecessary.javadoc.link.option=忽略 super 方法的內聯鏈接
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>\#ref</code> 不必要 \#loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含類別的 <code>\#ref</code> 不必要 \#loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>\#ref</code> 不必要 \#loc
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
unnecessary.label.on.break.statement.problem.descriptor=Break 語句上存在不必要的標籤 <code>\#ref</code> \#loc
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
unnecessary.label.on.continue.statement.problem.descriptor=Continue 語句上存在不必要的標籤 <code>\#ref</code> \#loc
unnecessary.label.remove.quickfix=移除標籤
unnecessary.local.variable.problem.descriptor=區域變數 <code>\#ref</code> 是冗餘的 \#loc
unnecessary.main.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於 Java {0} 的 ''main'' 方法是冗餘的 \#loc
unnecessary.modifier.display.name=不必要的修飾符
unnecessary.parentheses.conditional.option=忽略條件表達式條件周圍的圓括號
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.option=忽略澄清圓括號
unnecessary.parentheses.problem.descriptor=<code>\#ref</code> 周圍的圓括號不必要 \#loc
unnecessary.parentheses.remove.quickfix=移除不必要的圓括號
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>\#ref</code> 在此上下文中不必要 \#loc
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>\#ref</code> 在此上下文中不必要 \#loc
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.record.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於記錄是冗餘的
unnecessary.return.constructor.problem.descriptor=<code>\#ref</code> 不必要，因為是建構函式中的最後一條語句 \#loc
unnecessary.return.display.name=不必要的 'return' 語句
unnecessary.return.option=在具有 'else' 分支的 'if' 語句的 then 分支中忽略
unnecessary.return.problem.descriptor=<code>\#ref</code> 不必要，因為是 'void' 方法中的最後一條語句 \#loc
unnecessary.semicolon.display.name=不必要的分號
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚舉常數後的不必要分號
unnecessary.semicolon.problem.descriptor=不必要的分號 <code>\#ref</code> \#loc
unnecessary.semicolon.remove.quickfix=移除不必要的分號
unnecessary.strictfp.modifier.problem.descriptor=修飾符 <code>\#ref</code> 在 Java 17 和更高版本上是冗餘的
unnecessary.string.escape.display.name=不必要的轉義字元
unnecessary.string.escape.problem.descriptor=<code>{0}</code> 進行了不必要的轉義
unnecessary.string.escape.quickfix=移除不必要的轉義
unnecessary.super.constructor.display.name=對 'super()' 的呼叫不必要
unnecessary.super.constructor.problem.descriptor=<code>\#ref</code> 不必要 \#loc
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>\#ref</code> 在此上下文中不必要 \#loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
unnecessary.temporary.object.fix.family.name=取代串聯
unnecessary.temporary.on.conversion.from.string.display.name=從 'String' 轉換時有不必要的臨時物件
unnecessary.temporary.on.conversion.to.string.display.name=轉換為 'String' 時有不必要的臨時物件
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略欄位賦值
unnecessary.this.problem.descriptor=<code>\#ref</code> 在此上下文中不必要 \#loc
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
unnecessary.tostring.call.display.name=對 'toString()' 的呼叫不必要
unnecessary.tostring.call.option.report.with.empty.string=報告可被取代為帶空字串的串聯的呼叫
unnecessary.tostring.call.problem.descriptor=不必要的 <code>\#ref()</code> 呼叫 \#loc
unnecessary.tostring.call.problem.empty.string.descriptor=可以取代為帶空字串的串聯
unnecessary.transient.modifier.problem.descriptor=修飾符 <code>\#ref</code> 對於 'static' 欄位是冗餘的
unnecessary.unary.minus.display.name=不必要的一元負號
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>\#ref</code> 運算符 \#loc
unnecessary.unary.minus.quickfix=移除一元負號並反轉父運算符號
unnecessary.unary.minus.remove.quickfix=移除雙一元減號
unnecessary.unboxing.display.name=不必要的拆箱
unnecessary.unboxing.problem.descriptor=不必要的拆箱 \#loc
unnecessary.unboxing.remove.quickfix=移除拆箱
unnecessary.unboxing.superfluous.option=僅報告真正多餘的拆箱表達式
unnecessary.unicode.escape.display.name=不必要的 Unicode 轉義序列
unnecessary.unicode.escape.fix.family.name=取代為字元
unnecessary.unicode.escape.fix.text=取代為{0, choice, 1\#新行|2\#制表符|3\#空格}字元
unnecessary.unicode.escape.problem.descriptor=Unicode 轉義序列 <code>\#ref</code> 可被取代為 ''{0}'' \#loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 轉義序列 <code>\#ref</code> 可被取代為換行字元 \#loc
unpredictable.big.decimal.constructor.call.display.name=不可預知的 'BigDecimal' 建構函式呼叫
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多個字面量的建構函式呼叫 (例如 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有變量或方法呼叫實參的建構函式呼叫
unpredictable.big.decimal.constructor.call.problem.descriptor=不可預知的 <code>new \#ref()</code> 呼叫 \#loc
unqualified,static.usage.only.report.static.usages.option=僅報告來自非 static 上下文的靜態存取
unqualified.field.access.display.name=未使用 'this' 限定的實例欄位存取
unqualified.field.access.problem.descriptor=未使用 'this' 限定的實例欄位存取 <code>\#ref</code> \#loc
unqualified.inner.class.access.display.name=非限定內部類別存取
unqualified.inner.class.access.option=忽略對本地內部類別的參照
unqualified.inner.class.access.problem.descriptor=<code>\#ref</code> 未使用外部類別限定 \#loc
unqualified.inner.class.access.quickfix=使用外部類別限定
unqualified.method.access.display.name=未使用 'this' 限定的實例方法呼叫
unqualified.method.access.problem.descriptor=未使用 'this' 限定實例方法呼叫 <code>\#ref()</code> \#loc
unqualified.static.access.fix.family.name=限定靜態存取
unqualified.static.usage.display.name=非限定靜態存取
unqualified.static.usage.ignore.field.option=忽略非限定欄位存取
unqualified.static.usage.ignore.method.option=忽略非限定方法呼叫
unqualified.static.usage.problem.descriptor=非限定 static 方法呼叫 <code>\#ref()</code> \#loc
unqualified.static.usage.problem.descriptor1=非限定 static 欄位存取 <code>\#ref</code> \#loc
unqualified.static.usage.qualify.field.quickfix=限定 static 欄位存取
unqualified.static.usage.qualify.method.quickfix=限定 static 方法呼叫
unrunnable.main.method.problem.descriptor=無法執行方法 <code>\#ref()</code>，因為包含類別沒有完全限定名稱
unsecure.random.number.generation.display.name=不安全的隨機數生成
unsecure.random.number.generation.problem.descriptor1=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.\#ref()</code> \#loc
unsecure.random.number.generation.problem.descriptor2=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.util.\#ref</code> \#loc
unsecure.random.number.generation.problem.descriptor3=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>\#ref</code> \#loc
unused.import.problem.descriptor=未使用的 import <code>\#ref</code> \#loc
unused.label.display.name=未使用的標籤
unused.label.problem.descriptor=未使用的標籤 <code>\#ref</code> \#loc
unused.label.remove.quickfix=移除未使用的標籤
update.label=更新名稱開頭\:
upper.case.field.name.not.constant.display.name=具有大寫名稱的非常數欄位
upper.case.field.name.not.constant.problem.descriptor=帶常數樣式名稱的非常數欄位 <code>\#ref</code> \#loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' \#loc
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' \#loc
use.contentequals=使用 'contentEquals()' 與 'AbstractStringBuilder' 進行比較
use.equalsignorecase.for.case.insensitive.comparison=為不區分大小寫的比較使用 'equalsIgnoreCase()'
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 檢查字串是否為空或者僅包含空格
use.obsolete.collection.type.display.name=使用廢棄的集合類型
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略廢棄的集合類型
use.obsolete.collection.type.problem.descriptor=使用了廢棄的集合類型 <code>\#ref</code> \#loc
use.of.awt.peer.class.display.name=使用 AWT 對等類別
use.of.awt.peer.class.problem.descriptor=AWT 對等類別 <code>\#ref</code> 的使用不可移植 \#loc
use.of.clone.call.method.problem.descriptor=實作 <code>\#ref()</code>
use.of.clone.call.problem.descriptor=呼叫 <code>\#ref()</code>
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.reference.problem.descriptor=使用 <code>\#ref</code>
use.of.concrete.class.option.ignore.abstract=忽略抽象類別類型
use.of.concrete.class.option.ignore.records=忽略 Java 記錄
use.of.concrete.class.option.report.cast=報告轉換表達式中使用的類型
use.of.concrete.class.option.report.instance.fields=報告實例欄位類型
use.of.concrete.class.option.report.instanceof=報告 instanceof、patterns 或 getClass() 比較中使用的類型
use.of.concrete.class.option.report.local.variable=報告區域變數類型
use.of.concrete.class.option.report.method.returns=報告方法返回值類型
use.of.concrete.class.option.report.parameter=報告方法參數類型
use.of.concrete.class.option.report.static.fields=報告 static 欄位類型
use.of.concrete.jdbc.driver.class.display.name=使用具體的 JDBC 驅動程序類別
use.of.concrete.jdbc.driver.class.problem.descriptor=具體 JDBC 驅動程序類別 <code>\#ref</code> 的使用不可移植 \#loc
use.of.obsolete.date.time.api.display.name=使用廢棄的日期時間 API
use.of.obsolete.date.time.api.problem.descriptor=使用了廢棄的日期時間類型 <code>\#ref</code> \#loc
use.of.properties.as.hashtable.fix.family.name=修復屬性存取
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 類別
use.processbuilder.class.problem.descriptor=<code>\#ref</code> 的使用不可移植 \#loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=國際化上下文中的 <code>\#ref</code> \#loc
use.sun.classes.display.name=使用 'sun.*' 類別
use.sun.classes.problem.descriptor=Sun 提供的類別 <code>\#ref</code> 的使用不可移植 \#loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>\#ref</code> 的使用可能應當取代為更可靠的日誌 \#loc
use.system.out.err.problem.fix.err.option='System.err' 的日誌方法\:
use.system.out.err.problem.fix.out.option='System.out' 的日誌方法\:
utility.class.can.be.enum.display.name=實用程序類別可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=實用程序類別 <code>\#ref</code> 可以是 'enum' \#loc
utility.class.code.can.be.enum.quickfix=轉換為 'enum'
utility.class.display.name=實用程序類別
utility.class.problem.descriptor=類別 <code>\#ref</code> 只有 'static' 成員，指示程序建構 \#loc
utility.class.with.public.constructor.display.name=實用程序類別具有 'public' 建構函式
utility.class.with.public.constructor.fix.family.name=將建構函式設為非 public
utility.class.with.public.constructor.make.private.quickfix=將{0, choice, 1\#建構函式|2\#建構函式}設為 'private'
utility.class.with.public.constructor.make.protected.quickfix=將{0, choice, 1\#建構函式|2\#建構函式}設為 'protected'
utility.class.with.public.constructor.problem.descriptor=類別 <code>\#ref</code> 只有 'static' 成員和 'public' 建構函式 \#loc
utility.class.without.private.constructor.cant.generate.constructor.message=實用程序類別具有實例化，將不會建立 private 建構函式
utility.class.without.private.constructor.create.quickfix=生成空 'private' 建構函式
utility.class.without.private.constructor.display.name=實用程序類別沒有 'private' 建構函式
utility.class.without.private.constructor.make.quickfix=將建構函式設為 'private'
utility.class.without.private.constructor.option=忽略僅具有主方法的類別
utility.class.without.private.constructor.problem.descriptor=類別 <code>\#ref</code> 只有 'static' 成員，缺少 'private' 建構函式 \#loc
value.of.post.decrement.problem.descriptor=使用後減量表達式 <code>\#ref</code> 的值 \#loc
value.of.post.increment.problem.descriptor=使用後增量表達式 <code>\#ref</code> 的值 \#loc
value.of.pre.decrement.problem.descriptor=使用前減量表達式 <code>\#ref</code> 的值 \#loc
value.of.pre.increment.problem.descriptor=使用前增量表達式 <code>\#ref</code> 的值 \#loc
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>\#ref()</code> \#loc
variable.argument.method.quickfix=將 vararg 參數轉換為數組
variable.not.used.inside.conditional.problem.descriptor=條件內未使用檢查為 'null' 的 <code>\#ref</code> \#loc
variable.not.used.inside.if.display.name='if' 內未使用檢查為 'null' 的參照
variable.not.used.inside.if.problem.descriptor='if' 內未使用檢查為 'null' 的 <code>\#ref</code> \#loc
variable.type.can.be.explicit.display.name=變數類型可以是顯式的
volatile.array.field.display.name=volatile 陣列欄位
volatile.field.problem.descriptor=類型 ''{0}'' 的 volatile 欄位 <code>\#ref</code> \#loc
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'wait()'
wait.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>\#ref()</code> \#loc
wait.not.in.loop.display.name=未在迴圈中呼叫的 'wait()'
wait.not.in.loop.problem.descriptor=<code>\#ref()</code> 呼叫不在迴圈中 \#loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步時呼叫 <code>\#ref</code> \#loc
wait.or.await.without.timeout.display.name=無超時的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=無超時的 <code>\#ref</code> \#loc
wait.while.holding.two.locks.display.name=保持兩個鎖時 'wait()'
wait.while.holding.two.locks.problem.descriptor=在保持兩個鎖的情況下呼叫 <code>\#ref()</code> \#loc
wait.without.corresponding.notify.display.name=沒有相應 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在沒有相應 <code>notify()</code> 或 <code>notifyAll()</code> 的情況下呼叫 <code>\#ref()</code> \#loc
warn.level.and.lower.option=警告級別和更低
warn.on.label=警告物件\:
weaken.visibility.quickfix=削弱可見性
while.can.be.foreach.display.name='while' 迴圈可被取代為增強的 'for' 迴圈
while.can.be.foreach.problem.descriptor=<code>\#ref</code> 迴圈可被取代為增強的 'for' \#loc
while.loop.spins.on.field.display.name='while' 迴圈在欄位上自旋
while.loop.spins.on.field.fix.family.name=修復自旋迴圈
while.loop.spins.on.field.fix.spinwait=新增 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=將 ''{0}'' 設為 volatile
while.loop.spins.on.field.fix.volatile.spinwait=將 ''{0}'' 設為 volatile 並新增 Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=僅當迴圈為空時才發出警告
while.loop.spins.on.field.problem.descriptor=<code>\#ref</code> 迴圈在欄位上自旋 \#loc
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包裝
write.only.object.display.name=只寫入物件
write.only.object.option.ignore.impure.constructors=忽略不純的建構函式

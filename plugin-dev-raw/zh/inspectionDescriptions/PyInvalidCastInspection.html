<html>
<body>
<p>報告源類型和目標類型不相關的 <code>typing.cast</code> 呼叫。</p>
<p>當源類型既不是目標類型的子類型，目標類型也不是源類型的子類型時，將報告錯誤。
  此類別轉換通常指示邏輯錯誤，因為一種類型的實例不能被假定為另一種類型的實例，並且 <code>typing.cast</code> 不會動態驗證類型。</p>

<p>此檢查甚至適用於理論上可能具有共同後代的類型。
  例如，它將標記兩個同級類別 <code>Left</code> 和 <code>Right</code> 之間的轉換，因為它們都繼承自 <code>Top</code>，但彼此之間沒有直接繼承關係。</p>

<p><b>範例：</b></p>
<pre><code>
from typing import cast

# 非重疊類型 — 可能是錯誤
<b>cast(int, "a")</b>          # 'str' -> 'int'
<b>cast(list[int], ["a"])</b>  # 'list[str]' -> 'list[int]'

# 推薦的顯式逃生艙口是使用“雙重轉換”
cast(int, <b>cast(object, "a")</b>)  # 正常

# 合法的重疊情況
cast(int, object())    # 有效的向下轉換
cast(object, 1)        # 有效的向上轉換

# 但以下是無效轉換，因為 <code>list</code> 不可變。 當前不受此檢查支援
int_list = [1, 2, 3]
cast(list[object], int_list)
</code></pre>
<!-- tooltip end -->
<p>該檢查依賴於靜態類型資訊；當類型未知時，不會報告警告。

  尚未考慮泛型類型的差異。</p>
</body>
</html>
<html>
<body>
<p>報告不將 `infix` 修飾符作為中綴運算符的字母數字定義的用法。</p>

<ul>
<li>“使用反引號環繞”快速修復會在呼叫周圍新增 <code>`</code> 符號。</li>
<li>“從中綴表達式轉換”快速修復會將中綴呼叫轉換為方法語法 <code>.method(...)</code>。</li>
<li>“從中綴類型轉換”快速修復會將中綴類型轉換為前綴語法 <code>Type[...]</code>。</li>
<li>“從中綴模式轉換”快速修復會將中綴模式轉換為前綴語法 <code>pattern(...)</code>。</li>
</ul>

<p><b>範例：</b></p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Int Or String = ???
  val _ Pair _ = p
</code></pre>

<p>套用“使用反引號環繞”快速修復後：</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c `op` 2
  val or: Int `Or` String = ???
  val _ `Pair` _ = p
</code></pre>

<p>在套用“從中綴表達式轉換”快速修復後：</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c.op(2)
  val or: Int Or String = ???
  val _ Pair _ = p
</code></pre>

<p>套用“從中綴類型轉換”快速修復後：</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Or[Int, String] = ???
  val _ Pair _ = p
</code></pre>

<p>套用“從中綴模式轉換”快速修復後：</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Int Or String = ???
  val Pair(_, _) = p
</code></pre>
<!-- tooltip end -->
</body>
</html>
